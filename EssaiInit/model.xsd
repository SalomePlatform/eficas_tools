<?xml version="1.0" encoding="UTF-8"?>
<!-- edited with XMLSpy v2014 rel. 2 (x64) (http://www.altova.com) by BC (ED) -->
<xs:schema xmlns:xs="http://www.w3.org/2001/XMLSchema" xmlns:vc="http://www.w3.org/2007/XMLSchema-versioning" xmlns="http://chercheurs.edf.com/logiciels/efficas" xmlns:efficas="http://chercheurs.edf.com/logiciels/efficas" xmlns:altova="http://www.altova.com/xml-schema-extensions" targetNamespace="http://chercheurs.edf.com/logiciels/efficas" elementFormDefault="qualified" attributeFormDefault="unqualified" version="0" vc:minVersion="1.1">
	<xs:element name="doc" type="T_doc"/>
	<xs:element name="cata" type="T_cata"/>
	<xs:element name="regles" type="T_regles"/>
	<xs:element name="typeCree" type="T_classe_utilisateur"/>
	<xs:element name="ValeurDef" type="T_typeAttendu"/>
	<xs:element name="ValeurSugg" type="T_typeAttendu"/>
	<xs:element name="fonction_utilisateur" type="T_fonction_python"/>
	<xs:element name="commandes" type="T_commandes">
		<xs:unique name="Uniq_Command">
			<xs:selector xpath="*"/>
			<xs:field xpath="@efficas:nom"/>
		</xs:unique>
		<xs:key name="Uniq_Name_In_Oper">
			<xs:annotation>
				<xs:documentation>SIMP devrait être selectionné que si .//SIMP[portee='Global']</xs:documentation>
			</xs:annotation>
			<xs:selector xpath="./OPER/BLOC |./OPER/FACT|./OPER/SIMP"/>
			<xs:field xpath="@efficas:nom"/>
		</xs:key>
		<xs:keyref name="Ref_A_Name_In_Oper" refer="Uniq_Name_In_Oper">
			<xs:selector xpath="./OPER/regles"/>
			<xs:field xpath="EXCLUS"/>
		</xs:keyref>
		<xs:key name="Uniq_Name_In_Proc">
			<xs:annotation>
				<xs:documentation>SIMP devrait être selectionné que si .//SIMP[portee='Global']</xs:documentation>
			</xs:annotation>
			<xs:selector xpath="./PROC/BLOC | ./PROC/FACT| ./PROC/SIMP"/>
			<xs:field xpath="@efficas:nom"/>
		</xs:key>
		<xs:keyref name="Ref_A_Name_In_Proc" refer="Uniq_Name_In_Proc">
			<xs:selector xpath="./PROC/regles"/>
			<xs:field xpath="EXCLUS"/>
		</xs:keyref>
	</xs:element>
	<xs:element name="validators" type="T_validators"/>
	<xs:element name="PlageValeur" type="T_PlageValeur"/>
	<xs:element name="typeAttendu" type="T_name"/>
	<xs:element name="classeUtilisateurName" type="T_classe_utilisateur_username" abstract="true" substitutionGroup="typeAttendu"/>
	<xs:element name="SIMP" type="T_SIMP"/>
	<xs:element name="portee" type="T_portee" default="None"/>
	<xs:element name="condition" type="T_fonction_python"/>
	<xs:element name="borne_sup" type="T_typeAttendu"/>
	<xs:element name="borne_inf" type="T_typeAttendu"/>
	<!--	<xs:element name="into" type="T_into"/>-->
	<xs:element name="into" type="T_into"/>
	<!--	<xs:element name="into_plus_fonction" type="T_into" abstract="true" substitutionGroup="into"/>-->
	<xs:attribute name="nom" type="AT_nom"/>
	<xs:attribute name="ag" type="AT_ag"/>
	<xs:attribute name="fr" type="xs:string"/>
	<xs:attribute name="ang" type="xs:string"/>
	<xs:attribute name="docu" type="AT_docu"/>
	<xs:attribute name="valeur_sugg" type="AT_valeur_sugg"/>
	<xs:attribute name="statut" type="AT_statut" default="o"/>
	<xs:attribute name="max_occurs" type="AT_max_occurs"/>
	<xs:attribute name="min_occurs" type="AT_min_occurs"/>
	<xs:attribute name="subroutine" type="AT_subroutine" default="None"/>
	<xs:complexType name="T_doc">
		<xs:attribute ref="fr" use="optional"/>
		<xs:attribute ref="ang"/>
		<xs:attribute ref="docu"/>
	</xs:complexType>
	<xs:complexType name="T_cata">
		<xs:sequence>
			<xs:element ref="commandes" minOccurs="0" maxOccurs="unbounded"/>
		</xs:sequence>
	</xs:complexType>
	<xs:complexType name="T_commandes">
		<xs:choice minOccurs="0" maxOccurs="unbounded">
			<xs:element ref="OPER"/>
			<xs:element ref="PROC"/>
		</xs:choice>
	</xs:complexType>
	<xs:complexType name="T_Cardinalite"/>
	<xs:complexType name="T_PlageValeur">
		<xs:choice>
			<xs:sequence>
				<xs:element ref="borne_sup" minOccurs="0"/>
				<xs:element ref="borne_inf" minOccurs="0"/>
			</xs:sequence>
			<xs:element ref="into"/>
		</xs:choice>
	</xs:complexType>
	<xs:complexType name="T_Accas.Common">
		<xs:sequence>
			<xs:element ref="regles" minOccurs="0"/>
			<xs:element ref="doc" minOccurs="0"/>
			<xs:choice maxOccurs="unbounded">
				<xs:element ref="BLOC"/>
				<xs:element ref="FACT"/>
				<xs:element ref="SIMP"/>
			</xs:choice>
		</xs:sequence>
		<xs:attribute ref="nom" use="required"/>
	</xs:complexType>
	<xs:element name="OPER" type="T_OPER"/>
	<xs:complexType name="T_OPER">
		<xs:complexContent>
			<xs:extension base="T_Accas.Common">
				<xs:sequence>
					<xs:element ref="typeCree"/>
				</xs:sequence>
				<xs:attribute ref="subroutine"/>
			</xs:extension>
		</xs:complexContent>
	</xs:complexType>
	<xs:element name="PROC" type="T_PROC">
		<xs:unique name="Uniqb_NAme_In_PRoc">
			<xs:selector xpath="BLOC|FACT|SIMP"/>
			<xs:field xpath="@efficas:nom"/>
		</xs:unique>
	</xs:element>
	<xs:complexType name="T_PROC">
		<xs:complexContent>
			<xs:extension base="T_Accas.Common">
				<xs:attribute ref="subroutine"/>
			</xs:extension>
		</xs:complexContent>
	</xs:complexType>
	<xs:element name="FACT" type="T_FACT"/>
	<!--	<xs:complexType name="T_FACT">
		<xs:complexContent>
			<xs:restriction base="T_Accas.Common">
				<xs:sequence>
					<xs:element ref="regles" minOccurs="0"/>
					<xs:element ref="doc" minOccurs="0"/>
					<xs:choice maxOccurs="unbounded">
						<xs:element ref="BLOC"/>
						<xs:element ref="FACT"/>
						<xs:element ref="SIMP"/>
					</xs:choice>
				</xs:sequence>
			</xs:restriction>
		</xs:complexContent>
	</xs:complexType>-->
	<xs:complexType name="T_FACT">
		<xs:complexContent>
			<xs:extension base="T_Accas.Common">
				<xs:attribute ref="statut"/>
				<xs:attribute ref="min_occurs" default="1"/>
				<xs:attribute ref="max_occurs" default="1">
					<xs:annotation>
						<xs:documentation>La valuer -1 equivaut à oo</xs:documentation>
					</xs:annotation>
				</xs:attribute>
				<xs:assert test=".[exists(@efficas:max_occurs) and exists(@efficas:min_occurs) and @efficas:max_occurs  gt @efficas:min_occurs]"/>
				<!--<xs:assert test="if (.[exists(@efficas:max_occurs)] and .[exists(@efficas:min_occurs)] ) then (@efficas:max_occurs  gt @efficas:min_occurs) or @efficas:max_occurs = -1 else true" altova:message="Erreur max_occurs  > min_occurs "/>-->
			</xs:extension>
		</xs:complexContent>
	</xs:complexType>
	<xs:simpleType name="T_fonction_python">
		<xs:restriction base="xs:string"/>
	</xs:simpleType>
	<xs:element name="BLOC" type="T_BLOC"/>
	<xs:complexType name="T_BLOC">
		<xs:complexContent>
			<xs:extension base="T_Accas.Common">
				<xs:sequence>
					<xs:element ref="condition"/>
				</xs:sequence>
			</xs:extension>
		</xs:complexContent>
	</xs:complexType>
	<xs:complexType name="T_SIMP">
		<xs:sequence>
			<xs:element ref="doc" minOccurs="0"/>
			<xs:element ref="portee" minOccurs="0">
				<xs:annotation>
					<xs:documentation>La portée pouurait devenir un attribut de SIMP. Une autre solution consisterait a créer un SIMPG pour distinguer les @nom uniques des SIMP a portée globale des autres.</xs:documentation>
				</xs:annotation>
			</xs:element>
			<xs:element ref="ValeurDef" minOccurs="0"/>
			<xs:element ref="ValeurSugg" minOccurs="0"/>
			<xs:element ref="PlageValeur" minOccurs="0"/>
			<xs:element ref="typeAttendu"/>
			<xs:element ref="validators" minOccurs="0"/>
		</xs:sequence>
		<xs:attribute ref="nom" use="required"/>
		<xs:attribute ref="statut"/>
		<xs:attribute ref="min_occurs" default="1"/>
		<xs:attribute ref="max_occurs" default="1">
			<xs:annotation>
				<xs:documentation>La valuer -1 equivaut à oo</xs:documentation>
			</xs:annotation>
		</xs:attribute>
	</xs:complexType>
	<xs:simpleType name="AT_statut">
		<xs:restriction base="xs:string">
			<xs:enumeration value="f"/>
			<xs:enumeration value="o"/>
		</xs:restriction>
	</xs:simpleType>
	<!--<xs:simpleType name="T_repetable">
		<xs:restriction base="xs:string">
			<xs:enumeration value="n"/>
			<xs:enumeration value="o"/>
		</xs:restriction>
	</xs:simpleType>-->
	<xs:simpleType name="T_portee">
		<xs:restriction base="xs:string">
			<xs:enumeration value="None"/>
			<xs:enumeration value="Global"/>
		</xs:restriction>
	</xs:simpleType>
	<xs:simpleType name="AT_max_occurs">
		<xs:restriction base="xs:long">
			<xs:minInclusive value="-1"/>
		</xs:restriction>
	</xs:simpleType>
	<xs:simpleType name="AT_min_occurs">
		<xs:restriction base="xs:long">
			<xs:minExclusive value="0"/>
		</xs:restriction>
	</xs:simpleType>
	<!-- Comparable -->
	<!--	<xs:simpleType name="AT_borne_sup">
	<xs:atomic base="xs:double"/>
	</xs:simpleType>
	<xs:simpleType name="AT_borne_inf">
		<xs:restriction base="xs:double"/>
	</xs:simpleType>
-->
	<xs:simpleType name="AT_ag">
		<xs:restriction base="xs:string">
			<xs:enumeration value="No comment"/>
		</xs:restriction>
	</xs:simpleType>
	<xs:simpleType name="AT_docu">
		<xs:annotation>
			<xs:documentation>Référence une position dans un fichier maître contenant une liste de références à des pages de documentations</xs:documentation>
		</xs:annotation>
		<xs:restriction base="xs:string"/>
	</xs:simpleType>
	<xs:simpleType name="AT_valeur_sugg">
		<xs:restriction base="xs:string"/>
	</xs:simpleType>
	<!-- TODO: Exclure mots clés python|efficas -->
	<xs:simpleType name="AT_nom">
		<xs:restriction base="xs:string">
			<xs:pattern value="([A-Z]|[a-z]|_)([A-Z]|[a-z]|_|[0-9])*"/>
		</xs:restriction>
	</xs:simpleType>
	<xs:simpleType name="T_predicat1">
		<xs:list itemType="AT_nom"/>
		<!-- TODO: Supprimer la liste -->
	</xs:simpleType>
	<xs:complexType name="T_predicat2">
		<xs:sequence>
			<xs:element name="p1" type="T_predicat1" minOccurs="1"/>
			<xs:element name="p2" type="AT_nom" minOccurs="1"/>
		</xs:sequence>
		<!-- TODO: Supprimer la séquence -->
	</xs:complexType>
	<xs:element name="A_CLASSER" type="T_predicat2"/>
	<xs:element name="AU_MOINS_UN" type="T_predicat1"/>
	<xs:element name="AU_PLUS_UN" type="T_predicat1"/>
	<xs:element name="ENSEMBLE" type="T_predicat1"/>
	<xs:element name="EXCLUS" type="T_predicat1">
		<!-- A priori, ce n'est pas l'endroit pour le placer : ? scope de Uniq_Command-->
		<!--		<xs:keyref name="referToAnAlreadyDefinedName" refer="Uniq_Command">
			<xs:selector xpath="."/>
			<xs:field xpath="."/>
		</xs:keyref>
-->
	</xs:element>
	<xs:element name="PRESENT_ABSENT" type="T_predicat1"/>
	<xs:element name="PRESENT_PRESENT" type="T_predicat1"/>
	<xs:element name="UN_PARMI" type="T_predicat1"/>
	<xs:group name="predicat">
		<xs:choice>
			<xs:element ref="A_CLASSER"/>
			<xs:element ref="AU_MOINS_UN"/>
			<xs:element ref="AU_PLUS_UN"/>
			<xs:element ref="ENSEMBLE"/>
			<xs:element ref="EXCLUS">
				<!-- A priori, ce n'est pas l'endroit pour le placer -->
				<!--				<xs:keyref name="referToAnAlreadyDefinedName" refer="/Uniq_Command">
					<xs:selector xpath="."/>
					<xs:field xpath="."/>
				</xs:keyref>
-->
			</xs:element>
			<xs:element ref="PRESENT_ABSENT"/>
			<xs:element ref="PRESENT_PRESENT"/>
			<xs:element ref="UN_PARMI"/>
		</xs:choice>
	</xs:group>
	<xs:complexType name="T_regles">
		<xs:sequence maxOccurs="unbounded">
			<xs:group ref="predicat"/>
		</xs:sequence>
	</xs:complexType>
	<!--	<xs:simpleType name="T_typeCree">
		<xs:restriction base="T_classe_utilisateur"/>
	</xs:simpleType>
-->
	<xs:simpleType name="AT_subroutine">
		<xs:restriction base="AT_nom"/>
	</xs:simpleType>
	<xs:simpleType name="T_validators">
		<xs:restriction base="xs:string">
			<xs:enumeration value="NoRepeat"/>
			<xs:enumeration value="OnlyStr"/>
			<xs:enumeration value="VerifExiste"/>
			<xs:enumeration value="VerifTypeTuple"/>
		</xs:restriction>
	</xs:simpleType>
	<xs:simpleType name="T_Bool">
		<xs:restriction base="xs:boolean"/>
	</xs:simpleType>
	<xs:simpleType name="T_list_Bool">
		<xs:list itemType="T_Bool"/>
	</xs:simpleType>
	<xs:simpleType name="T_I">
		<xs:restriction base="xs:int"/>
	</xs:simpleType>
	<xs:simpleType name="T_list_I">
		<xs:list itemType="T_I"/>
	</xs:simpleType>
	<xs:simpleType name="T_R">
		<xs:restriction base="xs:double"/>
	</xs:simpleType>
	<xs:simpleType name="T_list_R">
		<xs:list itemType="T_R"/>
	</xs:simpleType>
	<xs:simpleType name="T_TXM">
		<xs:restriction base="AT_nom"/>
	</xs:simpleType>
	<xs:simpleType name="T_list_TXM">
		<xs:list itemType="T_TXM"/>
	</xs:simpleType>
	<!--fonctionne mais ne permet pas de créer une liste de liste -->
	<xs:simpleType name="T_C">
		<xs:restriction>
			<xs:simpleType>
				<xs:list itemType="xs:double"/>
			</xs:simpleType>
			<xs:minLength value="2"/>
			<xs:maxLength value="2"/>
		</xs:restriction>
	</xs:simpleType>
	<!-- Ajouter une contrainte : taille pair -->
	<!-- Il n'est pas possible de définir des listes de listes -->
	<xs:simpleType name="T_list_C">
		<xs:list itemType="xs:double"/>
	</xs:simpleType>
	<xs:simpleType name="T_name_base">
		<xs:restriction base="AT_nom"/>
	</xs:simpleType>
	<xs:simpleType name="T_simple_name">
		<xs:restriction base="T_name_base">
			<xs:enumeration value="Fichier"/>
			<xs:enumeration value="Repertoire"/>
			<xs:enumeration value="TXM"/>
			<xs:enumeration value="I"/>
			<xs:enumeration value="R"/>
			<xs:enumeration value="C"/>
			<xs:enumeration value="Bool"/>
			<xs:enumeration value="grma"/>
			<xs:enumeration value="grno"/>
			<xs:enumeration value="SalomeEntry"/>
		</xs:restriction>
	</xs:simpleType>
	<!-- On ne peut pas rendre abstrait un simpleType && 
          Il n'est pas possible de dérivé par restriction un simplecontent d'un type complex qui
          lui peut être abstrait
    -->
	<xs:simpleType name="T_classe_utilisateur_name">
		<xs:restriction base="T_name">
			<xs:enumeration value="T_classe_utilisateur"/>
		</xs:restriction>
	</xs:simpleType>
	<xs:complexType name="T_classe_utilisateur_username">
		<xs:simpleContent>
			<xs:extension base="T_classe_utilisateur_name">
				<xs:attribute ref="nom" use="required"/>
			</xs:extension>
		</xs:simpleContent>
	</xs:complexType>
	<xs:simpleType name="T_name">
		<xs:union memberTypes="T_simple_name">
			<xs:simpleType>
				<xs:restriction base="AT_nom">
					<xs:enumeration value="T_Matrice_double"/>
					<xs:enumeration value="T_Matrice_Symetrique_double"/>
					<xs:enumeration value="T_tuple"/>
					<xs:enumeration value="T_classe_utilisateur"/>
				</xs:restriction>
			</xs:simpleType>
		</xs:union>
	</xs:simpleType>
	<xs:complexType name="T_grma"/>
	<xs:complexType name="T_grno"/>
	<xs:complexType name="T_SalomeEntry"/>
	<xs:complexType name="T_Fichier"/>
	<!--	<xs:complexType name="T_Repertoire"/>-->
	<xs:simpleType name="T_Repertoire">
		<xs:list>
			<xs:simpleType>
				<xs:restriction base="xs:string">
					<xs:whiteSpace value="preserve"/>
				</xs:restriction>
			</xs:simpleType>
		</xs:list>
	</xs:simpleType>
	<xs:simpleType name="T_simple">
		<xs:union memberTypes="T_I T_list_I T_R T_list_R T_C T_list_C T_TXM T_list_TXM T_Bool T_list_Bool T_Repertoire"/>
	</xs:simpleType>
	<!--	<xs:complexType name="T_TXM"/>-->
	<!--	<xs:simpleType name="T_simple">
		<xs:restriction base="xs:string">
			<xs:enumeration value="Fichier"/>
			<xs:enumeration value="Repertoire"/>
			<xs:enumeration value="TXM"/>
			<xs:enumeration value="I"/>
			<xs:enumeration value="R"/>
			<xs:enumeration value="C"/>
			<xs:enumeration value="Bool"/>
			<xs:enumeration value="grma"/>
			<xs:enumeration value="grno"/>
			<xs:enumeration value="SalomeEntry"/>
		</xs:restriction>
	</xs:simpleType>
-->
	<xs:simpleType name="T_list_double">
		<xs:list itemType="xs:double"/>
	</xs:simpleType>
	<!-- Possibilité d'utiliser un type paramétré ? -->
	<xs:complexType name="T_Matrice_double">
		<xs:simpleContent>
			<xs:extension base="T_list_double">
				<xs:attribute name="n" type="xs:integer" use="required"/>
				<xs:attribute name="m" type="xs:integer" use="required"/>
			</xs:extension>
		</xs:simpleContent>
	</xs:complexType>
	<!-- Faire l'exercice de dériver de T_Matrice_double -->
	<xs:complexType name="T_Matrice_Symetrique_double">
		<xs:simpleContent>
			<xs:extension base="T_list_double">
				<xs:attribute name="n" type="xs:int" use="required"/>
			</xs:extension>
		</xs:simpleContent>
	</xs:complexType>
	<!-- Une liste est aussi un type simple !!!! -->
	<!--    <xs:simpleType name="T_list_anySimpleType">
		<xs:list itemType="xs:anySimpleType"/>
	</xs:simpleType>
-->
	<!-- Le fait de ne pas déclarer une liste risque d'être problématique pour le parsing : A voir-->
	<xs:complexType name="T_tuple">
		<xs:simpleContent>
			<xs:extension base="xs:anySimpleType">
				<xs:attribute name="n" type="xs:int" use="required"/>
			</xs:extension>
		</xs:simpleContent>
	</xs:complexType>
	<xs:simpleType name="T_classe_utilisateur">
		<xs:restriction base="AT_nom"/>
	</xs:simpleType>
	<xs:element name="typesimple" type="T_simple"/>
	<xs:element name="matrice_double" type="T_Matrice_double"/>
	<xs:element name="matrice_symetrique_double" type="T_Matrice_Symetrique_double"/>
	<xs:element name="tuple" type="T_tuple"/>
	<xs:element name="classe_utilisateur" type="T_classe_utilisateur"/>
	<!-- Essai -->
	<!--	<xs:group name="T_Attendu_group1">
		<xs:choice>
			<xs:element ref="typesimple"/>
			<xs:element ref="matrice_double"/>
			<xs:element ref="matrice_symetrique_double"/>
			<xs:element ref="tuple"/>
			<xs:element ref="classe_utilisateur"/>
		</xs:choice>
	</xs:group>

	<xs:group name="T_Attendu_group2">
		<xs:choice>
			<xs:element ref="typesimple"/>
			<xs:element ref="matrice_double"/>
			<xs:element ref="matrice_symetrique_double"/>
			<xs:element ref="tuple"/>
			<xs:element ref="classe_utilisateur"/>
			<xs:element ref="fonction_utilisateur" minOccurs="1" maxOccurs="unbounded"/>
		</xs:choice>
	</xs:group>

	<xs:complexType name="T_typeAttendu">
		<xs:group ref="T_Attendu_group1"/>
	</xs:complexType>
	-->
	<!-- Faire plutot un groupe de substitution pour ne pas croiser les choix -->
	<!--
	<xs:complexType name="T_into">
	  <xs:group ref="T_Attendu_group2"/>
	</xs:complexType>
	-->
	<xs:complexType name="T_into">
		<xs:choice>
			<!--			<xs:element ref="typesimple" type="T_Base"/>-->
			<xs:element ref="typesimple" minOccurs="0" maxOccurs="unbounded"/>
			<xs:element ref="matrice_double" minOccurs="0" maxOccurs="unbounded"/>
			<xs:element ref="matrice_symetrique_double" minOccurs="0" maxOccurs="unbounded"/>
			<xs:element ref="tuple" minOccurs="0" maxOccurs="unbounded"/>
			<xs:element ref="classe_utilisateur" minOccurs="0" maxOccurs="unbounded"/>
			<xs:element ref="fonction_utilisateur" minOccurs="1" maxOccurs="unbounded"/>
		</xs:choice>
	</xs:complexType>
	<xs:complexType name="T_typeAttendu">
		<xs:complexContent>
			<xs:restriction base="T_into">
				<xs:choice>
					<xs:element ref="typesimple" minOccurs="0" maxOccurs="unbounded"/>
					<xs:element ref="matrice_double" minOccurs="0" maxOccurs="unbounded"/>
					<xs:element ref="matrice_symetrique_double" minOccurs="0" maxOccurs="unbounded"/>
					<xs:element ref="tuple" minOccurs="0" maxOccurs="unbounded"/>
					<xs:element ref="classe_utilisateur" minOccurs="0" maxOccurs="unbounded"/>
				</xs:choice>
			</xs:restriction>
		</xs:complexContent>
	</xs:complexType>
</xs:schema>
<!-- Catalogue EFFICAS équivalent

# coding: utf-8
from Accas import *

class carte   (ASSD) : pass
class maille   (ASSD) : pass
class carte_flux_r   (carte):pass

class NOM_CHAM_INTO:
    def __call__(self, *l_typ_cham, **kwargs):
        return tuple(('A','B','C'))
C_NOM_CHAM_INTO = NOM_CHAM_INTO()

JdC = JDC_CATA(code='MAP',
               execmodul=None,
               regles=ENSEMBLE('E1','E2','E3')
               )

CREECARTE = OPER(nom="CREECARTE",op=None, sd_prod=carte, UNITE=SIMP(statut='f',typ='I',defaut=21),);

CREECARTEFLUX = OPER(nom="CREECARTEFLUX",op=None, sd_prod=carte_flux_r,
                   NOMFLUX=SIMP(statut='o',typ='TXM',defaut='monFlux'),
                );

CREEMAILLE = OPER(nom="CREEMAILLE",op=None, sd_prod=maille,
                NOEUDS=SIMP(statut='o',typ='I',defaut=(1,2),min=2,max=2)
              );

E1=PROC(nom="E1",
        op=None,
        regles    = (EXCLUS('ETAT_INIT','RESULTAT',),),
        ETAT_INIT = FACT(statut='f', max='**',
                         GROUP_MA_1=SIMP(statut='o',typ='I',validators=NoRepeat(),max='**'),
                         GROUP_NO_2=SIMP(statut='f',typ='I',validators=NoRepeat(),max='**'),
                    ),

        RESULTAT  = FACT(statut='f',
                         DEPL=SIMP(statut='o', typ='R',  validators=NoRepeat()),
                         VITE=SIMP(statut='f', typ='R',  validators=NoRepeat()),
                         ACCE=SIMP(statut='f', typ='R',  validators=NoRepeat()),
                    ), 
        );

E2=PROC(nom="E2", op=None,
        regles   = (UN_PARMI('CONCEPT','CHAINE','TOUT' ),),
        CONCEPT  = FACT(statut='f',max='**',
                   NOM = SIMP(statut='o',typ=assd,validators=NoRepeat(),max='**'),
                   ),
        CHAINE   = SIMP(statut='f',typ='TXM'),
        POSITION = SIMP(statut='f',typ='I',defaut=1),
        TOUT     = SIMP(statut='f',typ='TXM',into=("OUI",) ),
        );

E3=PROC(nom="E3",op=None,
        DEFORMATION = SIMP(statut='f',typ='TXM',defaut="PETIT",
                           into=("PETIT","PETIT_REAC","GROT_GDEP","SIMO_MIEHE","GDEF_HYPO_ELAS","GDEF_LOG")),
        b_blocIn    = BLOC(condition = "DEFORMATION in ('PETIT','PETIT_REAC','GROT_GDEP')",
             ITER_INTE_PAS = SIMP(statut='f',typ='I',defaut= 0 ),
             ALGO_INTE     = SIMP(statut='f',typ='TXM',into=("ANALYTIQUE", "SECANTE", "DEKKER", "NEWTON_1D","BRENT",),),
             CARTE	   = SIMP(statut='f',typ=carte,),
             b_carte       = BLOC(condition= "(AsType(CARTE) != carte_flux_r)",
                             CONTRAINTE = SIMP(statut='f',typ='TXM',validators=NoRepeat(),max='**',
                                          fr="Options pour le calcul de contraintes et efforts generalises",
                                           into=C_NOM_CHAM_INTO(phenomene='CONTRAINTE',categorie='lin'),)
                             ),
                      ),  
       );

-->
