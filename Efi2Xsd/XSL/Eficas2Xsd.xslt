<?xml version="1.0" encoding="UTF-8"?>
<!--
This file was generated by Altova MapForce 2018sp1

YOU SHOULD NOT MODIFY THIS FILE, BECAUSE IT WILL BE
OVERWRITTEN WHEN YOU RE-RUN CODE GENERATION.

Refer to the Altova MapForce Documentation for further details.
http://www.altova.com/mapforce
-->
<xsl:stylesheet version="2.0" xmlns:xsl="http://www.w3.org/1999/XSL/Transform" xmlns:ns0="http://chercheurs.edf.com/logiciels/efficas" xmlns:user="http://www.altova.com/MapForce/UDF/user" xmlns:vmf="http://www.altova.com/MapForce/UDF/vmf" xmlns:grp="http://www.altova.com/Mapforce/grouping" xmlns:xs="http://www.w3.org/2001/XMLSchema" xmlns:fn="http://www.w3.org/2005/xpath-functions" exclude-result-prefixes="ns0 user vmf grp xs fn">
	<xsl:param name="Model_Efficas__1_1____XMLSchema__1_1__v7" select="'Model Efficas (1.1) + XMLSchema (1.1) v7.xml'"/>
	<xsl:function name="grp:Fact_mapping_v2_var9_cur_of_nom">
		<xsl:param name="var8_cur" as="node()"/>
		<xsl:for-each select="$var8_cur/@ns0:nom">
			<xsl:sequence select="fn:string(.)"/>
		</xsl:for-each>
	</xsl:function>
	<xsl:function name="grp:Fact_mapping_v2_var39_cur_of_nom">
		<xsl:param name="var38_cur" as="node()"/>
		<xsl:for-each select="$var38_cur/@ns0:nom">
			<xsl:sequence select="fn:string(.)"/>
		</xsl:for-each>
	</xsl:function>
	<xsl:function name="grp:Fact_mapping_v2_var46_cur_of_nom">
		<xsl:param name="var45_cur" as="node()"/>
		<xsl:for-each select="$var45_cur/@ns0:nom">
			<xsl:sequence select="fn:string(.)"/>
		</xsl:for-each>
	</xsl:function>
	<xsl:function name="grp:Fact_mapping_v2_var48_cur_of_nom">
		<xsl:param name="var47_cur" as="node()"/>
		<xsl:for-each select="$var47_cur/@ns0:nom">
			<xsl:sequence select="fn:string(.)"/>
		</xsl:for-each>
	</xsl:function>
	<xsl:function name="grp:Fact_mapping_v2_var50_cur_of_nom">
		<xsl:param name="var49_cur" as="node()"/>
		<xsl:for-each select="$var49_cur/@ns0:nom">
			<xsl:sequence select="fn:string(.)"/>
		</xsl:for-each>
	</xsl:function>
	<xsl:template name="user:Fact_mapping_v2">
		<xsl:param name="NameSpaceName" select="()"/>
		<xsl:param name="efficasANDschema" select="()"/>
		<xsl:variable name="var55_nom" as="node()?" select="$efficasANDschema/@ns0:nom"/>
		<xsl:variable name="var56_SIMP" as="node()*" select="$efficasANDschema/ns0:SIMP"/>
		<xsl:variable name="var57_FACT" as="node()*" select="$efficasANDschema/ns0:FACT"/>
		<xsl:variable name="var54_test_resultof_logical_and" as="xs:string*">
			<xsl:choose>
				<xsl:when test="(fn:exists($var57_FACT) and xs:boolean(xs:decimal('0')))">
					<xsl:for-each select="$var55_nom">
						<xsl:variable name="var53_cur" as="node()" select="."/>
						<xsl:for-each-group select="$var57_FACT" group-by="grp:Fact_mapping_v2_var46_cur_of_nom(.)">
							<xsl:variable name="var52_create_FACT" as="node()">
								<FACT xmlns="http://chercheurs.edf.com/logiciels/efficas">
									<xsl:for-each select="current-group()">
										<FACT>
											<xsl:for-each select="@ns0:nom">
												<xsl:attribute name="ns0:nom" select="fn:string(.)"/>
											</xsl:for-each>
										</FACT>
									</xsl:for-each>
								</FACT>
							</xsl:variable>
							<xsl:for-each-group select="$var57_FACT" group-by="grp:Fact_mapping_v2_var48_cur_of_nom(.)">
								<xsl:variable name="var51_map_of_group_by" as="xs:string*">
									<xsl:for-each-group select="$var57_FACT" group-by="grp:Fact_mapping_v2_var50_cur_of_nom(.)">
										<xsl:for-each select="current-group()/@ns0:nom">
											<xsl:sequence select="fn:string(.)"/>
										</xsl:for-each>
									</xsl:for-each-group>
								</xsl:variable>
								<xsl:sequence select="fn:concat(fn:concat(fn:concat(fn:concat(fn:concat(fn:concat(fn:concat(fn:concat(fn:concat('T_', fn:string($var53_cur)), xs:string(fn:count($var52_create_FACT/ns0:FACT))), '.'), fn:string-join($var51_map_of_group_by, '.')), '.'), 'KEY:'), current-grouping-key()), '.GID:'), xs:string(xs:decimal('0')))"/>
							</xsl:for-each-group>
						</xsl:for-each-group>
					</xsl:for-each>
				</xsl:when>
				<xsl:otherwise>
					<xsl:for-each select="$var55_nom">
						<xsl:sequence select="fn:concat('T_', fn:string(.))"/>
					</xsl:for-each>
				</xsl:otherwise>
			</xsl:choose>
		</xsl:variable>
		<schema xmlns="http://www.w3.org/2001/XMLSchema">
			<xsl:variable name="var3_resultof_filter" as="node()*">
				<xsl:for-each select="$var56_SIMP">
					<xsl:variable name="var2_resultof_filter" as="node()*">
						<xsl:for-each select="ns0:typeAttendu">
							<xsl:variable name="var1_resultof_vmf__inputtoresult" as="xs:boolean">
								<xsl:call-template name="vmf:vmf2_inputtoresult">
									<xsl:with-param name="input" select="fn:string(.)" as="xs:string"/>
								</xsl:call-template>
							</xsl:variable>
							<xsl:if test="$var1_resultof_vmf__inputtoresult">
								<xsl:sequence select="."/>
							</xsl:if>
						</xsl:for-each>
					</xsl:variable>
					<xsl:if test="fn:exists($var2_resultof_filter)">
						<xsl:sequence select="."/>
					</xsl:if>
				</xsl:for-each>
			</xsl:variable>
			<xsl:for-each select="$var3_resultof_filter">
				<xsl:variable name="var7_cur" as="node()" select="."/>
				<xsl:variable name="var6_resultof_any" as="xs:boolean" select="fn:exists((./@ns0:max_occurs)[(xs:integer(fn:string(.)) != xs:decimal('1'))])"/>
				<simpleType>
					<xsl:for-each select="@ns0:nom">
						<xsl:variable name="var5_attribut" as="node()?" select="$var7_cur/@attribut"/>
						<xsl:variable name="var4_resultof_vmf__inputtoresult" as="xs:string">
							<xsl:call-template name="vmf:vmf3_inputtoresult">
								<xsl:with-param name="input" as="xs:string">
									<xsl:choose>
										<xsl:when test="fn:exists($var5_attribut)">
											<xsl:sequence select="fn:string($var5_attribut)"/>
										</xsl:when>
										<xsl:otherwise>
											<xsl:sequence select="'n'"/>
										</xsl:otherwise>
									</xsl:choose>
								</xsl:with-param>
							</xsl:call-template>
						</xsl:variable>
						<xsl:attribute name="name" namespace="" select="fn:concat($var4_resultof_vmf__inputtoresult, fn:string(.))"/>
					</xsl:for-each>
					<xsl:if test="fn:not($var6_resultof_any)">
						<restriction>
							<xsl:for-each select="ns0:typeAttendu">
								<xsl:attribute name="base" namespace="">
									<xsl:call-template name="vmf:vmf4_inputtoresult">
										<xsl:with-param name="input" select="fn:string(.)" as="xs:string"/>
									</xsl:call-template>
								</xsl:attribute>
							</xsl:for-each>
						</restriction>
					</xsl:if>
					<xsl:if test="$var6_resultof_any">
						<list>
							<xsl:for-each select="ns0:typeAttendu">
								<xsl:attribute name="itemType" namespace="">
									<xsl:call-template name="vmf:vmf4_inputtoresult">
										<xsl:with-param name="input" select="fn:string(.)" as="xs:string"/>
									</xsl:call-template>
								</xsl:attribute>
							</xsl:for-each>
						</list>
					</xsl:if>
				</simpleType>
			</xsl:for-each>
			<xsl:for-each select="$var57_FACT">
				<xsl:variable name="var14_cur" as="node()" select="."/>
				<xsl:variable name="var13_resultof_Fact_mapping_v_" as="node()?">
					<xsl:call-template name="user:Fact_mapping_v2">
						<xsl:with-param name="NameSpaceName" select="$NameSpaceName" as="xs:string"/>
						<xsl:with-param name="efficasANDschema" as="node()">
							<FACT xmlns="http://chercheurs.edf.com/logiciels/efficas">
								<xsl:for-each-group select="." group-by="grp:Fact_mapping_v2_var9_cur_of_nom(.)">
									<xsl:variable name="var12_nom" as="node()?" select="$var14_cur/@ns0:nom"/>
									<xsl:variable name="var10_create_FACT" as="node()">
										<FACT>
											<xsl:for-each select="current-group()">
												<FACT>
													<xsl:for-each select="@ns0:nom">
														<xsl:attribute name="ns0:nom" select="fn:string(.)"/>
													</xsl:for-each>
												</FACT>
											</xsl:for-each>
										</FACT>
									</xsl:variable>
									<xsl:variable name="var11_test_resultof_greater" as="xs:string?">
										<xsl:choose>
											<xsl:when test="(fn:count($var10_create_FACT/ns0:FACT) &gt; xs:decimal('1'))">
												<xsl:for-each select="$var12_nom">
													<xsl:sequence select="fn:concat(fn:concat(fn:string(.), '++'), xs:string(xs:decimal('0')))"/>
												</xsl:for-each>
											</xsl:when>
											<xsl:otherwise>
												<xsl:for-each select="$var12_nom">
													<xsl:sequence select="fn:string(.)"/>
												</xsl:for-each>
											</xsl:otherwise>
										</xsl:choose>
									</xsl:variable>
									<xsl:for-each select="$var11_test_resultof_greater">
										<xsl:attribute name="ns0:nom" select="."/>
									</xsl:for-each>
								</xsl:for-each-group>
								<xsl:for-each select="@ns0:statut">
									<xsl:attribute name="ns0:statut" select="fn:string(.)"/>
								</xsl:for-each>
								<xsl:for-each select="@ns0:min_occurs">
									<xsl:attribute name="ns0:min_occurs" select="xs:string(xs:integer(fn:string(.)))"/>
								</xsl:for-each>
								<xsl:for-each select="@ns0:max_occurs">
									<xsl:attribute name="ns0:max_occurs" select="xs:string(xs:integer(fn:string(.)))"/>
								</xsl:for-each>
								<xsl:for-each select="ns0:regles">
									<regles>
										<xsl:sequence select="(./@node(), ./node())"/>
									</regles>
								</xsl:for-each>
								<xsl:for-each select="ns0:doc">
									<doc>
										<xsl:sequence select="(./@node(), ./node())"/>
									</doc>
								</xsl:for-each>
								<xsl:for-each select="ns0:BLOC">
									<BLOC>
										<xsl:sequence select="(./@node(), ./node())"/>
									</BLOC>
								</xsl:for-each>
								<xsl:for-each select="ns0:FACT">
									<FACT>
										<xsl:sequence select="(./@node(), ./node())"/>
									</FACT>
								</xsl:for-each>
								<xsl:for-each select="ns0:SIMP">
									<SIMP>
										<xsl:sequence select="(./@node(), ./node())"/>
									</SIMP>
								</xsl:for-each>
							</FACT>
						</xsl:with-param>
					</xsl:call-template>
				</xsl:variable>
				<xsl:for-each select="$var13_resultof_Fact_mapping_v_/xs:simpleType">
					<simpleType>
						<xsl:sequence select="(./@node(), ./node())"/>
					</simpleType>
				</xsl:for-each>
			</xsl:for-each>
			<complexType>
				<xsl:if test="fn:exists($var54_test_resultof_logical_and)">
					<xsl:attribute name="name" namespace="" select="xs:string(fn:string-join(for $x in $var54_test_resultof_logical_and return xs:string($x), ' '))"/>
				</xsl:if>
				<sequence>
					<xsl:variable name="var16_resultof_filter" as="node()*">
						<xsl:for-each select="$var56_SIMP">
							<xsl:variable name="var15_vmf__inputtoresult_of_attribut" as="xs:boolean?">
								<xsl:for-each select="@attribut">
									<xsl:call-template name="vmf:vmf5_inputtoresult">
										<xsl:with-param name="input" select="fn:string(.)" as="xs:string"/>
									</xsl:call-template>
								</xsl:for-each>
							</xsl:variable>
							<xsl:if test="fn:not(fn:exists(($var15_vmf__inputtoresult_of_attribut)[.]))">
								<xsl:sequence select="."/>
							</xsl:if>
						</xsl:for-each>
					</xsl:variable>
					<xsl:for-each select="$var16_resultof_filter">
						<xsl:variable name="var21_cur" as="node()" select="."/>
						<xsl:variable name="var20_nom" as="node()?" select="@ns0:nom"/>
						<element>
							<xsl:for-each select="$var20_nom">
								<xsl:attribute name="name" namespace="" select="fn:string(.)"/>
							</xsl:for-each>
							<xsl:for-each select="$var20_nom">
								<xsl:variable name="var18_attribut" as="node()?" select="$var21_cur/@attribut"/>
								<xsl:variable name="var17_resultof_vmf__inputtoresult" as="xs:string">
									<xsl:call-template name="vmf:vmf3_inputtoresult">
										<xsl:with-param name="input" as="xs:string">
											<xsl:choose>
												<xsl:when test="fn:exists($var18_attribut)">
													<xsl:sequence select="fn:string($var18_attribut)"/>
												</xsl:when>
												<xsl:otherwise>
													<xsl:sequence select="'n'"/>
												</xsl:otherwise>
											</xsl:choose>
										</xsl:with-param>
									</xsl:call-template>
								</xsl:variable>
								<xsl:attribute name="type" namespace="" select="fn:QName(' ', fn:concat(fn:concat($NameSpaceName, ':'), fn:concat($var17_resultof_vmf__inputtoresult, fn:string(.))))"/>
							</xsl:for-each>
							<xsl:for-each select="@ns0:statut">
								<xsl:variable name="var19_resultof_vmf__inputtoresult" as="xs:string?">
									<xsl:call-template name="vmf:vmf6_inputtoresult">
										<xsl:with-param name="input" select="fn:string(.)" as="xs:string"/>
									</xsl:call-template>
								</xsl:variable>
								<xsl:for-each select="$var19_resultof_vmf__inputtoresult">
									<xsl:attribute name="minOccurs" namespace="" select="xs:string(xs:integer(.))"/>
								</xsl:for-each>
							</xsl:for-each>
						</element>
					</xsl:for-each>
					<xsl:for-each select="$var57_FACT">
						<xsl:variable name="var24_nom" as="node()?" select="@ns0:nom"/>
						<element>
							<xsl:for-each select="$var24_nom">
								<xsl:attribute name="name" namespace="" select="fn:string(.)"/>
							</xsl:for-each>
							<xsl:for-each select="$var24_nom">
								<xsl:attribute name="type" namespace="" select="fn:QName(' ', fn:concat(fn:concat($NameSpaceName, ':T_'), fn:string(.)))"/>
							</xsl:for-each>
							<xsl:for-each select="@ns0:statut">
								<xsl:variable name="var22_resultof_vmf__inputtoresult" as="xs:string?">
									<xsl:call-template name="vmf:vmf7_inputtoresult">
										<xsl:with-param name="input" select="fn:string(.)" as="xs:string"/>
									</xsl:call-template>
								</xsl:variable>
								<xsl:for-each select="$var22_resultof_vmf__inputtoresult">
									<xsl:attribute name="minOccurs" namespace="" select="xs:string(xs:integer(.))"/>
								</xsl:for-each>
							</xsl:for-each>
							<xsl:for-each select="@ns0:max_occurs">
								<xsl:variable name="var23_cur_as_integer" as="xs:integer" select="xs:integer(fn:string(.))"/>
								<xsl:attribute name="maxOccurs" namespace="">
									<xsl:choose>
										<xsl:when test="($var23_cur_as_integer = xs:decimal('-1'))">
											<xsl:sequence select="'unbounded'"/>
										</xsl:when>
										<xsl:otherwise>
											<xsl:sequence select="xs:string($var23_cur_as_integer)"/>
										</xsl:otherwise>
									</xsl:choose>
								</xsl:attribute>
							</xsl:for-each>
						</element>
					</xsl:for-each>
				</sequence>
				<xsl:variable name="var26_resultof_filter" as="node()*">
					<xsl:for-each select="$var56_SIMP">
						<xsl:variable name="var25_vmf__inputtoresult_of_attribut" as="xs:boolean?">
							<xsl:for-each select="@attribut">
								<xsl:call-template name="vmf:vmf5_inputtoresult">
									<xsl:with-param name="input" select="fn:string(.)" as="xs:string"/>
								</xsl:call-template>
							</xsl:for-each>
						</xsl:variable>
						<xsl:if test="fn:exists(($var25_vmf__inputtoresult_of_attribut)[.])">
							<xsl:sequence select="."/>
						</xsl:if>
					</xsl:for-each>
				</xsl:variable>
				<xsl:for-each select="$var26_resultof_filter">
					<xsl:variable name="var31_cur" as="node()" select="."/>
					<xsl:variable name="var30_nom" as="node()?" select="@ns0:nom"/>
					<attribute>
						<xsl:for-each select="$var30_nom">
							<xsl:attribute name="name" namespace="" select="fn:string(.)"/>
						</xsl:for-each>
						<xsl:for-each select="$var30_nom">
							<xsl:variable name="var28_attribut" as="node()?" select="$var31_cur/@attribut"/>
							<xsl:variable name="var27_resultof_vmf__inputtoresult" as="xs:string">
								<xsl:call-template name="vmf:vmf3_inputtoresult">
									<xsl:with-param name="input" as="xs:string">
										<xsl:choose>
											<xsl:when test="fn:exists($var28_attribut)">
												<xsl:sequence select="fn:string($var28_attribut)"/>
											</xsl:when>
											<xsl:otherwise>
												<xsl:sequence select="'n'"/>
											</xsl:otherwise>
										</xsl:choose>
									</xsl:with-param>
								</xsl:call-template>
							</xsl:variable>
							<xsl:attribute name="type" namespace="" select="fn:QName(' ', fn:concat(fn:concat($NameSpaceName, ':'), fn:concat($var27_resultof_vmf__inputtoresult, fn:string(.))))"/>
						</xsl:for-each>
						<xsl:for-each select="@ns0:statut">
							<xsl:variable name="var29_resultof_vmf__inputtoresult" as="xs:string?">
								<xsl:call-template name="vmf:vmf8_inputtoresult">
									<xsl:with-param name="input" select="fn:string(.)" as="xs:string"/>
								</xsl:call-template>
							</xsl:variable>
							<xsl:for-each select="$var29_resultof_vmf__inputtoresult">
								<xsl:attribute name="use" namespace="" select="."/>
							</xsl:for-each>
						</xsl:for-each>
					</attribute>
				</xsl:for-each>
			</complexType>
			<xsl:variable name="var34_resultof_filter" as="node()*">
				<xsl:for-each select="$var56_SIMP">
					<xsl:variable name="var33_resultof_filter" as="node()*">
						<xsl:for-each select="ns0:typeAttendu">
							<xsl:variable name="var32_resultof_vmf__inputtoresult" as="xs:boolean">
								<xsl:call-template name="vmf:vmf2_inputtoresult">
									<xsl:with-param name="input" select="fn:string(.)" as="xs:string"/>
								</xsl:call-template>
							</xsl:variable>
							<xsl:if test="$var32_resultof_vmf__inputtoresult">
								<xsl:sequence select="."/>
							</xsl:if>
						</xsl:for-each>
					</xsl:variable>
					<xsl:if test="fn:not(fn:exists($var33_resultof_filter))">
						<xsl:sequence select="."/>
					</xsl:if>
				</xsl:for-each>
			</xsl:variable>
			<xsl:for-each select="$var34_resultof_filter">
				<xsl:variable name="var37_cur" as="node()" select="."/>
				<complexType>
					<xsl:for-each select="@ns0:nom">
						<xsl:variable name="var36_attribut" as="node()?" select="$var37_cur/@attribut"/>
						<xsl:variable name="var35_resultof_vmf__inputtoresult" as="xs:string">
							<xsl:call-template name="vmf:vmf3_inputtoresult">
								<xsl:with-param name="input" as="xs:string">
									<xsl:choose>
										<xsl:when test="fn:exists($var36_attribut)">
											<xsl:sequence select="fn:string($var36_attribut)"/>
										</xsl:when>
										<xsl:otherwise>
											<xsl:sequence select="'n'"/>
										</xsl:otherwise>
									</xsl:choose>
								</xsl:with-param>
							</xsl:call-template>
						</xsl:variable>
						<xsl:attribute name="name" namespace="" select="fn:concat($var35_resultof_vmf__inputtoresult, fn:string(.))"/>
					</xsl:for-each>
				</complexType>
			</xsl:for-each>
			<xsl:for-each select="$var57_FACT">
				<xsl:variable name="var44_cur" as="node()" select="."/>
				<xsl:variable name="var43_resultof_Fact_mapping_v_" as="node()?">
					<xsl:call-template name="user:Fact_mapping_v2">
						<xsl:with-param name="NameSpaceName" select="$NameSpaceName" as="xs:string"/>
						<xsl:with-param name="efficasANDschema" as="node()">
							<FACT xmlns="http://chercheurs.edf.com/logiciels/efficas">
								<xsl:for-each-group select="." group-by="grp:Fact_mapping_v2_var39_cur_of_nom(.)">
									<xsl:variable name="var42_nom" as="node()?" select="$var44_cur/@ns0:nom"/>
									<xsl:variable name="var40_create_FACT" as="node()">
										<FACT>
											<xsl:for-each select="current-group()">
												<FACT>
													<xsl:for-each select="@ns0:nom">
														<xsl:attribute name="ns0:nom" select="fn:string(.)"/>
													</xsl:for-each>
												</FACT>
											</xsl:for-each>
										</FACT>
									</xsl:variable>
									<xsl:variable name="var41_test_resultof_greater" as="xs:string?">
										<xsl:choose>
											<xsl:when test="(fn:count($var40_create_FACT/ns0:FACT) &gt; xs:decimal('1'))">
												<xsl:for-each select="$var42_nom">
													<xsl:sequence select="fn:concat(fn:concat(fn:string(.), '++'), xs:string(xs:decimal('0')))"/>
												</xsl:for-each>
											</xsl:when>
											<xsl:otherwise>
												<xsl:for-each select="$var42_nom">
													<xsl:sequence select="fn:string(.)"/>
												</xsl:for-each>
											</xsl:otherwise>
										</xsl:choose>
									</xsl:variable>
									<xsl:for-each select="$var41_test_resultof_greater">
										<xsl:attribute name="ns0:nom" select="."/>
									</xsl:for-each>
								</xsl:for-each-group>
								<xsl:for-each select="@ns0:statut">
									<xsl:attribute name="ns0:statut" select="fn:string(.)"/>
								</xsl:for-each>
								<xsl:for-each select="@ns0:min_occurs">
									<xsl:attribute name="ns0:min_occurs" select="xs:string(xs:integer(fn:string(.)))"/>
								</xsl:for-each>
								<xsl:for-each select="@ns0:max_occurs">
									<xsl:attribute name="ns0:max_occurs" select="xs:string(xs:integer(fn:string(.)))"/>
								</xsl:for-each>
								<xsl:for-each select="ns0:regles">
									<regles>
										<xsl:sequence select="(./@node(), ./node())"/>
									</regles>
								</xsl:for-each>
								<xsl:for-each select="ns0:doc">
									<doc>
										<xsl:sequence select="(./@node(), ./node())"/>
									</doc>
								</xsl:for-each>
								<xsl:for-each select="ns0:BLOC">
									<BLOC>
										<xsl:sequence select="(./@node(), ./node())"/>
									</BLOC>
								</xsl:for-each>
								<xsl:for-each select="ns0:FACT">
									<FACT>
										<xsl:sequence select="(./@node(), ./node())"/>
									</FACT>
								</xsl:for-each>
								<xsl:for-each select="ns0:SIMP">
									<SIMP>
										<xsl:sequence select="(./@node(), ./node())"/>
									</SIMP>
								</xsl:for-each>
							</FACT>
						</xsl:with-param>
					</xsl:call-template>
				</xsl:variable>
				<xsl:for-each select="$var43_resultof_Fact_mapping_v_/xs:complexType">
					<complexType>
						<xsl:sequence select="(./@node(), ./node())"/>
					</complexType>
				</xsl:for-each>
			</xsl:for-each>
		</schema>
	</xsl:template>
	<xsl:template name="vmf:vmf1_inputtoresult">
		<xsl:param name="input" select="()"/>
		<xsl:choose>
			<xsl:when test="$input='f'">
				<xsl:copy-of select="'0'"/>
			</xsl:when>
			<xsl:when test="$input='o'">
				<xsl:copy-of select="'1'"/>
			</xsl:when>
		</xsl:choose>
	</xsl:template>
	<xsl:template name="vmf:vmf2_inputtoresult">
		<xsl:param name="input" select="()"/>
		<xsl:choose>
			<xsl:when test="$input='Fichier'">
				<xsl:copy-of select="true()"/>
			</xsl:when>
			<xsl:when test="$input='Repertoire'">
				<xsl:copy-of select="true()"/>
			</xsl:when>
			<xsl:when test="$input='TXM'">
				<xsl:copy-of select="true()"/>
			</xsl:when>
			<xsl:when test="$input='I'">
				<xsl:copy-of select="true()"/>
			</xsl:when>
			<xsl:when test="$input='R'">
				<xsl:copy-of select="true()"/>
			</xsl:when>
			<xsl:when test="$input='C'">
				<xsl:copy-of select="true()"/>
			</xsl:when>
			<xsl:when test="$input='Bool'">
				<xsl:copy-of select="true()"/>
			</xsl:when>
			<xsl:when test="$input='gma'">
				<xsl:copy-of select="true()"/>
			</xsl:when>
			<xsl:when test="$input='gmo'">
				<xsl:copy-of select="true()"/>
			</xsl:when>
			<xsl:when test="$input='SalomeEntry'">
				<xsl:copy-of select="true()"/>
			</xsl:when>
			<xsl:otherwise>
				<xsl:copy-of select="false()"/>
			</xsl:otherwise>
		</xsl:choose>
	</xsl:template>
	<xsl:template name="vmf:vmf3_inputtoresult">
		<xsl:param name="input" select="()"/>
		<xsl:choose>
			<xsl:when test="$input='o'">
				<xsl:copy-of select="'AT_'"/>
			</xsl:when>
			<xsl:when test="$input='n'">
				<xsl:copy-of select="'T_'"/>
			</xsl:when>
			<xsl:otherwise>
				<xsl:copy-of select="'T_'"/>
			</xsl:otherwise>
		</xsl:choose>
	</xsl:template>
	<xsl:template name="vmf:vmf4_inputtoresult">
		<xsl:param name="input" select="()"/>
		<xsl:choose>
			<xsl:when test="$input='TXM'">
				<xsl:copy-of select="fn:QName('', 'string')"/>
			</xsl:when>
			<xsl:when test="$input='I'">
				<xsl:copy-of select="fn:QName('', 'int')"/>
			</xsl:when>
			<xsl:when test="$input='R'">
				<xsl:copy-of select="fn:QName('', 'double')"/>
			</xsl:when>
			<xsl:when test="$input='Bool'">
				<xsl:copy-of select="fn:QName('', 'boolean')"/>
			</xsl:when>
			<xsl:when test="$input='gma'">
				<xsl:copy-of select="fn:QName('', 'string')"/>
			</xsl:when>
			<xsl:when test="$input='gmo'">
				<xsl:copy-of select="fn:QName('', 'string')"/>
			</xsl:when>
			<xsl:otherwise>
				<xsl:copy-of select="fn:QName('', 'false')"/>
			</xsl:otherwise>
		</xsl:choose>
	</xsl:template>
	<xsl:template name="vmf:vmf5_inputtoresult">
		<xsl:param name="input" select="()"/>
		<xsl:choose>
			<xsl:when test="$input='o'">
				<xsl:copy-of select="true()"/>
			</xsl:when>
			<xsl:when test="$input='n'">
				<xsl:copy-of select="false()"/>
			</xsl:when>
		</xsl:choose>
	</xsl:template>
	<xsl:template name="vmf:vmf6_inputtoresult">
		<xsl:param name="input" select="()"/>
		<xsl:choose>
			<xsl:when test="$input='f'">
				<xsl:copy-of select="'0'"/>
			</xsl:when>
			<xsl:when test="$input='o'">
				<xsl:copy-of select="'1'"/>
			</xsl:when>
		</xsl:choose>
	</xsl:template>
	<xsl:template name="vmf:vmf7_inputtoresult">
		<xsl:param name="input" select="()"/>
		<xsl:choose>
			<xsl:when test="$input='f'">
				<xsl:copy-of select="'0'"/>
			</xsl:when>
			<xsl:when test="$input='o'">
				<xsl:copy-of select="'1'"/>
			</xsl:when>
		</xsl:choose>
	</xsl:template>
	<xsl:template name="vmf:vmf8_inputtoresult">
		<xsl:param name="input" select="()"/>
		<xsl:choose>
			<xsl:when test="$input='f'">
				<xsl:copy-of select="'optional'"/>
			</xsl:when>
			<xsl:when test="$input='o'">
				<xsl:copy-of select="'required'"/>
			</xsl:when>
		</xsl:choose>
	</xsl:template>
	<xsl:output method="xml" encoding="UTF-8" byte-order-mark="no" indent="yes"/>
	<xsl:param name="UserNameSpace" as="xs:string" required="yes"/>
	<xsl:param name="PrefixName" as="xs:string" required="yes"/>
	<xsl:template match="/">
		<xsl:variable name="var8_resultof_concat" as="xs:string" select="fn:concat($UserNameSpace, $PrefixName)"/>
		<xsl:variable name="var7_cata" as="node()?" select="ns0:cata"/>
		<schema xmlns="http://www.w3.org/2001/XMLSchema">
			<xsl:namespace name="{$PrefixName}">
				<xsl:sequence select="$var8_resultof_concat"/>
			</xsl:namespace>
			<xsl:attribute name="targetNamespace" namespace="" select="xs:string(xs:anyURI($var8_resultof_concat))"/>
			<xsl:attribute name="attributeFormDefault" namespace="" select="'qualified'"/>
			<xsl:attribute name="elementFormDefault" namespace="" select="'qualified'"/>
			<xsl:for-each select="$var7_cata/ns0:commandes/ns0:PROC/ns0:FACT">
				<xsl:variable name="var1_resultof_Fact_mapping_v_" as="node()?">
					<xsl:call-template name="user:Fact_mapping_v2">
						<xsl:with-param name="NameSpaceName" select="$PrefixName" as="xs:string"/>
						<xsl:with-param name="efficasANDschema" as="node()">
							<FACT xmlns="http://chercheurs.edf.com/logiciels/efficas">
								<xsl:attribute name="ns0:nom" select="fn:string(@ns0:nom)"/>
								<xsl:for-each select="@ns0:statut">
									<xsl:attribute name="ns0:statut" select="fn:string(.)"/>
								</xsl:for-each>
								<xsl:for-each select="@ns0:max_occurs">
									<xsl:attribute name="ns0:max_occurs" select="xs:string(xs:integer(fn:string(.)))"/>
								</xsl:for-each>
								<xsl:for-each select="ns0:FACT">
									<FACT>
										<xsl:sequence select="(./@node(), ./node())"/>
									</FACT>
								</xsl:for-each>
								<xsl:for-each select="ns0:SIMP">
									<SIMP>
										<xsl:attribute name="ns0:nom" select="fn:string(@ns0:nom)"/>
										<xsl:for-each select="@ns0:statut">
											<xsl:attribute name="ns0:statut" select="fn:string(.)"/>
										</xsl:for-each>
										<xsl:for-each select="@ns0:max_occurs">
											<xsl:attribute name="ns0:max_occurs" select="xs:string(xs:integer(fn:string(.)))"/>
										</xsl:for-each>
										<xsl:for-each select="@attribut">
											<xsl:attribute name="attribut" namespace="" select="fn:string(.)"/>
										</xsl:for-each>
										<xsl:for-each select="ns0:typeAttendu">
											<typeAttendu>
												<xsl:sequence select="fn:string(.)"/>
											</typeAttendu>
										</xsl:for-each>
									</SIMP>
								</xsl:for-each>
							</FACT>
						</xsl:with-param>
					</xsl:call-template>
				</xsl:variable>
				<xsl:for-each select="$var1_resultof_Fact_mapping_v_/xs:simpleType">
					<simpleType>
						<xsl:sequence select="(./@node(), ./node())"/>
					</simpleType>
				</xsl:for-each>
			</xsl:for-each>
			<xsl:for-each select="$var7_cata/ns0:commandes/ns0:PROC">
				<complexType>
					<xsl:attribute name="name" namespace="" select="fn:concat('T_', fn:string(@ns0:nom))"/>
					<sequence>
						<xsl:for-each select="ns0:FACT">
							<xsl:variable name="var4_nom_as_string" as="xs:string" select="fn:string(@ns0:nom)"/>
							<element>
								<xsl:attribute name="name" namespace="" select="$var4_nom_as_string"/>
								<xsl:attribute name="type" namespace="" select="fn:QName(' ', fn:concat(fn:concat($PrefixName, ':T_'), $var4_nom_as_string))"/>
								<xsl:for-each select="@ns0:statut">
									<xsl:variable name="var2_resultof_vmf__inputtoresult" as="xs:string?">
										<xsl:call-template name="vmf:vmf1_inputtoresult">
											<xsl:with-param name="input" select="fn:string(.)" as="xs:string"/>
										</xsl:call-template>
									</xsl:variable>
									<xsl:for-each select="$var2_resultof_vmf__inputtoresult">
										<xsl:attribute name="minOccurs" namespace="" select="xs:string(xs:integer(.))"/>
									</xsl:for-each>
								</xsl:for-each>
								<xsl:for-each select="@ns0:max_occurs">
									<xsl:variable name="var3_cur_as_integer" as="xs:integer" select="xs:integer(fn:string(.))"/>
									<xsl:attribute name="maxOccurs" namespace="">
										<xsl:choose>
											<xsl:when test="($var3_cur_as_integer = xs:decimal('-1'))">
												<xsl:sequence select="'unbounded'"/>
											</xsl:when>
											<xsl:otherwise>
												<xsl:sequence select="xs:string($var3_cur_as_integer)"/>
											</xsl:otherwise>
										</xsl:choose>
									</xsl:attribute>
								</xsl:for-each>
							</element>
						</xsl:for-each>
					</sequence>
				</complexType>
			</xsl:for-each>
			<xsl:for-each select="$var7_cata/ns0:commandes/ns0:PROC/ns0:FACT">
				<xsl:variable name="var5_resultof_Fact_mapping_v_" as="node()?">
					<xsl:call-template name="user:Fact_mapping_v2">
						<xsl:with-param name="NameSpaceName" select="$PrefixName" as="xs:string"/>
						<xsl:with-param name="efficasANDschema" as="node()">
							<FACT xmlns="http://chercheurs.edf.com/logiciels/efficas">
								<xsl:attribute name="ns0:nom" select="fn:string(@ns0:nom)"/>
								<xsl:for-each select="@ns0:statut">
									<xsl:attribute name="ns0:statut" select="fn:string(.)"/>
								</xsl:for-each>
								<xsl:for-each select="@ns0:max_occurs">
									<xsl:attribute name="ns0:max_occurs" select="xs:string(xs:integer(fn:string(.)))"/>
								</xsl:for-each>
								<xsl:for-each select="ns0:FACT">
									<FACT>
										<xsl:sequence select="(./@node(), ./node())"/>
									</FACT>
								</xsl:for-each>
								<xsl:for-each select="ns0:SIMP">
									<SIMP>
										<xsl:attribute name="ns0:nom" select="fn:string(@ns0:nom)"/>
										<xsl:for-each select="@ns0:statut">
											<xsl:attribute name="ns0:statut" select="fn:string(.)"/>
										</xsl:for-each>
										<xsl:for-each select="@ns0:max_occurs">
											<xsl:attribute name="ns0:max_occurs" select="xs:string(xs:integer(fn:string(.)))"/>
										</xsl:for-each>
										<xsl:for-each select="@attribut">
											<xsl:attribute name="attribut" namespace="" select="fn:string(.)"/>
										</xsl:for-each>
										<xsl:for-each select="ns0:typeAttendu">
											<typeAttendu>
												<xsl:sequence select="fn:string(.)"/>
											</typeAttendu>
										</xsl:for-each>
									</SIMP>
								</xsl:for-each>
							</FACT>
						</xsl:with-param>
					</xsl:call-template>
				</xsl:variable>
				<xsl:for-each select="$var5_resultof_Fact_mapping_v_/xs:complexType">
					<complexType>
						<xsl:sequence select="(./@node(), ./node())"/>
					</complexType>
				</xsl:for-each>
			</xsl:for-each>
			<xsl:for-each select="$var7_cata/ns0:commandes/ns0:PROC">
				<xsl:variable name="var6_nom_as_string" as="xs:string" select="fn:string(@ns0:nom)"/>
				<element>
					<xsl:attribute name="type" namespace="" select="fn:QName(' ', fn:concat(fn:concat($PrefixName, ':T_'), $var6_nom_as_string))"/>
					<xsl:attribute name="name" namespace="" select="$var6_nom_as_string"/>
				</element>
			</xsl:for-each>
		</schema>
	</xsl:template>
</xsl:stylesheet>
