#& MODIF ENTETE  DATE 10/10/2006   AUTEUR MCOURTOI M.COURTOIS 
# -*- coding: iso-8859-1 -*-
#            CONFIGURATION MANAGEMENT OF EDF VERSION
# ======================================================================
# COPYRIGHT (C) 1991 - 2001  EDF R&D                  WWW.CODE-ASTER.ORG
# THIS PROGRAM IS FREE SOFTWARE; YOU CAN REDISTRIBUTE IT AND/OR MODIFY
# IT UNDER THE TERMS OF THE GNU GENERAL PUBLIC LICENSE AS PUBLISHED BY
# THE FREE SOFTWARE FOUNDATION; EITHER VERSION 2 OF THE LICENSE, OR
# (AT YOUR OPTION) ANY LATER VERSION.
#
# THIS PROGRAM IS DISTRIBUTED IN THE HOPE THAT IT WILL BE USEFUL, BUT
# WITHOUT ANY WARRANTY; WITHOUT EVEN THE IMPLIED WARRANTY OF
# MERCHANTABILITY OR FITNESS FOR A PARTICULAR PURPOSE. SEE THE GNU
# GENERAL PUBLIC LICENSE FOR MORE DETAILS.
#
# YOU SHOULD HAVE RECEIVED A COPY OF THE GNU GENERAL PUBLIC LICENSE
# ALONG WITH THIS PROGRAM; IF NOT, WRITE TO EDF R&D CODE_ASTER,
#    1 AVENUE DU GENERAL DE GAULLE, 92141 CLAMART CEDEX, FRANCE.
# ======================================================================

import Accas
from Accas import *
from Accas import _F
import string
from types import TupleType, ListType, StringType, InstanceType
import Numeric
from math import sin,cos,tan,asin,acos,atan2,atan,sinh,cosh,tanh,exp,log,log10
from math import sqrt,pi
import ops

try:
  import aster
except:
  pass

__version__="$Name:  $"
__Id__="$Id: cata.py,v 1.2.4.3 2006/12/14 17:30:02 pnoyret Exp $"

EnumTypes = (ListType, TupleType)

# -----------------------------------------------------------------------------
JdC = JDC_CATA(code='ASTER',
               execmodul=None,
               regles = (AU_MOINS_UN('DEBUT','POURSUITE'),
                         AU_MOINS_UN('FIN'),
                         A_CLASSER(('DEBUT','POURSUITE'),'FIN')))
# Type le plus general
class entier   (ASSD):
   def __init__(self,valeur=None,**args):
      ASSD.__init__(self,**args)
      self.valeur=valeur

   def __adapt__(self,validator):
      if validator.name == "list":
          #validateur liste,cardinalité
          return (self,)
      elif validator.name == "type":
          #validateur type
          return validator.adapt(self.valeur or 0)
      else:
          #validateur into et valid
          return self

class reel(ASSD):
   def __init__(self,valeur=None,**args):
      ASSD.__init__(self,**args)
      self.valeur=valeur

   def __call__(self):
      return self.valeur

   def __adapt__(self,validator):
      if validator.name == "list":
          #validateur liste,cardinalité
          return (self,)
      elif validator.name == "type":
          #validateur type
          return validator.adapt(self.valeur or 0.)
      else:
          #validateur into et valid
          return self


# -----------------------------------------------------------------------------
# Type geometriques
class no  (GEOM):pass
class grno(GEOM):pass
class ma  (GEOM):pass
class grma(GEOM):pass

# -----------------------------------------------------------------------------
# Autres
class cabl_precont    (ASSD):pass
class cara_elem       (ASSD):pass
class cham_mater      (ASSD):pass
class char_acou       (ASSD):pass
class char_cine_acou  (ASSD):pass
class char_cine_meca  (ASSD):pass
class char_cine_ther  (ASSD):pass
class char_meca       (ASSD):pass
class char_ther       (ASSD):pass
class compor_sdaster  (ASSD):pass
class courbe_sdaster  (ASSD):pass
class fiss_xfem       (ASSD):pass
class fond_fiss       (ASSD):pass
class interf_dyna_clas(ASSD):pass
class interspfact     (ASSD):pass
class listis_sdaster  (ASSD):pass
class melasflu_sdaster(ASSD):pass
class nume_ddl_sdaster(ASSD):pass
class nume_ddl_gene   (ASSD):pass
class sd_feti_sdaster (ASSD):pass
class spectre_sdaster (ASSD):pass
class surface_sdaster (ASSD):pass
class tran_gene       (ASSD):pass
class type_flui_stru  (ASSD):pass

# -----------------------------------------------------------------------------
# modeles :
class modele_sdaster  (ASSD):pass
class modele_gene     (ASSD):
  def LIST_SOUS_STRUCT(self) :
    """ retourne la liste des sous structures du modele generalise
        la liste des macro-elements sous-jacents"""
    if self.par_lot():
      raise Accas.AsException("Erreur dans modele_gene.LIST_SOUS_STRUCT en PAR_LOT='OUI'")
    nommodgen=self.get_name()
    ncham=nommodgen+(8-len(nommodgen))*' '
    ssno=aster.getvectjev(ncham+(14-len(ncham))*' '+'.MODG.SSNO')
    ssme=aster.getcolljev(ncham+(14-len(ncham))*' '+'.MODG.SSME')
    return [([ssno[ind], ssme[ind+1]]) for ind in range(len(ssno))]
  def LIST_LIAIS_STRUCT(self) :
    """ retourne la liste des liaisons entre sous structures du modele generalise sous la forme :
        [ (ss1, nom_liais1,  ss2 , nom_liais2), ...] """
    if self.par_lot() :
      raise Accas.AsException("Erreur dans modele_gene.LIST_LIAIS_STRUCT en PAR_LOT='OUI'")
    nommodgen=self.get_name()
    ncham=nommodgen+(8-len(nommodgen))*' '
    lidf=aster.getcolljev(ncham+(14-len(ncham))*' '+'.MODG.LIDF')
    return [([(lidf[ind][indb]) for indb in range(4)]) for ind in lidf]


# -----------------------------------------------------------------------------
# materiau
class mater_sdaster(ASSD):
   def RCVALE(self, phenomene, nompar=(), valpar=(), nomres=(), stop='F'):
      """Appel à la routine fortran RCVALE pour récupérer les valeurs des
      propriétés du matériau.
      """
      if self.par_lot() :
         raise Accas.AsException("Erreur dans mater.RCVALE en PAR_LOT='OUI'")
      from Utilitai.Utmess import UTMESS
      # vérification des arguments
      if not type(nompar) in EnumTypes:
         nompar = [nompar,]
      if not type(valpar) in EnumTypes:
         valpar = [valpar,]
      if not type(nomres) in EnumTypes:
         nomres = [nomres,]
      nompar = tuple(nompar)
      valpar = tuple(valpar)
      nomres = tuple(nomres)
      if len(nompar) != len(valpar):
         UTMESS('F', 'RCVALE', """Arguments incohérents :
      Nom des paramètres : %s
   Valeur des paramètres : %s""" \
         % (', '.join(nompar), ', '.join([repr(v) for v in valpar])))
      if len(nomres) < 1:
         UTMESS('F', 'RCVALE', 'Argument invalide : "nomres" vide !')
      # appel à l'interface Python/C
      return aster.rcvale(self.nom, phenomene, nompar, valpar, nomres, stop)

# -----------------------------------------------------------------------------
# macro-elements :
class macr_elem_dyna  (ASSD):
  def NBRE_MODES(self) :
    """ retourne le nombre de modes total, dynamiques et d'interface """
    if self.par_lot() :
      raise Accas.AsException("Erreur dans macr_elem_dyna.NBRE_MODES en PAR_LOT='OUI'")
    nommacr=self.get_name()
    ncham=nommacr+(8-len(nommacr))*' '
    ncham=nommacr+(8-len(nommacr))*' '+'.MAEL'
    nombase=aster.getvectjev(ncham+'_REFE')[0]
    nbmode=Numeric.array(aster.getvectjev(nombase[0:8]+(19-len(nombase[0:8]))*' '+'.UTIL'))
    nbmodtot=nbmode[1]
    nbmoddyn=nbmode[2]
    nbmodint=nbmode[3]
    return [nbmodtot,nbmoddyn,nbmodint]

  def EXTR_MATR_GENE(self,typmat) :
    """ retourne les valeurs des matrices generalisees reelles
    dans un format Numerical Array
        typmat='MASS_GENE' pour obtenir la matrice de masse generalisee
        typmat='RIGI_GENE' pour obtenir la matrice de raideur generalisee
        typmat='AMOR_GENE' pour obtenir la matrice d'amortissement generalisee
        Attributs retourne
          - self.valeurs : Numeric.array contenant les valeurs """
    if self.par_lot() :
      raise Accas.AsException("Erreur dans macr_elem_dyna.EXTR_MATR_GENE en PAR_LOT='OUI'")

    nommacr=self.get_name()
    if (typmat=='MASS_GENE') :
       ext='.MAEL_MASS'
    elif (typmat=='RIGI_GENE') :
       ext='.MAEL_RAID'
    elif (typmat=='AMOR_GENE') :
       ext='.MAEL_AMOR'
    else:
       raise Accas.AsException("Le type de la matrice est incorrect")
    ncham=nommacr+(8-len(nommacr))*' '+ext
    desc=Numeric.array(aster.getvectjev(ncham+'_DESC'))

    # On teste si le DESC du vecteur existe
    if (desc==None):
       raise Accas.AsException("L'objet matrice n'existe pas ou \
       est mal cree par Code Aster")

    tmp=Numeric.array(aster.getvectjev(ncham+'_VALE'))
    matrice=Numeric.zeros([desc[1],desc[1]],Numeric.Float)
    for j in range(desc[1]+1):
      for i in range(j):
        k=j*(j-1)/2+i
        matrice[j-1,i]=tmp[k]
    matrice=(matrice+Numeric.transpose(matrice))
    for i in range(desc[1]):
      matrice[i,i]=0.5*matrice[i,i]
    return matrice

  def RECU_MATR_GENE(self,typmat,matrice) :
    """ envoie les valeurs d'un Numerical Array dans des matrices generalisees
    reelles definies dans jeveux
        typmat='MASS_GENE' pour obtenir la matrice de masse generalisee
        typmat='RIGI_GENE' pour obtenir la matrice de raideur generalisee
        typmat='AMOR_GENE' pour obtenir la matrice d'amortissement generalisee
        Attributs ne retourne rien """
    if self.par_lot() :
      raise Accas.AsException("Erreur dans macr_elem_dyna.RECU_MATR_GENE en PAR_LOT='OUI'")
    from Utilitai.Utmess import UTMESS

    # avertissement generique
    UTMESS('A','RECU_MATR_GENE',' ATTENTION, VOUS ALLEZ ECRASER DES CONCEPTS EXISTANTS')

    nommacr=self.get_name()
    if (typmat=='MASS_GENE') :
       ext='.MAEL_MASS'
    elif (typmat=='RIGI_GENE') :
       ext='.MAEL_RAID'
    elif (typmat=='AMOR_GENE') :
       ext='.MAEL_AMOR'
    else:
       raise Accas.AsException("Le type de la matrice \
                                est incorrect")
    ncham=nommacr+(8-len(nommacr))*' '+ext
    desc=Numeric.array(aster.getvectjev(ncham+'_DESC'))

    # On teste si le DESC de la matrice jeveux existe
    if (desc==None):
       raise Accas.AsException("L'objet matrice n'existe pas ou \
                                est mal cree par Code Aster")
    Numeric.asarray(matrice)

    # On teste si la matrice python est de dimension 2
    if (len(Numeric.shape(matrice))<>2):
       raise Accas.AsException("La dimension de la matrice \
                                est incorrecte")

    # On teste si les tailles de la matrice jeveux et python sont identiques
    if (tuple([desc[1],desc[1]])<>Numeric.shape(matrice)) :
       raise Accas.AsException("La dimension de la matrice \
                                est incorrecte")
    taille=desc[1]*desc[1]/2.0+desc[1]/2.0
    tmp=Numeric.zeros([int(taille)],Numeric.Float)
    for j in range(desc[1]+1):
      for i in range(j):
        k=j*(j-1)/2+i
        tmp[k]=matrice[j-1,i]
    aster.putvectjev(ncham+'_VALE',len(tmp),tuple((
    range(1,len(tmp)+1))),tuple(tmp),tuple(tmp),1)
    return

class macr_elem_stat  (ASSD):pass


# -----------------------------------------------------------------------------
# liste :
class listr8_sdaster   (ASSD):
   def Valeurs(self) :
      """
      Retourne la liste des valeurs : [val1, ..., valN]
      """
      if not self.par_lot():
         vale='%-19s.VALE' % self.get_name()
         t_vale = aster.getvectjev(vale)
         if t_vale == None:
            UTMESS('F', 'listr8.Valeurs', "Objet '%s' inexistant" % vale)
         return list(t_vale)
      else:
         raise Accas.AsException("Erreur dans listr8.Valeurs en PAR_LOT='OUI'")


# -----------------------------------------------------------------------------
# post-traitement :
class post_comp_cham_el :
  def __init__(self,valeurs,maille=None,point=None,sous_point=None) :
    self.valeurs=valeurs
    self.maille=maille
    self.point=point
    self.sous_point=sous_point

class post_comp_cham_no :
  def __init__(self,valeurs,noeud=None) :
    self.valeurs=valeurs
    self.noeud=noeud

# -----------------------------------------------------------------------------
# maillage :
class maillage_sdaster(ASSD):
  def LIST_GROUP_NO(self) :
      """ retourne la liste des groupes de noeuds sous la forme :
        [ (gno1, nb noeuds  gno1), ...] """
      if self.par_lot() :
         raise Accas.AsException("Erreur dans maillage.LIST_GROUP_NO en PAR_LOT='OUI'")
      nommail=self.get_name()
      dic_gpno=aster.getcolljev(nommail.ljust(8)+".GROUPENO")
      return [(gpno.strip(),len(dic_gpno[gpno])) for gpno in dic_gpno]
  def LIST_GROUP_MA(self) :
      """ retourne la liste des groupes de mailles sous la forme :
        [ (gma1, nb mailles gma1, dime max des mailles gma1), ...] """
      if self.par_lot() :
         raise Accas.AsException("Erreur dans maillage.LIST_GROUP_MA en PAR_LOT='OUI'")
      nommail=self.get_name()
      nommail=nommail.ljust(8)
      ngpma=[]
      ltyma =aster.getvectjev("&CATA.TM.NOMTM")
      catama=aster.getcolljev("&CATA.TM.TMDIM")
      dic_gpma=aster.getcolljev(nommail+".GROUPEMA")
      dimama=[catama[ltyma[ma-1]][0] for ma in aster.getvectjev(nommail+".TYPMAIL")]
      for grp in dic_gpma.keys():
         dim=max([dimama[ma-1] for ma in dic_gpma[grp]])
         ngpma.append((grp.strip(),len(dic_gpma[grp]),dim))
      return ngpma

class squelette     (maillage_sdaster):pass


# -----------------------------------------------------------------------------
# champ_gd/carte
class cham_gd_sdaster(ASSD):pass
class carte_sdaster  (cham_gd_sdaster):pass

# -----------------------------------------------------------------------------
# cham_elem
class cham_elem(cham_gd_sdaster):
  def EXTR_COMP(self,comp,lgma,topo=0) :
      """ retourne les valeurs de la composante comp du champ sur la liste
        de groupes de mailles lgma avec eventuellement l'info de la
        topologie si topo>0. Si lgma est une liste vide, c'est equivalent
        a un TOUT='OUI' dans les commandes aster
        Attributs retourne
          - self.valeurs : Numeric.array contenant les valeurs
        Si on a demande la topo  :
          - self.maille  : numero de mailles
          - self.point   : numero du point dans la maille
          - self.sous_point : numero du sous point dans la maille """
      if self.par_lot() :
         raise Accas.AsException("Erreur dans cham_elem.EXTR_COMP en PAR_LOT='OUI'")

      ncham=self.get_name()
      ncham=ncham+(8-len(ncham))*' '
      nchams=ncham[0:7]+'S'
      ncmp=comp+(8-len(comp))*' '

      aster.prepcompcham(ncham,nchams,ncmp,"EL      ",topo,lgma)

      valeurs=Numeric.array(aster.getvectjev(nchams+(19-len(ncham))*' '+'.V'))

      if (topo>0) :
         maille=(aster.getvectjev(nchams+(19-len(ncham))*' '+'.M'))
         point=(aster.getvectjev(nchams+(19-len(ncham))*' '+'.P'))
         sous_point=(aster.getvectjev(nchams+(19-len(ncham))*' '+'.SP'))
      else :
         maille=None
         point=None
         sous_point=None

      aster.prepcompcham("__DETR__",nchams,ncmp,"EL      ",topo,lgma)

      return post_comp_cham_el(valeurs,maille,point,sous_point)

# -----------------------------------------------------------------------------
# cham_no :
class cham_no_sdaster(cham_gd_sdaster):

  def EXTR_COMP(self,comp,lgno,topo=0) :
      """ retourne les valeurs de la composante comp du champ sur la liste
        de groupes de noeuds lgno avec eventuellement l'info de la
        topologie si topo>0. Si lgno est une liste vide, c'est equivalent
        a un TOUT='OUI' dans les commandes aster
        Attributs retourne
          - self.valeurs : Numeric.array contenant les valeurs
        Si on a demande la topo (i.e. self.topo = 1) :
          - self.noeud  : numero de noeud """
      if self.par_lot() :
         raise Accas.AsException("Erreur dans cham_no.EXTR_COMP en PAR_LOT='OUI'")

      ncham=self.get_name()
      ncham=ncham+(8-len(ncham))*' '
      nchams=ncham[0:7]+'S'
      ncmp=comp+(8-len(comp))*' '

      aster.prepcompcham(ncham,nchams,ncmp,"NO      ",topo,lgno)

      valeurs=Numeric.array(aster.getvectjev(nchams+(19-len(ncham))*' '+'.V'))

      if (topo>0) :
         noeud=(aster.getvectjev(nchams+(19-len(ncham))*' '+'.N'))
      else :
         noeud=None

      aster.prepcompcham("__DETR__",nchams,ncmp,"NO      ",topo,lgno)

      return post_comp_cham_no(valeurs,noeud)

# -----------------------------------------------------------------------------
# resultat_sdaster : (evol_sdaster,mode_stat,mode_meca)
class resultat_sdaster(ASSD):
  def LIST_CHAMPS (self) :
    if self.par_lot() :
      raise Accas.AsException("Erreur dans resultat.LIST_CHAMPS en PAR_LOT='OUI'")
    return aster.GetResu(self.get_name(), "CHAMPS")
  def LIST_NOM_CMP (self) :
    if self.par_lot() :
      raise Accas.AsException("Erreur dans resultat.LIST_NOM_CMP en PAR_LOT='OUI'")
    return aster.GetResu(self.get_name(), "COMPOSANTES")
  def LIST_VARI_ACCES (self) :
    if self.par_lot() :
      raise Accas.AsException("Erreur dans resultat.LIST_VARI_ACCES en PAR_LOT='OUI'")
    return aster.GetResu(self.get_name(), "VARI_ACCES")
  def LIST_PARA (self) :
    if self.par_lot() :
      raise Accas.AsException("Erreur dans resultat.LIST_PARA en PAR_LOT='OUI'")
    return aster.GetResu(self.get_name(), "PARAMETRES")

class resultat_jeveux(resultat_sdaster):
   """Classe permettant d'accéder à un resultat jeveux qui n'a pas d'ASSD associée,
   c'est le cas des concepts résultats (table, evol_xxxx) dérivés."""
   def __init__(self,nom_jeveux):
      self.nom=nom_jeveux

# -----------------------------------------------------------------------------
class acou_harmo    (resultat_sdaster):pass
class base_modale   (resultat_sdaster):pass
class comb_fourier  (resultat_sdaster):pass
class dyna_harmo    (resultat_sdaster):pass
class dyna_trans    (resultat_sdaster):pass
class fourier_elas  (resultat_sdaster):pass
class fourier_ther  (resultat_sdaster):pass
class harm_gene     (resultat_sdaster):pass
class mode_acou     (resultat_sdaster):pass
class mode_cycl     (resultat_sdaster):pass
class mode_flamb    (resultat_sdaster):pass
class mode_gene     (resultat_sdaster):pass
class mult_elas     (resultat_sdaster):pass
class theta_geom    (resultat_sdaster):pass

# -----------------------------------------------------------------------------
# resultat_sdaster/evol_sdaster :
class evol_sdaster(resultat_sdaster):pass
class evol_char(evol_sdaster):pass
class evol_elas(evol_sdaster):pass
class evol_noli(evol_sdaster):pass
class evol_ther(evol_sdaster):pass
class evol_varc(evol_sdaster):pass

# -----------------------------------------------------------------------------
# resultat_sdaster/mode_stat :
class mode_stat(resultat_sdaster):pass
class mode_stat_depl(mode_stat):pass
class mode_stat_acce(mode_stat):pass
class mode_stat_forc(mode_stat):pass


# -----------------------------------------------------------------------------
# resultat_sdaster/mode_meca :
class mode_meca(resultat_sdaster):pass
class mode_meca_c(mode_meca):pass


# -----------------------------------------------------------------------------
# types 'fonction' :
class fonction_class(ASSD):
   def Valeurs(self):pass
   def Parametres(self):
      """
      Retourne un dictionnaire contenant les parametres de la fonction ;
      le type jeveux (FONCTION, FONCT_C, NAPPE) n'est pas retourne,
      le dictionnaire peut ainsi etre fourni a CALC_FONC_INTERP tel quel.
      """
      if not self.par_lot():
        TypeProl={'E':'EXCLU', 'L':'LINEAIRE', 'C':'CONSTANT' }
        objev = '%-19s.PROL' % self.get_name()
        prol = aster.getvectjev(objev)
        if prol == None:
           UTMESS('F', 'fonction.Parametres', "Objet '%s' inexistant" % objev)
        dico={
         'INTERPOL'    : [prol[1][0:3],prol[1][4:7]],
         'NOM_PARA'    : string.strip(prol[2][0:16]),
         'NOM_RESU'    : string.strip(prol[3][0:16]),
         'PROL_DROITE' : TypeProl[prol[4][1]],
         'PROL_GAUCHE' : TypeProl[prol[4][0]],
        }
      elif hasattr(self,'etape') and self.etape.nom=='DEFI_FONCTION' :
        dico={
         'INTERPOL'    : self.etape['INTERPOL'],
         'NOM_PARA'    : self.etape['NOM_PARA'],
         'NOM_RESU'    : self.etape['NOM_RESU'],
         'PROL_DROITE' : self.etape['PROL_DROITE'],
         'PROL_GAUCHE' : self.etape['PROL_GAUCHE'],
        }
        if   type(dico['INTERPOL'])==TupleType :
                  dico['INTERPOL']=list(dico['INTERPOL'])
        elif type(dico['INTERPOL'])==StringType :
                  dico['INTERPOL']=[dico['INTERPOL'],]
        if len(dico['INTERPOL'])==1 :
           dico['INTERPOL']=dico['INTERPOL']*2
      else:
         raise Accas.AsException("Erreur dans fonction.Parametres en PAR_LOT='OUI'")
      return dico
   def Trace(self,FORMAT='TABLEAU',**kargs):
      """Tracé d'une fonction"""
      if self.par_lot() :
         raise Accas.AsException("Erreur dans fonction.Trace en PAR_LOT='OUI'")
      from Utilitai.Graph import Graph
      gr=Graph()
      gr.AjoutCourbe(Val=self.Valeurs(),
            Lab=[self.Parametres()['NOM_PARA'],self.Parametres()['NOM_RESU']])
      gr.Trace(FORMAT=FORMAT,**kargs)

class fonction_sdaster(fonction_class):
   def convert(self,arg='real'):
      """
      Retourne un objet de la classe t_fonction
      représentation python de la fonction
      """
      from Utilitai.t_fonction import t_fonction,t_fonction_c
      if arg=='real' :
        return t_fonction(self.Absc(),
                          self.Ordo(),
                          self.Parametres())
      elif arg=='complex' :
        return t_fonction_c(self.Absc(),
                            self.Ordo(),
                            self.Parametres())
   def Valeurs(self) :
      """
      Retourne deux listes de valeurs : abscisses et ordonnees
      """
      if not self.par_lot():
        vale = '%-19s.VALE' % self.get_name()
        lbl = aster.getvectjev(vale)
        if lbl == None:
           UTMESS('F', 'fonction.Valeurs', "Objet '%s' inexistant" % vale)
        lbl = list(lbl)
        dim = len(lbl)/2
        lx = lbl[0:dim]
        ly = lbl[dim:2*dim]
      elif hasattr(self, 'etape') and self.etape.nom == 'DEFI_FONCTION' :
         if self.etape['VALE'] != None:
            lbl = list(self.etape['VALE'])
            dim = len(lbl)
            lx = [lbl[i] for i in range(0,dim,2)]
            ly = [lbl[i] for i in range(1,dim,2)]
         elif self.etape['VALE_PARA']!=None:
            lx = self.etape['VALE_PARA'].Valeurs()
            ly = self.etape['VALE_FONC'].Valeurs()
      else:
         raise Accas.AsException("Erreur (fonction.Valeurs) : ne fonctionne en " \
               "PAR_LOT='OUI' que sur des fonctions produites par DEFI_FONCTION " \
               "dans le jdc courant.")
      return [lx, ly]
   def Absc(self):
      """Retourne la liste des abscisses"""
      return self.Valeurs()[0]
   def Ordo(self):
      """Retourne la liste des ordonnées"""
      return self.Valeurs()[1]
   def __call__(self,val):
      ### Pour EFICAS : substitution de l'instance de classe
      ### parametre par sa valeur
      if type(val)==InstanceType:
         val=val.valeur
      ###
      __ff=self.convert()
      return __ff(val)

class para_sensi(fonction_sdaster): pass

class fonction_c(fonction_class):
   def convert(self,arg='real'):
      """
      Retourne un objet de la classe t_fonction ou t_fonction_c,
      représentation python de la fonction complexe
      """
      from Utilitai.t_fonction import t_fonction,t_fonction_c
      if arg=='real' :
        return t_fonction(self.Absc(),
                          self.Ordo(),
                          self.Parametres())
      elif arg=='imag' :
        return t_fonction(self.Absc(),
                          self.OrdoImg(),
                          self.Parametres())
      elif arg=='modul' :
        modul=Numeric.sqrt(Numeric.array(self.Ordo())**2+Numeric.array(self.OrdoImg())**2)
        return t_fonction(self.Absc(),
                          modul,
                          self.Parametres())
      elif arg=='phase' :
        phase=Numeric.arctan2(Numeric.array(self.OrdoImg()),Numeric.array(self.Ordo()))
        phase=phase*180./pi
        return t_fonction(self.Absc(),
                          phase,
                          self.Parametres())
      elif arg=='complex' :
        return t_fonction_c(self.Absc(),
                            map(complex,self.Ordo(),self.OrdoImg()),
                            self.Parametres())
   def Valeurs(self) :
      """
      Retourne trois listes de valeurs : abscisses, parties reelles et imaginaires.
      """
      if not self.par_lot():
         vale = '%-19s.VALE' % self.get_name()
         lbl = aster.getvectjev(vale)
         if lbl == None:
            UTMESS('F', 'fonction.Valeurs', "Objet '%s' inexistant" % vale)
         lbl = list(lbl)
         dim=len(lbl)/3
         lx=lbl[0:dim]
         lr=[]
         li=[]
         for i in range(dim):
            lr.append(lbl[dim+2*i])
            li.append(lbl[dim+2*i+1])
      elif hasattr(self, 'etape') and self.etape.nom == 'DEFI_FONCTION':
         lbl=list(self.etape['VALE_C'])
         dim=len(lbl)
         lx=[lbl[i] for i in range(0,dim,3)]
         lr=[lbl[i] for i in range(1,dim,3)]
         li=[lbl[i] for i in range(2,dim,3)]
      else:
         raise Accas.AsException("Erreur (fonction_c.Valeurs) : ne fonctionne en " \
               "PAR_LOT='OUI' que sur des fonctions produites par DEFI_FONCTION " \
               "dans le jdc courant.")
      return [lx, lr, li]
   def Absc(self):
      """Retourne la liste des abscisses"""
      return self.Valeurs()[0]
   def Ordo(self):
      """Retourne la liste des parties réelles des ordonnées"""
      return self.Valeurs()[1]
   def OrdoImg(self):
      """Retourne la liste des parties imaginaires des ordonnées"""
      return self.Valeurs()[2]
   def Trace(self,FORMAT='TABLEAU',**kargs):
      """Tracé d'une fonction complexe"""
      if self.par_lot() :
         raise Accas.AsException("Erreur dans fonction_c.Trace en PAR_LOT='OUI'")
      from Utilitai.Graph import Graph
      gr=Graph()
      gr.AjoutCourbe(Val=self.Valeurs(),
       Lab=[self.Parametres()['NOM_PARA'],self.Parametres()['NOM_RESU'],'IMAG'])
      gr.Trace(FORMAT=FORMAT,**kargs)
   def __call__(self,val):
      ### Pour EFICAS : substitution de l'instance de classe
      ### parametre par sa valeur
      if type(val)==InstanceType:
         val=val.valeur
      ###
      __ff=convert(self)
      return __ff(val)

class nappe_sdaster(fonction_class):
   def convert(self):
      """
      Retourne un objet de la classe t_nappe, représentation python de la nappe
      """
      from Utilitai.t_fonction import t_fonction,t_nappe
      para=self.Parametres()
      vale=self.Valeurs()
      l_fonc=[]
      i=0
      for pf in para[1] :
          para_f={'INTERPOL'    : pf['INTERPOL_FONC'],
                  'PROL_DROITE' : pf['PROL_DROITE_FONC'],
                  'PROL_GAUCHE' : pf['PROL_GAUCHE_FONC'],
                  'NOM_PARA'    : para[0]['NOM_PARA_FONC'],
                  'NOM_RESU'    : para[0]['NOM_RESU'],
                 }
          l_fonc.append(t_fonction(vale[1][i][0],vale[1][i][1],para_f))
          i+=1
      return t_nappe(vale[0],
                     l_fonc,
                     para[0])
   def Valeurs(self):
      """
      Retourne la liste des valeurs du parametre,
      et une liste de couples (abscisses,ordonnees) de chaque fonction.
      """
      if self.par_lot():
         raise Accas.AsException("Erreur dans nappe.Valeurs en PAR_LOT='OUI'")
      nsd = '%-19s' % self.get_name()
      dicv=aster.getcolljev(nsd+'.VALE')
      # les cles de dicv sont 1,...,N (indice du parametre)
      lpar=aster.getvectjev(nsd+'.PARA')
      if lpar == None:
         UTMESS('F', 'fonction.Valeurs', "Objet '%s' inexistant" % (nsd+'.PARA'))
      lval=[]
      for k in range(len(dicv)):
         lbl=dicv[k+1]
         dim=len(lbl)/2
         lval.append([lbl[0:dim],lbl[dim:2*dim]])
      return [list(lpar),lval]
   def Parametres(self):
      """
      Retourne un dictionnaire contenant les parametres de la nappe,
      le type jeveux (NAPPE) n'est pas retourne,
      le dictionnaire peut ainsi etre fourni a CALC_FONC_INTERP tel quel,
      et une liste de dictionnaire des parametres de chaque fonction.
      """
      if self.par_lot():
         raise Accas.AsException("Erreur dans nappe.Parametres en PAR_LOT='OUI'")
      TypeProl={'E':'EXCLU', 'L':'LINEAIRE', 'C':'CONSTANT' }
      objev = '%-19s.PROL' % self.get_name()
      prol=aster.getvectjev(objev)
      if prol == None:
         UTMESS('F', 'fonction.Parametres', "Objet '%s' inexistant" % objev)
      dico={
         'INTERPOL'      : [prol[1][0:3],prol[1][4:7]],
         'NOM_PARA'      : string.strip(prol[2][0:16]),
         'NOM_RESU'      : string.strip(prol[3][0:16]),
         'PROL_DROITE'   : TypeProl[prol[4][1]],
         'PROL_GAUCHE'   : TypeProl[prol[4][0]],
         'NOM_PARA_FONC' : string.strip(prol[5][0:4]),
      }
      lparf=[]
      nbf=(len(prol)-6)/2
      for i in range(nbf):
         dicf={
            'INTERPOL_FONC'    : [prol[6+i*2][0:3],prol[6+i*2][4:7]],
            'PROL_DROITE_FONC' : TypeProl[prol[7+i*2][1]],
            'PROL_GAUCHE_FONC' : TypeProl[prol[7+i*2][0]],
         }
         lparf.append(dicf)
      return [dico,lparf]
   def Absc(self):
      """Retourne la liste des abscisses"""
      return self.Valeurs()[0]
   def Trace(self,FORMAT='TABLEAU',**kargs):
      """Tracé d'une nappe"""
      if self.par_lot():
         raise Accas.AsException("Erreur dans nappe.Trace en PAR_LOT='OUI'")
      from Utilitai.Graph import Graph
      gr=Graph()
      lv=self.Valeurs()[1]
      dp=self.Parametres()[0]
      for lx,ly in lv:
         gr.AjoutCourbe(Val=[lx,ly], Lab=[dp['NOM_PARA_FONC'],dp['NOM_RESU']])
      gr.Trace(FORMAT=FORMAT,**kargs)

# -----------------------------------------------------------------------------
# matr_asse :
class matr_asse(ASSD):pass
class matr_asse_gene(matr_asse):pass

class matr_asse_gene_r(matr_asse_gene):
  def EXTR_MATR_GENE(self) :
    """ retourne les valeurs de la matrice generalisee reelle
    dans un format Numerical Array
        Attributs retourne
          - self.valeurs : Numeric.array contenant les valeurs """
    if self.par_lot():
       raise Accas.AsException("Erreur dans matr_asse_gene.EXTR_MATR_GENE en PAR_LOT='OUI'")

    ncham=self.get_name()
    ncham=ncham+(8-len(ncham))*' '
    desc=Numeric.array(aster.getvectjev(ncham+(19-len(ncham))*' '+'.DESC'))
    # On teste si le DESC de la matrice existe
    if (desc==None):
       raise Accas.AsException("L'objet matrice n'existe pas ou \
                                est mal cree par Code Aster")
    # Si le stockage est plein
    if desc[2]==2 :
      tmp=Numeric.array(aster.getcolljev(ncham+(19-len(ncham))*' '+'.VALM')[1])
      valeur=Numeric.zeros([desc[1],desc[1]],Numeric.Float)
      for j in range(desc[1]+1):
        for i in range(j):
          k=j*(j-1)/2+i
          valeur[j-1,i]=tmp[k]
      valeur=(valeur+Numeric.transpose(valeur))
      for i in range(desc[1]):
        valeur[i,i]=0.5*valeur[i,i]
    # Si le stockage est diagonal
    elif desc[2]==1 :
      tmp=Numeric.array(aster.getcolljev(ncham+(19-len(ncham))*' '+'.VALM')[1])
      valeur=Numeric.zeros([desc[1],desc[1]],Numeric.Float)
      for i in range(desc[1]):
        valeur[i,i]=tmp[i]
    # Sinon on arrete tout
    else:
      raise KeyError
    return valeur

  def RECU_MATR_GENE(self,matrice) :
    """ envoie les valeurs d'un Numerical Array dans des matrices
    generalisees reelles definies dans jeveux
        Attributs ne retourne rien """
    if self.par_lot():
       raise Accas.AsException("Erreur dans matr_asse_gene.RECU_MATR_GENE en PAR_LOT='OUI'")
    from Utilitai.Utmess import UTMESS

    # avertissement generique
    UTMESS('A','RECU_MATR_GENE',' ATTENTION, VOUS ALLEZ ECRASER DES CONCEPTS EXISTANTS')

    ncham=self.get_name()
    ncham=ncham+(8-len(ncham))*' '
    desc=Numeric.array(aster.getvectjev(ncham+(19-len(ncham))*' '+'.DESC'))

    # On teste si le DESC de la matrice existe
    if (desc==None):
       raise Accas.AsException("L'objet matrice n'existe pas ou \
                                est mal cree par Code Aster")
    Numeric.asarray(matrice)

    # On teste si la dimension de la matrice python est 2
    if (len(Numeric.shape(matrice))<>2) :
       raise Accas.AsException("La dimension de la matrice est incorrecte ")

    # On teste si les tailles des matrices jeveux et python sont identiques
    if (tuple([desc[1],desc[1]])<>Numeric.shape(matrice)) :
       raise Accas.AsException("La taille de la matrice est incorrecte ")

    # Si le stockage est plein
    if desc[2]==2 :
      taille=desc[1]*desc[1]/2.0+desc[1]/2.0
      tmp=Numeric.zeros([int(taille)],Numeric.Float)
      for j in range(desc[1]+1):
        for i in range(j):
          k=j*(j-1)/2+i
          tmp[k]=matrice[j-1,i]
      aster.putcolljev(ncham+(19-len(ncham))*' '+'.VALM',len(tmp),tuple((\
      range(1,len(tmp)+1))),tuple(tmp),tuple(tmp),1)
    # Si le stockage est diagonal
    elif desc[2]==1 :
      tmp=Numeric.zeros(desc[1],Numeric.Float)
      for j in range(desc[1]):
          tmp[j]=matrice[j,j]
      aster.putcolljev(ncham+(19-len(ncham))*' '+'.VALM',len(tmp),tuple((\
      range(1,len(tmp)+1))),tuple(tmp),tuple(tmp),1)
    # Sinon on arrete tout
    else:
      raise KeyError
    return


class matr_asse_gene_c(matr_asse_gene):
  def EXTR_MATR_GENE(self) :
    """ retourne les valeurs de la matrice generalisee complexe
    dans un format Numerical Array
        Attributs retourne
          - self.valeurs : Numeric.array contenant les valeurs """
    if self.par_lot():
       raise Accas.AsException("Erreur dans matr_asse_gene_c.EXTR_MATR_GENE en PAR_LOT='OUI'")

    ncham=self.get_name()
    ncham=ncham+(8-len(ncham))*' '
    desc=Numeric.array(aster.getvectjev(ncham+(19-len(ncham))*' '+'.DESC'))
    if (desc==None):
       raise Accas.AsException("L'objet matrice n'existe pas ou \
       est mal cree par Code Aster ")
    # Si le stockage est plein
    if desc[2]==2 :
      tmp=Numeric.array(aster.getcolljev(ncham+(19-len(ncham))*' '+'.VALM')[1])
      valeur=Numeric.zeros([desc[1],desc[1]],Numeric.Complex)
      for j in range(desc[1]+1):
        for i in range(j):
          k=j*(j-1)/2+i
          valeur[j-1,i]=tmp[k]
      valeur=(valeur+Numeric.transpose(valeur))
      for i in range(desc[1]):
        valeur[i,i]=0.5*valeur[i,i]
    # Si le stockage est diagonal
    elif desc[2]==1 :
      tmp=Numeric.array(aster.getcolljev(ncham+(19-len(ncham))*' '+'.VALM')[1])
      valeur=Numeric.zeros([desc[1],desc[1]],Numeric.Complex)
      for i in range(desc[1]):
        valeur[i,i]=tmp[i]
    # Sinon on arrete tout
    else:
      raise KeyError
    return valeur

  def RECU_MATR_GENE(self,matrice) :
    """ envoie les valeurs d'un Numerical Array dans des matrices
    generalisees reelles definies dans jeveux
        Attributs ne retourne rien """
    if self.par_lot():
       raise Accas.AsException("Erreur dans matr_asse_gene_c.RECU_MATR_GENE en PAR_LOT='OUI'")
    from Utilitai.Utmess import UTMESS

    # avertissement generique
    UTMESS('A','RECU_MATR_GENE',' ATTENTION, VOUS ALLEZ ECRASER DES CONCEPTS EXISTANTS')

    Numeric.asarray(matrice)
    ncham=self.get_name()
    ncham=ncham+(8-len(ncham))*' '
    desc=Numeric.array(aster.getvectjev(ncham+(19-len(ncham))*' '+'.DESC'))

    # On teste si le DESC de la matrice existe
    if (desc==None):
       raise Accas.AsException("L'objet matrice n'existe pas ou \
       est mal cree par Code Aster")
    Numeric.asarray(matrice)

    # On teste si la dimension de la matrice python est 2
    if (len(Numeric.shape(matrice))<>2) :
       raise Accas.AsException("La dimension de la matrice est incorrecte ")

    # On teste si la taille de la matrice jeveux et python est identique
    if (tuple([desc[1],desc[1]])<>Numeric.shape(matrice)) :
       raise Accas.AsException("La taille de la matrice est incorrecte ")

    # Si le stockage est plein
    if desc[2]==2 :
      taille=desc[1]*desc[1]/2.0+desc[1]/2.0
      tmpr=Numeric.zeros([int(taille)],Numeric.Float)
      tmpc=Numeric.zeros([int(taille)],Numeric.Float)
      for j in range(desc[1]+1):
        for i in range(j):
          k=j*(j-1)/2+i
          tmpr[k]=matrice[j-1,i].real
          tmpc[k]=matrice[j-1,i].imag
      aster.putvectjev(ncham+(19-len(ncham))*' '+'.VALM',len(tmpr),tuple((\
                       range(1,len(tmpr)+1))),tuple(tmpr),tuple(tmpc),1)
    # Si le stockage est diagonal
    elif desc[2]==1 :
      tmpr=Numeric.zeros(desc[1],Numeric.Float)
      tmpc=Numeric.zeros(desc[1],Numeric.Float)
      for j in range(desc[1]):
          tmpr[j]=matrice[j,j].real
          tmpc[j]=matrice[j,j].imag
      aster.putvectjev(ncham+(19-len(ncham))*' '+'.VALM',len(tmpr),tuple((\
                       range(1,len(tmpr)+1))),tuple(tmpr),tuple(tmpc),1)
    # Sinon on arrete tout
    else:
      raise KeyError
    return

# -----------------------------------------------------------------------------
class matr_asse_gd(matr_asse):pass
class matr_asse_depl_c(matr_asse_gd):pass
class matr_asse_depl_r(matr_asse_gd):pass
class matr_asse_pres_c(matr_asse_gd):pass
class matr_asse_pres_r(matr_asse_gd):pass
class matr_asse_temp_c(matr_asse_gd):pass
class matr_asse_temp_r(matr_asse_gd):pass

# -----------------------------------------------------------------------------
# matr_elem :
class matr_elem(ASSD):pass
class matr_elem_depl_c(matr_elem):pass
class matr_elem_depl_r(matr_elem):pass
class matr_elem_pres_c(matr_elem):pass
class matr_elem_temp_r(matr_elem):pass

# -----------------------------------------------------------------------------
# table :
class table_sdaster(ASSD):
   def __getitem__(self,key):
      from Utilitai.Utmess import UTMESS
      if self.par_lot():
         raise Accas.AsException("Erreur dans table.__getitem__ en PAR_LOT='OUI'")
      requete = '%-24s' % key[0]
      tblp = '%-19s.TBLP' % self.get_name()
      tabnom = aster.getvectjev(tblp)
      if tabnom == None:
         UTMESS('F', 'TABLE[]', "Objet '%s' inexistant" % tblp)
      for i in range(len(tabnom)) :
         if tabnom[i]==requete: break
      resu=aster.getvectjev(tabnom[i+2])
      if resu == None:
         UTMESS('F', 'TABLE[]', "Objet '%s' inexistant" % tabnom[i+2])
      exist=aster.getvectjev(tabnom[i+3])
      if exist == None:
         UTMESS('F', 'TABLE[]', "Objet '%s' inexistant" % tabnom[i+3])
      if key[1]>len(resu) or exist[key[1]-1]==0:
         raise KeyError
      else:
         return resu[key[1]-1]
   
   def TITRE(self):
      """Retourne le titre d'une table Aster
      (Utile pour récupérer le titre et uniquement le titre d'une table dont
      on souhaite manipuler la dérivée).
      """
      if self.par_lot():
         raise Accas.AsException("Erreur dans table.TITRE en PAR_LOT='OUI'")
      titj=aster.getvectjev('%-19s.TITR' % self.get_name())
      if titj<>None:
         titr='\n'.join(titj)
      else:
         titr=''
      return titr
      
   def EXTR_TABLE(self) :
      """Produit un objet Table à partir du contenu d'une table Aster
      """
      def Nonefy(l1,l2) :
          if l2==0 : return None
          else     : return l1
      if self.par_lot():
         raise Accas.AsException("Erreur dans table.EXTR_TABLE en PAR_LOT='OUI'")
      from Utilitai.Table import Table
      # titre
      titr = self.TITRE()
      # récupération des paramètres
      v_tblp = aster.getvectjev('%-19s.TBLP' % self.get_name())
      if v_tblp == None:
         # retourne une table vide
         return Table(titr=titr)
      tabnom=list(v_tblp)
      nparam=len(tabnom)/4
      lparam=[tabnom[4*i:4*i+4] for i in range(nparam)]
      dval={}
      # liste des paramètres et des types
      lpar=[]
      ltyp=[]
      for i in lparam :
         value=list(aster.getvectjev(i[2]))
         exist=aster.getvectjev(i[3])
         dval[string.strip(i[0])]=map(Nonefy,value,exist)
         lpar.append(string.strip(i[0]))
         ltyp.append(string.strip(i[1]))
      n=len(dval[lpar[0]])
      # contenu : liste de dict
      lisdic=[]
      for i in range(n) :
        d={}
        for p in lpar : d[p]=dval[p][i]
        lisdic.append(d)
      return Table(lisdic, lpar, ltyp, titr)

# -----------------------------------------------------------------------------
class table_fonction(table_sdaster):
   """Table contenant en plus une colonne FONCTION et/ou FONCTION_C dont les
   valeurs des cellules sont des noms de fonction_sdaster ou fonction_c.
   """

class table_jeveux(table_sdaster):
   """Classe permettant d'accéder à une table jeveux qui n'a pas d'ASSD associée,
   c'est le cas des concepts résultats (table, evol_xxxx) dérivés."""
   def __init__(self,nom_jeveux):
      self.nom=nom_jeveux

# -----------------------------------------------------------------------------
# vect_asse :
class vect_asse(ASSD):pass

class vect_asse_gene(vect_asse):
  def EXTR_VECT_GENE_R(self) :
    """ retourne les valeurs du vecteur generalisee
    dans un format Numerical Array
        Attributs retourne
          - self.valeurs : Numeric.array contenant les valeurs """
    if self.par_lot():
       raise Accas.AsException("Erreur dans vect_asse_gene_r.EXTR_VECT_GENE en PAR_LOT='OUI'")
    ncham=self.get_name()
    ncham=ncham+(8-len(ncham))*' '
    valeur=Numeric.array(aster.getvectjev(ncham+(19-len(ncham))*' '+'.VALE'))
    return valeur

  def RECU_VECT_GENE_R(self,vecteur) :
    """ envoie les valeurs d'un Numerical Array dans un vecteur generalise
    reel definie dans jeveux
        Attributs ne retourne rien """
    if self.par_lot():
       raise Accas.AsException("Erreur dans vect_asse_gene_r.RECU_VECT_GENE en PAR_LOT='OUI'")
    from Utilitai.Utmess import UTMESS

    # avertissement generique
    UTMESS('A','RECU_VECT_GENE',' ATTENTION, VOUS ALLEZ ECRASER DES CONCEPTS EXISTANTS')

    Numeric.asarray(vecteur)
    ncham=self.get_name()
    ncham=ncham+(8-len(ncham))*' '
    desc=Numeric.array(aster.getvectjev(ncham+(19-len(ncham))*' '+'.DESC'))
    # On teste si le DESC du vecteur existe
    if (desc==None):
       raise Accas.AsException("L'objet vecteur n'existe pas ou \
       est mal cree par Code Aster")
    # On teste si la taille du vecteur jeveux et python est identique
    if desc[1]<>Numeric.shape(vecteur)[0] :
       raise Accas.AsException("La taille du vecteur python est incorrecte")
    aster.putvectjev(ncham+(19-len(ncham))*' '+'.VALE',len(vecteur),tuple((\
    range(1,len(vecteur)+1))),tuple(vecteur),tuple(vecteur),1)
    return

  def EXTR_VECT_GENE_C(self) :
    """ retourne les valeurs du vecteur generalisee
    dans un format Numerical Array
        Attributs retourne
          - self.valeurs : Numeric.array contenant les valeurs """
    if self.par_lot():
       raise Accas.AsException("Erreur dans vect_asse_gene_c.EXTR_VECT_GENE en PAR_LOT='OUI'")

    ncham=self.get_name()
    ncham=ncham+(8-len(ncham))*' '
    valeur=Numeric.array(aster.getvectjev(ncham+(19-len(ncham))*' '+'.VALE'),Numeric.Complex)

    return valeur

  def RECU_VECT_GENE_C(self,vecteur) :
    """ envoie les valeurs d'un Numerical Array dans un vecteur generalise
    complexe definie dans jeveux
        Attributs ne retourne rien """
    if self.par_lot():
       raise Accas.AsException("Erreur dans vect_asse_gene_c.RECU_VECT_GENE en PAR_LOT='OUI'")
    from Utilitai.Utmess import UTMESS

    # avertissement generique
    UTMESS('A','RECU_VECT_GENE',' ATTENTION, VOUS ALLEZ ECRASER DES CONCEPTS EXISTANTS')

    Numeric.asarray(vecteur)
    ncham=self.get_name()
    ncham=ncham+(8-len(ncham))*' '
    desc=Numeric.array(aster.getvectjev(ncham+(19-len(ncham))*' '+'.DESC'))
    # On teste si le DESC de la matrice existe
    if (desc==None):
       raise Accas.AsException("L'objet vecteur n'existe pas ou \
       est mal cree par Code Aster")
    # On teste si la taille de la matrice jeveux et python est identique
    if desc[1]<>Numeric.shape(vecteur)[0] :
       raise Accas.AsException("La taille du vecteur python est incorrecte")
    tmpr=vecteur.real
    tmpc=vecteur.imag
    aster.putvectjev(ncham+(19-len(ncham))*' '+'.VALE',len(tmpr),tuple((
    range(1,len(tmpr)+1))),tuple(tmpr),tuple(tmpc),1)
    return

# -----------------------------------------------------------------------------
# vect_elem :
class vect_elem(ASSD):pass
class vect_elem_depl_r(vect_elem):pass
class vect_elem_pres_c(vect_elem):pass
class vect_elem_pres_r(vect_elem):pass
class vect_elem_temp_r(vect_elem):pass

#& MODIF COMMUN  DATE 07/11/2006   AUTEUR MARKOVIC D.MARKOVIC 
#            CONFIGURATION MANAGEMENT OF EDF VERSION
# RESPONSABLE JMBHH01 J.M.PROIX
# ======================================================================
# COPYRIGHT (C) 1991 - 2003  EDF R&D                  WWW.CODE-ASTER.ORG
# THIS PROGRAM IS FREE SOFTWARE; YOU CAN REDISTRIBUTE IT AND/OR MODIFY  
# IT UNDER THE TERMS OF THE GNU GENERAL PUBLIC LICENSE AS PUBLISHED BY  
# THE FREE SOFTWARE FOUNDATION; EITHER VERSION 2 OF THE LICENSE, OR     
# (AT YOUR OPTION) ANY LATER VERSION.                                                  
#                                                                       
# THIS PROGRAM IS DISTRIBUTED IN THE HOPE THAT IT WILL BE USEFUL, BUT   
# WITHOUT ANY WARRANTY; WITHOUT EVEN THE IMPLIED WARRANTY OF            
# MERCHANTABILITY OR FITNESS FOR A PARTICULAR PURPOSE. SEE THE GNU      
# GENERAL PUBLIC LICENSE FOR MORE DETAILS.                              
#                                                                       
# YOU SHOULD HAVE RECEIVED A COPY OF THE GNU GENERAL PUBLIC LICENSE     
# ALONG WITH THIS PROGRAM; IF NOT, WRITE TO EDF R&D CODE_ASTER,         
#    1 AVENUE DU GENERAL DE GAULLE, 92141 CLAMART CEDEX, FRANCE.        
# ======================================================================
def C_COMP_INCR() : return FACT(statut='f',min=1,max='**',  #COMMUN#
           RELATION        =SIMP(statut='o',typ='TXM',defaut="VMIS_ISOT_TRAC",
                                 into=( "ELAS",
                                        "ELAS_HYPER",
                                        "VMIS_ISOT_TRAC",
                                        "VISC_ISOT_TRAC",
                                        "VMIS_ISOT_LINE",
                                        "VISC_ISOT_LINE",
                                        "VMIS_ISOT_PUIS",
                                        "VMIS_ECMI_TRAC",
                                        "VMIS_ECMI_LINE",
                                        "LABORD_1D",
                                        "ENDO_FRAGILE",
                                        "ENDO_ISOT_BETON",
                                        "ENDO_ORTH_BETON",
                                        "BETON_REGLE_PR",
                                        "MAZARS",
                                        "JOINT_BA",
                                        "RUPT_FRAG",
                                        "CZM_EXP_REG",
                                        "CZM_EXP",
                                        "META_P_IL",
                                        "META_P_IL_PT",
                                        "META_P_IL_RE",
                                        "META_P_IL_PT_RE",
                                        "META_V_IL",
                                        "META_V_IL_PT",
                                        "META_V_IL_RE",
                                        "META_V_IL_PT_RE",
                                        "META_P_INL",
                                        "META_P_INL_PT",
                                        "META_P_INL_RE",
                                        "META_P_INL_PT_RE",
                                        "META_V_INL",
                                        "META_V_INL_PT",
                                        "META_V_INL_RE",
                                        "META_V_INL_PT_RE",
                                        "META_P_CL",
                                        "META_P_CL_PT",
                                        "META_P_CL_RE",
                                        "META_P_CL_PT_RE",
                                        "META_V_CL",
                                        "META_V_CL_PT",
                                        "META_V_CL_RE",
                                        "META_V_CL_PT_RE",
                                        "VMIS_CINE_LINE",
                                        "VISC_TAHERI",
                                        "VISCOCHAB",
                                        "VMIS_CIN1_CHAB",
                                        "VMIS_CIN2_CHAB",
                                        "VISC_CIN1_CHAB",
                                        "VISC_CIN2_CHAB",
                                        "LMARC",
                                        "LMARC_IRRA",
                                        "ROUSSELIER",
                                        "ROUSS_PR",
                                        "ROUSS_VISC",
                                        "VMIS_POU_LINE",
                                        "VMIS_POU_FLEJOU",
                                        "ARME",
                                        "ASSE_CORN",
                                        "NORTON_HOFF",
                                        "LEMAITRE",
                                        "LEMAITRE_IRRA",
                                        "LEMA_SEUIL",
                                        "IRRAD3M",
                                        "ZIRC_CYRA2",
                                        "VISC_IRRA_LOG",
                                        "GRAN_IRRA_LOG",
                                        "ZIRC_EPRI",
                                        "VENDOCHAB",
                                        "NADAI_B",
                                        "DIS_CONTACT",
                                        "DIS_CHOC",
                                        "DIS_GRICRA",
                                        "DIS_GOUJ2E_PLAS",
                                        "DIS_GOUJ2E_ELAS",
                                        "GRILLE_ISOT_LINE",
                                        "GRILLE_CINE_LINE",
                                        "GRILLE_PINTO_MEN",
                                        "PINTO_MENEGOTTO",
                                        "CJS",
                                        "CAM_CLAY",
                                        "BARCELONE",
                                        "LAIGLE",
                                        "DRUCKER_PRAGER",
                                        "HOEK_BROWN",
                                        "HOEK_BROWN_EFF",
                                        "HOEK_BROWN_TOT",
                                        "GRANGER_FP",
                                        "GRANGER_FP_INDT",
                                        "GRANGER_FP_V",
                                        "BAZANT_FD",
                                        "BETON_UMLV_FP",
                                        "BETON_DOUBLE_DP",
                                        "KIT_HM",
                                        "KIT_HHM",
                                        "KIT_THH",
                                        "KIT_THV",
                                        "KIT_THM",
                                        "KIT_THHM",
                                        "VMIS_ASYM_LINE",
                                        "ELAS_THER",
                                        "KIT_DDI",
                                        "GLRC_DAMAGE",
                                        "GLRC_DM",
                                        "SANS",
                                        "CORR_ACIER",
                                        "MONOCRISTAL",
                                        "POLYCRISTAL",
                                        "ZMAT",
                                        "GATT_MONERIE",
                                     ) ),
          ELAS            =SIMP(statut='c',typ='I',defaut=1,into=(1,)),
          ELAS_HYPER      =SIMP(statut='c',typ='I',defaut=1,into=(1,)),
          SANS            =SIMP(statut='c',typ='I',defaut=1,into=(1,)),
          CORR_ACIER      =SIMP(statut='c',typ='I',defaut=3,into=(3,)),        
          VMIS_ISOT_TRAC  =SIMP(statut='c',typ='I',defaut=2,into=(2,)),
          VISC_ISOT_TRAC  =SIMP(statut='c',typ='I',defaut=3,into=(3,)),
          VMIS_ISOT_LINE  =SIMP(statut='c',typ='I',defaut=2,into=(2,)),
          VISC_ISOT_LINE  =SIMP(statut='c',typ='I',defaut=3,into=(3,)),
          VMIS_ISOT_PUIS  =SIMP(statut='c',typ='I',defaut=2,into=(2,)),
          VMIS_ECMI_TRAC  =SIMP(statut='c',typ='I',defaut=8,into=(8,)),
          VMIS_ECMI_LINE  =SIMP(statut='c',typ='I',defaut=8,into=(8,)),
          LABORD_1D       =SIMP(statut='c',typ='I',defaut=5,into=(5,)),
          ENDO_FRAGILE    =SIMP(statut='c',typ='I',defaut=2,into=(2,)),
          ENDO_ISOT_BETON =SIMP(statut='c',typ='I',defaut=2,into=(2,)),
          ENDO_ORTH_BETON =SIMP(statut='c',typ='I',defaut=7,into=(7,)),
          BETON_REGLE_PR  =SIMP(statut='c',typ='I',defaut=1,into=(1,)),
          MAZARS          =SIMP(statut='c',typ='I',defaut=4,into=(4,)),
          JOINT_BA        =SIMP(statut='c',typ='I',defaut=6,into=(6,)),
          RUPT_FRAG       =SIMP(statut='c',typ='I',defaut=1,into=(1,)),
          CZM_EXP_REG      =SIMP(statut='c',typ='I',defaut=4,into=(4,)),
          CZM_EXP          =SIMP(statut='c',typ='I',defaut=7,into=(7,)),                              
          META_P_IL         =SIMP(statut='c',typ='I',defaut=1,into=(1,)),
          META_P_IL_PT       =SIMP(statut='c',typ='I',defaut=1,into=(1,)),
          META_P_IL_RE       =SIMP(statut='c',typ='I',defaut=1,into=(1,)),
          META_P_IL_PT_RE    =SIMP(statut='c',typ='I',defaut=1,into=(1,)),
          META_V_IL          =SIMP(statut='c',typ='I',defaut=1,into=(1,)),
          META_V_IL_PT       =SIMP(statut='c',typ='I',defaut=1,into=(1,)),
          META_V_IL_RE       =SIMP(statut='c',typ='I',defaut=1,into=(1,)),
          META_V_IL_PT_RE    =SIMP(statut='c',typ='I',defaut=1,into=(1,)),
          META_P_INL         =SIMP(statut='c',typ='I',defaut=1,into=(1,)),
          META_P_INL_PT      =SIMP(statut='c',typ='I',defaut=1,into=(1,)),
          META_P_INL_RE      =SIMP(statut='c',typ='I',defaut=1,into=(1,)),
          META_P_INL_PT_RE   =SIMP(statut='c',typ='I',defaut=1,into=(1,)),
          META_V_INL         =SIMP(statut='c',typ='I',defaut=1,into=(1,)),
          META_V_INL_PT      =SIMP(statut='c',typ='I',defaut=1,into=(1,)),
          META_V_INL_RE      =SIMP(statut='c',typ='I',defaut=1,into=(1,)),
          META_V_INL_PT_RE   =SIMP(statut='c',typ='I',defaut=1,into=(1,)),
          META_P_CL          =SIMP(statut='c',typ='I',defaut=6,into=(6,)),
          META_P_CL_PT       =SIMP(statut='c',typ='I',defaut=6,into=(6,)),
          META_P_CL_RE       =SIMP(statut='c',typ='I',defaut=6,into=(6,)),
          META_P_CL_PT_RE    =SIMP(statut='c',typ='I',defaut=6,into=(6,)),
          META_V_CL          =SIMP(statut='c',typ='I',defaut=6,into=(6,)),
          META_V_CL_PT       =SIMP(statut='c',typ='I',defaut=6,into=(6,)),
          META_V_CL_RE       =SIMP(statut='c',typ='I',defaut=6,into=(6,)),
          META_V_CL_PT_RE    =SIMP(statut='c',typ='I',defaut=6,into=(6,)),
          VMIS_CINE_LINE  =SIMP(statut='c',typ='I',defaut=7,into=(7,)),
          VISCOCHAB       =SIMP(statut='c',typ='I',defaut=28,into=(28,)),
          VMIS_CIN1_CHAB  =SIMP(statut='c',typ='I',defaut=8,into=(8,)),
          VMIS_CIN2_CHAB  =SIMP(statut='c',typ='I',defaut=14,into=(14,)),
          VISC_CIN1_CHAB  =SIMP(statut='c',typ='I',defaut=8,into=(8,)),
          VISC_CIN2_CHAB  =SIMP(statut='c',typ='I',defaut=14,into=(14,)),
          LMARC           =SIMP(statut='c',typ='I',defaut=20,into=(20,)),
          LMARC_IRRA      =SIMP(statut='c',typ='I',defaut=20,into=(20,)),
          VISC_TAHERI     =SIMP(statut='c',typ='I',defaut=9,into=(9,)),
          ROUSSELIER      =SIMP(statut='c',typ='I',defaut=9,into=(9,)),
          ROUSS_PR        =SIMP(statut='c',typ='I',defaut=3,into=(3,)),
          ROUSS_VISC      =SIMP(statut='c',typ='I',defaut=3,into=(3,)),
          VMIS_POU_LINE   =SIMP(statut='c',typ='I',defaut=9,into=(9,)),
          VMIS_POU_FLEJOU =SIMP(statut='c',typ='I',defaut=9 ,into=(9,)),
          ASSE_CORN       =SIMP(statut='c',typ='I',defaut=7,into=(7,)),
          ARME            =SIMP(statut='c',typ='I',defaut=1,into=(1,)),
          NORTON_HOFF     =SIMP(statut='c',typ='I',defaut=1,into=(1,)),
          LEMAITRE        =SIMP(statut='c',typ='I',defaut=2,into=(2,)),
          LEMA_SEUIL      =SIMP(statut='c',typ='I',defaut=2,into=(2,)),
          IRRAD3M         =SIMP(statut='c',typ='I',defaut=5,into=(5,)),
          LEMAITRE_IRRA   =SIMP(statut='c',typ='I',defaut=2,into=(2,)),
          ZIRC_CYRA2      =SIMP(statut='c',typ='I',defaut=2,into=(2,)),
          ZIRC_EPRI       =SIMP(statut='c',typ='I',defaut=2,into=(2,)),
          VISC_IRRA_LOG   =SIMP(statut='c',typ='I',defaut=2,into=(2,)),
          GRAN_IRRA_LOG   =SIMP(statut='c',typ='I',defaut=2,into=(2,)),
          NADAI_B         =SIMP(statut='c',typ='I',defaut=34,into=(34,)),
          VENDOCHAB       =SIMP(statut='c',typ='I',defaut=10,into=(10,)),
          GRILLE_ISOT_LINE=SIMP(statut='c',typ='I',defaut=4,into=(4,)),
          GRILLE_CINE_LINE=SIMP(statut='c',typ='I',defaut=4,into=(4,)),
          GRILLE_PINTO_MEN=SIMP(statut='c',typ='I',defaut=16,into=(16,)),
          DIS_CONTACT     =SIMP(statut='c',typ='I',defaut=6,into=(6,)),
          DIS_CHOC        =SIMP(statut='c',typ='I',defaut=7,into=(7,)),
          DIS_GRICRA     =SIMP(statut='c',typ='I',defaut=5,into=(5,)),
          DIS_GOUJ2E_PLAS =SIMP(statut='c',typ='I',defaut=2,into=(2,)),
          DIS_GOUJ2E_ELAS =SIMP(statut='c',typ='I',defaut=1,into=(1,)),
          PINTO_MENEGOTTO =SIMP(statut='c',typ='I',defaut=8,into=(8,)),
          CJS             =SIMP(statut='c',typ='I',defaut=16,into=(16,)),
          CAM_CLAY        =SIMP(statut='c',typ='I',defaut=2,into=(2,)),
          BARCELONE       =SIMP(statut='c',typ='I',defaut=5,into=(5,)),
          LAIGLE          =SIMP(statut='c',typ='I',defaut=4,into=(4,)),
          DRUCKER_PRAGER  =SIMP(statut='c',typ='I',defaut=3,into=(3,)),
          HOEK_BROWN      =SIMP(statut='c',typ='I',defaut=3,into=(3,)),
          HOEK_BROWN_EFF  =SIMP(statut='c',typ='I',defaut=3,into=(3,)),
          HOEK_BROWN_TOT  =SIMP(statut='c',typ='I',defaut=3,into=(3,)),
          GRANGER_FP      =SIMP(statut='c',typ='I',defaut=55,into=(55,)),
          GRANGER_FP_INDT =SIMP(statut='c',typ='I',defaut=55,into=(55,)),
          GRANGER_FP_V    =SIMP(statut='c',typ='I',defaut=55,into=(55,)),
          BAZANT_FD       =SIMP(statut='c',typ='I',defaut=1,into=(1,)),
          BETON_DOUBLE_DP =SIMP(statut='c',typ='I',defaut=4,into=(4,)),
          KIT_HM          =SIMP(statut='c',typ='I',defaut=0,into=(0,)),
          KIT_HHM         =SIMP(statut='c',typ='I',defaut=0,into=(0,)),
          KIT_THH         =SIMP(statut='c',typ='I',defaut=0,into=(0,)),
          KIT_THV         =SIMP(statut='c',typ='I',defaut=0,into=(0,)),
          KIT_THM         =SIMP(statut='c',typ='I',defaut=0,into=(0,)),
          KIT_THHM        =SIMP(statut='c',typ='I',defaut=0,into=(0,)),
          VMIS_ASYM_LINE  =SIMP(statut='c',typ='I',defaut=4,into=(4,)),
          BETON_UMLV_FP   =SIMP(statut='c',typ='I',defaut=21,into=(21,)),
          GLRC_DAMAGE     =SIMP(statut='c',typ='I',defaut=21,into=(21,)),
          GLRC_DM         =SIMP(statut='c',typ='I',defaut=4,into=(4,)),
          GATT_MONERIE    =SIMP(statut='c',typ='I',defaut=2,into=(2,)),

           b_monox     = BLOC(condition = "RELATION == 'MONOCRISTAL' ",
                                 fr="SD issue de DEFI_COMPOR",
                   COMPOR =SIMP(statut='o',typ=compor_sdaster,max=1),),
#          
           b_polyx     = BLOC(condition = "RELATION == 'POLYCRISTAL' ",
                                 fr="SD issue de DEFI_COMPOR",
                   COMPOR =SIMP(statut='o',typ=compor_sdaster,max=1),),
#          
           b_zmat      = BLOC(condition = "RELATION == 'ZMAT' ",
                                 fr="Comportement de la bibliotheque Zmat",
                   NB_VARI =SIMP(statut='o',typ='I',max=1),
                   UNITE =SIMP(statut='o',typ='I',max=1),),



           RELATION_KIT    =SIMP(statut='f',typ='TXM',max='**',validators=NoRepeat(),
                                 into=(
# MECA
                                       "ELAS",
                                       "CJS",
                                       "CAM_CLAY",
                                       "BARCELONE",
                                       "LAIGLE",
                                       "DRUCKER_PRAGER",
                                       "HOEK_BROWN_EFF",
                                       "HOEK_BROWN_TOT",
                                       "ELAS_THER",
                                       "MAZARS",
                                       "ENDO_ISOT_BETON",
# THMC
                                       "GAZ",
                                       "LIQU_SATU",
                                       "LIQU_GAZ_ATM",
                                       "LIQU_VAPE_GAZ",
                                       "LIQU_AD_GAZ_VAPE",
                                       "LIQU_VAPE",
                                       "LIQU_GAZ",
# HYDR
                                       "HYDR_UTIL",
                                       "HYDR",
                                       "HYDR_ENDO",
# MECA_META
                                       "ACIER",
                                       "ZIRC",
# MECA KIT_DDI
                                       "VMIS_ISOT_TRAC",
                                       "VMIS_ISOT_LINE",
                                       "VMIS_ISOT_CINE",
                                       "VMIS_ISOT_PUIS",
                                       "GRANGER_FP",
                                       "GRANGER_FP_INDT",
                                       "GRANGER_FP_V",
                                       "BETON_UMLV_FP",
                                       "ROUSS_PR",
                                       "NADAI_B",
                                       "BETON_DOUBLE_DP",
                                       ),),
                            
                                        
           ELAS_THER       =SIMP(statut='c',typ='I',defaut=1,into=(1,)),
           GAZ             =SIMP(statut='c',typ='I',defaut=1,into=(1,)),
           LIQU_SATU       =SIMP(statut='c',typ='I',defaut=1,into=(1,)),
           LIQU_GAZ_ATM    =SIMP(statut='c',typ='I',defaut=2,into=(2,)),
           LIQU_VAPE_GAZ   =SIMP(statut='c',typ='I',defaut=3,into=(3,)),
           LIQU_AD_GAZ_VAPE=SIMP(statut='c',typ='I',defaut=3,into=(3,)),
           LIQU_VAPE       =SIMP(statut='c',typ='I',defaut=3,into=(3,)),
           LIQU_GAZ        =SIMP(statut='c',typ='I',defaut=2,into=(2,)),
           HYDR_UTIL       =SIMP(statut='c',typ='I',defaut=1,into=(1,)),
           HYDR            =SIMP(statut='c',typ='I',defaut=1,into=(1,)),
           HYDR_ENDO       =SIMP(statut='c',typ='I',defaut=1,into=(1,)),
           ACIER           =SIMP(statut='c',typ='I',defaut=5,into=(5,)),
           ZIRC            =SIMP(statut='c',typ='I',defaut=3,into=(3,)),

           DEFORMATION     =SIMP(statut='f',typ='TXM',defaut="PETIT",
                             into=("PETIT","PETIT_REAC","SIMO_MIEHE","GREEN_GR","GREEN","COROTATIONNEL","REAC_GEOM")),
           ALGO_C_PLAN     =SIMP(statut='f',typ='TXM',defaut="ANALYTIQUE",into=("DEBORST","ANALYTIQUE",)),
           ALGO_1D         =SIMP(statut='f',typ='TXM',defaut="ANALYTIQUE",into=("DEBORST","ANALYTIQUE",)),
      regles=(PRESENT_ABSENT('TOUT','GROUP_MA','MAILLE'),),
           TOUT            =SIMP(statut='f',typ='TXM',into=("OUI",) ),
           GROUP_MA        =SIMP(statut='f',typ=grma,validators=NoRepeat(),max='**'),
           MAILLE          =SIMP(statut='f',typ=ma  ,validators=NoRepeat(),max='**'),
           RESI_INTE_RELA  =SIMP(statut='f',typ='R',defaut= 1.0E-6),
           ITER_INTE_MAXI  =SIMP(statut='f',typ='I',defaut= 10 ),
           ITER_INTE_PAS   =SIMP(statut='f',typ='I',defaut= 0 ),
           RESO_INTE       =SIMP(statut='f',typ='TXM',defaut="IMPLICITE",
                                 into=("RUNGE_KUTTA_2","RUNGE_KUTTA_4","IMPLICITE")),
           PARM_THETA      =SIMP(statut='f',typ='R',defaut= 1. ),
         ) ;
#& MODIF COMMUN  DATE 07/11/2006   AUTEUR CIBHHLV L.VIVAN 
#            CONFIGURATION MANAGEMENT OF EDF VERSION
# ======================================================================
# COPYRIGHT (C) 1991 - 2003  EDF R&D                  WWW.CODE-ASTER.ORG
# THIS PROGRAM IS FREE SOFTWARE; YOU CAN REDISTRIBUTE IT AND/OR MODIFY  
# IT UNDER THE TERMS OF THE GNU GENERAL PUBLIC LICENSE AS PUBLISHED BY  
# THE FREE SOFTWARE FOUNDATION; EITHER VERSION 2 OF THE LICENSE, OR     
# (AT YOUR OPTION) ANY LATER VERSION.                                                  
#                                                                       
# THIS PROGRAM IS DISTRIBUTED IN THE HOPE THAT IT WILL BE USEFUL, BUT   
# WITHOUT ANY WARRANTY; WITHOUT EVEN THE IMPLIED WARRANTY OF            
# MERCHANTABILITY OR FITNESS FOR A PARTICULAR PURPOSE. SEE THE GNU      
# GENERAL PUBLIC LICENSE FOR MORE DETAILS.                              
#                                                                       
# YOU SHOULD HAVE RECEIVED A COPY OF THE GNU GENERAL PUBLIC LICENSE     
# ALONG WITH THIS PROGRAM; IF NOT, WRITE TO EDF R&D CODE_ASTER,         
#    1 AVENUE DU GENERAL DE GAULLE, 92141 CLAMART CEDEX, FRANCE.        
# ======================================================================
# RESPONSABLE VABHHTS J.PELLET
# ce fichier contient la liste des "into" possibles pour le mot cle NOM_CHAM
# c'est a dire les noms de champs des SD RESULTAT (DATA de la routine RSCRSD)
def C_NOM_CHAM_INTO() : return  ("ACCE",    #COMMUN#
                        "ACCE_ABSOLU",
                        "ALPH0_ELGA_EPSP",
                        "ALPHP_ELGA_ALPH0",
                        "ARCO_ELNO_SIGM",
                        "ARCO_NOEU_SIGM",
                        "COMPORTEMENT",
                        "COMPORTHER",
                        "CRIT_ELNO_RUPT",
                        "DCHA_ELGA_SIGM",
                        "DCHA_ELNO_SIGM",
                        "DCHA_NOEU_SIGM",
                        "DEDE_ELNO_DLDE",
                        "DEDE_NOEU_DLDE",
                        "DEGE_ELNO_DEPL",
                        "DEGE_NOEU_DEPL",
                        "DEPL",
                        "DEPL_ABSOLU",
                        "DESI_ELNO_DLSI",
                        "DESI_NOEU_DLSI",
                        "DETE_ELNO_DLTE",
                        "DETE_NOEU_DLTE",
                        "DURT_ELGA_META",
                        "DURT_ELNO_META",
                        "DURT_NOEU_META",
                        "ECIN_ELEM_DEPL",
                        "EFGE_ELNO_CART",
                        "EFGE_ELNO_DEPL",
                        "EFGE_NOEU_CART",
                        "EFGE_NOEU_DEPL",
                        "ENDO_ELGA",
                        "ENDO_ELNO_ELGA",
                        "ENDO_ELNO_SIGA",
                        "ENDO_ELNO_SINO",
                        "ENDO_NOEU_SINO",
                        "ENEL_ELGA",
                        "ENEL_ELNO_ELGA",
                        "ENEL_NOEU_ELGA",
                        "EPEQ_ELNO_TUYO",
                        "EPVC_ELGA",
                        "EPVC_ELNO",
                        "EPFD_ELGA",
                        "EPFD_ELNO",
                        "EPFP_ELGA",
                        "EPFP_ELNO",
                        "EPME_ELGA_DEPL",
                        "EPME_ELNO_DEPL",
                        "EPMG_ELGA_DEPL",
                        "EPMG_ELNO_DEPL",
                        "EPMG_NOEU_DEPL",
                        "EPOT_ELEM_DEPL",
                        "EPSA_ELNO",
                        "EPSA_NOEU",
                        "EPSG_ELGA_DEPL",
                        "EPSG_ELNO_DEPL",
                        "EPSG_NOEU_DEPL",
                        "EPSI_ELGA_DEPL",
                        "EPSI_ELNO_DEPL",
                        "EPSI_ELNO_TUYO",
                        "EPSI_NOEU_DEPL",
                        "EPSP_ELGA",
                        "EPSP_ELNO",
                        "EPSP_ELNO_ZAC",
                        "EPSP_NOEU",
                        "EPSP_NOEU_ZAC",
                        "EQUI_ELGA_EPME",
                        "EQUI_ELGA_EPSI",
                        "EQUI_ELGA_SIGM",
                        "EQUI_ELNO_EPME",
                        "EQUI_ELNO_EPSI",
                        "EQUI_ELNO_SIGM",
                        "EQUI_NOEU_EPME",
                        "EQUI_NOEU_EPSI",
                        "EQUI_NOEU_SIGM",
                        "ERRE_ELEM_SIGM",
                        "ERRE_ELEM_TEMP",
                        "ERRE_ELNO_ELEM",
                        "ERRE_NOEU_ELEM",
                        "ERZ1_ELEM_SIGM",
                        "ERZ2_ELEM_SIGM",
                        "QIRE_ELEM_SIGM",
                        "QIRE_ELNO_ELEM",
                        "QIZ1_ELEM_SIGM",
                        "QIZ2_ELEM_SIGM",
                        "SING_ELEM",
                        "SING_ELNO_ELEM",
                        "ETOT_ELEM",
                        "ETOT_ELGA",
                        "ETOT_ELNO_ELGA",
                        "EXTR_ELGA_VARI",
                        "EXTR_ELNO_VARI",
                        "EXTR_NOEU_VARI",
                        "FLUX_ELGA_TEMP",
                        "FLUX_ELNO_TEMP",
                        "FLUX_NOEU_TEMP",
                        "FORC_NODA",
                        "FSUR_2D",
                        "FSUR_3D",
                        "FVOL_2D",
                        "FVOL_3D",
                        "GRAD_NOEU_THETA",
                        "HYDR_ELNO_ELGA",
                        "HYDR_NOEU_ELGA",
                        "INDI_LOCA_ELGA",
                        "INTE_ELNO_ACTI",
                        "INTE_ELNO_REAC",
                        "INTE_NOEU_ACTI",
                        "INTE_NOEU_REAC",
                        "IRRA",
                        "LANL_ELGA",
                        "META_ELGA_TEMP",
                        "META_ELNO_TEMP",
                        "META_NOEU_TEMP",
                        "MODE_FLAMB",
                        "PMPB_ELGA_SIEF",
                        "PMPB_ELNO_SIEF",
                        "PMPB_NOEU_SIEF",
                        "PRES",
                        "PRES_DBEL_DEPL",
                        "PRES_ELNO_DBEL",
                        "PRES_ELNO_IMAG",
                        "PRES_ELNO_REEL",
                        "PRES_NOEU_DBEL",
                        "PRES_NOEU_IMAG",
                        "PRES_NOEU_REEL",
                        "RADI_ELGA_SIGM",
                        "RADI_ELNO_SIGM",
                        "RADI_NOEU_SIGM",
                        "REAC_NODA",
                        "SIEF_ELGA",
                        "SIEF_ELGA_DEPL",
                        "SIEF_ELNO",
                        "SIEF_ELNO_ELGA",
                        "SIEF_NOEU",
                        "SIEF_NOEU_ELGA",
                        "SIEQ_ELNO_TUYO",
                        "SIGM_ELNO_CART",
                        "SIGM_ELNO_COQU",
                        "SIGM_ELNO_DEPL",
                        "SIGM_ELNO_SIEF",
                        "SIGM_ELNO_TUYO",
                        "SIGM_ELNO_ZAC",
                        "SIGM_NOEU_CART",
                        "SIGM_NOEU_COQU",
                        "SIGM_NOEU_DEPL",
                        "SIGM_NOEU_SIEF",
                        "SIGM_NOEU_ZAC",
                        "SIGM_NOZ1_ELGA",
                        "SIGM_NOZ2_ELGA",
                        "SIPO_ELNO_DEPL",
                        "SIPO_ELNO_SIEF",
                        "SIPO_NOEU_DEPL",
                        "SIPO_NOEU_SIEF",
                        "SIRE_ELNO_DEPL",
                        "SIRE_NOEU_DEPL",
                        "SOUR_ELGA_ELEC",
                        "TEMP",
                        "THETA",
                        "VALE_CONT",
                        "VALE_NCOU_MAXI",
                        "VARI_ELGA",
                        "VARI_ELGA_ZAC",
                        "VARI_ELNO",
                        "VARI_ELNO_COQU",
                        "VARI_ELNO_ELGA",
                        "VARI_ELNO_TUYO",
                        "VARI_NOEU",
                        "VARI_NOEU_ELGA",
                        "VARI_NON_LOCAL",
                        "VITE",
                        "VITE_ABSOLU",
                        "VITE_VENT",
                        )
#& MODIF COMMUN  DATE 04/04/2006   AUTEUR CIBHHLV L.VIVAN 
#            CONFIGURATION MANAGEMENT OF EDF VERSION
# ======================================================================
# COPYRIGHT (C) 1991 - 2005  EDF R&D                  WWW.CODE-ASTER.ORG
# THIS PROGRAM IS FREE SOFTWARE; YOU CAN REDISTRIBUTE IT AND/OR MODIFY  
# IT UNDER THE TERMS OF THE GNU GENERAL PUBLIC LICENSE AS PUBLISHED BY  
# THE FREE SOFTWARE FOUNDATION; EITHER VERSION 2 OF THE LICENSE, OR     
# (AT YOUR OPTION) ANY LATER VERSION.                                                  
#                                                                       
# THIS PROGRAM IS DISTRIBUTED IN THE HOPE THAT IT WILL BE USEFUL, BUT   
# WITHOUT ANY WARRANTY; WITHOUT EVEN THE IMPLIED WARRANTY OF            
# MERCHANTABILITY OR FITNESS FOR A PARTICULAR PURPOSE. SEE THE GNU      
# GENERAL PUBLIC LICENSE FOR MORE DETAILS.                              
#                                                                       
# YOU SHOULD HAVE RECEIVED A COPY OF THE GNU GENERAL PUBLIC LICENSE     
# ALONG WITH THIS PROGRAM; IF NOT, WRITE TO EDF R&D CODE_ASTER,         
#    1 AVENUE DU GENERAL DE GAULLE, 92141 CLAMART CEDEX, FRANCE.        
# ======================================================================
# ce fichier contient la liste des  noms des grandeurs de CODE_ASTER
def C_NOM_GRANDEUR() : return  ( #COMMUN# 
"ABSC_R",
"ADRSJEVE",
"ADRSJEVN",
"CAARPO",
"CACABL",
"CACOQU",
"CADISA",
"CADISK",
"CADISM",
"CAFI_R",
"CAGEBA",
"CAGEPO",
"CAGNBA",
"CAGNPO",
"CAMASS",
"CAORIE",
"CAPOUF",
"CARCRI",
"CASECT",
"CHLI_R",
"CODE_I",
"COEH_F",
"COEH_R",
"COMPOR",
"CORR_R",
"CRRU_R",
"DBEL_R",
"DCEL_I",
"DDLI_C",
"DDLI_F",
"DDLI_R",
"DDLM_C",
"DDLM_R",
"DEPL_C",
"DEPL_F",
"DEPL_R",
"DOMMAG",
"DURT_R",
"ENER_R",
"EPSI_F",
"EPSI_R",
"ERREUR",
"FACY_R",
"FELECR",
"FISS_R",
"FLAPLA",
"FLUN_F",
"FLUN_R",
"FLUX_F",
"FLUX_R",
"FORC_C",
"FORC_F",
"FORC_R",
"FREQ_R",
"FTHM_F",
"FTHM_R",
"G",
"GEOM_R",
"G_DEPL_R",
"HARMON",
"HYDR_R",
"IMPE_C",
"IMPE_F",
"IMPE_R",
"IND_LOCA",
"INFC_R",
"INST_R",
"INTE_R",
"INTLOC",
"IRRA_R",
"ITECREL",
"ITEDEC",
"J",
"LISTMA",
"MACOMP",
"MASS_R",
"MATE_F",
"NBSP_I",
"NEUT_F",
"NEUT_I",
"NEUT_K16",
"NEUT_K24",
"NEUT_K8",
"NEUT_R",
"NUMC_I",
"NUMMOD",
"ONDE_F",
"ONDE_R",
"PESA_R",
"PILO_K",
"PILO_R",
"POSI",
"PREC",
"PRES_C",
"PRES_F",
"PRES_R",
"RAYO_F",
"RAYO_R",
"RCCM_K",
"RCCM_R",
"RESCREL",
"RICE_TRA",
"ROTA_R",
"SECTION",
"SIEF_C",
"SIEF_R",
"SIZZ_R",
"SOUR_F",
"SOUR_R",
"SPMA_R",
"STAOUDYN",
"TEMP_C",
"TEMP_F",
"TEMP_R",
"THETA",
"VALO_R",
"VANL_R",
"VAR2_R",
"VARI_R",
"VENTCX_F",
"VNOR_C",
"VNOR_F",
"VOISIN",
"WEIBULL",
"XCONTAC",
                                 )
#& MODIF COMMUN  DATE 27/06/2005   AUTEUR D6BHHJP J.P.LEFEBVRE 
#            CONFIGURATION MANAGEMENT OF EDF VERSION
# ======================================================================
# COPYRIGHT (C) 1991 - 2004  EDF R&D                  WWW.CODE-ASTER.ORG
# THIS PROGRAM IS FREE SOFTWARE; YOU CAN REDISTRIBUTE IT AND/OR MODIFY  
# IT UNDER THE TERMS OF THE GNU GENERAL PUBLIC LICENSE AS PUBLISHED BY  
# THE FREE SOFTWARE FOUNDATION; EITHER VERSION 2 OF THE LICENSE, OR     
# (AT YOUR OPTION) ANY LATER VERSION.                                                  
#                                                                       
# THIS PROGRAM IS DISTRIBUTED IN THE HOPE THAT IT WILL BE USEFUL, BUT   
# WITHOUT ANY WARRANTY; WITHOUT EVEN THE IMPLIED WARRANTY OF            
# MERCHANTABILITY OR FITNESS FOR A PARTICULAR PURPOSE. SEE THE GNU      
# GENERAL PUBLIC LICENSE FOR MORE DETAILS.                              
#                                                                       
# YOU SHOULD HAVE RECEIVED A COPY OF THE GNU GENERAL PUBLIC LICENSE     
# ALONG WITH THIS PROGRAM; IF NOT, WRITE TO EDF R&D CODE_ASTER,         
#    1 AVENUE DU GENERAL DE GAULLE, 92141 CLAMART CEDEX, FRANCE.        
# ======================================================================
# ce fichier contient la liste des PARA possibles pour les fonctions et les nappes
def C_PARA_FONCTION() : return  ( #COMMUN#
                   "DX","DY","DZ","DRX","DRY","DRZ","TEMP","TSEC",
                   "INST","X","Y","Z","EPSI","META","FREQ","PULS","DSP",
                   "AMOR","ABSC","SIGM","HYDR","SECH","PORO","SAT",
                   "PGAZ","PCAP","VITE","ENDO","NORM","EPAIS",
                   "NEUT1","NEUT2",)
#& MODIF COMMUN  DATE 27/06/2005   AUTEUR D6BHHJP J.P.LEFEBVRE 
#            CONFIGURATION MANAGEMENT OF EDF VERSION
# ======================================================================
# COPYRIGHT (C) 1991 - 2004  EDF R&D                  WWW.CODE-ASTER.ORG
# THIS PROGRAM IS FREE SOFTWARE; YOU CAN REDISTRIBUTE IT AND/OR MODIFY  
# IT UNDER THE TERMS OF THE GNU GENERAL PUBLIC LICENSE AS PUBLISHED BY  
# THE FREE SOFTWARE FOUNDATION; EITHER VERSION 2 OF THE LICENSE, OR     
# (AT YOUR OPTION) ANY LATER VERSION.                                                  
#                                                                       
# THIS PROGRAM IS DISTRIBUTED IN THE HOPE THAT IT WILL BE USEFUL, BUT   
# WITHOUT ANY WARRANTY; WITHOUT EVEN THE IMPLIED WARRANTY OF            
# MERCHANTABILITY OR FITNESS FOR A PARTICULAR PURPOSE. SEE THE GNU      
# GENERAL PUBLIC LICENSE FOR MORE DETAILS.                              
#                                                                       
# YOU SHOULD HAVE RECEIVED A COPY OF THE GNU GENERAL PUBLIC LICENSE     
# ALONG WITH THIS PROGRAM; IF NOT, WRITE TO EDF R&D CODE_ASTER,         
#    1 AVENUE DU GENERAL DE GAULLE, 92141 CLAMART CEDEX, FRANCE.        
# ======================================================================
#
# ce fichier contient la liste des "into" possibles pour le mot cle TYPE_CHAM
def C_TYPE_CHAM_INTO() : #COMMUN#
   l=[]
   for gd in C_NOM_GRANDEUR() :
        for typ in ("ELEM","ELNO","ELGA","CART","NOEU") :
             l.append(typ+"_"+gd)
   return tuple(l)

#& MODIF COMMANDE  DATE 19/09/2006   AUTEUR A3BHHAE H.ANDRIAMBOLOLONA 
#            CONFIGURATION MANAGEMENT OF EDF VERSION
# ======================================================================
# COPYRIGHT (C) 1991 - 2001  EDF R&D                  WWW.CODE-ASTER.ORG
# THIS PROGRAM IS FREE SOFTWARE; YOU CAN REDISTRIBUTE IT AND/OR MODIFY
# IT UNDER THE TERMS OF THE GNU GENERAL PUBLIC LICENSE AS PUBLISHED BY
# THE FREE SOFTWARE FOUNDATION; EITHER VERSION 2 OF THE LICENSE, OR   
# (AT YOUR OPTION) ANY LATER VERSION.                                 
#
# THIS PROGRAM IS DISTRIBUTED IN THE HOPE THAT IT WILL BE USEFUL, BUT 
# WITHOUT ANY WARRANTY; WITHOUT EVEN THE IMPLIED WARRANTY OF          
# MERCHANTABILITY OR FITNESS FOR A PARTICULAR PURPOSE. SEE THE GNU    
# GENERAL PUBLIC LICENSE FOR MORE DETAILS.                            
#
# YOU SHOULD HAVE RECEIVED A COPY OF THE GNU GENERAL PUBLIC LICENSE   
# ALONG WITH THIS PROGRAM; IF NOT, WRITE TO EDF R&D CODE_ASTER,       
#    1 AVENUE DU GENERAL DE GAULLE, 92141 CLAMART CEDEX, FRANCE.      
# ======================================================================
# RESPONSABLE MJBHHPE J.L.FLEJOU
AFFE_CARA_ELEM=OPER(nom="AFFE_CARA_ELEM",op=  19,sd_prod=cara_elem,
                    fr="Affectation de caractéristiques à des éléments de structure",
                    reentrant='n',
            UIinfo={"groupes":("Modélisation",)},
         regles=(AU_MOINS_UN('POUTRE','BARRE','COQUE','CABLE','DISCRET','DISCRET_2D','MASSIF',
                             'GRILLE','AFFE_SECT','AFFE_FIBRE','RIGI_PARASOL'),),
         MODELE          =SIMP(statut='o',typ=modele_sdaster ),
         INFO            =SIMP(statut='f',typ='I', defaut= 1 ,into=(1,2) ),
         VERIF           =SIMP(statut='f',typ='TXM',validators=NoRepeat(),max='**',into=("MAILLE","NOEUD") ),

#============================================================================
         POUTRE          =FACT(statut='f',max='**',
           regles=(UN_PARMI('MAILLE','GROUP_MA'),),
           MAILLE          =SIMP(statut='f',typ=ma  ,validators=NoRepeat(),max='**'),
           GROUP_MA        =SIMP(statut='f',typ=grma,validators=NoRepeat(),max='**'),
           SECTION         =SIMP(statut='o',typ='TXM' ,into=("GENERALE","RECTANGLE","CERCLE") ),
           PREC_AIRE       =SIMP(statut='f',typ='R',defaut=0.01),
           PREC_INERTIE    =SIMP(statut='f',typ='R',defaut=0.1),
           b_generale      =BLOC( condition = "SECTION=='GENERALE'",
             VARI_SECT       =SIMP(statut='f',typ='TXM',into=("CONSTANT","HOMOTHETIQUE"),defaut="CONSTANT"),
             b_constant      =BLOC( condition = "VARI_SECT=='CONSTANT'",
               CARA            =SIMP(statut='o',typ='TXM',validators=NoRepeat(),min=4 ,max=15,
                                 fr="A,IY,IZ,JX sont des paramètres obligatoires",
                                 into=("A","IY","IZ","AY","AZ","EY","EZ","JX","RY","RZ","RT",
                                       "JG","IYR2","IZR2","AI") ),
               VALE            =SIMP(statut='o',typ='R',min=4 ,max=15),
             ),
             b_homothetique  =BLOC( condition = "VARI_SECT=='HOMOTHETIQUE'",
               CARA            =SIMP(statut='o',typ='TXM',validators=NoRepeat(),min=8 ,max=30,
                                 fr="A1,A2,IY1,IY2,IZ1,IZ2,JX1,JX2 sont des paramètres obligatoires",
                                 into=("A1","IY1","IZ1","AY1","AZ1","EY1","EZ1","JX1","RY1",
                                       "RZ1","RT1","JG1","IYR21","IZR21","AI1",
                                       "A2","IY2","IZ2","AY2","AZ2","EY2","EZ2","JX2","RY2",
                                       "RZ2","RT2","JG2","IYR22","IZR22","AI2") ),
               VALE            =SIMP(statut='o',typ='R',min=8 ,max=30),
             ),
           ),
           b_rectangle     =BLOC( condition = "SECTION=='RECTANGLE'",
             VARI_SECT       =SIMP(statut='f',typ='TXM',into=("CONSTANT","HOMOTHETIQUE","AFFINE"),defaut="CONSTANT"),
             b_constant      =BLOC( condition = "VARI_SECT=='CONSTANT'",
               CARA            =SIMP(statut='o',typ='TXM',validators=NoRepeat(),min=1 ,max=4,
                                 into=("H","EP", "HY","HZ","EPY","EPZ") ),
               VALE            =SIMP(statut='o',typ='R',min=1 ,max=4),
             ),
             b_homothetique  =BLOC( condition = "VARI_SECT=='HOMOTHETIQUE'",
               CARA            =SIMP(statut='o',typ='TXM',validators=NoRepeat(),min=2 ,max=8,
                                     into=("H1","HZ1","HY1","EP1","EPY1","EPZ1",
                                           "H2","HZ2","HY2","EP2","EPY2","EPZ2") ),
               VALE            =SIMP(statut='o',typ='R',min=2 ,max=8),
             ),
             b_affine =BLOC( condition = "VARI_SECT=='AFFINE'",
               CARA            =SIMP(statut='o',typ='TXM',validators=NoRepeat(),min=3 ,max=6,
                                     into=("HY","EPY", "HZ1","EPZ1","HZ2","EPZ2") ),
               VALE            =SIMP(statut='o',typ='R',min=3 ,max=6),
             ),
           ),
           b_cercle        =BLOC( condition = "SECTION=='CERCLE'",
             VARI_SECT       =SIMP(statut='f',typ='TXM',into=("CONSTANT","HOMOTHETIQUE"),defaut="CONSTANT"),
             b_constant      =BLOC( condition = "VARI_SECT=='CONSTANT'",
               CARA            =SIMP(statut='o',typ='TXM',validators=NoRepeat(),min=1 ,max=2,
                                 fr="R est un paramètre obligatoire",
                                     into=("R","EP") ),
               VALE            =SIMP(statut='o',typ='R',min=1 ,max=2),
             ),
             b_homothetique  =BLOC( condition = "VARI_SECT=='HOMOTHETIQUE'",
               CARA            =SIMP(statut='o',typ='TXM',validators=NoRepeat(),min=2 ,max=4,
                                 fr="R1, R2 sont des paramètres obligatoires",
                                     into=("R1","R2","EP1","EP2") ),
               VALE            =SIMP(statut='o',typ='R',min=2 ,max=4),
             ),
             MODI_METRIQUE   =SIMP(statut='f',typ='TXM',defaut="NON",into=("OUI","NON") ),
             FCX             =SIMP(statut='f',typ=(fonction_sdaster,nappe_sdaster,formule) ),
             TUYAU_NSEC      =SIMP(statut='f',typ='I',val_max=32,defaut=16),
             TUYAU_NCOU      =SIMP(statut='f',typ='I',val_max=10,defaut=3),
           ),
         ),

#============================================================================
         BARRE           =FACT(statut='f',max='**',
           regles=(UN_PARMI('MAILLE','GROUP_MA'),),
           MAILLE          =SIMP(statut='f',typ=ma  ,validators=NoRepeat(),max='**'),
           GROUP_MA        =SIMP(statut='f',typ=grma,validators=NoRepeat(),max='**'),
           SECTION         =SIMP(statut='o',typ='TXM',into=("GENERALE","RECTANGLE","CERCLE") ),
           b_generale      =BLOC( condition = "SECTION=='GENERALE'",
             CARA            =SIMP(statut='o',typ='TXM',into=("A",) ),
             VALE            =SIMP(statut='o',typ='R',min=1,max=1 ),
           ),
           b_rectangle     =BLOC( condition = "SECTION=='RECTANGLE'",
             CARA            =SIMP(statut='o',typ='TXM',into=("H","EP",
                                                              "HZ","HY","EPY","EPZ"),
                                                        validators=NoRepeat(),min=1,max=4 ),
             VALE            =SIMP(statut='o',typ='R',min=1,max=4 ),
           ),
           b_cercle        =BLOC( condition = "SECTION=='CERCLE'",
             CARA            =SIMP(statut='o',typ='TXM',validators=NoRepeat(),min=1,max=2,into=("R","EP") ),
             VALE            =SIMP(statut='o',typ='R',min=1,max=2 ),
           ),
           FCX             =SIMP(statut='f',typ=(fonction_sdaster,nappe_sdaster,formule) ),
         ),

#============================================================================
         COQUE           =FACT(statut='f',max='**',
           regles=(UN_PARMI('MAILLE','GROUP_MA' ),
                   PRESENT_PRESENT( 'EXCENTREMENT','INER_ROTA' ),),
           MAILLE          =SIMP(statut='f',typ=ma  ,validators=NoRepeat(),max='**'),
           GROUP_MA        =SIMP(statut='f',typ=grma,validators=NoRepeat(),max='**'),
           EPAIS           =SIMP(statut='o',typ='R' ),
           ANGL_REP        =SIMP(statut='f',typ='R',min=2,max=2),
           VECTEUR         =SIMP(statut='f',typ='R',min=3,max=3),
           A_CIS           =SIMP(statut='c',typ='R',defaut= 0.8333333E0),
           COEF_RIGI_DRZ   =SIMP(statut='f',typ='R',defaut= 1.0E-5 ),
           COQUE_NCOU      =SIMP(statut='f',typ='I',defaut= 1 ),
           EXCENTREMENT    =SIMP(statut='f',typ='R' ),
           INER_ROTA       =SIMP(statut='f',typ='TXM',into=("OUI",) ),
           MODI_METRIQUE   =SIMP(statut='f',typ='TXM',defaut="NON",into=("OUI","NON") ),
         ),

#============================================================================
         CABLE           =FACT(statut='f',max='**',
           regles=(UN_PARMI('MAILLE','GROUP_MA'),),
           MAILLE          =SIMP(statut='f',typ=ma  ,validators=NoRepeat(),max='**'),
           GROUP_MA        =SIMP(statut='f',typ=grma,validators=NoRepeat(),max='**'),
           N_INIT          =SIMP(statut='f',typ='R',defaut= 5000. ),
           SECTION         =SIMP(statut='f',typ='R' ),
           FCX             =SIMP(statut='f',typ=(fonction_sdaster,nappe_sdaster,formule) ),
         ),

#============================================================================
         DISCRET         =FACT(statut='f',max='**',
           REPERE          =SIMP(statut='f',typ='TXM',into=("LOCAL","GLOBAL") ),
           AMOR_HYST       =SIMP(statut='f',typ='R' ),
           CARA            =SIMP(statut='o',typ='TXM',validators=NoRepeat(),max=1,
          fr="Affectation de matrices de rigidité, de masse ou d'amortissement à des mailles ou noeuds",
                                 into=("K_T_D_N","K_T_D_L","K_TR_D_N","K_TR_D_L",
                                       "K_T_N",  "K_T_L",  "K_TR_N",  "K_TR_L",
                                       "M_T_D_N","M_TR_D_N","M_T_N",
                                       "M_T_L",  "M_TR_N",  "M_TR_L",
                                       "A_T_D_N","A_TR_D_N","A_T_D_L","A_TR_D_L",
                                       "A_T_N",  "A_T_L",   "A_TR_N", "A_TR_L") ),

# affection des caractéristiques de RIGIDITE/AMORTISSEMENT
              b_K_T_D_N  =BLOC(condition = "(CARA=='K_T_D_N')or(CARA=='A_T_D_N')",
                               regles=(UN_PARMI('MAILLE','GROUP_MA','NOEUD','GROUP_NO'),
                                       AU_MOINS_UN('VALE','VALE_F',),PRESENT_ABSENT('VALE','VALE_F',),),
                               NOEUD    =SIMP(statut='f',typ=no  ,validators=NoRepeat(),max='**'),
                               MAILLE   =SIMP(statut='f',typ=ma  ,validators=NoRepeat(),max='**'),
                               GROUP_MA =SIMP(statut='f',typ=grma,validators=NoRepeat(),max='**'),
                               GROUP_NO =SIMP(statut='f',typ=grno,validators=NoRepeat(),max='**'),
                               VALE     =SIMP(statut='f',typ='R',min=3 ,max=3 ),
                               VALE_F =SIMP(statut='f',typ=(para_sensi,),min=3 ,max=3 ),),
              b_K_T_D_L  =BLOC(condition = "(CARA=='K_T_D_L')or(CARA=='A_T_D_L')",
                               regles=(UN_PARMI('MAILLE','GROUP_MA'),
                                       AU_MOINS_UN('VALE','VALE_F',),PRESENT_ABSENT('VALE','VALE_F',),),
                               MAILLE   =SIMP(statut='f',typ=ma  ,validators=NoRepeat(),max='**'),
                               GROUP_MA =SIMP(statut='f',typ=grma,validators=NoRepeat(),max='**'),
                               VALE =SIMP(statut='f',typ='R',min=3 ,max=3 ),
                               VALE_F =SIMP(statut='f',typ=(para_sensi,),min=3 ,max=3 ),),
              b_K_TR_D_N =BLOC(condition = "(CARA=='K_TR_D_N')or(CARA=='A_TR_D_N')",
                               regles=(UN_PARMI('MAILLE','GROUP_MA','NOEUD','GROUP_NO'),
                                       AU_MOINS_UN('VALE','VALE_F',),PRESENT_ABSENT('VALE','VALE_F',),),
                               NOEUD    =SIMP(statut='f',typ=no  ,validators=NoRepeat(),max='**'),
                               MAILLE   =SIMP(statut='f',typ=ma  ,validators=NoRepeat(),max='**'),
                               GROUP_MA =SIMP(statut='f',typ=grma,validators=NoRepeat(),max='**'),
                               GROUP_NO =SIMP(statut='f',typ=grno,validators=NoRepeat(),max='**'),
                               VALE =SIMP(statut='f',typ='R',min=6 ,max=6 ),
                               VALE_F =SIMP(statut='f',typ=(para_sensi,),min=6 ,max=6 ),),
              b_K_TR_D_L =BLOC(condition = "(CARA=='K_TR_D_L')or(CARA=='A_TR_D_L')",
                               regles=(UN_PARMI('MAILLE','GROUP_MA'),
                                       AU_MOINS_UN('VALE','VALE_F',),PRESENT_ABSENT('VALE','VALE_F',),),
                               MAILLE   =SIMP(statut='f',typ=ma  ,validators=NoRepeat(),max='**'),
                               GROUP_MA =SIMP(statut='f',typ=grma,validators=NoRepeat(),max='**'),
                               VALE =SIMP(statut='f',typ='R',min=6 ,max=6 ),
                               VALE_F =SIMP(statut='f',typ=(para_sensi,),min=6 ,max=6 ),),
              b_K_T_N    =BLOC(condition = "(CARA=='K_T_N')or(CARA=='A_T_N')",
                               regles=(UN_PARMI('MAILLE','GROUP_MA','NOEUD','GROUP_NO'),
                                       AU_MOINS_UN('VALE','VALE_F',),PRESENT_ABSENT('VALE','VALE_F',),),
                               NOEUD    =SIMP(statut='f',typ=no  ,validators=NoRepeat(),max='**'),
                               MAILLE   =SIMP(statut='f',typ=ma  ,validators=NoRepeat(),max='**'),
                               GROUP_MA =SIMP(statut='f',typ=grma,validators=NoRepeat(),max='**'),
                               GROUP_NO =SIMP(statut='f',typ=grno,validators=NoRepeat(),max='**'),
                               VALE =SIMP(statut='f',typ='R',min=6 ,max=6 ),
                               VALE_F =SIMP(statut='f',typ=(para_sensi,),min=6 ,max=6 ),),
              b_K_T_L    =BLOC(condition = "(CARA=='K_T_L')or(CARA=='A_T_L')",
                               regles=(UN_PARMI('MAILLE','GROUP_MA'),
                                       AU_MOINS_UN('VALE','VALE_F',),PRESENT_ABSENT('VALE','VALE_F',),),
                               MAILLE   =SIMP(statut='f',typ=ma  ,validators=NoRepeat(),max='**'),
                               GROUP_MA =SIMP(statut='f',typ=grma,validators=NoRepeat(),max='**'),
                               VALE =SIMP(statut='f',typ='R',min=21,max=21),
                               VALE_F =SIMP(statut='f',typ=(para_sensi,),min=21 ,max=21 ),),
              b_K_TR_N   =BLOC(condition = "(CARA=='K_TR_N')or(CARA=='A_TR_N')",
                               regles=(UN_PARMI('MAILLE','GROUP_MA','NOEUD','GROUP_NO'),
                                       AU_MOINS_UN('VALE','VALE_F',),PRESENT_ABSENT('VALE','VALE_F',),),
                               NOEUD    =SIMP(statut='f',typ=no  ,validators=NoRepeat(),max='**'),
                               MAILLE   =SIMP(statut='f',typ=ma  ,validators=NoRepeat(),max='**'),
                               GROUP_MA =SIMP(statut='f',typ=grma,validators=NoRepeat(),max='**'),
                               GROUP_NO =SIMP(statut='f',typ=grno,validators=NoRepeat(),max='**'),
                               VALE =SIMP(statut='f',typ='R',min=21,max=21),
                               VALE_F =SIMP(statut='f',typ=(para_sensi,),min=21 ,max=21 ),),
              b_K_TR_L   =BLOC(condition = "(CARA=='K_TR_L')or(CARA=='A_TR_L')",
                               regles=(UN_PARMI('MAILLE','GROUP_MA'),
                                       AU_MOINS_UN('VALE','VALE_F',),PRESENT_ABSENT('VALE','VALE_F',),),
                               MAILLE   =SIMP(statut='f',typ=ma  ,validators=NoRepeat(),max='**'),
                               GROUP_MA =SIMP(statut='f',typ=grma,validators=NoRepeat(),max='**'),
                               VALE =SIMP(statut='f',typ='R',min=78,max=78),
                               VALE_F =SIMP(statut='f',typ=(para_sensi,),min=78 ,max=78 ),),

# affection des caractéristiques de MASSE
              b_M_T_D_N  =BLOC(condition = "CARA=='M_T_D_N'",
          fr="NOEUD: 1 valeur de masse",
                               regles=(UN_PARMI('MAILLE','GROUP_MA','NOEUD','GROUP_NO'),
                                       AU_MOINS_UN('VALE','VALE_F',),PRESENT_ABSENT('VALE','VALE_F',),),
                               NOEUD    =SIMP(statut='f',typ=no  ,validators=NoRepeat(),max='**'),
                               MAILLE   =SIMP(statut='f',typ=ma  ,validators=NoRepeat(),max='**'),
                               GROUP_MA =SIMP(statut='f',typ=grma,validators=NoRepeat(),max='**'),
                               GROUP_NO =SIMP(statut='f',typ=grno,validators=NoRepeat(),max='**'),
                               VALE =SIMP(statut='f',typ='R',min=1 ,max=1 ),
                               VALE_F =SIMP(statut='f',typ=(para_sensi,),min=1 ,max=1 ),),
              b_M_TR_D_N =BLOC(condition = "CARA=='M_TR_D_N'",
          fr="NOEUD: 1 valeur de masse, 6 valeurs du tenseur d'inertie, 3 composantes du vecteur d'excentricité",
                               regles=(UN_PARMI('MAILLE','GROUP_MA','NOEUD','GROUP_NO'),
                                       AU_MOINS_UN('VALE','VALE_F',),PRESENT_ABSENT('VALE','VALE_F',),),
                               NOEUD    =SIMP(statut='f',typ=no  ,validators=NoRepeat(),max='**'),
                               MAILLE   =SIMP(statut='f',typ=ma  ,validators=NoRepeat(),max='**'),
                               GROUP_MA =SIMP(statut='f',typ=grma,validators=NoRepeat(),max='**'),
                               GROUP_NO =SIMP(statut='f',typ=grno,validators=NoRepeat(),max='**'),
                               VALE =SIMP(statut='f',typ='R',min=10,max=10),
                               VALE_F =SIMP(statut='f',typ=(para_sensi,),min=10 ,max=10 ),),
              b_M_T_N    =BLOC(condition = "CARA=='M_T_N'",
          fr="NOEUD: 6 valeurs de masse (triangulaire supérieure par colonne)",
                               regles=(UN_PARMI('MAILLE','GROUP_MA','NOEUD','GROUP_NO'),
                                       AU_MOINS_UN('VALE','VALE_F',),PRESENT_ABSENT('VALE','VALE_F',),),
                               NOEUD    =SIMP(statut='f',typ=no  ,validators=NoRepeat(),max='**'),
                               MAILLE   =SIMP(statut='f',typ=ma  ,validators=NoRepeat(),max='**'),
                               GROUP_MA =SIMP(statut='f',typ=grma,validators=NoRepeat(),max='**'),
                               GROUP_NO =SIMP(statut='f',typ=grno,validators=NoRepeat(),max='**'),
                               VALE =SIMP(statut='f',typ='R',min=6 ,max=6 ),
                               VALE_F =SIMP(statut='f',typ=(para_sensi,),min=6 ,max=6 ),),
              b_M_T_L    =BLOC(condition = "CARA=='M_T_L'",
          fr="SEGMENT: 21 valeurs de masse (triangulaire supérieure par colonne)",
                               regles=(UN_PARMI('MAILLE','GROUP_MA'),
                                       AU_MOINS_UN('VALE','VALE_F',),PRESENT_ABSENT('VALE','VALE_F',),),
                               MAILLE   =SIMP(statut='f',typ=ma  ,validators=NoRepeat(),max='**'),
                               GROUP_MA =SIMP(statut='f',typ=grma,validators=NoRepeat(),max='**'),
                               VALE =SIMP(statut='f',typ='R',min=21,max=21),
                               VALE_F =SIMP(statut='f',typ=(para_sensi,),min=21 ,max=21 ),),
              b_M_TR_N   =BLOC(condition = "CARA=='M_TR_N'",
          fr="NOEUD: 21 valeurs de masse (triangulaire supérieure par colonne)",
                               regles=(UN_PARMI('MAILLE','GROUP_MA','NOEUD','GROUP_NO'),
                                       AU_MOINS_UN('VALE','VALE_F',),PRESENT_ABSENT('VALE','VALE_F',),),
                               NOEUD    =SIMP(statut='f',typ=no  ,validators=NoRepeat(),max='**'),
                               MAILLE   =SIMP(statut='f',typ=ma  ,validators=NoRepeat(),max='**'),
                               GROUP_MA =SIMP(statut='f',typ=grma,validators=NoRepeat(),max='**'),
                               GROUP_NO =SIMP(statut='f',typ=grno,validators=NoRepeat(),max='**'),
                               VALE =SIMP(statut='f',typ='R',min=21,max=21),
                               VALE_F =SIMP(statut='f',typ=(para_sensi,),min=21 ,max=21 ),),
              b_M_TR_L   =BLOC(condition = "CARA=='M_TR_L'",
          fr="SEGMENT: 78 valeurs de masse (triangulaire supérieure par colonne)",
                               regles=(UN_PARMI('MAILLE','GROUP_MA'),
                                       AU_MOINS_UN('VALE','VALE_F',),PRESENT_ABSENT('VALE','VALE_F',),),
                               MAILLE   =SIMP(statut='f',typ=ma  ,validators=NoRepeat(),max='**'),
                               GROUP_MA =SIMP(statut='f',typ=grma,validators=NoRepeat(),max='**'),
                               VALE =SIMP(statut='f',typ='R',min=78,max=78),
                               VALE_F =SIMP(statut='f',typ=(para_sensi,),min=78 ,max=78 ),),
         ),

#============================================================================
         DISCRET_2D      =FACT(statut='f',max='**',
           REPERE          =SIMP(statut='f',typ='TXM',into=("LOCAL","GLOBAL") ),
           AMOR_HYST       =SIMP(statut='f',typ='R' ),
           CARA            =SIMP(statut='o',typ='TXM',validators=NoRepeat(),max=1,
          fr="Affectation de matrices de rigidité, de masse ou d'amortissement à des mailles ou noeuds",
                                 into=("K_T_D_N","K_T_D_L","K_TR_D_N","K_TR_D_L",
                                       "K_T_N",  "K_T_L",  "K_TR_N",  "K_TR_L",
                                       "M_T_D_N","M_T_N",  "M_TR_D_N",
                                       "M_T_L",  "M_TR_N",  "M_TR_L",
                                       "A_T_D_N","A_TR_D_N","A_T_D_L","A_TR_D_L",
                                       "A_T_N",  "A_T_L",   "A_TR_N", "A_TR_L") ),

# affection des caractéristiques de RIGIDITE/AMORTISSEMENT
              b_K_T_D_N  =BLOC(condition = "(CARA=='K_T_D_N')or(CARA=='A_T_D_N')",
                               regles=(UN_PARMI('MAILLE','GROUP_MA','NOEUD','GROUP_NO'),
                                       AU_MOINS_UN('VALE','VALE_F',),PRESENT_ABSENT('VALE','VALE_F',),),
                               NOEUD    =SIMP(statut='f',typ=no  ,validators=NoRepeat(),max='**'),
                               MAILLE   =SIMP(statut='f',typ=ma  ,validators=NoRepeat(),max='**'),
                               GROUP_MA =SIMP(statut='f',typ=grma,validators=NoRepeat(),max='**'),
                               GROUP_NO =SIMP(statut='f',typ=grno,validators=NoRepeat(),max='**'),
                               VALE =SIMP(statut='f',typ='R',min=2 ,max=2 ),
                               VALE_F =SIMP(statut='f',typ=(para_sensi,),min=2 ,max=2 ),),
              b_K_T_D_L  =BLOC(condition = "(CARA=='K_T_D_L')or(CARA=='A_T_D_L')",
                               regles=(UN_PARMI('MAILLE','GROUP_MA'),
                                       AU_MOINS_UN('VALE','VALE_F',),PRESENT_ABSENT('VALE','VALE_F',),),
                               MAILLE   =SIMP(statut='f',typ=ma  ,validators=NoRepeat(),max='**'),
                               GROUP_MA =SIMP(statut='f',typ=grma,validators=NoRepeat(),max='**'),
                               VALE =SIMP(statut='f',typ='R',min=2 ,max=2 ),
                               VALE_F =SIMP(statut='f',typ=(para_sensi,),min=2 ,max=2 ),),
              b_K_TR_D_N =BLOC(condition = "(CARA=='K_TR_D_N')or(CARA=='A_TR_D_N')",
                               regles=(UN_PARMI('MAILLE','GROUP_MA','NOEUD','GROUP_NO'),
                                       AU_MOINS_UN('VALE','VALE_F',),PRESENT_ABSENT('VALE','VALE_F',),),
                               NOEUD    =SIMP(statut='f',typ=no  ,validators=NoRepeat(),max='**'),
                               MAILLE   =SIMP(statut='f',typ=ma  ,validators=NoRepeat(),max='**'),
                               GROUP_MA =SIMP(statut='f',typ=grma,validators=NoRepeat(),max='**'),
                               GROUP_NO =SIMP(statut='f',typ=grno,validators=NoRepeat(),max='**'),
                               VALE =SIMP(statut='f',typ='R',min=3 ,max=3 ),
                               VALE_F =SIMP(statut='f',typ=(para_sensi,),min=3 ,max=3 ),),
              b_K_TR_D_L =BLOC(condition = "(CARA=='K_TR_D_L')or(CARA=='A_TR_D_L')",
                               regles=(UN_PARMI('MAILLE','GROUP_MA'),
                                       AU_MOINS_UN('VALE','VALE_F',),PRESENT_ABSENT('VALE','VALE_F',),),
                               MAILLE   =SIMP(statut='f',typ=ma  ,validators=NoRepeat(),max='**'),
                               GROUP_MA =SIMP(statut='f',typ=grma,validators=NoRepeat(),max='**'),
                               VALE =SIMP(statut='f',typ='R',min=3 ,max=3 ),
                               VALE_F =SIMP(statut='f',typ=(para_sensi,),min=3 ,max=3 ),),
              b_K_T_N    =BLOC(condition = "(CARA=='K_T_N')or(CARA=='A_T_N')",
                               regles=(UN_PARMI('MAILLE','GROUP_MA','NOEUD','GROUP_NO'),
                                       AU_MOINS_UN('VALE','VALE_F',),PRESENT_ABSENT('VALE','VALE_F',),),
                               NOEUD    =SIMP(statut='f',typ=no  ,validators=NoRepeat(),max='**'),
                               MAILLE   =SIMP(statut='f',typ=ma  ,validators=NoRepeat(),max='**'),
                               GROUP_MA =SIMP(statut='f',typ=grma,validators=NoRepeat(),max='**'),
                               GROUP_NO =SIMP(statut='f',typ=grno,validators=NoRepeat(),max='**'),
                               VALE =SIMP(statut='f',typ='R',min=3 ,max=3 ),
                               VALE_F =SIMP(statut='f',typ=(para_sensi,),min=3 ,max=3 ),),
              b_K_T_L    =BLOC(condition = "(CARA=='K_T_L')or(CARA=='A_T_L')",
                               regles=(UN_PARMI('MAILLE','GROUP_MA'),
                                       AU_MOINS_UN('VALE','VALE_F',),PRESENT_ABSENT('VALE','VALE_F',),),
                               MAILLE   =SIMP(statut='f',typ=ma  ,validators=NoRepeat(),max='**'),
                               GROUP_MA =SIMP(statut='f',typ=grma,validators=NoRepeat(),max='**'),
                               VALE =SIMP(statut='f',typ='R',min=10,max=10),
                               VALE_F =SIMP(statut='f',typ=(para_sensi,),min=10 ,max=10 ),),
              b_K_TR_N   =BLOC(condition = "(CARA=='K_TR_N')or(CARA=='A_TR_N')",
                               regles=(UN_PARMI('MAILLE','GROUP_MA','NOEUD','GROUP_NO'),
                                       AU_MOINS_UN('VALE','VALE_F',),PRESENT_ABSENT('VALE','VALE_F',),),
                               NOEUD    =SIMP(statut='f',typ=no  ,validators=NoRepeat(),max='**'),
                               MAILLE   =SIMP(statut='f',typ=ma  ,validators=NoRepeat(),max='**'),
                               GROUP_MA =SIMP(statut='f',typ=grma,validators=NoRepeat(),max='**'),
                               GROUP_NO =SIMP(statut='f',typ=grno,validators=NoRepeat(),max='**'),
                               VALE =SIMP(statut='f',typ='R',min=6 ,max=6),
                               VALE_F =SIMP(statut='f',typ=(para_sensi,),min=6 ,max=6 ),),
              b_K_TR_L   =BLOC(condition = "(CARA=='K_TR_L')or(CARA=='A_TR_L')",
                               regles=(UN_PARMI('MAILLE','GROUP_MA'),
                                       AU_MOINS_UN('VALE','VALE_F',),PRESENT_ABSENT('VALE','VALE_F',),),
                               MAILLE   =SIMP(statut='f',typ=ma  ,validators=NoRepeat(),max='**'),
                               GROUP_MA =SIMP(statut='f',typ=grma,validators=NoRepeat(),max='**'),
                               VALE =SIMP(statut='f',typ='R',min=21,max=21),
                               VALE_F =SIMP(statut='f',typ=(para_sensi,),min=21 ,max=21 ),),

# affection des caractéristiques de MASSE
              b_M_T_D_N  =BLOC(condition = "CARA=='M_T_D_N'",
          fr="NOEUD: 1 valeur de masse",
                               regles=(UN_PARMI('MAILLE','GROUP_MA','NOEUD','GROUP_NO'),
                                       AU_MOINS_UN('VALE','VALE_F',),PRESENT_ABSENT('VALE','VALE_F',),),
                               NOEUD    =SIMP(statut='f',typ=no  ,validators=NoRepeat(),max='**'),
                               MAILLE   =SIMP(statut='f',typ=ma  ,validators=NoRepeat(),max='**'),
                               GROUP_MA =SIMP(statut='f',typ=grma,validators=NoRepeat(),max='**'),
                               GROUP_NO =SIMP(statut='f',typ=grno,validators=NoRepeat(),max='**'),
                               VALE =SIMP(statut='f',typ='R',min=1 ,max=1 ),
                               VALE_F =SIMP(statut='f',typ=(para_sensi,),min=1 ,max=1 ),),
              b_M_TR_D_N =BLOC(condition = "CARA=='M_TR_D_N'",
          fr="NOEUD: 1 valeur de masse(m), 1 valeur d'inertie(Izz), 2 composantes du vecteur d'excentricité(ex,ey) ",
                               regles=(UN_PARMI('MAILLE','GROUP_MA','NOEUD','GROUP_NO'),
                                       AU_MOINS_UN('VALE','VALE_F',),PRESENT_ABSENT('VALE','VALE_F',),),
                               NOEUD    =SIMP(statut='f',typ=no  ,validators=NoRepeat(),max='**'),
                               MAILLE   =SIMP(statut='f',typ=ma  ,validators=NoRepeat(),max='**'),
                               GROUP_MA =SIMP(statut='f',typ=grma,validators=NoRepeat(),max='**'),
                               GROUP_NO =SIMP(statut='f',typ=grno,validators=NoRepeat(),max='**'),
                               VALE =SIMP(statut='f',typ='R',min=4 ,max=4 ),
                               VALE_F =SIMP(statut='f',typ=(para_sensi,),min=4 ,max=4 ),),
              b_M_T_N    =BLOC(condition = "CARA=='M_T_N'",
          fr="NOEUD: 3 valeurs de masse (triangulaire supérieure par colonne)",
                               regles=(UN_PARMI('MAILLE','GROUP_MA','NOEUD','GROUP_NO'),
                                       AU_MOINS_UN('VALE','VALE_F',),PRESENT_ABSENT('VALE','VALE_F',),),
                               NOEUD    =SIMP(statut='f',typ=no  ,validators=NoRepeat(),max='**'),
                               MAILLE   =SIMP(statut='f',typ=ma  ,validators=NoRepeat(),max='**'),
                               GROUP_MA =SIMP(statut='f',typ=grma,validators=NoRepeat(),max='**'),
                               GROUP_NO =SIMP(statut='f',typ=grno,validators=NoRepeat(),max='**'),
                               VALE =SIMP(statut='f',typ='R',min=3 ,max=3 ),
                               VALE_F =SIMP(statut='f',typ=(para_sensi,),min=3 ,max=3 ),),
              b_M_T_L    =BLOC(condition = "CARA=='M_T_L'",
          fr="SEGMENT: 10 valeurs de masse (triangulaire supérieure par colonne)",
                               regles=(UN_PARMI('MAILLE','GROUP_MA'),
                                       AU_MOINS_UN('VALE','VALE_F',),PRESENT_ABSENT('VALE','VALE_F',),),
                               MAILLE   =SIMP(statut='f',typ=ma  ,validators=NoRepeat(),max='**'),
                               GROUP_MA =SIMP(statut='f',typ=grma,validators=NoRepeat(),max='**'),
                               VALE =SIMP(statut='f',typ='R',min=10,max=10),
                               VALE_F =SIMP(statut='f',typ=(para_sensi,),min=10 ,max=10 ),),
              b_M_TR_N   =BLOC(condition = "CARA=='M_TR_N'",
          fr="NOEUD: 6 valeurs de masse (triangulaire supérieure par colonne)",
                               regles=(UN_PARMI('MAILLE','GROUP_MA','NOEUD','GROUP_NO'),
                                       AU_MOINS_UN('VALE','VALE_F',),PRESENT_ABSENT('VALE','VALE_F',),),
                               NOEUD    =SIMP(statut='f',typ=no  ,validators=NoRepeat(),max='**'),
                               MAILLE   =SIMP(statut='f',typ=ma  ,validators=NoRepeat(),max='**'),
                               GROUP_MA =SIMP(statut='f',typ=grma,validators=NoRepeat(),max='**'),
                               GROUP_NO =SIMP(statut='f',typ=grno,validators=NoRepeat(),max='**'),
                               VALE =SIMP(statut='f',typ='R',min=6 ,max=6 ),
                               VALE_F =SIMP(statut='f',typ=(para_sensi,),min=6 ,max=6 ),),
              b_M_TR_L   =BLOC(condition = "CARA=='M_TR_L'",
          fr="SEGMENT: 21 valeurs de masse (triangulaire supérieure par colonne)",
                               regles=(UN_PARMI('MAILLE','GROUP_MA'),
                                       AU_MOINS_UN('VALE','VALE_F',),PRESENT_ABSENT('VALE','VALE_F',),),
                               MAILLE   =SIMP(statut='f',typ=ma  ,validators=NoRepeat(),max='**'),
                               GROUP_MA =SIMP(statut='f',typ=grma,validators=NoRepeat(),max='**'),
                               VALE =SIMP(statut='f',typ='R',min=21,max=21),
                               VALE_F =SIMP(statut='f',typ=(para_sensi,),min=21 ,max=21 ),),
         ),

#============================================================================
         ORIENTATION     =FACT(statut='f',max='**',
           regles=(UN_PARMI('MAILLE','GROUP_MA','NOEUD','GROUP_NO' ),),
           MAILLE          =SIMP(statut='f',typ=ma  ,validators=NoRepeat(),max='**'),
           GROUP_MA        =SIMP(statut='f',typ=grma,validators=NoRepeat(),max='**'),
           NOEUD           =SIMP(statut='f',typ=no  ,validators=NoRepeat(),max='**'),
           GROUP_NO        =SIMP(statut='f',typ=grno,validators=NoRepeat(),max='**'),
           CARA            =SIMP(statut='o',typ='TXM',
                                 into=("VECT_Y","ANGL_VRIL","VECT_X_Y","ANGL_NAUT","GENE_TUYAU") ),
           VALE            =SIMP(statut='o',typ='R',max='**'),
           PRECISION       =SIMP(statut='f',typ='R',defaut= 1.0E-4 ),
           CRITERE         =SIMP(statut='f',typ='TXM',defaut="RELATIF",into=("RELATIF","ABSOLU") ),
         ),

#============================================================================
         DEFI_ARC        =FACT(statut='f',max='**',
           regles=(UN_PARMI('MAILLE','GROUP_MA'),
                   UN_PARMI('ORIE_ARC','CENTRE','NOEUD_CENTRE','GROUP_NO_CENTRE',
                            'POIN_TANG','NOEUD_POIN_TANG','GROUP_NO_POIN_TG'),
                   PRESENT_PRESENT('ORIE_ARC','RAYON'),
                   EXCLUS('COEF_FLEX','COEF_FLEX_XY'),
                   EXCLUS('COEF_FLEX','COEF_FLEX_XZ'),
                   EXCLUS('INDI_SIGM','INDI_SIGM_XY'),
                   EXCLUS('INDI_SIGM','INDI_SIGM_XZ'),
                   PRESENT_PRESENT('COEF_FLEX_XY','COEF_FLEX_XZ'),
                   PRESENT_PRESENT('INDI_SIGM_XY','INDI_SIGM_XZ'),),
           MAILLE          =SIMP(statut='f',typ=ma  ,validators=NoRepeat(),max='**'),
           GROUP_MA        =SIMP(statut='f',typ=grma,validators=NoRepeat(),max='**'),
           ORIE_ARC        =SIMP(statut='f',typ='R'),
           CENTRE          =SIMP(statut='f',typ='R',max='**'),
           NOEUD_CENTRE    =SIMP(statut='f',typ=no),
           GROUP_NO_CENTRE =SIMP(statut='f',typ=grno),
           POIN_TANG       =SIMP(statut='f',typ='R',max='**'),
           NOEUD_POIN_TANG =SIMP(statut='f',typ=no),
           GROUP_NO_POIN_TG=SIMP(statut='f',typ=grno),
           RAYON           =SIMP(statut='f',typ='R'),
           COEF_FLEX       =SIMP(statut='f',typ='R'),
           INDI_SIGM       =SIMP(statut='f',typ='R'),
           COEF_FLEX_XY    =SIMP(statut='f',typ='R'),
           INDI_SIGM_XY    =SIMP(statut='f',typ='R'),
           COEF_FLEX_XZ    =SIMP(statut='f',typ='R'),
           INDI_SIGM_XZ    =SIMP(statut='f',typ='R'),
           PRECISION       =SIMP(statut='f',typ='R',defaut= 1.0E-3),
           CRITERE         =SIMP(statut='f',typ='TXM',defaut="RELATIF",into=("RELATIF","ABSOLU") ),
         ),

#============================================================================
         MASSIF          =FACT(statut='f',max='**',
           regles=(UN_PARMI('MAILLE','GROUP_MA'),
                   UN_PARMI('ANGL_REP','ANGL_AXE','ANGL_EULER'),
                   EXCLUS('ANGL_REP','ANGL_EULER'),
                   EXCLUS('ANGL_REP','ANGL_AXE'),
                   EXCLUS('ANGL_REP','ORIG_AXE'),
                   PRESENT_PRESENT('ANGL_AXE','ORIG_AXE'), ),
           MAILLE          =SIMP(statut='f',typ=ma  ,validators=NoRepeat(),max='**'),
           GROUP_MA        =SIMP(statut='f',typ=grma,validators=NoRepeat(),max='**'),
           ANGL_REP        =SIMP(statut='f',typ='R',max=3),
           ANGL_EULER      =SIMP(statut='f',typ='R',min=3,max=3),
           ANGL_AXE        =SIMP(statut='f',typ='R',max=2),
           ORIG_AXE        =SIMP(statut='f',typ='R',max=3),
         ),


#============================================================================
         POUTRE_FLUI     =FACT(statut='f',max='**',
           regles=(UN_PARMI('MAILLE','GROUP_MA'),),
           MAILLE          =SIMP(statut='f',typ=ma  ,validators=NoRepeat(),max='**'),
           GROUP_MA        =SIMP(statut='f',typ=grma,validators=NoRepeat(),max='**'),
           B_T             =SIMP(statut='o',typ='R'),
           B_N             =SIMP(statut='o',typ='R'),
           B_TN            =SIMP(statut='o',typ='R',defaut= 0.E+0 ),
           A_FLUI          =SIMP(statut='o',typ='R'),
           A_CELL          =SIMP(statut='o',typ='R'),
           COEF_ECHELLE    =SIMP(statut='o',typ='R'),
         ),

#============================================================================
         GRILLE          =FACT(statut='f',max='**',
           regles=(UN_PARMI('MAILLE','GROUP_MA'),
                   EXCLUS('ANGL_REP','ORIG_AXE'),
                   ENSEMBLE('ORIG_AXE','AXE')),
           MAILLE          =SIMP(statut='f',typ=ma  ,validators=NoRepeat(),max='**'),
           GROUP_MA        =SIMP(statut='f',typ=grma,validators=NoRepeat(),max='**'),
           SECTION         =SIMP(statut='o',typ='R'),
           ANGL_REP        =SIMP(statut='f',typ='R',max=2),
           EXCENTREMENT    =SIMP(statut='f',typ='R'),
           ORIG_AXE        =SIMP(statut='f',typ='R',max='**'),
           AXE             =SIMP(statut='f',typ='R',max='**'),
           COEF_RIGI_DRZ   =SIMP(statut='f',typ='R',defaut= 1.0E-10 ),
           GRILLE_NCOU     =SIMP(statut='f',typ='I',defaut= 1,),
         ),

#============================================================================
         RIGI_PARASOL    =FACT(statut='f',max='**',
            regles=(UN_PARMI('COEF_GROUP','FONC_GROUP'),
                    UN_PARMI('COOR_CENTRE','NOEUD_CENTRE','GROUP_NO_CENTRE'),
                    EXCLUS('GROUP_MA_POI1','GROUP_MA_SEG2'),),
            GROUP_MA        =SIMP(statut='o',typ=ma,validators=NoRepeat(),max='**',
               fr="Surface servant à répartir les caractéristiques des discrets"),
            GROUP_MA_POI1   =SIMP(statut='f',typ=ma,validators=NoRepeat(),max=1,
               fr="Mailles de type point correspondant aux discrets"),
            GROUP_MA_SEG2   =SIMP(statut='f',typ=ma,validators=NoRepeat(),max=1,
               fr="Mailles de type seg2 correspondant aux discrets"),
            FONC_GROUP      =SIMP(statut='f',typ=(fonction_sdaster,nappe_sdaster,formule) ),
            COEF_GROUP      =SIMP(statut='f',typ='R',max='**'),
            REPERE          =SIMP(statut='f',typ='TXM',into=("LOCAL","GLOBAL") ),
            CARA            =SIMP(statut='o',typ='TXM',validators=NoRepeat(),max=2,
                            into=("K_TR_D_N","K_T_D_N","K_TR_D_L","K_T_D_L",
                                  "A_TR_D_N","A_T_D_N","A_TR_D_L","A_T_D_L") ),
            VALE            =SIMP(statut='o',typ='R',max='**'),
            GROUP_NO_CENTRE =SIMP(statut='f',typ=grno),
            NOEUD_CENTRE    =SIMP(statut='f',typ=no),
            COOR_CENTRE     =SIMP(statut='f',typ='R',min=2,max=3),
         ),
         
#============================================================================
         RIGI_MISS_3D    =FACT(statut='f',max='**',
           GROUP_MA_POI1   =SIMP(statut='o',typ=ma,max=1),
           GROUP_MA_SEG2   =SIMP(statut='f',typ=ma,max=1),
           FREQ_EXTR       =SIMP(statut='o',typ='R',max=1),
           UNITE_RESU_IMPE =SIMP(statut='f',typ='I',defaut=30),
         ),
         
#============================================================================
         AFFE_SECT     =FACT(statut='f',max='**',
              regles=(AU_MOINS_UN('GROUP_MA','MAILLE'),
                      AU_MOINS_UN('TOUT_SECT','GROUP_MA_SECT','MAILLE_SECT'),
                      PRESENT_ABSENT('TOUT_SECT','GROUP_MA_SECT','MAILLE_SECT'),),

              NOM             =SIMP(statut='f',typ='TXM'),

              GROUP_MA        =SIMP(statut='f',typ=grma,validators=NoRepeat(),max='**'),
              MAILLE          =SIMP(statut='f',typ=ma  ,validators=NoRepeat(),max='**'),

              TOUT_SECT         =SIMP(statut='f',typ='TXM',into=("OUI",) ),
              GROUP_MA_SECT     =SIMP(statut='f',typ=grma,validators=NoRepeat(),max='**'),
              MAILLE_SECT       =SIMP(statut='f',typ=ma  ,validators=NoRepeat(),max='**'),

              MAILLAGE_SECT     =SIMP(statut='o',typ=maillage_sdaster),
              COOR_AXE_POUTRE    =SIMP(statut='o',typ='R',min=2,max=2),
         ),


#============================================================================
         AFFE_FIBRE     =FACT(statut='f',max='**',
              regles=(AU_MOINS_UN('GROUP_MA','MAILLE'),),

              NOM             =SIMP(statut='f',typ='TXM'),

              GROUP_MA        =SIMP(statut='f',typ=grma,validators=NoRepeat(),max='**'),
              MAILLE          =SIMP(statut='f',typ=ma  ,validators=NoRepeat(),max='**'),

              CARA              =SIMP(statut='f',typ='TXM',defaut='SURFACE',into=('SURFACE','DIAMETRE',)),
              VALE              =SIMP(statut='o',typ='R',max='**'),
              COOR_AXE_POUTRE    =SIMP(statut='o',typ='R',min=2,max=2),
         ),


) ;
#& MODIF COMMANDE  DATE 10/06/2004   AUTEUR REZETTE C.REZETTE 
#            CONFIGURATION MANAGEMENT OF EDF VERSION
# ======================================================================
# COPYRIGHT (C) 1991 - 2001  EDF R&D                  WWW.CODE-ASTER.ORG
# THIS PROGRAM IS FREE SOFTWARE; YOU CAN REDISTRIBUTE IT AND/OR MODIFY
# IT UNDER THE TERMS OF THE GNU GENERAL PUBLIC LICENSE AS PUBLISHED BY
# THE FREE SOFTWARE FOUNDATION; EITHER VERSION 2 OF THE LICENSE, OR   
# (AT YOUR OPTION) ANY LATER VERSION.                                 
#
# THIS PROGRAM IS DISTRIBUTED IN THE HOPE THAT IT WILL BE USEFUL, BUT 
# WITHOUT ANY WARRANTY; WITHOUT EVEN THE IMPLIED WARRANTY OF          
# MERCHANTABILITY OR FITNESS FOR A PARTICULAR PURPOSE. SEE THE GNU    
# GENERAL PUBLIC LICENSE FOR MORE DETAILS.                            
#
# YOU SHOULD HAVE RECEIVED A COPY OF THE GNU GENERAL PUBLIC LICENSE   
# ALONG WITH THIS PROGRAM; IF NOT, WRITE TO EDF R&D CODE_ASTER,       
#    1 AVENUE DU GENERAL DE GAULLE, 92141 CLAMART CEDEX, FRANCE.      
# ======================================================================
AFFE_CHAR_ACOU=OPER(nom="AFFE_CHAR_ACOU",op=  68,sd_prod=char_acou,
                    fr="Affectation de charges et conditions aux limites acoustiques constantes",
                    reentrant='n',
            UIinfo={"groupes":("Modélisation",)},
         regles=(AU_MOINS_UN('PRES_IMPO','VITE_FACE','IMPE_FACE','LIAISON_UNIF' ),),
         MODELE          =SIMP(statut='o',typ=modele_sdaster ),
         VERI_DDL        =SIMP(statut='f',typ='TXM',defaut="OUI",into=("OUI","NON") ),
         PRES_IMPO       =FACT(statut='f',max='**',
           regles=(AU_MOINS_UN('TOUT','GROUP_MA','MAILLE','GROUP_NO','NOEUD'),),
           TOUT            =SIMP(statut='f',typ='TXM',into=("OUI",) ),
           GROUP_MA        =SIMP(statut='f',typ=grma,validators=NoRepeat(),max='**'),
           MAILLE          =SIMP(statut='f',typ=ma  ,validators=NoRepeat(),max='**'),
           GROUP_NO        =SIMP(statut='f',typ=grno,validators=NoRepeat(),max='**'),
           NOEUD           =SIMP(statut='f',typ=no  ,validators=NoRepeat(),max='**'),
           PRES            =SIMP(statut='o',typ='C' ),
         ),
         VITE_FACE       =FACT(statut='f',max='**',
             regles=(AU_MOINS_UN('TOUT','GROUP_MA','MAILLE'),
                     PRESENT_ABSENT('TOUT','GROUP_MA','MAILLE'),),
           TOUT            =SIMP(statut='f',typ='TXM',into=("OUI",) ),
           GROUP_MA        =SIMP(statut='f',typ=grma,validators=NoRepeat(),max='**'),
           MAILLE          =SIMP(statut='f',typ=ma  ,validators=NoRepeat(),max='**'),
           VNOR            =SIMP(statut='o',typ='C' ),
         ),
         IMPE_FACE       =FACT(statut='f',max='**',
             regles=(AU_MOINS_UN('TOUT','GROUP_MA','MAILLE'),
                     PRESENT_ABSENT('TOUT','GROUP_MA','MAILLE'),),
           TOUT            =SIMP(statut='f',typ='TXM',into=("OUI",) ),
           GROUP_MA        =SIMP(statut='f',typ=grma,validators=NoRepeat(),max='**'),
           MAILLE          =SIMP(statut='f',typ=ma  ,validators=NoRepeat(),max='**'),
           IMPE            =SIMP(statut='o',typ='C' ),
         ),
         LIAISON_UNIF    =FACT(statut='f',max='**',
           regles=(UN_PARMI('GROUP_NO','NOEUD','GROUP_MA','MAILLE' ),),
           GROUP_NO        =SIMP(statut='f',typ=grno,validators=NoRepeat(),max='**'),
           NOEUD           =SIMP(statut='f',typ=no  ,validators=NoRepeat(),max='**'),
           GROUP_MA        =SIMP(statut='f',typ=grma,validators=NoRepeat(),max='**'),
           MAILLE          =SIMP(statut='f',typ=ma  ,validators=NoRepeat(),max='**'),
           DDL             =SIMP(statut='o',typ='TXM',max='**'),
         ),
)  ;
#& MODIF COMMANDE  DATE 27/11/2006   AUTEUR PELLET J.PELLET 
#            CONFIGURATION MANAGEMENT OF EDF VERSION
# ======================================================================
# COPYRIGHT (C) 1991 - 2001  EDF R&D                  WWW.CODE-ASTER.ORG
# THIS PROGRAM IS FREE SOFTWARE; YOU CAN REDISTRIBUTE IT AND/OR MODIFY
# IT UNDER THE TERMS OF THE GNU GENERAL PUBLIC LICENSE AS PUBLISHED BY
# THE FREE SOFTWARE FOUNDATION; EITHER VERSION 2 OF THE LICENSE, OR
# (AT YOUR OPTION) ANY LATER VERSION.
#
# THIS PROGRAM IS DISTRIBUTED IN THE HOPE THAT IT WILL BE USEFUL, BUT
# WITHOUT ANY WARRANTY; WITHOUT EVEN THE IMPLIED WARRANTY OF
# MERCHANTABILITY OR FITNESS FOR A PARTICULAR PURPOSE. SEE THE GNU
# GENERAL PUBLIC LICENSE FOR MORE DETAILS.
#
# YOU SHOULD HAVE RECEIVED A COPY OF THE GNU GENERAL PUBLIC LICENSE
# ALONG WITH THIS PROGRAM; IF NOT, WRITE TO EDF R&D CODE_ASTER,
#    1 AVENUE DU GENERAL DE GAULLE, 92141 CLAMART CEDEX, FRANCE.
# ======================================================================
# RESPONSABLE VABHHTS J.PELLET
def affe_char_cine_prod(MECA_IMPO,THER_IMPO,ACOU_IMPO,**args):
  if MECA_IMPO != None  : return char_cine_meca
  if THER_IMPO != None  : return char_cine_ther
  if ACOU_IMPO != None  : return char_cine_acou
  raise AsException("type de concept resultat non prevu")

AFFE_CHAR_CINE=OPER(nom="AFFE_CHAR_CINE",op= 101,sd_prod=affe_char_cine_prod
                    ,fr="Affectation de conditions aux limites cinématiques constantes pour un traitement sans dualisation",
                     reentrant='n',
            UIinfo={"groupes":("Modélisation",)},
         regles=(AU_MOINS_UN('MECA_IMPO','THER_IMPO','ACOU_IMPO'),
                 EXCLUS('MECA_IMPO','THER_IMPO'),
                 EXCLUS('MECA_IMPO','ACOU_IMPO'),
                 EXCLUS('THER_IMPO','ACOU_IMPO'),),
         MODELE          =SIMP(statut='o',typ=modele_sdaster ),
         MECA_IMPO       =FACT(statut='f',max='**',
           regles=(UN_PARMI('TOUT','GROUP_MA','MAILLE','GROUP_NO','NOEUD'),
                   AU_MOINS_UN('DX','DY','DZ','DRX','DRY','DRZ','GRX','PRES','PHI',
                               'TEMP'),),
             TOUT            =SIMP(statut='f',typ='TXM',into=("OUI",) ),
             GROUP_MA        =SIMP(statut='f',typ=grma,validators=NoRepeat(),max='**'),
             MAILLE          =SIMP(statut='f',typ=ma  ,validators=NoRepeat(),max='**'),
             GROUP_NO        =SIMP(statut='f',typ=grno,validators=NoRepeat(),max='**'),
             NOEUD           =SIMP(statut='f',typ=no  ,validators=NoRepeat(),max='**'),
             DX              =SIMP(statut='f',typ='R' ),
             DY              =SIMP(statut='f',typ='R' ),
             DZ              =SIMP(statut='f',typ='R' ),
             DRX             =SIMP(statut='f',typ='R' ),
             DRY             =SIMP(statut='f',typ='R' ),
             DRZ             =SIMP(statut='f',typ='R' ),
             GRX             =SIMP(statut='f',typ='R' ),
             PRES            =SIMP(statut='f',typ='R' ),
             PHI             =SIMP(statut='f',typ='R' ),
             TEMP            =SIMP(statut='f',typ='R' ),
         ),
         THER_IMPO       =FACT(statut='f',max='**',
           regles=(UN_PARMI('TOUT','GROUP_MA','MAILLE','GROUP_NO','NOEUD'),
                   AU_MOINS_UN('TEMP','TEMP_INF','TEMP_SUP'),),
           TOUT            =SIMP(statut='f',typ='TXM',into=("OUI",) ),
           GROUP_MA        =SIMP(statut='f',typ=grma,validators=NoRepeat(),max='**'),
           MAILLE          =SIMP(statut='f',typ=ma  ,validators=NoRepeat(),max='**'),
           GROUP_NO        =SIMP(statut='f',typ=grno,validators=NoRepeat(),max='**'),
           NOEUD           =SIMP(statut='f',typ=no  ,validators=NoRepeat(),max='**'),
           TEMP_SUP        =SIMP(statut='f',typ='R' ),
           TEMP            =SIMP(statut='f',typ='R' ),
           TEMP_INF        =SIMP(statut='f',typ='R' ),
         ),
         ACOU_IMPO       =FACT(statut='f',max='**',
           regles=(UN_PARMI('TOUT','GROUP_MA','MAILLE','GROUP_NO','NOEUD'),),
           TOUT            =SIMP(statut='f',typ='TXM',into=("OUI",) ),
           GROUP_MA        =SIMP(statut='f',typ=grma,validators=NoRepeat(),max='**'),
           MAILLE          =SIMP(statut='f',typ=ma  ,validators=NoRepeat(),max='**'),
           GROUP_NO        =SIMP(statut='f',typ=grno,validators=NoRepeat(),max='**'),
           NOEUD           =SIMP(statut='f',typ=no  ,validators=NoRepeat(),max='**'),
           PRES            =SIMP(statut='o',typ='C' ),
         ),
         INFO            =SIMP(statut='f',typ='I',defaut= 1,into=( 1 , 2) ),
)  ;
#& MODIF COMMANDE  DATE 05/09/2005   AUTEUR CIBHHLV L.VIVAN 
#            CONFIGURATION MANAGEMENT OF EDF VERSION
# ======================================================================
# COPYRIGHT (C) 1991 - 2001  EDF R&D                  WWW.CODE-ASTER.ORG
# THIS PROGRAM IS FREE SOFTWARE; YOU CAN REDISTRIBUTE IT AND/OR MODIFY
# IT UNDER THE TERMS OF THE GNU GENERAL PUBLIC LICENSE AS PUBLISHED BY
# THE FREE SOFTWARE FOUNDATION; EITHER VERSION 2 OF THE LICENSE, OR
# (AT YOUR OPTION) ANY LATER VERSION.
#
# THIS PROGRAM IS DISTRIBUTED IN THE HOPE THAT IT WILL BE USEFUL, BUT
# WITHOUT ANY WARRANTY; WITHOUT EVEN THE IMPLIED WARRANTY OF
# MERCHANTABILITY OR FITNESS FOR A PARTICULAR PURPOSE. SEE THE GNU
# GENERAL PUBLIC LICENSE FOR MORE DETAILS.
#fon
# YOU SHOULD HAVE RECEIVED A COPY OF THE GNU GENERAL PUBLIC LICENSE
# ALONG WITH THIS PROGRAM; IF NOT, WRITE TO EDF R&D CODE_ASTER,
#    1 AVENUE DU GENERAL DE GAULLE, 92141 CLAMART CEDEX, FRANCE.
# ======================================================================
def affe_char_cine_f_prod(MECA_IMPO,THER_IMPO,**args):
  if MECA_IMPO != None  : return char_cine_meca
  if THER_IMPO != None  : return char_cine_ther
  raise AsException("type de concept resultat non prevu")

AFFE_CHAR_CINE_F=OPER(nom="AFFE_CHAR_CINE_F",op= 108,sd_prod=affe_char_cine_f_prod,
                      fr="Affectation de conditions aux limites cinématiques fonction d'un (ou plusieurs) paramètres"
                        +" pour un traitement sans dualisation",
                     reentrant='n',
            UIinfo={"groupes":("Modélisation",)},
         regles=(AU_MOINS_UN('MECA_IMPO','THER_IMPO'),
                 EXCLUS('MECA_IMPO','THER_IMPO'),),
         MODELE          =SIMP(statut='o',typ=modele_sdaster ),
         MECA_IMPO       =FACT(statut='f',max='**',
           regles=(UN_PARMI('TOUT','GROUP_MA','MAILLE','GROUP_NO','NOEUD'),
                   AU_MOINS_UN('DX','DY','DZ','DRX','DRY','DRZ','GRX','PRES','TEMP','PHI'),),
           TOUT            =SIMP(statut='f',typ='TXM',into=("OUI",) ),
           GROUP_MA        =SIMP(statut='f',typ=grma,validators=NoRepeat(),max='**'),
           MAILLE          =SIMP(statut='f',typ=ma  ,validators=NoRepeat(),max='**'),
           GROUP_NO        =SIMP(statut='f',typ=grno,validators=NoRepeat(),max='**'),
           NOEUD           =SIMP(statut='f',typ=no  ,validators=NoRepeat(),max='**'),
           DX              =SIMP(statut='f',typ=(fonction_sdaster,nappe_sdaster,formule) ),
           DY              =SIMP(statut='f',typ=(fonction_sdaster,nappe_sdaster,formule) ),
           DZ              =SIMP(statut='f',typ=(fonction_sdaster,nappe_sdaster,formule) ),
           DRX             =SIMP(statut='f',typ=(fonction_sdaster,nappe_sdaster,formule) ),
           DRY             =SIMP(statut='f',typ=(fonction_sdaster,nappe_sdaster,formule) ),
           DRZ             =SIMP(statut='f',typ=(fonction_sdaster,nappe_sdaster,formule) ),
           GRX             =SIMP(statut='f',typ=(fonction_sdaster,nappe_sdaster,formule) ),
           PRES            =SIMP(statut='f',typ=(fonction_sdaster,nappe_sdaster,formule) ),
           TEMP            =SIMP(statut='f',typ=(fonction_sdaster,nappe_sdaster,formule) ),
           PHI             =SIMP(statut='f',typ=(fonction_sdaster,nappe_sdaster,formule) ),
         ),
         THER_IMPO       =FACT(statut='f',max='**',
           regles=(UN_PARMI('TOUT','GROUP_MA','MAILLE','GROUP_NO','NOEUD'),
                   AU_MOINS_UN('TEMP','TEMP_INF','TEMP_SUP' ),),
           TOUT            =SIMP(statut='f',typ='TXM',into=("OUI",) ),
           GROUP_MA        =SIMP(statut='f',typ=grma,validators=NoRepeat(),max='**'),
           MAILLE          =SIMP(statut='f',typ=ma  ,validators=NoRepeat(),max='**'),
           GROUP_NO        =SIMP(statut='f',typ=grno,validators=NoRepeat(),max='**'),
           NOEUD           =SIMP(statut='f',typ=no  ,validators=NoRepeat(),max='**'),
           TEMP_SUP        =SIMP(statut='f',typ=(fonction_sdaster,nappe_sdaster,formule) ),
           TEMP            =SIMP(statut='f',typ=(fonction_sdaster,nappe_sdaster,formule) ),
           TEMP_INF        =SIMP(statut='f',typ=(fonction_sdaster,nappe_sdaster,formule) ),
         ),
         INFO            =SIMP(statut='f',typ='I',defaut= 1,into=( 1 , 2) ),
)  ;
#& MODIF COMMANDE  DATE 14/11/2006   AUTEUR TARDIEU N.TARDIEU 
#            CONFIGURATION MANAGEMENT OF EDF VERSION
# ======================================================================
# COPYRIGHT (C) 1991 - 2001  EDF R&D                  WWW.CODE-ASTER.ORG
# THIS PROGRAM IS FREE SOFTWARE; YOU CAN REDISTRIBUTE IT AND/OR MODIFY
# IT UNDER THE TERMS OF THE GNU GENERAL PUBLIC LICENSE AS PUBLISHED BY
# THE FREE SOFTWARE FOUNDATION; EITHER VERSION 2 OF THE LICENSE, OR
# (AT YOUR OPTION) ANY LATER VERSION.
#
# THIS PROGRAM IS DISTRIBUTED IN THE HOPE THAT IT WILL BE USEFUL, BUT
# WITHOUT ANY WARRANTY; WITHOUT EVEN THE IMPLIED WARRANTY OF
# MERCHANTABILITY OR FITNESS FOR A PARTICULAR PURPOSE. SEE THE GNU
# GENERAL PUBLIC LICENSE FOR MORE DETAILS.
#
# YOU SHOULD HAVE RECEIVED A COPY OF THE GNU GENERAL PUBLIC LICENSE
# ALONG WITH THIS PROGRAM; IF NOT, WRITE TO EDF R&D CODE_ASTER,
#    1 AVENUE DU GENERAL DE GAULLE, 92141 CLAMART CEDEX, FRANCE.
# ======================================================================
# RESPONSABLE G8BHHXD X.DESROCHES
AFFE_CHAR_MECA=OPER(nom="AFFE_CHAR_MECA",op=   7,sd_prod=char_meca,
                    fr="Affectation de charges et conditions aux limites mécaniques constantes",
                     reentrant='n',
            UIinfo={"groupes":("Modélisation",)},
         regles=(AU_MOINS_UN('DDL_IMPO','FACE_IMPO','CHAMNO_IMPO','LIAISON_DDL','LIAISON_XFEM','FORCE_NODALE',
                             'FORCE_FACE','FORCE_ARETE','FORCE_CONTOUR','FORCE_INTERNE',
                             'PRES_REP','FORCE_POUTRE','FORCE_COQUE','LIAISON_OBLIQUE',
                             'FORCE_ELEC','INTE_ELEC','PESANTEUR','ROTATION','IMPE_FACE',
                             'VITE_FACE','TEMP_CALCULEE','RELA_CINE_BP','EPSI_INIT','CONTACT',
                             'LIAISON_GROUP','LIAISON_UNIF','FLUX_THM_REP','LIAISON_SOLIDE',
                             'LIAISON_ELEM','ONDE_FLUI','LIAISON_CHAMNO','VECT_ASSE','LIAISON_COQUE',
                             'LIAISON_MAIL','LIAISON_CYCL','FORCE_TUYAU',
                             'EFFE_FOND','EVOL_CHAR','ARLEQUIN','DDL_POUTRE','GRAPPE_FLUIDE',
                             'LIAISON_UNILATER'),
                         ),
         VERI_NORM       =SIMP(statut='f',typ='TXM',defaut="OUI",into=("OUI","NON") ),
         MODELE          =SIMP(statut='o',typ=(modele_sdaster) ),
         TEMP_CALCULEE   =SIMP(statut='f',fr="Champ de température issu d'un autre calcul",
                               typ=(evol_ther,cham_no_sdaster,carte_sdaster) ),
         EVOL_CHAR       =SIMP(statut='f',fr="Champ de pression issu d'un autre calcul",
                               typ=evol_char ),

         PESANTEUR       =SIMP(statut='f',typ='R',fr="Champ de pesanteur",min=4,max=4),
         ROTATION        =SIMP(statut='f',typ='R',fr="Champ de rotation", min=4,max=4),
         b_rotation      =BLOC ( condition = "ROTATION != None",
           CENTRE          =SIMP(statut='f',typ='R',defaut=(0.,0.,0.),max=3),),

         DDL_IMPO        =FACT(statut='f',max='**',
             fr="Impose à des noeuds une ou plusieurs valeurs de déplacement (ou de certaines grandeurs asscociées)",
             regles=(AU_MOINS_UN('TOUT','GROUP_MA','MAILLE','GROUP_NO','NOEUD'),
                     AU_MOINS_UN('DX','DY','DZ','DRX','DRY','DRZ','GRX','PRES','PHI',
                                 'TEMP','PRE1','PRE2','UI2','UI3','VI2','VI3','WI2','WI3','UO2',
                                 'UO3','VO2','VO3','WO2','WO3','UI4','UI5','VI4','VI5','WI4',
                                 'WI5','UO4','UO5','VO4','VO5','WO4','WO5','UI6','UO6','VI6',
                                 'VO6','WI6','WO6','WO','WI1','WO1','GONF','LIAISON','DCX',
                                 'DCY','DCZ','H1X','H1Y','H1Z','E1X','E1Y','E1Z','E2X','E2Y','E2Z',
                                 'E3X','E3Y','E3Z','E4X','E4Y','E4Z','LAGS_C'),),
             TOUT            =SIMP(statut='f',typ='TXM',into=("OUI",) ),
             GROUP_NO        =SIMP(statut='f',typ=grno,validators=NoRepeat(),max='**'),
             NOEUD           =SIMP(statut='f',typ=no  ,validators=NoRepeat(),max='**'),
             GROUP_MA        =SIMP(statut='f',typ=grma,validators=NoRepeat(),max='**'),
             MAILLE          =SIMP(statut='f',typ=ma  ,validators=NoRepeat(),max='**'),
             LIAISON         =SIMP(statut='f',typ='TXM',into=('ENCASTRE',)),
             DX              =SIMP(statut='f',typ='R' ),
             DY              =SIMP(statut='f',typ='R' ),
             DZ              =SIMP(statut='f',typ='R' ),
             DRX             =SIMP(statut='f',typ='R' ),
             DRY             =SIMP(statut='f',typ='R' ),
             DRZ             =SIMP(statut='f',typ='R' ),
             GRX             =SIMP(statut='f',typ='R' ),
             PRES            =SIMP(statut='f',typ='R' ),
             PHI             =SIMP(statut='f',typ='R' ),
             TEMP            =SIMP(statut='f',typ='R' ),
             PRE1            =SIMP(statut='f',typ='R' ),
             PRE2            =SIMP(statut='f',typ='R' ),
             UI2             =SIMP(statut='f',typ='R' ),
             UI3             =SIMP(statut='f',typ='R' ),
             UI4             =SIMP(statut='f',typ='R' ),
             UI5             =SIMP(statut='f',typ='R' ),
             UI6             =SIMP(statut='f',typ='R' ),
             UO2             =SIMP(statut='f',typ='R' ),
             UO3             =SIMP(statut='f',typ='R' ),
             UO4             =SIMP(statut='f',typ='R' ),
             UO5             =SIMP(statut='f',typ='R' ),
             UO6             =SIMP(statut='f',typ='R' ),
             VI2             =SIMP(statut='f',typ='R' ),
             VI3             =SIMP(statut='f',typ='R' ),
             VI4             =SIMP(statut='f',typ='R' ),
             VI5             =SIMP(statut='f',typ='R' ),
             VI6             =SIMP(statut='f',typ='R' ),
             VO2             =SIMP(statut='f',typ='R' ),
             VO3             =SIMP(statut='f',typ='R' ),
             VO4             =SIMP(statut='f',typ='R' ),
             VO5             =SIMP(statut='f',typ='R' ),
             VO6             =SIMP(statut='f',typ='R' ),
             WI2             =SIMP(statut='f',typ='R' ),
             WI3             =SIMP(statut='f',typ='R' ),
             WI4             =SIMP(statut='f',typ='R' ),
             WI5             =SIMP(statut='f',typ='R' ),
             WI6             =SIMP(statut='f',typ='R' ),
             WO2             =SIMP(statut='f',typ='R' ),
             WO3             =SIMP(statut='f',typ='R' ),
             WO4             =SIMP(statut='f',typ='R' ),
             WO5             =SIMP(statut='f',typ='R' ),
             WO6             =SIMP(statut='f',typ='R' ),
             WO              =SIMP(statut='f',typ='R' ),
             WI1             =SIMP(statut='f',typ='R' ),
             WO1             =SIMP(statut='f',typ='R' ),
             GONF            =SIMP(statut='f',typ='R' ),
             DCX             =SIMP(statut='f',typ='R' ),
             DCY             =SIMP(statut='f',typ='R' ),
             DCZ             =SIMP(statut='f',typ='R' ),
             H1X             =SIMP(statut='f',typ='R' ),
             H1Y             =SIMP(statut='f',typ='R' ),
             H1Z             =SIMP(statut='f',typ='R' ),                  
             E1X             =SIMP(statut='f',typ='R' ),
             E1Y             =SIMP(statut='f',typ='R' ),
             E1Z             =SIMP(statut='f',typ='R' ),      
             E2X             =SIMP(statut='f',typ='R' ),
             E2Y             =SIMP(statut='f',typ='R' ),
             E2Z             =SIMP(statut='f',typ='R' ),      
             E3X             =SIMP(statut='f',typ='R' ),
             E3Y             =SIMP(statut='f',typ='R' ),
             E3Z             =SIMP(statut='f',typ='R' ),      
             E4X             =SIMP(statut='f',typ='R' ),
             E4Y             =SIMP(statut='f',typ='R' ),
             E4Z             =SIMP(statut='f',typ='R' ),      
             LAGS_C          =SIMP(statut='f',typ='R' ),
           ),



         DDL_POUTRE    =FACT(statut='f',max='**',
             fr="Bloque des DDLs dans un repère local d'une poutre",
             regles=(AU_MOINS_UN('GROUP_NO','NOEUD'),
                     AU_MOINS_UN('DX','DY','DZ','DRX','DRY','DRZ'),
                     UN_PARMI('VECT_Y','ANGL_VRIL'),),
             GROUP_NO        =SIMP(statut='f',typ=grno,validators=NoRepeat(),max='**'),
             NOEUD           =SIMP(statut='f',typ=no  ,validators=NoRepeat(),max='**'),
             DX              =SIMP(statut='f',typ='R' ),
             DY              =SIMP(statut='f',typ='R' ),
             DZ              =SIMP(statut='f',typ='R' ),
             DRX             =SIMP(statut='f',typ='R' ),
             DRY             =SIMP(statut='f',typ='R' ),
             DRZ             =SIMP(statut='f',typ='R' ),
#  définition du repère local
             VECT_Y          =SIMP(statut='f',typ='R',min=3,max=3),
             ANGL_VRIL       =SIMP(statut='f',typ='R',),
#  restriction sur les mailles servant à définir le repère local
             GROUP_MA        =SIMP(statut='f',typ=grma,),
             MAILLE          =SIMP(statut='f',typ=ma,),
                            ),



           FACE_IMPO       =FACT(statut='f',max='**',
             fr="Impose à tous les noeuds d'une face une ou plusieurs valeurs de déplacement (ou de certaines grandeurs associées)",
             regles=(UN_PARMI('GROUP_MA','MAILLE',),
                     AU_MOINS_UN('DX','DY','DZ','DRX','DRY','DRZ','GRX','PRES','PHI',
                                 'TEMP','PRE1','PRE2','DNOR','DTAN'),
                     EXCLUS('DNOR','DX'),
                     EXCLUS('DNOR','DY'),
                     EXCLUS('DNOR','DZ'),
                     EXCLUS('DNOR','DRX'),
                     EXCLUS('DNOR','DRY'),
                     EXCLUS('DNOR','DRZ'),
                     EXCLUS('DTAN','DX'),
                     EXCLUS('DTAN','DY'),
                     EXCLUS('DTAN','DZ'),
                     EXCLUS('DTAN','DRX'),
                     EXCLUS('DTAN','DRY'),
                     EXCLUS('DTAN','DRZ'),),
#  rajout d'un mot clé REPERE :/ LOCAL /GLOBAL
             GROUP_MA        =SIMP(statut='f',typ=grma,validators=NoRepeat(),max='**'),
             MAILLE          =SIMP(statut='f',typ=ma  ,validators=NoRepeat(),max='**'),
             SANS_GROUP_MA   =SIMP(statut='f',typ=grma,validators=NoRepeat(),max='**'),
             SANS_MAILLE     =SIMP(statut='f',typ=ma  ,validators=NoRepeat(),max='**'),
             DX              =SIMP(statut='f',typ='R' ),
             DY              =SIMP(statut='f',typ='R' ),
             DZ              =SIMP(statut='f',typ='R' ),
             DRX             =SIMP(statut='f',typ='R' ),
             DRY             =SIMP(statut='f',typ='R' ),
             DRZ             =SIMP(statut='f',typ='R' ),
             DNOR            =SIMP(statut='f',typ='R' ),
             DTAN            =SIMP(statut='f',typ='R' ),
             GRX             =SIMP(statut='f',typ='R' ),
             PRES            =SIMP(statut='f',typ='R' ),
             PHI             =SIMP(statut='f',typ='R' ),
             TEMP            =SIMP(statut='f',typ='R' ),
             PRE1            =SIMP(statut='f',typ='R' ),
             PRE2            =SIMP(statut='f',typ='R' ),
           ),

         CHAMNO_IMPO  =FACT(statut='f',max='**',
             fr="Impose des DDLs aux valeurs d'un concept cham_no_sdaster",
#  type de cham_no_sdaster CO()
             CHAM_NO         =SIMP(statut='o',typ=cham_no_sdaster), #CO()
             COEF_MULT       =SIMP(statut='o',typ='R' ),
             NUME_LAGR       =SIMP(statut='f',typ='TXM',defaut="NORMAL",into=("NORMAL","APRES") ),
           ),


           LIAISON_DDL     =FACT(statut='f',max='**',
             fr="Définit une relation linéaire entre des DDLs de deux ou plusieurs noeuds",
             regles=(UN_PARMI('GROUP_NO','NOEUD'),),
             GROUP_NO        =SIMP(statut='f',typ=grno ,max='**'),
             NOEUD           =SIMP(statut='f',typ=no   ,max='**'),
             DDL             =SIMP(statut='o',typ='TXM',max='**'),
             COEF_MULT       =SIMP(statut='o',typ='R'  ,max='**'),
             COEF_IMPO       =SIMP(statut='o',typ='R' ),
           ),

           LIAISON_OBLIQUE =FACT(statut='f',max='**',
             fr="Applique à des noeuds la meme valeur de déplacement définie composante par composante"
              +" dans un repère oblique quelconque",
             regles=(UN_PARMI('GROUP_NO','NOEUD'),
                     UN_PARMI('DX','DY','DZ','DRX','DRY','DRZ'),),
             GROUP_NO        =SIMP(statut='f',typ=grno,validators=NoRepeat(),max='**'),
             NOEUD           =SIMP(statut='f',typ=no  ,validators=NoRepeat(),max='**'),
             ANGL_NAUT       =SIMP(statut='o',typ='R',max=3),
             DX              =SIMP(statut='f',typ='R' ),
             DY              =SIMP(statut='f',typ='R' ),
             DZ              =SIMP(statut='f',typ='R' ),
             DRX             =SIMP(statut='f',typ='R' ),
             DRY             =SIMP(statut='f',typ='R' ),
             DRZ             =SIMP(statut='f',typ='R' ),
           ),

           LIAISON_GROUP   =FACT(statut='f',max='**',
             fr="Définit la meme relation linéaire entre certains DDLs de couples de noeuds",
             regles=(UN_PARMI('GROUP_MA_1','MAILLE_1','GROUP_NO_1','NOEUD_1'),
                     UN_PARMI('GROUP_MA_2','MAILLE_2','GROUP_NO_2','NOEUD_2'),
                     EXCLUS('GROUP_MA_1','GROUP_NO_2'),
                     EXCLUS('GROUP_MA_1','NOEUD_2'),
                     EXCLUS('GROUP_NO_1','GROUP_MA_2'),
                     EXCLUS('GROUP_NO_1','MAILLE_2'),
                     EXCLUS('MAILLE_1','GROUP_NO_2'),
                     EXCLUS('MAILLE_1','NOEUD_2'),
                     EXCLUS('NOEUD_1','GROUP_MA_2'),
                     EXCLUS('NOEUD_1','MAILLE_2'),
                     EXCLUS('SANS_NOEUD','SANS_GROUP_NO'),),

               GROUP_MA_1      =SIMP(statut='f',typ=grma,validators=NoRepeat(),max='**'),
               MAILLE_1        =SIMP(statut='f',typ=ma  ,validators=NoRepeat(),max='**'),
               GROUP_MA_2      =SIMP(statut='f',typ=grma,validators=NoRepeat(),max='**'),
               MAILLE_2        =SIMP(statut='f',typ=ma  ,validators=NoRepeat(),max='**'),
               GROUP_NO_1      =SIMP(statut='f',typ=grno,validators=NoRepeat(),max='**'),
               NOEUD_1         =SIMP(statut='f',typ=no  ,validators=NoRepeat(),max='**'),
               GROUP_NO_2      =SIMP(statut='f',typ=no  ,validators=NoRepeat(),max='**'),
               NOEUD_2         =SIMP(statut='f',typ=no  ,validators=NoRepeat(),max='**'),

             SANS_NOEUD      =SIMP(statut='f',typ=no   ,validators=NoRepeat(),max='**'),
             SANS_GROUP_NO   =SIMP(statut='f',typ=grno ,validators=NoRepeat(),max='**'),
             DDL_1           =SIMP(statut='o',typ='TXM',max='**'),
             COEF_MULT_1     =SIMP(statut='o',typ='R'  ,max='**'),
             DDL_2           =SIMP(statut='o',typ='TXM',max='**'),
             COEF_MULT_2     =SIMP(statut='o',typ='R'  ,max='**'),
             COEF_IMPO       =SIMP(statut='o',typ='R' ),
             SOMMET          =SIMP(statut='f',typ='TXM',into=("OUI",) ),
             TRAN            =SIMP(statut='f',typ='R',max=3),
             ANGL_NAUT       =SIMP(statut='f',typ='R',max=3),
             CENTRE          =SIMP(statut='f',typ='R',max=3),
           ),

           LIAISON_MAIL    =FACT(statut='f',max='**',
             fr="Définit des relations linéaires permettant de recoller deux bords d'une structure",
             regles=(AU_MOINS_UN('GROUP_MA_MAIT','MAILLE_MAIT'),
                     AU_MOINS_UN('GROUP_MA_ESCL','MAILLE_ESCL','GROUP_NO_ESCL','NOEUD_ESCL'),
                     PRESENT_PRESENT('DDL_MAIT','DDL_ESCL'),),
              GROUP_MA_MAIT   =SIMP(statut='f',typ=grma,validators=NoRepeat(),max='**'),
              MAILLE_MAIT     =SIMP(statut='f',typ=ma  ,validators=NoRepeat(),max='**'),
              GROUP_MA_ESCL   =SIMP(statut='f',typ=grma,validators=NoRepeat(),max='**'),
              MAILLE_ESCL     =SIMP(statut='f',typ=ma  ,validators=NoRepeat(),max='**'),
              GROUP_NO_ESCL   =SIMP(statut='f',typ=grno,validators=NoRepeat(),max='**'),
              NOEUD_ESCL      =SIMP(statut='f',typ=no  ,validators=NoRepeat(),max='**'),
              TRAN            =SIMP(statut='f',typ='R',max=3 ),
              ANGL_NAUT       =SIMP(statut='f',typ='R',max=3 ),
              CENTRE          =SIMP(statut='f',typ='R',max=3 ),
              DDL_MAIT        =SIMP(statut='f',typ='TXM',into=("DNOR",) ),
              DDL_ESCL        =SIMP(statut='f',typ='TXM',into=("DNOR",) ),
              ELIM_MULT       =SIMP(statut='f',typ='TXM',defaut="NON",into=("OUI","NON") ),
         ),

           LIAISON_CYCL    =FACT(statut='f',max='**',
             fr="Définit des relations linéaires permettant de recoller les bords de deux parties symétriquement cycliques",
             regles=(AU_MOINS_UN('GROUP_MA_MAIT1','MAILLE_MAIT1'),
                     AU_MOINS_UN('GROUP_MA_ESCL','MAILLE_ESCL','GROUP_NO_ESCL','NOEUD_ESCL'),
                     PRESENT_PRESENT('DDL_MAIT','DDL_ESCL'),
                     ),
              GROUP_MA_MAIT1   =SIMP(statut='f',typ=grma,validators=NoRepeat(),max='**'),
              MAILLE_MAIT1     =SIMP(statut='f',typ=ma  ,validators=NoRepeat(),max='**'),
              GROUP_MA_MAIT2   =SIMP(statut='f',typ=grma,validators=NoRepeat(),max='**'),
              MAILLE_MAIT2     =SIMP(statut='f',typ=ma  ,validators=NoRepeat(),max='**'),
              GROUP_MA_ESCL   =SIMP(statut='f',typ=grma,validators=NoRepeat(),max='**'),
              MAILLE_ESCL     =SIMP(statut='f',typ=ma  ,validators=NoRepeat(),max='**'),
              GROUP_NO_ESCL   =SIMP(statut='f',typ=grno,validators=NoRepeat(),max='**'),
              NOEUD_ESCL     =SIMP(statut='f',typ=no  ,validators=NoRepeat(),max='**'),
              TRAN            =SIMP(statut='f',typ='R',max=3 ),
              ANGL_NAUT       =SIMP(statut='f',typ='R',max=3 ),
              CENTRE          =SIMP(statut='f',typ='R',max=3 ),
              COEF_MAIT1            =SIMP(statut='f',typ='R',max=1 ),
              COEF_MAIT2            =SIMP(statut='f',typ='R',max=1 ),
              COEF_ESCL            =SIMP(statut='f',typ='R',max=1 ),
              DDL_MAIT        =SIMP(statut='f',typ='TXM',into=("DNOR",) ),
              DDL_ESCL        =SIMP(statut='f',typ='TXM',into=("DNOR",) ),
         ),


           LIAISON_SOLIDE  =FACT(statut='f',fr="Modélise une partie indéformable d'une structure",max='**',
             regles=(UN_PARMI('GROUP_NO','NOEUD','GROUP_MA','MAILLE'),),
             GROUP_NO        =SIMP(statut='f',typ=grno,validators=NoRepeat(),max='**'),
             NOEUD           =SIMP(statut='f',typ=no  ,validators=NoRepeat(),max='**'),
             GROUP_MA        =SIMP(statut='f',typ=grma,validators=NoRepeat(),max='**'),
             MAILLE          =SIMP(statut='f',typ=ma  ,validators=NoRepeat(),max='**'),
             NUME_LAGR       =SIMP(statut='f',typ='TXM',defaut="NORMAL",into=("NORMAL","APRES") ),
           ),

           LIAISON_ELEM    =FACT(statut='f',max='**',
             fr="Modélise le raccord d'une partie massive 3D avec une poutre ou avec un tuyau, le raccord d'une coque"
              +" avec une poutre ou avec un tuyau",
             regles=(UN_PARMI('GROUP_MA_1','MAILLE_1'),
                     UN_PARMI('GROUP_NO_2','NOEUD_2'),),
             OPTION          =SIMP(statut='o',typ='TXM',into=("3D_TUYAU","3D_POU","COQ_POU","COQ_TUYAU") ),
             GROUP_MA_1      =SIMP(statut='f',typ=grma,validators=NoRepeat(),max='**'),
             MAILLE_1        =SIMP(statut='f',typ=ma  ,validators=NoRepeat(),max='**'),
             GROUP_NO_2      =SIMP(statut='f',typ=grno,validators=NoRepeat(),max='**'),
             NOEUD_2         =SIMP(statut='f',typ=no  ,validators=NoRepeat(),max='**'),
             NUME_LAGR       =SIMP(statut='f',typ='TXM',defaut="NORMAL",into=("NORMAL","APRES") ),
             CARA_ELEM       =SIMP(statut='f',typ=(cara_elem) ),
             AXE_POUTRE      =SIMP(statut='f',typ='R',max=3),
             ANGL_MAX        =SIMP(statut='f',typ='R',defaut= 1. ),
           ),

           LIAISON_UNIF    =FACT(statut='f',max='**',
             fr="Impose une meme valeur (inconnue) à des DDLs d'un ensemble de noeuds",
             regles=(UN_PARMI('GROUP_NO','NOEUD','GROUP_MA','MAILLE'),),
             GROUP_NO        =SIMP(statut='f',typ=grno,validators=NoRepeat(),max='**'),
             NOEUD           =SIMP(statut='f',typ=no  ,validators=NoRepeat(),max='**'),
             GROUP_MA        =SIMP(statut='f',typ=grma,validators=NoRepeat(),max='**'),
             MAILLE          =SIMP(statut='f',typ=ma  ,validators=NoRepeat(),max='**'),
             DDL             =SIMP(statut='o',typ='TXM',max='**'),
           ),

         LIAISON_CHAMNO  =FACT(statut='f',max='**',
             fr="Définit une relation linéaire entre tous les DDLs présents dans un concept CHAM_NO",
#  type de cham_no_sdaster CO()
             CHAM_NO         =SIMP(statut='o',typ=cham_no_sdaster), #CO()
             COEF_IMPO       =SIMP(statut='o',typ='R' ),
             NUME_LAGR       =SIMP(statut='f',typ='TXM',defaut="NORMAL",into=("NORMAL","APRES") ),
           ),

         LIAISON_XFEM      =SIMP(statut='f',typ='TXM',into=("OUI","NON"),defaut="NON" ),

         VECT_ASSE       =SIMP(statut='f',typ=cham_no_sdaster ),
#
# LIAISON UNILATERALE
# 
         LIAISON_UNILATER=FACT(statut='f',max='**',
           fr="Définit les zones soumises à des conditions de liaison unilaterale (inegalite sur un DDL)",
           regles=(UN_PARMI('GROUP_MA','MAILLE','GROUP_NO','NOEUD'),),
                                         
           GROUP_MA        =SIMP(statut='f',typ=grma ,validators=NoRepeat(),max='**'),
           MAILLE          =SIMP(statut='f',typ=ma   ,validators=NoRepeat(),max='**'),
           GROUP_NO        =SIMP(statut='f',typ=grno ,validators=NoRepeat(),max='**'),
           NOEUD           =SIMP(statut='f',typ=no   ,validators=NoRepeat(),max='**'),   

           SANS_NOEUD      =SIMP(statut='f',typ=no  ,validators=NoRepeat(),max='**'),
           SANS_GROUP_NO   =SIMP(statut='f',typ=grno,validators=NoRepeat(),max='**'),
                 
           NB_RESOL        =SIMP(statut='f',typ='I', defaut=10 ),

           NOM_CMP         =SIMP(statut='o',typ='TXM',max='**'),           
           
           COEF_IMPO       =SIMP(statut='f',typ='R'),
           COEF_MULT       =SIMP(statut='f',typ='R',max='**'),         

           METHODE         =SIMP(statut='f',typ='TXM',defaut="CONTRAINTE",
                                 into=("CONTRAINTE","GCPC",) ),
           
                 
        ),
#
# CONTACT
#       
         CONTACT         =FACT(statut='f',max='**',
           fr="Définit les zones soumises à des conditions de contact unilatéral avec ou sans frottement",
           regles=(UN_PARMI('GROUP_MA_ESCL','MAILLE_ESCL'),),
           APPARIEMENT     =SIMP(statut='f',typ='TXM',defaut="MAIT_ESCL",
                                 into=("RIGIDE","NODAL","MAIT_ESCL","MAIT_ESCL_SYME")),
           RECHERCHE       =SIMP(statut='f',typ='TXM',defaut="NOEUD_BOUCLE",
                                 into=("NOEUD_BOUCLE","NOEUD_VOISIN")),
           LISSAGE         =SIMP(statut='f',typ='TXM',defaut="NON",
                                 into=("OUI","NON")),
           DIST_POUTRE     =SIMP(statut='f',typ='TXM',defaut="NON", into=("OUI","NON")),
           DIST_COQUE      =SIMP(statut='f',typ='TXM',defaut="NON", into=("OUI","NON")),
           NORMALE         =SIMP(statut='f',typ='TXM',defaut="MAIT",
                                 into=("MAIT","MAIT_ESCL")),
           METHODE         =SIMP(statut='f',typ='TXM',defaut="CONTRAINTE",
                                 into=("VERIF","CONTRAINTE","LAGRANGIEN","PENALISATION","CONTINUE","GCP") ),
           PROJECTION      =SIMP(statut='f',typ='TXM',defaut="LINEAIRE",
                                 into=("LINEAIRE","QUADRATIQUE") ),
           GROUP_MA_MAIT   =SIMP(statut='f',typ=grma ,validators=NoRepeat(),max='**'),
           MAILLE_MAIT     =SIMP(statut='f',typ=ma   ,validators=NoRepeat(),max='**'),
           GROUP_MA_ESCL   =SIMP(statut='f',typ=grma ,validators=NoRepeat(),max='**'),
           MAILLE_ESCL     =SIMP(statut='f',typ=ma   ,validators=NoRepeat(),max='**'), 
                    
           b_cara         =BLOC(condition = "DIST_POUTRE == 'OUI' or DIST_COQUE == 'OUI'",
               CARA_ELEM       =SIMP(statut='o',typ=(cara_elem) ),
           ),
         
           b_verif         =BLOC(condition = "METHODE == 'VERIF' ",
                                 fr="Paramètres de la méthode sans calcul de contact",
                STOP_INTERP     =SIMP(statut='f',typ='TXM',defaut="NON",
                                      into=("OUI","NON")),
                TOLE_INTERP     =SIMP(statut='f',typ='R',defaut = 0.),
                DIST_MAIT       =SIMP(statut='f',typ='R'),
                DIST_ESCL       =SIMP(statut='f',typ='R'),
                VECT_NORM_ESCL  =SIMP(statut='f',typ='R',max=3),
                VECT_ORIE_POU   =SIMP(statut='f',typ='R',min=3,max=3),
           ),

           b_active        =BLOC(condition = "METHODE == 'CONTRAINTE' ",
                                 fr="Paramètres de la méthode des contraintes actives (contact uniquement)",
                GLISSIERE       =SIMP(statut='f',typ='TXM',defaut="NON",
                                      into=("OUI","NON")),
                b_glissiere     =BLOC(condition = "GLISSIERE == 'OUI' ",                    
                      ALARME_JEU  =SIMP(statut='f',typ='R',defaut=0.),
                                 ),
                TOLE_PROJ_EXT   =SIMP(statut='f',typ='R'  ,defaut=0.50),
                TOLE_PROJ_INT   =SIMP(statut='f',typ='R'  ,defaut=0.001),
                STOP_SINGULIER  =SIMP(statut='f',typ='TXM',defaut="OUI",
                                      into=("OUI","NON")),
                NB_RESOL        =SIMP(statut='f',typ='I', defaut=10 ),
                REAC_GEOM       =SIMP(statut='f',typ='TXM',defaut="AUTOMATIQUE",
                        into=("AUTOMATIQUE","CONTROLE","SANS")),
                b_reac_sans     =BLOC(condition = "REAC_GEOM == 'SANS' ",
                                 fr="Paramètre de la réactualisation géométrique",
                                 ),
                b_reac_geom     =BLOC(condition = "REAC_GEOM == 'CONTROLE' ",
                                 fr="Paramètre de la réactualisation géométrique",
                      NB_REAC_GEOM   =SIMP(statut='o',typ='I'),

                                 ),
                b_reac_auto     =BLOC(condition = "REAC_GEOM == 'AUTOMATIQUE' ",
                      fr="Paramètre de la réactualisation géométrique auto",
                                 ), 
                SANS_NOEUD      =SIMP(statut='f',typ=no  ,validators=NoRepeat(),max='**'),
                SANS_GROUP_NO   =SIMP(statut='f',typ=grno,validators=NoRepeat(),max='**'),
                SANS_NOEUD_QUAD =SIMP(statut='f',typ='TXM',defaut="OUI",into=("OUI","NON")),
                VECT_NORM_ESCL  =SIMP(statut='f',typ='R',max=3),
                VECT_ORIE_POU   =SIMP(statut='f',typ='R',min=3,max=3),
                DIST_MAIT       =SIMP(statut='f',typ='R'),
                DIST_ESCL       =SIMP(statut='f',typ='R'),

           ),
           b_lagrangien    =BLOC(condition = "METHODE == 'LAGRANGIEN' ",
                                 fr="Paramètres de la méthode Lagrangienne (contact avec ou sans frottement)",
                FROTTEMENT      =SIMP(statut='f',typ='TXM',defaut="SANS",into=("SANS","COULOMB",) ),
                TOLE_PROJ_EXT   =SIMP(statut='f',typ='R'  ,defaut=0.50),
                TOLE_PROJ_INT   =SIMP(statut='f',typ='R'  ,defaut=0.001),
                STOP_SINGULIER  =SIMP(statut='f',typ='TXM',defaut="OUI",
                                      into=("OUI","NON")),
                NB_RESOL        =SIMP(statut='f',typ='I', defaut=10 ),
                ITER_MULT_MAXI  =SIMP(statut='f',typ='I'  ,defaut=4),

                REAC_GEOM       =SIMP(statut='f',typ='TXM',defaut="AUTOMATIQUE",
                                      into=("AUTOMATIQUE","CONTROLE","SANS")),
                b_reac_sans     =BLOC(condition = "REAC_GEOM == 'SANS' ",fr="Paramètre de la réactualisation géométrique",
                                 ),
                b_reac_geom     =BLOC(condition = "REAC_GEOM == 'CONTROLE' ",fr="Paramètre de la réactualisation géométrique",
                      NB_REAC_GEOM   =SIMP(statut='o',typ='I'),

                                 ),
                b_reac_auto     =BLOC(condition = "REAC_GEOM == 'AUTOMATIQUE' ",
                      fr="Paramètre de la réactualisation géométrique auto",
                                  ), 

               
                SANS_NOEUD      =SIMP(statut='f',typ=no  ,validators=NoRepeat(),max='**'),
                SANS_GROUP_NO   =SIMP(statut='f',typ=grno,validators=NoRepeat(),max='**'),
                SANS_NOEUD_QUAD =SIMP(statut='f',typ='TXM',defaut="NON",into=("OUI","NON")),
                DIST_MAIT       =SIMP(statut='f',typ='R'),
                DIST_ESCL       =SIMP(statut='f',typ='R'),
                
                regles=(EXCLUS('VECT_Y','VECT_ORIE_POU')),
                
                VECT_Y          =SIMP(statut='f',typ='R',min=3,max=3),
                VECT_ORIE_POU   =SIMP(statut='f',typ='R',min=3,max=3),
                b_frottement    =BLOC(condition = "FROTTEMENT == 'COULOMB' ",fr="Paramètres du frottement de Coulomb",
                     COULOMB         =SIMP(statut='o',typ='R',),
                     COEF_MATR_FROT  =SIMP(statut='f',typ='R',defaut=0.E+0),
                     ),),
           
           b_penalisation       =BLOC(condition = "METHODE == 'PENALISATION' ",
                                      fr="Paramètres de la méthode pénalisée (contact avec ou sans frottement)",
                E_N             =SIMP(statut='f',typ='R'),
                FROTTEMENT      =SIMP(statut='f',typ='TXM',defaut="SANS",into=("SANS","COULOMB",) ),
                TOLE_PROJ_EXT   =SIMP(statut='f',typ='R'  ,defaut=0.50),
                TOLE_PROJ_INT   =SIMP(statut='f',typ='R'  ,defaut=0.001),
                STOP_SINGULIER  =SIMP(statut='f',typ='TXM',defaut="OUI",
                                      into=("OUI","NON")),
                NB_RESOL        =SIMP(statut='f',typ='I', defaut=10 ),
                ITER_MULT_MAXI  =SIMP(statut='f',typ='I',defaut=4),
                
                REAC_GEOM       =SIMP(statut='f',typ='TXM',defaut="AUTOMATIQUE",
                                      into=("AUTOMATIQUE","CONTROLE","SANS")),
                b_reac_sans     =BLOC(condition = "REAC_GEOM == 'SANS' ",fr="Paramètre de la réactualisation géométrique",
                                 ),
                b_reac_geom     =BLOC(condition = "REAC_GEOM == 'CONTROLE' ",fr="Paramètre de la réactualisation géométrique",
                      NB_REAC_GEOM   =SIMP(statut='o',typ='I'),
                                 ),
                b_reac_auto     =BLOC(condition = "REAC_GEOM == 'AUTOMATIQUE' ",
                      fr="Paramètre de la réactualisation géométrique auto",
                                 ), 

                SANS_NOEUD      =SIMP(statut='f',typ=no  ,validators=NoRepeat(),max='**'),
                SANS_GROUP_NO   =SIMP(statut='f',typ=grno,validators=NoRepeat(),max='**'),
                SANS_NOEUD_QUAD =SIMP(statut='f',typ='TXM',defaut="NON",into=("OUI","NON")),
                DIST_MAIT       =SIMP(statut='f',typ='R'),
                DIST_ESCL       =SIMP(statut='f',typ='R'),
                regles=(EXCLUS('VECT_Y','VECT_ORIE_POU')),
                VECT_Y          =SIMP(statut='f',typ='R',min=3,max=3),
                VECT_ORIE_POU   =SIMP(statut='f',typ='R',min=3,max=3),
                
                b_frottement    =BLOC(condition = "FROTTEMENT == 'COULOMB' ",fr="Paramètres du frottement de Coulomb",
                     COULOMB         =SIMP(statut='o',typ='R',),
                     E_T             =SIMP(statut='f',typ='R',
                                           fr="Active la pénalisation sur le frottement et définit le coefficient de pénalisation"),
                     COEF_MATR_FROT  =SIMP(statut='f',typ='R',defaut=0.E+0),
                     ),),

           b_continue      =BLOC(condition = "METHODE == 'CONTINUE' ",
                                 fr="Paramètres de la méthode continue (contact avec ou sans frottement)",
#                regles=(UN_PARMI('GLISSIERE','FROTTEMENT'),),
                GLISSIERE       =SIMP(statut='f',typ='TXM',defaut="NON",
                                      into=("OUI","NON")),
                b_glissiere     =BLOC(condition = "GLISSIERE == 'OUI' ",                    
                      ALARME_JEU  =SIMP(statut='f',typ='R',defaut=0.),
                                 ),
                FROTTEMENT      =SIMP(statut='f',typ='TXM',defaut="SANS",into=("SANS","COULOMB",) ),
                COMPLIANCE      =SIMP(statut='f',typ='TXM',defaut="NON",into=("OUI","NON",) ),
                FOND_FISSURE    =SIMP(statut='f',typ='TXM',defaut="NON",into=("OUI","NON",) ),
                RACCORD_LINE_QUAD=SIMP(statut='f',typ='TXM',defaut="NON",into=("OUI","NON",) ),

                INTEGRATION     =SIMP(statut='f',typ='TXM',defaut="NOEUD",into=("GAUSS","NOEUD","SIMPSON","SIMPSON1","SIMPSON2",
                                                                                                "NCOTES","NCOTES1","NCOTES2")),
                COEF_REGU_CONT  =SIMP(statut='f',typ='R',defaut=100.E+0),
                MODL_AXIS       =SIMP(statut='o',typ='TXM',into=("OUI","NON")),
                FORMULATION     =SIMP(statut='f',typ='TXM',defaut="DEPL",into=("DEPL","VITE")),
                DIRE_APPA       =SIMP(statut='f',typ='R',max=3,defaut=(0.,0.,0.,)),
                ITER_GEOM_MAXI  =SIMP(statut='f',typ='I',defaut=2),
                ITER_CONT_MAXI  =SIMP(statut='f',typ='I',defaut=30),
                DIST_MAIT       =SIMP(statut='f',typ='R',defaut=0.),
                DIST_ESCL       =SIMP(statut='f',typ='R',defaut=0.),
                VECT_ORIE_POU   =SIMP(statut='f',typ='R',min=3,max=3),
                TOLE_PROJ_EXT   =SIMP(statut='f',typ='R'  ,defaut=0.50),
                CONTACT_INIT    =SIMP(statut='f',typ='TXM',defaut="NON",into=("OUI","NON",) ),
                b_FOND_FISSURE  =BLOC(condition = "FOND_FISSURE == 'OUI' ",fr="TRAITEMENT EN FOND DE FISSURE",
                     regles=(UN_PARMI('NOEUD_FOND','GROUP_NO_FOND','MAILLE_FOND','GROUP_MA_FOND'),),
                     NOEUD_FOND      =SIMP(statut='f',typ=no  ,validators=NoRepeat(),max='**'),
                     GROUP_NO_FOND   =SIMP(statut='f',typ=grno,validators=NoRepeat(),max='**'),
                     MAILLE_FOND     =SIMP(statut='f',typ=ma  ,validators=NoRepeat(),max='**'),
                     GROUP_MA_FOND   =SIMP(statut='f',typ=grma,validators=NoRepeat(),max='**'),),
                b_RACCORD_SURF  =BLOC(condition = "RACCORD_LINE_QUAD == 'OUI' ",fr="TRAITEMENT DU RACCORD SURFACIQUE",
                     regles=(UN_PARMI('NOEUD_RACC','GROUP_NO_RACC'),),
                     NOEUD_RACC      =SIMP(statut='f',typ=no  ,validators=NoRepeat(),max='**'),
                     GROUP_NO_RACC   =SIMP(statut='f',typ=grno,validators=NoRepeat(),max='**'),),
 
                b_compliance    =BLOC(condition = "COMPLIANCE == 'OUI' ",fr="Parametres de la compliance",
                     ASPERITE        =SIMP(statut='o',typ='R',),
                     E_N             =SIMP(statut='o',typ='R',),
                     E_V             =SIMP(statut='f',typ='R',defaut=0.E+0),),
                b_frottement    =BLOC(condition = "FROTTEMENT == 'COULOMB' ",fr="Paramètres du frottement de Coulomb",
                     COULOMB         =SIMP(statut='o',typ='R',),
                     SANS_NOEUD      =SIMP(statut='f',typ=no  ,validators=NoRepeat(),max='**'),
                     SANS_GROUP_NO   =SIMP(statut='f',typ=grno,validators=NoRepeat(),max='**'),
                     VECT_Y          =SIMP(statut='f',typ='R',min=3,max=3),
                     VECT_Z          =SIMP(statut='f',typ='R',min=3,max=3),
                     ITER_FROT_MAXI  =SIMP(statut='f',typ='I',defaut=2),
                     COEF_REGU_FROT  =SIMP(statut='f',typ='R',defaut=100.E+0),
                     SEUIL_INIT      =SIMP(statut='f',typ='R',defaut=0.E+0),),),

           b_gcp        =BLOC(condition = "METHODE == 'GCP' ",
                                 fr="Paramètres de la méthode du gradient conjugué projeté (contact uniquement)",
                RESI_ABSO       =SIMP(statut='o',typ='R',
                                      fr="Critère de convergence (niveau d'interpénétration autorisé)"),
                REAC_ITER       =SIMP(statut='f',typ='I',defaut=3, fr="Fréquence de réinitialisation de la conjugaison"),
                TOLE_PROJ_EXT   =SIMP(statut='f',typ='R'  ,defaut=0.50),
                TOLE_PROJ_INT   =SIMP(statut='f',typ='R'  ,defaut=0.001),
                TOLE_REAC_GEOM  =SIMP(statut='f',typ='R'  ,defaut=0.05),
                STOP_SINGULIER  =SIMP(statut='f',typ='TXM',defaut="OUI",
                                      into=("OUI","NON")),
                REAC_GEOM       =SIMP(statut='f',typ='TXM',defaut="AUTOMATIQUE",
                        into=("AUTOMATIQUE","CONTROLE","SANS")),
                b_reac_sans     =BLOC(condition = "REAC_GEOM == 'SANS' ",
                                 fr="Paramètre de la réactualisation géométrique",
                      
                      STOP_REAC_GEOM =SIMP(statut='f',typ='TXM',defaut="NON",
                                           into=("OUI","NON")),
                                 ),
                b_reac_geom     =BLOC(condition = "REAC_GEOM == 'CONTROLE' ",
                                 fr="Paramètre de la réactualisation géométrique",
                      NB_REAC_GEOM   =SIMP(statut='o',typ='I'),
                      
                      STOP_REAC_GEOM =SIMP(statut='f',typ='TXM',defaut="ALARME",
                                           into=("OUI","NON")),
                                 ),
                b_reac_auto     =BLOC(condition = "REAC_GEOM == 'AUTOMATIQUE' ",
                      fr="Paramètre de la réactualisation géométrique auto",
                      NB_REAC_MAXI   =SIMP(statut='o',typ='I',defaut = 10),
                                 ), 
                SANS_NOEUD      =SIMP(statut='f',typ=no  ,validators=NoRepeat(),max='**'),
                SANS_GROUP_NO   =SIMP(statut='f',typ=grno,validators=NoRepeat(),max='**'),
                SANS_NOEUD_QUAD =SIMP(statut='f',typ='TXM',defaut="NON",into=("OUI","NON")),
                VECT_NORM_ESCL  =SIMP(statut='f',typ='R',max=3),
                VECT_ORIE_POU   =SIMP(statut='f',typ='R',min=3,max=3),
                DIST_MAIT       =SIMP(statut='f',typ='R'),
                DIST_ESCL       =SIMP(statut='f',typ='R'),
           ),
         ),

         FORCE_NODALE    =FACT(statut='f',fr="Applique à des noeuds des forces nodales",max='**',
           regles=(AU_MOINS_UN('GROUP_NO','NOEUD'),
                   AU_MOINS_UN('FX','FY','FZ','MX','MY','MZ' ),),
           GROUP_NO        =SIMP(statut='f',typ=grno,validators=NoRepeat(),max='**'),
           NOEUD           =SIMP(statut='f',typ=no  ,validators=NoRepeat(),max='**'),
           FX              =SIMP(statut='f',typ='R' ),
           FY              =SIMP(statut='f',typ='R' ),
           FZ              =SIMP(statut='f',typ='R' ),
           MX              =SIMP(statut='f',typ='R' ),
           MY              =SIMP(statut='f',typ='R' ),
           MZ              =SIMP(statut='f',typ='R' ),
           ANGL_NAUT       =SIMP(statut='f',typ='R',max=3),
         ),

         FORCE_FACE      =FACT(statut='f',max='**',
             fr="Applique des forces surfaciques sur une face d'élément volumique",
             regles=(AU_MOINS_UN('GROUP_MA','MAILLE'),
                     AU_MOINS_UN('FX','FY','FZ'),),
             GROUP_MA        =SIMP(statut='f',typ=grma,validators=NoRepeat(),max='**'),
             MAILLE          =SIMP(statut='f',typ=ma  ,validators=NoRepeat(),max='**'),
             FX              =SIMP(statut='f',typ='R' ),
             FY              =SIMP(statut='f',typ='R' ),
             FZ              =SIMP(statut='f',typ='R' ),
           ),

         FORCE_ARETE     =FACT(statut='f',max='**',
         fr="Applique des forces linéiques à une arete d'élément volumique ou de coque",
             regles=(AU_MOINS_UN('GROUP_MA','MAILLE',),
                     AU_MOINS_UN('FX','FY','FZ','MX','MY','MZ' ),),
             GROUP_MA        =SIMP(statut='f',typ=grma,validators=NoRepeat(),max='**'),
             MAILLE          =SIMP(statut='f',typ=ma  ,validators=NoRepeat(),max='**'),
             FX              =SIMP(statut='f',typ='R' ),
             FY              =SIMP(statut='f',typ='R' ),
             FZ              =SIMP(statut='f',typ='R' ),
             MX              =SIMP(statut='f',typ='R' ),
             MY              =SIMP(statut='f',typ='R' ),
             MZ              =SIMP(statut='f',typ='R' ),
           ),

         FORCE_CONTOUR   =FACT(statut='f',max='**',
             fr="Applique des forces linéiques au bord d'un domaine 2D ou AXIS ou AXIS_FOURIER",
             regles=(AU_MOINS_UN('GROUP_MA','MAILLE'),
                     AU_MOINS_UN('FX','FY','FZ','MX','MY','MZ'),),
             GROUP_MA        =SIMP(statut='f',typ=grma,validators=NoRepeat(),max='**'),
             MAILLE          =SIMP(statut='f',typ=ma  ,validators=NoRepeat(),max='**'),
             FX              =SIMP(statut='f',typ='R' ),
             FY              =SIMP(statut='f',typ='R' ),
             FZ              =SIMP(statut='f',typ='R' ),
             MX              =SIMP(statut='f',typ='R' ),
             MY              =SIMP(statut='f',typ='R' ),
             MZ              =SIMP(statut='f',typ='R' ),
           ),

         FORCE_INTERNE   =FACT(statut='f',max='**',
             fr="Applique des forces volumiques (2D ou 3D) à un domaine volumique",
             regles=(AU_MOINS_UN('TOUT','GROUP_MA','MAILLE'),
                     PRESENT_ABSENT('TOUT','GROUP_MA','MAILLE'),
                     AU_MOINS_UN('FX','FY','FZ' ),),
             TOUT            =SIMP(statut='f',typ='TXM',into=("OUI",) ),
             GROUP_MA        =SIMP(statut='f',typ=grma,validators=NoRepeat(),max='**'),
             MAILLE          =SIMP(statut='f',typ=ma  ,validators=NoRepeat(),max='**'),
             FX              =SIMP(statut='f',typ='R' ),
             FY              =SIMP(statut='f',typ='R' ),
             FZ              =SIMP(statut='f',typ='R' ),
           ),

         PRES_REP        =FACT(statut='f',max='**',
             fr="Applique une pression à un domaine de milieu continu 2D ou 3D, ou à un domaine de coques et tuyaux",
             regles=(AU_MOINS_UN('TOUT','GROUP_MA','MAILLE'),
                     PRESENT_ABSENT('TOUT','GROUP_MA','MAILLE'),
                     AU_MOINS_UN('PRES','CISA_2D' ),),
             TOUT            =SIMP(statut='f',typ='TXM',into=("OUI",) ),
             GROUP_MA        =SIMP(statut='f',typ=grma,validators=NoRepeat(),max='**'),
             MAILLE          =SIMP(statut='f',typ=ma  ,validators=NoRepeat(),max='**'),
             PRES            =SIMP(statut='f',typ='R' ),
             CISA_2D         =SIMP(statut='f',typ='R' ),
           ),

         EFFE_FOND       =FACT(statut='f',max='**',
           fr="Calcul l'effet de fond sur une branche de tuyauterie (modélisation 3D) soumise à une pression",
           regles=(AU_MOINS_UN('GROUP_MA','MAILLE'),),
           GROUP_MA_INT    =SIMP(statut='o',typ=grma,validators=NoRepeat(),max='**'),
           GROUP_MA        =SIMP(statut='f',typ=grma,validators=NoRepeat(),max='**'),
           MAILLE          =SIMP(statut='f',typ=ma  ,validators=NoRepeat(),max='**'),
           PRES            =SIMP(statut='o',typ='R' ),
         ),

         EPSI_INIT       =FACT(statut='f',max='**',
             fr="Applique un chargement de déformation initiale à un élément 2D, 3D ou de structure",
             regles=(AU_MOINS_UN('TOUT','GROUP_MA','MAILLE'),
                     PRESENT_ABSENT('TOUT','GROUP_MA','MAILLE'),
                     AU_MOINS_UN('EPXX','EPYY','EPZZ','EPXY','EPXZ','EPYZ','EPX',
                                 'KY','KZ','EXX','EYY','EXY','KXX','KYY','KXY'),),
             TOUT            =SIMP(statut='f',typ='TXM',into=("OUI",) ),
             GROUP_MA        =SIMP(statut='f',typ=grma,validators=NoRepeat(),max='**'),
             MAILLE          =SIMP(statut='f',typ=ma  ,validators=NoRepeat(),max='**'),
             EPXX            =SIMP(statut='f',typ='R' ),
             EPYY            =SIMP(statut='f',typ='R' ),
             EPZZ            =SIMP(statut='f',typ='R' ),
             EPXY            =SIMP(statut='f',typ='R' ),
             EPXZ            =SIMP(statut='f',typ='R' ),
             EPYZ            =SIMP(statut='f',typ='R' ),
             EPX             =SIMP(statut='f',typ='R' ),
             KY              =SIMP(statut='f',typ='R' ),
             KZ              =SIMP(statut='f',typ='R' ),
             EXX             =SIMP(statut='f',typ='R' ),
             EYY             =SIMP(statut='f',typ='R' ),
             EXY             =SIMP(statut='f',typ='R' ),
             KXX             =SIMP(statut='f',typ='R' ),
             KYY             =SIMP(statut='f',typ='R' ),
             KXY             =SIMP(statut='f',typ='R' ),
           ),

         ARLEQUIN        =FACT(statut='f',min=1,max='**',
           fr="Définit les paramètres de la méthode Arlequin",
           GROUP_MA_1     =SIMP(statut='o',typ=grma,max='**'),
           GROUP_MA_2     =SIMP(statut='o',typ=grma,max='**'),
           GROUP_MA_COLL  =SIMP(statut='f',typ=grma,max='**'),
           CARA_ELEM      =SIMP(statut='f',typ=cara_elem ),
           COND_LIM       =SIMP(statut='f',typ=char_meca ),
           COLLAGE        =SIMP(statut='f',typ='TXM',defaut="GROSSIER",into=("GROSSIER","FIN","GROUP_MA_1","GROUP_MA_2"),),
           regles         =(UN_PARMI('POIDS_1','POIDS_2','POIDS_GROSSIER','POIDS_FIN',),),
           POIDS_1        =SIMP(statut='f',typ='R'),
           POIDS_2        =SIMP(statut='f',typ='R'),
           POIDS_GROSSIER =SIMP(statut='f',typ='R'),
           POIDS_FIN      =SIMP(statut='f',typ='R'),),

        FORCE_POUTRE    =FACT(statut='f',max='**',
             fr="Applique des forces linéiques sur des éléments de type poutre",
             regles=(AU_MOINS_UN('TOUT','GROUP_MA','MAILLE'),
                     PRESENT_ABSENT('TOUT','GROUP_MA','MAILLE'),
                     AU_MOINS_UN('FX','FY','FZ','N','VY','VZ'),
                     PRESENT_ABSENT('FX','N','VY','VZ'),
                     PRESENT_ABSENT('FY','N','VY','VZ'),
                     PRESENT_ABSENT('FZ','N','VY','VZ'),
                     PRESENT_ABSENT('N','FX','FY','FZ'),
                     PRESENT_ABSENT('VY','FX','FY','FZ'),
                     PRESENT_ABSENT('VZ','FX','FY','FZ'),),
             TOUT            =SIMP(statut='f',typ='TXM',into=("OUI",) ),
             GROUP_MA        =SIMP(statut='f',typ=grma,validators=NoRepeat(),max='**'),
             MAILLE          =SIMP(statut='f',typ=ma  ,validators=NoRepeat(),max='**'),
             TYPE_CHARGE     =SIMP(statut='f',typ='TXM',defaut="FORCE",into=("VENT","FORCE",) ),
#  rajour d'un mot clé REPERE :/ LOCAL /GLOBAL
               FX              =SIMP(statut='f',typ='R' ),
               FY              =SIMP(statut='f',typ='R' ),
               FZ              =SIMP(statut='f',typ='R' ),

               N               =SIMP(statut='f',typ='R' ),
               VY              =SIMP(statut='f',typ='R' ),
               VZ              =SIMP(statut='f',typ='R' ),

           ),

         FORCE_TUYAU     =FACT(statut='f',max='**',
             fr="Applique une pression sur des éléments TUYAU",
             regles=(AU_MOINS_UN('TOUT','GROUP_MA','MAILLE'),
                     PRESENT_ABSENT('TOUT','GROUP_MA','MAILLE'),),
             TOUT            =SIMP(statut='f',typ='TXM',into=("OUI",) ),
             GROUP_MA        =SIMP(statut='f',typ=grma,validators=NoRepeat(),max='**'),
             MAILLE          =SIMP(statut='f',typ=ma  ,validators=NoRepeat(),max='**'),
             PRES            =SIMP(statut='f',typ='R' ),
           ),

         FORCE_COQUE     =FACT(statut='f',max='**',
             fr="Applique des forces surfaciques sur des éléments de types coques",
             regles=(AU_MOINS_UN('TOUT','GROUP_MA','MAILLE'),
                     PRESENT_ABSENT('TOUT','GROUP_MA','MAILLE'),
                     AU_MOINS_UN('FX','FY','FZ','MX','MY','MZ','PRES','F1','F2','F3','MF1','MF2'),
                     PRESENT_ABSENT('FX','PRES','F1','F2','F3','MF1','MF2'),
                     PRESENT_ABSENT('FY','PRES','F1','F2','F3','MF1','MF2'),
                     PRESENT_ABSENT('FZ','PRES','F1','F2','F3','MF1','MF2'),
                     PRESENT_ABSENT('MX','PRES','F1','F2','F3','MF1','MF2'),
                     PRESENT_ABSENT('MY','PRES','F1','F2','F3','MF1','MF2'),
                     PRESENT_ABSENT('MZ','PRES','F1','F2','F3','MF1','MF2'),
                     PRESENT_ABSENT('F1','FX','FY','FZ','MX','MY','MZ','PRES'),
                     PRESENT_ABSENT('F2','FX','FY','FZ','MX','MY','MZ','PRES'),
                     PRESENT_ABSENT('F3','FX','FY','FZ','MX','MY','MZ','PRES'),
                     PRESENT_ABSENT('MF1','FX','FY','FZ','MX','MY','MZ','PRES'),
                     PRESENT_ABSENT('MF2','FX','FY','FZ','MX','MY','MZ','PRES'),
                     PRESENT_ABSENT('PRES','FX','FY','FZ','MX','MY','MZ','F1','F2','F3','MF1','MF2'),),
#  rajour d'un mot clé REPERE :/ LOCAL /GLOBAL
             TOUT            =SIMP(statut='f',typ='TXM',into=("OUI",) ),
             GROUP_MA        =SIMP(statut='f',typ=grma,validators=NoRepeat(),max='**'),
             MAILLE          =SIMP(statut='f',typ=ma  ,validators=NoRepeat(),max='**'),

               FX              =SIMP(statut='f',typ='R' ),
               FY              =SIMP(statut='f',typ='R' ),
               FZ              =SIMP(statut='f',typ='R' ),
               MX              =SIMP(statut='f',typ='R' ),
               MY              =SIMP(statut='f',typ='R' ),
               MZ              =SIMP(statut='f',typ='R' ),

               F1              =SIMP(statut='f',typ='R' ),
               F2              =SIMP(statut='f',typ='R' ),
               F3              =SIMP(statut='f',typ='R' ),
               MF1             =SIMP(statut='f',typ='R' ),
               MF2             =SIMP(statut='f',typ='R' ),

             PRES            =SIMP(statut='f',typ='R' ),
             PLAN            =SIMP(statut='f',typ='TXM',defaut="MAIL",into=("SUP","INF","MOY","MAIL",) ),
           ),


           GRAPPE_FLUIDE   =FACT(statut='f',max='**',
             fr="Définit les données de calcul des forces fluides lors des études de chute de grappe",
             regles=(EXCLUS('GROUP_NO_EXTR','NOEUD_EXTR'),
                     EXCLUS('GROUP_NO_ORIG','NOEUD_ORIG'),
                     PRESENT_PRESENT('CARA_HYDR','VALE_HYDR'),
                     PRESENT_PRESENT('CARA_GRAPPE','VALE_GRAPPE'),
                     PRESENT_PRESENT('CARA_COMMANDE','VALE_COMMANDE'),
                     PRESENT_PRESENT('CARA_MANCHETTE','VALE_MANCHETTE'),
                     PRESENT_PRESENT('CARA_GUIDE','VALE_GUIDE'),
                     PRESENT_PRESENT('CARA_ASSEMBLAGE','VALE_ASSEMBLAGE'),
                     PRESENT_PRESENT('CARA_PDC','VALE_PDC'),),
             GROUP_MA        =SIMP(statut='f',typ=grma,max=1),
             GROUP_NO_EXTR   =SIMP(statut='f',typ=grno,max=1),
             NOEUD_EXTR      =SIMP(statut='f',typ=no,max=1),
             GROUP_NO_ORIG   =SIMP(statut='f',typ=grno,max=1),
             NOEUD_ORIG      =SIMP(statut='f',typ=no,max=1),
             Z0              =SIMP(statut='f',typ='R' ),
             CARA_HYDR       =SIMP(statut='f',typ='TXM',validators=NoRepeat(),max='**',
                                 fr="définition des données hydrauliques",
                                 into=("Q","ROC","ROD","ROP","ROM","ROML","ROG","NUC","NUM",
                                       "NUML","NUG","P2","P3","P4","CGG","G") ),
             VALE_HYDR       =SIMP(statut='f',typ='R',max='**',
                                 fr="valeurs des données hydrauliques",),
             CARA_GRAPPE     =SIMP(statut='f',typ='TXM',validators=NoRepeat(),max='**',
                                 fr="définition des données géométriques de la grappe",
                                 into=("M","DTIGE","DTMOY","ROTIGE","LTIGE","LLT","LCT",
                                       "VARAI","RORAI","DCRAY","ROCRAY","LCRAY","LCHUT",
                                       "CFCM","CFCI","CFCG","HRUGC","HRUGTC","NCA") ),
             VALE_GRAPPE     =SIMP(statut='f',typ='R',max='**',
                                 fr="valeurs des données géométriques de la grappe",),
             CARA_COMMANDE   =SIMP(statut='f',typ='TXM',validators=NoRepeat(),max='**',
                                 fr="définition des données géométriques du mécanisme de commande",
                                 into=("LI","LML","LG","LIG","DIML","DEML","DCSP",
                                       "DG","HRUGML","HRUGCSP","HRUGG") ),
             VALE_COMMANDE   =SIMP(statut='f',typ='R',max='**',
                                 fr="valeurs des données géométriques du mécanisme de commande",),
             CARA_MANCHETTE  =SIMP(statut='f',typ='TXM',validators=NoRepeat(),max='**',
                                 fr="définition des données géométriques de la manchette et son adaptateur",
                                 into=("LM","LA","LIM","DIMT","DEMT","DCMT","VMT",
                                       "ROMT","DA","HRUGM","HRUGA") ),
             VALE_MANCHETTE  =SIMP(statut='f',typ='R',max='**',
                                 fr="valeurs des données géométriques de la manchette et son adaptateur",),
             CARA_GUIDE      =SIMP(statut='f',typ='TXM',validators=NoRepeat(),max='**',
                                 fr="définition des données géométriques des tubes guides",
                                 into=("NRET","L0","L1","L2","L3","L4","DTG","DR",
                                       "DOR","D0","D00","HRUGTG") ),
             VALE_GUIDE      =SIMP(statut='f',typ='R',max='**',
                                 fr="valeurs des données géométriques des tubes guides",),
             CARA_ASSEMBLAGE =SIMP(statut='f',typ='TXM',validators=NoRepeat(),max='**',
                                 fr="définition des données géométriques des assemblages",
                                 into=("SASS","DCC","DTI","NGM","NGMDP","KM","KS","KI",
                                       "KES","KEI","KF") ),
             VALE_ASSEMBLAGE =SIMP(statut='f',typ='R',max='**',
                                 fr="valeurs des données géométriques des assemblages",),
             CARA_PDC        =SIMP(statut='f',typ='TXM',validators=NoRepeat(),max='**',
                                 fr="définition des coefficients de perte de charge singulière",
                                 into=("CD0","CD1","CD2","CDELARG","CDRET","CDM","CDA","CDML",
                                       "CDI","CDG") ),
             VALE_PDC        =SIMP(statut='f',typ='R',max='**',
                                 fr="valeurs des coefficients de perte de charge singulière",),
             APPL_FORC_ARCHI  =SIMP(statut='f',typ='TXM',defaut="REPARTIE" ,
                                 fr="application de la force d'archimède",
                                 into=("REPARTIE","CDG") ),
             APPL_FORC_FPLAQ  =SIMP(statut='f',typ='TXM',defaut="REPARTIE" ,
                                 fr="application de la force de plaquage dans le guidage continu",
                                 into=("REPARTIE","CDG","ZONE","MILIEU","DISTRI") ),
             APPL_FORC_FMEC   =SIMP(statut='f',typ='TXM',defaut="REPARTIE" ,
                                 fr="application de la force dans le mécanisme de levée",
                                 into=("REPARTIE","CDG","ZONE","PTREP") ),
             APPL_FORC_FTG    =SIMP(statut='f',typ='TXM',defaut="REPARTIE" ,
                                 fr="application de la force tube_guide",
                                 into=("REPARTIE","CDG","ZONE","PTREP") ),
             DIRE_FORC_FPLAQ  =SIMP(statut='f',typ='R',min=3,max=3,
                                 fr="direction d'application de la force de plaquage",),
             b_CDG    =BLOC(condition = "(APPL_FORC_ARCHI == 'CDG') or (APPL_FORC_FPLAQ == 'CDG') or \
                                         (APPL_FORC_FMEC  == 'CDG') or (APPL_FORC_FTG   == 'CDG')",
                MASS_INER        =SIMP(statut='o',typ=table_sdaster ),
             ),
             UNITE_IMPR_FORCE =SIMP(statut='f',typ='I',
                                 fr="unité d'impression des forces",),
             UNITE_IMPR_NOEUD =SIMP(statut='f',typ='I',
                                 fr="unité d'impression des noeuds par zone",),
           ),

           LIAISON_COQUE   =FACT(statut='f',max='**',
             fr="Permet de représenter le raccord entre des éléments de coques au moyen des relations linéaires",
             GROUP_MA_1      =SIMP(statut='f',typ=grma,validators=NoRepeat(),max='**'),
             MAILLE_1        =SIMP(statut='f',typ=ma  ,validators=NoRepeat(),max='**'),
             GROUP_NO_1      =SIMP(statut='f',typ=grno,validators=NoRepeat(),max='**'),
             NOEUD_1         =SIMP(statut='f',typ=no  ,validators=NoRepeat(),max='**'),
             GROUP_MA_2      =SIMP(statut='f',typ=grma,validators=NoRepeat(),max='**'),
             MAILLE_2        =SIMP(statut='f',typ=ma  ,validators=NoRepeat(),max='**'),
             GROUP_NO_2      =SIMP(statut='f',typ=grno,validators=NoRepeat(),max='**'),
             NOEUD_2         =SIMP(statut='f',typ=no  ,validators=NoRepeat(),max='**'),
             NUME_LAGR       =SIMP(statut='f',typ='TXM',defaut="NORMAL",into=("NORMAL","APRES") ),
           ),

         RELA_CINE_BP    =FACT(statut='f',max='**',
           fr="Etablir des relations cinématiques permettant de relier les noeuds cable aux noeuds du béton, et spécifier"
              +" la prise en compte des contraintes initiales dans les cables",
           CABLE_BP        =SIMP(statut='o',typ=cabl_precont ),
           SIGM_BPEL       =SIMP(statut='f',typ='TXM',defaut="NON",into=("OUI","NON") ),
           RELA_CINE       =SIMP(statut='f',typ='TXM',defaut="OUI",into=("OUI","NON") ),
         ),

         FORCE_ELEC      =FACT(statut='f',max='**',
             fr="Appliquer la force de LAPLACE agissant sur un conducteur principal, due à la présence d'un conducteur"
                 +" secondaire droit",
             regles=(AU_MOINS_UN('TOUT','GROUP_MA','MAILLE'),
                     PRESENT_ABSENT('TOUT','GROUP_MA','MAILLE'),),

             TOUT            =SIMP(statut='f',typ='TXM',into=("OUI",) ),
             GROUP_MA        =SIMP(statut='f',typ=grma,validators=NoRepeat(),max='**'),
             MAILLE          =SIMP(statut='f',typ=ma  ,validators=NoRepeat(),max='**'),

             POSITION        =SIMP(statut='f',typ='TXM',fr="Direction prédéfinie",into=("PARA","INFI","FINI",) ),
             b_fxyz  =BLOC ( condition = "POSITION == None",
                  FX   =SIMP(statut='f',typ='R',defaut= 0.E+0 ),
                  FY   =SIMP(statut='f',typ='R',defaut= 0.E+0 ),
                  FZ   =SIMP(statut='f',typ='R',defaut= 0.E+0 ),
                       ),

             b_para     =BLOC ( condition = "POSITION == 'PARA'",
               regles=(UN_PARMI('TRANS','DIST'),),
               TRANS           =SIMP(statut='f',typ='R',max=3),
               DIST            =SIMP(statut='f',typ='R' ),
               b_point2        =BLOC ( condition = "DIST != None",
                 POINT2           =SIMP(statut='o',typ='R',max=3),
               ),
             ),
             b_fini_infi     =BLOC ( condition = "(POSITION == 'FINI') or (POSITION == 'INFI')",
               POINT1          =SIMP(statut='o',typ='R',max=3),
               POINT2          =SIMP(statut='o',typ='R',max=3),
             ),
           ),




        INTE_ELEC       =FACT(statut='f',max='**',
             fr="Appliquer la force de LAPLACE agissant sur un conducteur principal, due à la présence d'un conducteur"
               +" secondaire non nécessairement droit",
             regles=(AU_MOINS_UN('TOUT','GROUP_MA','MAILLE'),
                     PRESENT_ABSENT('TOUT','GROUP_MA','MAILLE'),
                     AU_MOINS_UN('GROUP_MA_2','MAILLE_2','TRANS','SYME'),
                     EXCLUS('TRANS','SYME'),),
             TOUT            =SIMP(statut='f',typ='TXM',into=("OUI",) ),
             GROUP_MA        =SIMP(statut='f',typ=grma,validators=NoRepeat(),max='**'),
             MAILLE          =SIMP(statut='f',typ=ma  ,validators=NoRepeat(),max='**'),
             GROUP_MA_2      =SIMP(statut='f',typ=grma,validators=NoRepeat(),max='**'),
             MAILLE_2        =SIMP(statut='f',typ=ma  ,validators=NoRepeat(),max='**'),
             TRANS           =SIMP(statut='f',typ='R' ,max='**'),
             SYME            =SIMP(statut='f',typ='R' ,max='**'),
           ),


         IMPE_FACE       =FACT(statut='f',fr="Applique une impédance acoustique à une face",max='**',
             regles=(AU_MOINS_UN('GROUP_MA','MAILLE' ),),
             GROUP_MA        =SIMP(statut='f',typ=grma,validators=NoRepeat(),max='**'),
             MAILLE          =SIMP(statut='f',typ=ma  ,validators=NoRepeat(),max='**'),
             IMPE            =SIMP(statut='o',typ='R' ),
           ),

         VITE_FACE       =FACT(statut='f',fr="Impose des vitesses normales à une face (phénomène ACOUSTIQUE), ",max='**',
             regles=(AU_MOINS_UN('GROUP_MA','MAILLE'),),
             GROUP_MA        =SIMP(statut='f',typ=grma,validators=NoRepeat(),max='**'),
             MAILLE          =SIMP(statut='f',typ=ma  ,validators=NoRepeat(),max='**'),
             VNOR            =SIMP(statut='o',typ='R' ),
           ),



         ONDE_FLUI       =FACT(statut='f',max='**',
             fr="Applique une amplitude de pression d'onde incidente sinusoidale arrivant normalement à une face",
             regles=(AU_MOINS_UN('GROUP_MA','MAILLE'),),
             GROUP_MA        =SIMP(statut='f',typ=grma,validators=NoRepeat(),max='**'),
             MAILLE          =SIMP(statut='f',typ=ma  ,validators=NoRepeat(),max='**'),
             PRES            =SIMP(statut='o',typ='R' ),
           ),

         FLUX_THM_REP    =FACT(statut='f',max='**',
             fr="Applique à un domaine de milieu continu 2D ou 3D un flux de chaleur et/ou un apport de masse fluide"
                 +" (flux hydraulique)",
             regles=(AU_MOINS_UN('TOUT','GROUP_MA','MAILLE'),
                     PRESENT_ABSENT('TOUT','GROUP_MA','MAILLE'),
                     AU_MOINS_UN('FLUN','FLUN_HYDR1','FLUN_HYDR2'),),
             TOUT            =SIMP(statut='f',typ='TXM',into=("OUI",) ),
             GROUP_MA        =SIMP(statut='f',typ=grma,validators=NoRepeat(),max='**'),
             MAILLE          =SIMP(statut='f',typ=ma  ,validators=NoRepeat(),max='**'),
             FLUN            =SIMP(statut='f',typ='R' ),
             FLUN_HYDR1      =SIMP(statut='f',typ='R' ),
             FLUN_HYDR2      =SIMP(statut='f',typ='R' ),
           ),

         INFO            =SIMP(statut='f',typ='I',defaut= 1,into=( 1 , 2) ),
)  ;


#& MODIF COMMANDE  DATE 24/08/2005   AUTEUR MABBAS M.ABBAS 
#            CONFIGURATION MANAGEMENT OF EDF VERSION
# ======================================================================
# COPYRIGHT (C) 1991 - 2001  EDF R&D                  WWW.CODE-ASTER.ORG
# THIS PROGRAM IS FREE SOFTWARE; YOU CAN REDISTRIBUTE IT AND/OR MODIFY
# IT UNDER THE TERMS OF THE GNU GENERAL PUBLIC LICENSE AS PUBLISHED BY
# THE FREE SOFTWARE FOUNDATION; EITHER VERSION 2 OF THE LICENSE, OR   
# (AT YOUR OPTION) ANY LATER VERSION.                                 
#
# THIS PROGRAM IS DISTRIBUTED IN THE HOPE THAT IT WILL BE USEFUL, BUT 
# WITHOUT ANY WARRANTY; WITHOUT EVEN THE IMPLIED WARRANTY OF          
# MERCHANTABILITY OR FITNESS FOR A PARTICULAR PURPOSE. SEE THE GNU    
# GENERAL PUBLIC LICENSE FOR MORE DETAILS.                            
#
# YOU SHOULD HAVE RECEIVED A COPY OF THE GNU GENERAL PUBLIC LICENSE   
# ALONG WITH THIS PROGRAM; IF NOT, WRITE TO EDF R&D CODE_ASTER,       
#    1 AVENUE DU GENERAL DE GAULLE, 92141 CLAMART CEDEX, FRANCE.      
# ======================================================================
# RESPONSABLE G8BHHXD X.DESROCHES
AFFE_CHAR_MECA_C=OPER(nom="AFFE_CHAR_MECA_C",op=   7,sd_prod=char_meca,
                     fr="Affectation de charges et conditions aux limites mécaniques complexes",
                     reentrant='n',
            UIinfo={"groupes":("Modélisation",)},
         regles=(AU_MOINS_UN('DDL_IMPO','FORCE_POUTRE','LIAISON_DDL', ),),
         MODELE          =SIMP(statut='o',typ=modele_sdaster ),
         VERI_DDL        =SIMP(statut='f',typ='TXM',defaut="OUI",into=("OUI","NON") ),
         DDL_IMPO        =FACT(statut='f',max='**',
           fr="Impose à des noeuds une ou plusieurs valeurs de déplacement (ou de certaines grandeurs asscociées)",
           regles=(AU_MOINS_UN('TOUT','GROUP_MA','MAILLE','GROUP_NO','NOEUD',),
                   AU_MOINS_UN('DX','DY','DZ','DRX','DRY','DRZ','GRX','PRES','PHI','LIAISON', ),),
           TOUT            =SIMP(statut='f',typ='TXM',into=("OUI",) ),
           GROUP_MA        =SIMP(statut='f',typ=grma,validators=NoRepeat(),max='**'),
           MAILLE          =SIMP(statut='f',typ=ma  ,validators=NoRepeat(),max='**'),
           GROUP_NO        =SIMP(statut='f',typ=grno,validators=NoRepeat(),max='**'),
           NOEUD           =SIMP(statut='f',typ=no  ,validators=NoRepeat(),max='**'),
           LIAISON         =SIMP(statut='f',typ='TXM',into=('ENCASTRE',)), 
           DX              =SIMP(statut='f',typ='C' ),
           DY              =SIMP(statut='f',typ='C' ),
           DZ              =SIMP(statut='f',typ='C' ),
           DRX             =SIMP(statut='f',typ='C' ),
           DRY             =SIMP(statut='f',typ='C' ),
           DRZ             =SIMP(statut='f',typ='C' ),
           GRX             =SIMP(statut='f',typ='C' ),
           PRES            =SIMP(statut='f',typ='C' ),
           PHI             =SIMP(statut='f',typ='C' ),
         ),
         FORCE_POUTRE    =FACT(statut='f',max='**',
           fr="Applique des forces linéiques sur des éléments de type poutre",
           regles=(AU_MOINS_UN('TOUT','GROUP_MA','MAILLE'),
                   PRESENT_ABSENT('TOUT','GROUP_MA','MAILLE'),
                   AU_MOINS_UN('FX','FY','FZ','N','VY','VZ',),
                   PRESENT_ABSENT('FX','N','VY','VZ',),
                   PRESENT_ABSENT('FY','N','VY','VZ',),
                   PRESENT_ABSENT('FZ','N','VY','VZ',),
                   PRESENT_ABSENT('N','FX','FY','FZ',),
                   PRESENT_ABSENT('VY', 'FX','FY','FZ',),
                   PRESENT_ABSENT('VZ','FX','FY','FZ', ),),
           TOUT            =SIMP(statut='f',typ='TXM',into=("OUI",) ),
           GROUP_MA        =SIMP(statut='f',typ=grma,validators=NoRepeat(),max='**'),
           MAILLE          =SIMP(statut='f',typ=ma  ,validators=NoRepeat(),max='**'),
           TYPE_CHARGE     =SIMP(statut='f',typ='TXM',defaut="FORCE",into=("VENT","FORCE") ),
           FX              =SIMP(statut='f',typ='C' ),
           FY              =SIMP(statut='f',typ='C' ),
           FZ              =SIMP(statut='f',typ='C' ),
           N               =SIMP(statut='f',typ='C' ),
           VY              =SIMP(statut='f',typ='C' ),
           VZ              =SIMP(statut='f',typ='C' ),
         ),
         LIAISON_DDL     =FACT(statut='f',max='**',
           fr="Définit une relation linéaire entre les DDLs de deux ou plusieurs noeuds",
           regles=(UN_PARMI('GROUP_NO','NOEUD', ),),
           GROUP_NO        =SIMP(statut='f',typ=grno,max='**'),
           NOEUD           =SIMP(statut='f',typ=no  ,max='**'),
           DDL             =SIMP(statut='o',typ='TXM',max='**'),
           COEF_MULT       =SIMP(statut='o',typ='R'  ,max='**'),
           COEF_IMPO       =SIMP(statut='o',typ='C' ),
         ),
         INFO            =SIMP(statut='f',typ='I',defaut= 1,into=( 1 , 2) ),
)  ;
#& MODIF COMMANDE  DATE 14/11/2006   AUTEUR TARDIEU N.TARDIEU 
#            CONFIGURATION MANAGEMENT OF EDF VERSION
# ======================================================================
# COPYRIGHT (C) 1991 - 2001  EDF R&D                  WWW.CODE-ASTER.ORG
# THIS PROGRAM IS FREE SOFTWARE; YOU CAN REDISTRIBUTE IT AND/OR MODIFY
# IT UNDER THE TERMS OF THE GNU GENERAL PUBLIC LICENSE AS PUBLISHED BY
# THE FREE SOFTWARE FOUNDATION; EITHER VERSION 2 OF THE LICENSE, OR   
# (AT YOUR OPTION) ANY LATER VERSION.                                 
#
# THIS PROGRAM IS DISTRIBUTED IN THE HOPE THAT IT WILL BE USEFUL, BUT 
# WITHOUT ANY WARRANTY; WITHOUT EVEN THE IMPLIED WARRANTY OF          
# MERCHANTABILITY OR FITNESS FOR A PARTICULAR PURPOSE. SEE THE GNU    
# GENERAL PUBLIC LICENSE FOR MORE DETAILS.                            
#
# YOU SHOULD HAVE RECEIVED A COPY OF THE GNU GENERAL PUBLIC LICENSE   
# ALONG WITH THIS PROGRAM; IF NOT, WRITE TO EDF R&D CODE_ASTER,       
#    1 AVENUE DU GENERAL DE GAULLE, 92141 CLAMART CEDEX, FRANCE.      
# ======================================================================
# RESPONSABLE G8BHHXD X.DESROCHES
AFFE_CHAR_MECA_F=OPER(nom="AFFE_CHAR_MECA_F",op=7,sd_prod=char_meca,
                      fr="Affectation de charges et conditions aux limites mécaniques fonction d'un (ou plusieurs) paramètres",
                      reentrant='n',
            UIinfo={"groupes":("Modélisation",)},
        regles=(AU_MOINS_UN('DDL_IMPO','FACE_IMPO','LIAISON_DDL','FORCE_NODALE',
                            'FORCE_FACE','FORCE_ARETE','FORCE_CONTOUR','FORCE_INTERNE',
                            'PRES_REP','FORCE_POUTRE','VITE_FACE','IMPE_FACE','ONDE_PLANE',
                            'LIAISON_OBLIQUE','EPSI_INIT','LIAISON_GROUP','LIAISON_UNIF',
                            'LIAISON_SOLIDE','FORCE_COQUE','LIAISON_COQUE','FORCE_TUYAU',
                           
'CONTACT','EFFE_FOND','FLUX_THM_REP','LIAISON_UNILATER'),),
         VERI_DDL        =SIMP(statut='f',typ='TXM',defaut="OUI",into=("OUI","NON") ),
         VERI_NORM       =SIMP(statut='f',typ='TXM',defaut="OUI",into=("OUI","NON") ),
         MODELE          =SIMP(statut='o',typ=modele_sdaster),

         DDL_IMPO        =FACT(statut='f',max='**',
           fr="Impose à des noeuds une ou plusieurs valeurs de déplacement (ou de certaines grandeurs asscociées) fournies"
               +" par l'intermédiaire d'un concept fonction ",
           regles=(AU_MOINS_UN('TOUT','GROUP_MA','MAILLE','GROUP_NO','NOEUD'),
                   AU_MOINS_UN('DX','DY','DZ','DRX','DRY','DRZ','GRX','PRES','PHI',
                               'TEMP','PRE1','PRE2','LIAISON','DCX','DCY','DCZ','H1X',
                               'H1Y','H1Z','E1X','E1Y','E1Z','E2X','E2Y','E2Z',
                               'E3X','E3Y','E3Z','E4X','E4Y','E4Z','LAGS_C'),),
           TOUT            =SIMP(statut='f',typ='TXM',into=("OUI",) ),
           GROUP_MA        =SIMP(statut='f',typ=grma,validators=NoRepeat(),max='**'),
           MAILLE          =SIMP(statut='f',typ=ma  ,validators=NoRepeat(),max='**'),
           GROUP_NO        =SIMP(statut='f',typ=grno,validators=NoRepeat(),max='**'),
           NOEUD           =SIMP(statut='f',typ=no  ,validators=NoRepeat(),max='**'),
           LIAISON         =SIMP(statut='f',typ='TXM',into=('ENCASTRE',)), 
           DX              =SIMP(statut='f',typ=(fonction_sdaster,nappe_sdaster,formule) ),
           DY              =SIMP(statut='f',typ=(fonction_sdaster,nappe_sdaster,formule) ),
           DZ              =SIMP(statut='f',typ=(fonction_sdaster,nappe_sdaster,formule) ),
           DRX             =SIMP(statut='f',typ=(fonction_sdaster,nappe_sdaster,formule) ),
           DRY             =SIMP(statut='f',typ=(fonction_sdaster,nappe_sdaster,formule) ),
           DRZ             =SIMP(statut='f',typ=(fonction_sdaster,nappe_sdaster,formule) ),
           GRX             =SIMP(statut='f',typ=(fonction_sdaster,nappe_sdaster,formule) ),
           PRES            =SIMP(statut='f',typ=(fonction_sdaster,nappe_sdaster,formule) ),
           PHI             =SIMP(statut='f',typ=(fonction_sdaster,nappe_sdaster,formule) ),
           TEMP            =SIMP(statut='f',typ=(fonction_sdaster,nappe_sdaster,formule) ),
           PRE1            =SIMP(statut='f',typ=(fonction_sdaster,nappe_sdaster,formule) ),
           PRE2            =SIMP(statut='f',typ=(fonction_sdaster,nappe_sdaster,formule) ),
           DCX             =SIMP(statut='f',typ=(fonction_sdaster,nappe_sdaster,formule) ),
           DCY             =SIMP(statut='f',typ=(fonction_sdaster,nappe_sdaster,formule) ),
           DCZ             =SIMP(statut='f',typ=(fonction_sdaster,nappe_sdaster,formule) ),
           H1X             =SIMP(statut='f',typ=(fonction_sdaster,nappe_sdaster,formule) ),
           H1Y             =SIMP(statut='f',typ=(fonction_sdaster,nappe_sdaster,formule) ),
           H1Z             =SIMP(statut='f',typ=(fonction_sdaster,nappe_sdaster,formule) ),                  
           E1X             =SIMP(statut='f',typ=(fonction_sdaster,nappe_sdaster,formule) ),
           E1Y             =SIMP(statut='f',typ=(fonction_sdaster,nappe_sdaster,formule) ),
           E1Z             =SIMP(statut='f',typ=(fonction_sdaster,nappe_sdaster,formule) ),      
           E2X             =SIMP(statut='f',typ=(fonction_sdaster,nappe_sdaster,formule) ),
           E2Y             =SIMP(statut='f',typ=(fonction_sdaster,nappe_sdaster,formule) ),
           E2Z             =SIMP(statut='f',typ=(fonction_sdaster,nappe_sdaster,formule) ),      
           E3X             =SIMP(statut='f',typ=(fonction_sdaster,nappe_sdaster,formule) ),
           E3Y             =SIMP(statut='f',typ=(fonction_sdaster,nappe_sdaster,formule) ),
           E3Z             =SIMP(statut='f',typ=(fonction_sdaster,nappe_sdaster,formule) ),      
           E4X             =SIMP(statut='f',typ=(fonction_sdaster,nappe_sdaster,formule) ),
           E4Y             =SIMP(statut='f',typ=(fonction_sdaster,nappe_sdaster,formule) ),
           E4Z             =SIMP(statut='f',typ=(fonction_sdaster,nappe_sdaster,formule) ),      
           LAGS_C          =SIMP(statut='f',typ=(fonction_sdaster,nappe_sdaster,formule) ),     
         ),

         FACE_IMPO       =FACT(statut='f',max='**',
           fr="Impose à tous les noeuds d'une face une ou plusieurs valeurs de déplacement (ou de certaines grandeurs associées)"
              +" fournies par l'intérmédiaire d'un concept fonction",
           regles=(UN_PARMI('GROUP_MA','MAILLE'),
                   AU_MOINS_UN('DX','DY','DZ','DRX','DRY','DRZ','GRX','PRES','PHI','TEMP','PRE1','PRE2','DNOR','DTAN'),
                   EXCLUS('DNOR','DX'),
                   EXCLUS('DNOR','DY'),
                   EXCLUS('DNOR','DZ'),
                   EXCLUS('DNOR','DRX'),
                   EXCLUS('DNOR','DRY'),
                   EXCLUS('DNOR','DRZ'),
                   EXCLUS('DTAN','DX'),
                   EXCLUS('DTAN','DY'),
                   EXCLUS('DTAN','DZ'),
                   EXCLUS('DTAN','DRX'),
                   EXCLUS('DTAN','DRY'),
                   EXCLUS('DTAN','DRZ'),),
#  rajout d un mot cle REPERE : / GLOBAL / LOCAL
           GROUP_MA        =SIMP(statut='f',typ=grma,validators=NoRepeat(),max='**'),
           MAILLE          =SIMP(statut='f',typ=ma  ,validators=NoRepeat(),max='**'),
           SANS_GROUP_MA   =SIMP(statut='f',typ=grma,validators=NoRepeat(),max='**'),
           SANS_MAILLE     =SIMP(statut='f',typ=ma  ,validators=NoRepeat(),max='**'),
           DX              =SIMP(statut='f',typ=(fonction_sdaster,nappe_sdaster,formule) ),
           DY              =SIMP(statut='f',typ=(fonction_sdaster,nappe_sdaster,formule) ),
           DZ              =SIMP(statut='f',typ=(fonction_sdaster,nappe_sdaster,formule) ),
           DRX             =SIMP(statut='f',typ=(fonction_sdaster,nappe_sdaster,formule) ),
           DRY             =SIMP(statut='f',typ=(fonction_sdaster,nappe_sdaster,formule) ),
           DRZ             =SIMP(statut='f',typ=(fonction_sdaster,nappe_sdaster,formule) ),
           GRX             =SIMP(statut='f',typ=(fonction_sdaster,nappe_sdaster,formule) ),
           PRES            =SIMP(statut='f',typ=(fonction_sdaster,nappe_sdaster,formule) ),
           PHI             =SIMP(statut='f',typ=(fonction_sdaster,nappe_sdaster,formule) ),
           TEMP            =SIMP(statut='f',typ=(fonction_sdaster,nappe_sdaster,formule) ),
           PRE1            =SIMP(statut='f',typ=(fonction_sdaster,nappe_sdaster,formule) ),
           PRE2            =SIMP(statut='f',typ=(fonction_sdaster,nappe_sdaster,formule) ),
           DNOR            =SIMP(statut='f',typ=(fonction_sdaster,nappe_sdaster,formule) ),
           DTAN            =SIMP(statut='f',typ=(fonction_sdaster,nappe_sdaster,formule) ),
         ),
         
         LIAISON_DDL     =FACT(statut='f',max='**',
           fr="Définit une relation linéaire entre des DDLs de deux ou plusieurs noeuds, les valeurs sont fournies par"
               +" l'intermediaire d'un concept de type fonction",
           regles=(UN_PARMI('GROUP_NO','NOEUD'),UN_PARMI('COEF_MULT','COEF_MULT_FONC'),),
           GROUP_NO        =SIMP(statut='f',typ=grno,max='**'),
           NOEUD           =SIMP(statut='f',typ=no  ,max='**'),
           DDL             =SIMP(statut='o',typ='TXM',max='**'),
           COEF_MULT       =SIMP(statut='f',typ='R',max='**'),
           COEF_MULT_FONC  =SIMP(statut='f',typ=(fonction_sdaster,nappe_sdaster,formule),max='**'),
           COEF_IMPO       =SIMP(statut='o',typ=(fonction_sdaster,nappe_sdaster,formule) ),
         ),

         LIAISON_OBLIQUE =FACT(statut='f',max='**',
           fr="Applique à des noeuds la meme valeur de déplacement définie composante par composante dans un repère oblique"
              +" quelconque, les valeurs sont fournis par l'intermédiaire d'un concept fonction",
           regles=(UN_PARMI('GROUP_NO','NOEUD'),
                   UN_PARMI('DX','DY','DZ','DRX','DRY','DRZ'),),
           GROUP_NO        =SIMP(statut='f',typ=grno,max='**'),
           NOEUD           =SIMP(statut='f',typ=no  ,max='**'),
           ANGL_NAUT       =SIMP(statut='o',typ='R',max=3),
           DX              =SIMP(statut='f',typ=(fonction_sdaster,nappe_sdaster,formule) ),
           DY              =SIMP(statut='f',typ=(fonction_sdaster,nappe_sdaster,formule) ),
           DZ              =SIMP(statut='f',typ=(fonction_sdaster,nappe_sdaster,formule) ),
           DRX             =SIMP(statut='f',typ=(fonction_sdaster,nappe_sdaster,formule) ),
           DRY             =SIMP(statut='f',typ=(fonction_sdaster,nappe_sdaster,formule) ),
           DRZ             =SIMP(statut='f',typ=(fonction_sdaster,nappe_sdaster,formule) ),
         ),         
         
         LIAISON_GROUP   =FACT(statut='f',max='**',
           fr="Définit la meme relation linéaire entre certains DDLs de couples de noeuds, les valeurs sont fournies par"
               +" l'intermédiaire de concept fonction",
           regles=(UN_PARMI('GROUP_MA_1','MAILLE_1','GROUP_NO_1','NOEUD_1'),
                   UN_PARMI('GROUP_MA_2','MAILLE_2','GROUP_NO_2','NOEUD_2'),
                   EXCLUS('GROUP_MA_1','GROUP_NO_2'),
                   EXCLUS('GROUP_MA_1','NOEUD_2'),
                   EXCLUS('GROUP_NO_1','GROUP_MA_2'),
                   EXCLUS('GROUP_NO_1','MAILLE_2'),
                   EXCLUS('MAILLE_1','GROUP_NO_2'),
                   EXCLUS('MAILLE_1','NOEUD_2'),
                   EXCLUS('NOEUD_1','GROUP_MA_2'),
                   EXCLUS('NOEUD_1','MAILLE_2'),
                   EXCLUS('SANS_NOEUD','SANS_GROUP_NO'),),
           GROUP_MA_1      =SIMP(statut='f',typ=grma,validators=NoRepeat(),max='**'),
           MAILLE_1        =SIMP(statut='f',typ=ma  ,validators=NoRepeat(),max='**'),
           GROUP_NO_1      =SIMP(statut='f',typ=grno,validators=NoRepeat(),max='**'),
           NOEUD_1         =SIMP(statut='f',typ=no  ,validators=NoRepeat(),max='**'),
           GROUP_MA_2      =SIMP(statut='f',typ=grma,validators=NoRepeat(),max='**'),
           MAILLE_2        =SIMP(statut='f',typ=ma  ,validators=NoRepeat(),max='**'),
           GROUP_NO_2      =SIMP(statut='f',typ=grno,validators=NoRepeat(),max='**'),
           NOEUD_2         =SIMP(statut='f',typ=no  ,validators=NoRepeat(),max='**'),
           SANS_NOEUD      =SIMP(statut='f',typ=no  ,validators=NoRepeat(),max='**'),
           SANS_GROUP_NO   =SIMP(statut='f',typ=grno,validators=NoRepeat(),max='**'),
           DDL_1           =SIMP(statut='o',typ='TXM',max='**'),
           COEF_MULT_1     =SIMP(statut='o',typ='R',max='**'),
           DDL_2           =SIMP(statut='o',typ='TXM',max='**'),
           COEF_MULT_2     =SIMP(statut='o',typ='R',max='**'),
           COEF_IMPO       =SIMP(statut='o',typ=(fonction_sdaster,nappe_sdaster,formule) ),
           SOMMET          =SIMP(statut='f',typ='TXM',into=("OUI",) ),
           TRAN            =SIMP(statut='f',typ='R',max=3),
           ANGL_NAUT       =SIMP(statut='f',typ='R',max=3),
           CENTRE          =SIMP(statut='f',typ='R',max=3),
         ),
#
# LIAISON UNILATERALE
# 
         LIAISON_UNILATER=FACT(statut='f',max='**',
           fr="Définit les zones soumises à des conditions de liaison unilaterale (inegalite sur un DDL)",
           regles=(UN_PARMI('GROUP_MA','MAILLE','GROUP_NO','NOEUD'),),
                                         
           GROUP_MA        =SIMP(statut='f',typ=grma ,validators=NoRepeat(),max='**'),
           MAILLE          =SIMP(statut='f',typ=ma   ,validators=NoRepeat(),max='**'),
           GROUP_NO        =SIMP(statut='f',typ=grno ,validators=NoRepeat(),max='**'),
           NOEUD           =SIMP(statut='f',typ=no   ,validators=NoRepeat(),max='**'),   

           SANS_NOEUD      =SIMP(statut='f',typ=no  ,validators=NoRepeat(),max='**'),
           SANS_GROUP_NO   =SIMP(statut='f',typ=grno,validators=NoRepeat(),max='**'),
                 
           NB_RESOL        =SIMP(statut='f',typ='I', defaut=10 ),

           NOM_CMP         =SIMP(statut='o',typ='TXM',max='**'),           
           
           COEF_IMPO       =SIMP(statut='f',typ=(fonction_sdaster,nappe_sdaster,formule)),
           COEF_MULT       =SIMP(statut='f',typ=(fonction_sdaster,nappe_sdaster,formule),max='**'),         

           METHODE         =SIMP(statut='f',typ='TXM',defaut="CONTRAINTE",
                                 into=("CONTRAINTE","GCPC",) ),
           
                 
        ),
         CONTACT         =FACT(statut='f',
           fr="Définit les zones soumises à des conditions de contact unilatéral avec ou \sans frottement, certaines valeurs"
           +" sont données par l'intermédiaire de concept fonction",max='**',
           regles=(UN_PARMI('GROUP_MA_ESCL','MAILLE_ESCL'),),
           APPARIEMENT     =SIMP(statut='f',typ='TXM',defaut="MAIT_ESCL",
                                 into=("NODAL","MAIT_ESCL","MAIT_ESCL_SYME")),
           RECHERCHE       =SIMP(statut='f',typ='TXM',defaut="NOEUD_BOUCLE",into=("NOEUD_BOUCLE","NOEUD_VOISIN")),
           LISSAGE         =SIMP(statut='f',typ='TXM',defaut="NON",into=("OUI","NON")),                 
           DIST_POUTRE     =SIMP(statut='f',typ='TXM',defaut="NON", into=("OUI","NON")),
           DIST_COQUE      =SIMP(statut='f',typ='TXM',defaut="NON", into=("OUI","NON")),
           NORMALE         =SIMP(statut='f',typ='TXM',defaut="MAIT",into=("MAIT","MAIT_ESCL")),
           METHODE         =SIMP(statut='f',typ='TXM',defaut="CONTRAINTE",    
                                 into=("CONTRAINTE","VERIF","LAGRANGIEN","PENALISATION","CONTINUE","GCP") ),           
           PROJECTION      =SIMP(statut='f',typ='TXM',defaut="LINEAIRE",into=("LINEAIRE","QUADRATIQUE") ),
           GROUP_MA_MAIT   =SIMP(statut='f',typ=grma,validators=NoRepeat(),max='**'),
           MAILLE_MAIT     =SIMP(statut='f',typ=ma  ,validators=NoRepeat(),max='**'),
           GROUP_MA_ESCL   =SIMP(statut='f',typ=grma,validators=NoRepeat(),max='**'),
           MAILLE_ESCL     =SIMP(statut='f',typ=ma  ,validators=NoRepeat(),max='**'),
           b_cara         =BLOC(condition = "DIST_POUTRE == 'OUI' or DIST_COQUE == 'OUI'",
               CARA_ELEM       =SIMP(statut='o',typ=(cara_elem) ),
           ),
                    
           b_verif         =BLOC(condition = "METHODE == 'VERIF' ",
                                 fr="Paramètres de la méthode sans calcul de contact",
                STOP_INTERP     =SIMP(statut='f',typ='TXM',defaut="NON",
                                      into=("OUI","NON")),
                TOLE_INTERP     =SIMP(statut='f',typ='R',defaut = 0.),
                DIST_MAIT       =SIMP(statut='f',typ='R'),
                DIST_ESCL       =SIMP(statut='f',typ='R'),
                VECT_NORM_ESCL  =SIMP(statut='f',typ='R',max=3),
                VECT_ORIE_POU   =SIMP(statut='f',typ='R',min=3,max=3),
           ),

           b_active        =BLOC(condition = "METHODE == 'CONTRAINTE' ",
                                 fr="Paramètres de la méthode des contraintes actives (contact uniquement)",
                GLISSIERE       =SIMP(statut='f',typ='TXM',defaut="NON",
                                      into=("OUI","NON")),
                b_glissiere     =BLOC(condition = "GLISSIERE == 'OUI' ",                    
                      ALARME_JEU  =SIMP(statut='f',typ='R',defaut=0.),
                                 ),
                TOLE_PROJ_EXT   =SIMP(statut='f',typ='R'  ,defaut=0.50),
                TOLE_PROJ_INT   =SIMP(statut='f',typ='R'  ,defaut=0.001),
                STOP_SINGULIER  =SIMP(statut='f',typ='TXM',defaut="OUI",
                                      into=("OUI","NON")),
                NB_RESOL        =SIMP(statut='f',typ='I', defaut=10 ),
                REAC_GEOM       =SIMP(statut='f',typ='TXM',defaut="AUTOMATIQUE",
                        into=("AUTOMATIQUE","CONTROLE","SANS")),
                b_reac_sans     =BLOC(condition = "REAC_GEOM == 'SANS' ",
                                 fr="Parametre de la reactualisation geometrique",
                      
                                 ),
                b_reac_geom     =BLOC(condition = "REAC_GEOM == 'CONTROLE' ",
                                 fr="Parametre de la reactualisation geometrique",
                      NB_REAC_GEOM   =SIMP(statut='o',typ='I'),
                      
                                 ),
                b_reac_auto     =BLOC(condition = "REAC_GEOM == 'AUTOMATIQUE' ",
                      fr="Parametre de la reactualisation geometrique auto",
                                 ), 
                SANS_NOEUD      =SIMP(statut='f',typ=no  ,validators=NoRepeat(),max='**'),
                SANS_GROUP_NO   =SIMP(statut='f',typ=grno,validators=NoRepeat(),max='**'),
                SANS_NOEUD_QUAD =SIMP(statut='f',typ='TXM',defaut="OUI",into=("OUI","NON")),
                VECT_NORM_ESCL  =SIMP(statut='f',typ='R',max=3),
                VECT_ORIE_POU   =SIMP(statut='f',typ='R',min=3,max=3),
                DIST_MAIT       =SIMP(statut='f',typ=(fonction_sdaster,nappe_sdaster,formule)),
                DIST_ESCL       =SIMP(statut='f',typ=(fonction_sdaster,nappe_sdaster,formule)),
            ),
           b_lagrangien    =BLOC(condition = "METHODE == 'LAGRANGIEN' ",
                                 fr="Paramètres de la méthode Lagrangienne (contact avec ou sans frottement)",
                FROTTEMENT      =SIMP(statut='f',typ='TXM',defaut="SANS",into=("SANS","COULOMB",) ),
                TOLE_PROJ_EXT   =SIMP(statut='f',typ='R'  ,defaut=0.50),
                TOLE_PROJ_INT   =SIMP(statut='f',typ='R'  ,defaut=0.001),
                STOP_SINGULIER  =SIMP(statut='f',typ='TXM',defaut="OUI",
                                      into=("OUI","NON")),
                NB_RESOL        =SIMP(statut='f',typ='I', defaut=10 ),
                ITER_MULT_MAXI  =SIMP(statut='f',typ='I'  ,defaut=4),

                REAC_GEOM       =SIMP(statut='f',typ='TXM',defaut="AUTOMATIQUE",
                                      into=("AUTOMATIQUE","CONTROLE","SANS")),
                b_reac_sans     =BLOC(condition = "REAC_GEOM == 'SANS' ",fr="Parametre de la reactualisation geometrique",
                                 ),
                b_reac_geom     =BLOC(condition = "REAC_GEOM == 'CONTROLE' ",fr="Parametre de la reactualisation geometrique",
                      NB_REAC_GEOM   =SIMP(statut='o',typ='I'),

                                 ),
                b_reac_auto     =BLOC(condition = "REAC_GEOM == 'AUTOMATIQUE' ",
                      fr="Parametre de la reactualisation geometrique auto",
                                 ), 

                SANS_NOEUD      =SIMP(statut='f',typ=no  ,validators=NoRepeat(),max='**'),
                SANS_GROUP_NO   =SIMP(statut='f',typ=grno,validators=NoRepeat(),max='**'),
                SANS_NOEUD_QUAD =SIMP(statut='f',typ='TXM',defaut="NON",into=("OUI","NON")),
                DIST_MAIT       =SIMP(statut='f',typ=(fonction_sdaster,nappe_sdaster,formule)),
                DIST_ESCL       =SIMP(statut='f',typ=(fonction_sdaster,nappe_sdaster,formule)),
                regles=(EXCLUS('VECT_Y','VECT_ORIE_POU')),
                VECT_Y          =SIMP(statut='f',typ='R',min=3,max=3),
                VECT_ORIE_POU   =SIMP(statut='f',typ='R',min=3,max=3),                
                b_frottement    =BLOC(condition = "FROTTEMENT == 'COULOMB' ",fr="Paramètres du frottement de Coulomb",
                     COULOMB         =SIMP(statut='o',typ='R',),
                     COEF_MATR_FROT  =SIMP(statut='f',typ='R',defaut=0.E+0),  
                     ),),
           b_penalisation       =BLOC(condition = "METHODE == 'PENALISATION' ",
                                      fr="Paramètres de la méthode pénalisée (contact avec ou sans frottement)",
                E_N             =SIMP(statut='f',typ='R'), 
                FROTTEMENT      =SIMP(statut='f',typ='TXM',defaut="SANS",into=("SANS","COULOMB",) ),
                TOLE_PROJ_EXT   =SIMP(statut='f',typ='R'  ,defaut=0.50),
                TOLE_PROJ_INT   =SIMP(statut='f',typ='R'  ,defaut=0.001),
                STOP_SINGULIER  =SIMP(statut='f',typ='TXM',defaut="OUI",
                                      into=("OUI","NON")),
                NB_RESOL        =SIMP(statut='f',typ='I', defaut=10 ),
                ITER_MULT_MAXI  =SIMP(statut='f',typ='I',defaut=4),
                
                REAC_GEOM       =SIMP(statut='f',typ='TXM',defaut="AUTOMATIQUE",
                                      into=("AUTOMATIQUE","CONTROLE","SANS")),
                b_reac_sans     =BLOC(condition = "REAC_GEOM == 'SANS' ",fr="Paramètre de la réactualisation géométrique",
                                 ),
                b_reac_geom     =BLOC(condition = "REAC_GEOM == 'CONTROLE' ",fr="Paramètre de la réactualisation géométrique",
                      NB_REAC_GEOM   =SIMP(statut='o',typ='I'),
                                 ),
                b_reac_auto     =BLOC(condition = "REAC_GEOM == 'AUTOMATIQUE' ",
                     fr="Paramètre de la réactualisation géométrique auto",
                                 ), 
                SANS_NOEUD      =SIMP(statut='f',typ=no  ,validators=NoRepeat(),max='**'),
                SANS_GROUP_NO   =SIMP(statut='f',typ=grno,validators=NoRepeat(),max='**'),
                SANS_NOEUD_QUAD =SIMP(statut='f',typ='TXM',defaut="NON",into=("OUI","NON")),
                DIST_MAIT       =SIMP(statut='f',typ=(fonction_sdaster,nappe_sdaster,formule)),
                DIST_ESCL       =SIMP(statut='f',typ=(fonction_sdaster,nappe_sdaster,formule)),
                regles=(EXCLUS('VECT_Y','VECT_ORIE_POU')),
                VECT_Y          =SIMP(statut='f',typ='R',min=3,max=3),
                VECT_ORIE_POU   =SIMP(statut='f',typ='R',min=3,max=3),                
                b_frottement    =BLOC(condition = "FROTTEMENT == 'COULOMB' ",fr="Paramètres du frottement de Coulomb",
                     COULOMB         =SIMP(statut='o',typ='R',),
                     E_T             =SIMP(statut='f',typ='R',
                                           fr="Active la pénalisation sur le frottement et définit le coefficient de pénalisation"),
                     COEF_MATR_FROT  =SIMP(statut='f',typ='R',defaut=0.E+0),  
                     ),),
           b_continue      =BLOC(condition = "METHODE == 'CONTINUE' ",
                                 fr="Paramètres de la méthode continue (contact avec ou sans frottement)",
#                regles=(UN_PARMI('GLISSIERE','FROTTEMENT'),),
                GLISSIERE       =SIMP(statut='f',typ='TXM',defaut="NON",
                                      into=("OUI","NON")),
                b_glissiere     =BLOC(condition = "GLISSIERE == 'OUI' ",                    
                      ALARME_JEU  =SIMP(statut='f',typ='R',defaut=0.),
                                 ),
                FROTTEMENT      =SIMP(statut='f',typ='TXM',defaut="SANS",into=("SANS","COULOMB",) ), 
                COMPLIANCE      =SIMP(statut='f',typ='TXM',defaut="NON",into=("OUI","NON",) ),
                INTEGRATION     =SIMP(statut='f',typ='TXM',defaut="NOEUD",into=("GAUSS","NOEUD","SIMPSON","SIMPSON1","SIMPSON2",
                                                                                                "NCOTES","NCOTES1","NCOTES2")),
                COEF_REGU_CONT  =SIMP(statut='f',typ='R',defaut=100.E+0),
                FORMULATION     =SIMP(statut='f',typ='TXM',defaut="DEPL",into=("DEPL","VITE")),
                MODL_AXIS       =SIMP(statut='o',typ='TXM',into=("OUI","NON")),
                DIRE_APPA       =SIMP(statut='f',typ='R',max=3),
                ITER_GEOM_MAXI  =SIMP(statut='f',typ='I',defaut=2),
                ITER_CONT_MAXI  =SIMP(statut='f',typ='I',defaut=30),
                DIST_MAIT       =SIMP(statut='f',typ='R'),
                DIST_ESCL       =SIMP(statut='f',typ='R'),
                CONTACT_INIT    =SIMP(statut='f',typ='TXM',defaut="NON",into=("OUI","NON",) ),
                b_compliance    =BLOC(condition = "COMPLIANCE == 'OUI' ",fr="Parametres de la compliance",
                     ASPERITE        =SIMP(statut='o',typ='R',),
                     E_N             =SIMP(statut='o',typ='R',),
                     E_V             =SIMP(statut='f',typ='R',defaut=0.E+0),),
                b_frottement    =BLOC(condition = "FROTTEMENT == 'COULOMB' ",fr="Paramètres du frottement de Coulomb",
                     COULOMB         =SIMP(statut='o',typ='R',),
                     SANS_NOEUD      =SIMP(statut='f',typ=no  ,validators=NoRepeat(),max='**'),
                     SANS_GROUP_NO   =SIMP(statut='f',typ=grno,validators=NoRepeat(),max='**'),
                     VECT_Y          =SIMP(statut='f',typ='R',min=3,max=3),
                     VECT_Z          =SIMP(statut='f',typ='R',min=3,max=3),
                     ITER_FROT_MAXI  =SIMP(statut='f',typ='I',defaut=2),
                     COEF_REGU_FROT  =SIMP(statut='f',typ='R',defaut=100.E+0),
                     SEUIL_INIT      =SIMP(statut='f',typ='I',defaut=0),),),

           b_gcp        =BLOC(condition = "METHODE == 'GCP' ",
                                 fr="Paramètres de la méthode du gradient conjugué projeté (contact uniquement)",
                RESI_ABSO       =SIMP(statut='o',typ='R',
                                      fr="Critère de convergence (niveau d'interpénétration autorisé)"),
                REAC_ITER       =SIMP(statut='f',typ='I',defaut=3, fr="Fréquence de réinitialisation de la conjugaison"),
                TOLE_PROJ_EXT   =SIMP(statut='f',typ='R'  ,defaut=0.50),
                TOLE_PROJ_INT   =SIMP(statut='f',typ='R'  ,defaut=0.001),
                TOLE_REAC_GEOM  =SIMP(statut='f',typ='R'  ,defaut=0.05),
                STOP_SINGULIER  =SIMP(statut='f',typ='TXM',defaut="OUI",
                                      into=("OUI","NON")),
                REAC_GEOM       =SIMP(statut='f',typ='TXM',defaut="AUTOMATIQUE",
                        into=("AUTOMATIQUE","CONTROLE","SANS")),
                b_reac_sans     =BLOC(condition = "REAC_GEOM == 'SANS' ",
                                 fr="Paramètre de la réactualisation géométrique",
                      
                      STOP_REAC_GEOM =SIMP(statut='f',typ='TXM',defaut="NON",
                                           into=("OUI","NON")),
                                 ),
                b_reac_geom     =BLOC(condition = "REAC_GEOM == 'CONTROLE' ",
                                 fr="Paramètre de la réactualisation géométrique",
                      NB_REAC_GEOM   =SIMP(statut='o',typ='I'),
                      
                      STOP_REAC_GEOM =SIMP(statut='f',typ='TXM',defaut="ALARME",
                                           into=("OUI","NON")),
                                 ),
                b_reac_auto     =BLOC(condition = "REAC_GEOM == 'AUTOMATIQUE' ",
                      fr="Paramètre de la réactualisation géométrique auto",
                      NB_REAC_MAXI   =SIMP(statut='o',typ='I',defaut = 10),
                                 ), 
                SANS_NOEUD      =SIMP(statut='f',typ=no  ,validators=NoRepeat(),max='**'),
                SANS_GROUP_NO   =SIMP(statut='f',typ=grno,validators=NoRepeat(),max='**'),
                SANS_NOEUD_QUAD =SIMP(statut='f',typ='TXM',defaut="NON",into=("OUI","NON")),
                VECT_NORM_ESCL  =SIMP(statut='f',typ='R',max=3),
                VECT_ORIE_POU   =SIMP(statut='f',typ='R',min=3,max=3),
                DIST_MAIT       =SIMP(statut='f',typ=(fonction_sdaster,nappe_sdaster,formule)),
                DIST_ESCL       =SIMP(statut='f',typ=(fonction_sdaster,nappe_sdaster,formule)),
           ),
         ),        
         
          LIAISON_UNIF    =FACT(statut='f',max='**',
           fr="Impose une meme valeur (inconnue) à des DDLs d'un ensemble de noeuds",
           regles=(UN_PARMI('GROUP_NO','NOEUD','GROUP_MA','MAILLE'),),
           GROUP_MA        =SIMP(statut='f',typ=grma,validators=NoRepeat(),max='**'),
           MAILLE          =SIMP(statut='f',typ=ma  ,validators=NoRepeat(),max='**'),
           GROUP_NO        =SIMP(statut='f',typ=grno,validators=NoRepeat(),max='**'),
           NOEUD           =SIMP(statut='f',typ=no  ,validators=NoRepeat(),max='**'),
           DDL             =SIMP(statut='o',typ='TXM',max='**'),
         ),

         LIAISON_SOLIDE  =FACT(statut='f',max='**',
           fr="Modélise une partie indéformable d'une structure",
           regles=(UN_PARMI('GROUP_NO','NOEUD','GROUP_MA','MAILLE'),),
           GROUP_MA        =SIMP(statut='f',typ=grma,validators=NoRepeat(),max='**'),
           MAILLE          =SIMP(statut='f',typ=ma  ,validators=NoRepeat(),max='**'),
           GROUP_NO        =SIMP(statut='f',typ=grno,validators=NoRepeat(),max='**'),
           NOEUD           =SIMP(statut='f',typ=no  ,validators=NoRepeat(),max='**'),
           NUME_LAGR       =SIMP(statut='f',typ='TXM',defaut="NORMAL",into=("NORMAL","APRES",) ),
         ),



         FORCE_NODALE    =FACT(statut='f',max='**',
           fr="Applique à des noeuds des forces nodales dont les valeurs des composantes sont fournies par l'intermédiaire"
               +" d'un concept fonction",
           regles=(UN_PARMI('GROUP_NO','NOEUD'),
                   AU_MOINS_UN('FX','FY','FZ','MX','MY','MZ'),),
           GROUP_NO        =SIMP(statut='f',typ=grno,validators=NoRepeat(),max='**'),
           NOEUD           =SIMP(statut='f',typ=no  ,validators=NoRepeat(),max='**'),
           FX              =SIMP(statut='f',typ=(fonction_sdaster,nappe_sdaster,formule) ),
           FY              =SIMP(statut='f',typ=(fonction_sdaster,nappe_sdaster,formule) ),
           FZ              =SIMP(statut='f',typ=(fonction_sdaster,nappe_sdaster,formule) ),
           MX              =SIMP(statut='f',typ=(fonction_sdaster,nappe_sdaster,formule) ),
           MY              =SIMP(statut='f',typ=(fonction_sdaster,nappe_sdaster,formule) ),
           MZ              =SIMP(statut='f',typ=(fonction_sdaster,nappe_sdaster,formule) ),
           ANGL_NAUT       =SIMP(statut='f',typ=(fonction_sdaster,nappe_sdaster,formule),max=3 ),
         ),

         FORCE_FACE      =FACT(statut='f',max='**',
           fr="Applique des forces surfaciques sur une face d'élément volumique dont les valeurs des composantes sont fournies"
               +" par l'intermédiaire d'un concept fonction",
           regles=(AU_MOINS_UN('GROUP_MA','MAILLE'),
                   AU_MOINS_UN('FX','FY','FZ'),),
           GROUP_MA        =SIMP(statut='f',typ=grma,validators=NoRepeat(),max='**'),
           MAILLE          =SIMP(statut='f',typ=ma  ,validators=NoRepeat(),max='**'),
           FX              =SIMP(statut='f',typ=(fonction_sdaster,nappe_sdaster,formule) ),
           FY              =SIMP(statut='f',typ=(fonction_sdaster,nappe_sdaster,formule) ),
           FZ              =SIMP(statut='f',typ=(fonction_sdaster,nappe_sdaster,formule) ),
         ),
         FORCE_ARETE     =FACT(statut='f',max='**',
           fr="Applique des forces linéiques à une arete d'élément volumique ou de coque dont les valeurs des composantes sont"
               +" fournies par l'intermédiaire d'un concept fonction",
           regles=(AU_MOINS_UN('GROUP_MA','MAILLE'),
                   AU_MOINS_UN('FX','FY','FZ','MX','MY','MZ'),),
           GROUP_MA        =SIMP(statut='f',typ=grma,validators=NoRepeat(),max='**'),
           MAILLE          =SIMP(statut='f',typ=ma  ,validators=NoRepeat(),max='**'),
           FX              =SIMP(statut='f',typ=(fonction_sdaster,nappe_sdaster,formule) ),
           FY              =SIMP(statut='f',typ=(fonction_sdaster,nappe_sdaster,formule) ),
           FZ              =SIMP(statut='f',typ=(fonction_sdaster,nappe_sdaster,formule) ),
           MX              =SIMP(statut='f',typ=(fonction_sdaster,nappe_sdaster,formule) ),
           MY              =SIMP(statut='f',typ=(fonction_sdaster,nappe_sdaster,formule) ),
           MZ              =SIMP(statut='f',typ=(fonction_sdaster,nappe_sdaster,formule) ),
         ),
         FORCE_CONTOUR   =FACT(statut='f',max='**',
           fr="Applique des forces linéiques au bord d'un domaine 2D ou AXIS ou AXIS_FOURIER, dont les valeurs des composantes"
               +" sont fournies par l'intermédiaire d'un concept fonction",
           regles=(AU_MOINS_UN('GROUP_MA','MAILLE'),
                   AU_MOINS_UN('FX','FY','FZ','MX','MY','MZ'),),
           GROUP_MA        =SIMP(statut='f',typ=grma,validators=NoRepeat(),max='**'),
           MAILLE          =SIMP(statut='f',typ=ma  ,validators=NoRepeat(),max='**'),
           FX              =SIMP(statut='f',typ=(fonction_sdaster,nappe_sdaster,formule) ),
           FY              =SIMP(statut='f',typ=(fonction_sdaster,nappe_sdaster,formule) ),
           FZ              =SIMP(statut='f',typ=(fonction_sdaster,nappe_sdaster,formule) ),
           MX              =SIMP(statut='f',typ=(fonction_sdaster,nappe_sdaster,formule) ),
           MY              =SIMP(statut='f',typ=(fonction_sdaster,nappe_sdaster,formule) ),
           MZ              =SIMP(statut='f',typ=(fonction_sdaster,nappe_sdaster,formule) ),
         ),

         FORCE_INTERNE   =FACT(statut='f',max='**',
           fr="Applique des forces volumiques (2D ou 3D) à un domaine volumique, dont les valeurs des composantes sont fournies"
               +" par l'intermédiaire d'un concept fonction",
           regles=(AU_MOINS_UN('TOUT','GROUP_MA','MAILLE'),
                   PRESENT_ABSENT('TOUT','GROUP_MA','MAILLE'),
                   AU_MOINS_UN('FX','FY','FZ'),),
           TOUT            =SIMP(statut='f',typ='TXM',into=("OUI",) ),
           GROUP_MA        =SIMP(statut='f',typ=grma,validators=NoRepeat(),max='**'),
           MAILLE          =SIMP(statut='f',typ=ma  ,validators=NoRepeat(),max='**'),
           FX              =SIMP(statut='f',typ=(fonction_sdaster,nappe_sdaster,formule) ),
           FY              =SIMP(statut='f',typ=(fonction_sdaster,nappe_sdaster,formule) ),
           FZ              =SIMP(statut='f',typ=(fonction_sdaster,nappe_sdaster,formule) ),
         ),
         
         PRES_REP        =FACT(statut='f',max='**',
           fr="Applique une pression à un domaine de milieu continu 2D ou 3D ou à un domaine de coques et tuyaux, dont les"
               +" valeurs imposées (pression et/ou cisaillement) sont fournies par l'intermédiaire d'un concept fonction",
           regles=(AU_MOINS_UN('TOUT','GROUP_MA','MAILLE'),
                   PRESENT_ABSENT('TOUT','GROUP_MA','MAILLE'),
                   AU_MOINS_UN('PRES','CISA_2D'),),
           TOUT            =SIMP(statut='f',typ='TXM',into=("OUI",) ),
           GROUP_MA        =SIMP(statut='f',typ=grma,validators=NoRepeat(),max='**'),
           MAILLE          =SIMP(statut='f',typ=ma  ,validators=NoRepeat(),max='**'),
           PRES            =SIMP(statut='f',typ=(fonction_sdaster,nappe_sdaster,formule) ),
           CISA_2D         =SIMP(statut='f',typ=(fonction_sdaster,nappe_sdaster,formule) ),
         ),

         EFFE_FOND       =FACT(statut='f',max='**',
           fr="Calcul l'effet de fond sur une branche de tuyauterie (modélisation 3D) soumise"
               +" à une pression dont la valeur est fournie par l'intermédiaire d'un concept fonction",
           regles=(AU_MOINS_UN('GROUP_MA','MAILLE'),),
           GROUP_MA_INT    =SIMP(statut='o',typ=grma,validators=NoRepeat(),max='**'),
           GROUP_MA        =SIMP(statut='f',typ=grma,validators=NoRepeat(),max='**'),
           MAILLE          =SIMP(statut='f',typ=ma  ,validators=NoRepeat(),max='**'),
           PRES            =SIMP(statut='o',typ=(fonction_sdaster,nappe_sdaster,formule) ),
         ),

         EPSI_INIT       =FACT(statut='f',max='**',
           fr="Applique un chargement de déformation initiale à un élément 2D, 3D ou de structure dont les composantes"
               +" du tenseur de déformation sont fournies par l'intermédiaire d'un concept fonction",
           regles=(AU_MOINS_UN('TOUT','GROUP_MA','MAILLE'),
                   PRESENT_ABSENT('TOUT','GROUP_MA','MAILLE'),
                   AU_MOINS_UN('EPXX','EPYY','EPZZ','EPXY','EPXZ','EPYZ'),),
           TOUT            =SIMP(statut='f',typ='TXM',into=("OUI",) ),
           GROUP_MA        =SIMP(statut='f',typ=grma,validators=NoRepeat(),max='**'),
           MAILLE          =SIMP(statut='f',typ=ma  ,validators=NoRepeat(),max='**'),
           EPXX            =SIMP(statut='f',typ=(fonction_sdaster,nappe_sdaster,formule) ),
           EPYY            =SIMP(statut='f',typ=(fonction_sdaster,nappe_sdaster,formule) ),
           EPZZ            =SIMP(statut='f',typ=(fonction_sdaster,nappe_sdaster,formule) ),
           EPXY            =SIMP(statut='f',typ=(fonction_sdaster,nappe_sdaster,formule) ),
           EPXZ            =SIMP(statut='f',typ=(fonction_sdaster,nappe_sdaster,formule) ),
           EPYZ            =SIMP(statut='f',typ=(fonction_sdaster,nappe_sdaster,formule) ),
         ),
         
         FORCE_POUTRE    =FACT(statut='f',max='**',
           fr="Applique des forces linéiques sur des éléments de type poutre dont les valeurs sont fournies par"
               +" l'intermédiaire d'un concept fonction",
           regles=(AU_MOINS_UN('TOUT','GROUP_MA','MAILLE'),
                   PRESENT_ABSENT('TOUT','GROUP_MA','MAILLE'),
                   AU_MOINS_UN('FX','FY','FZ','N','VY','VZ'),
                   PRESENT_ABSENT('FX','N','VY','VZ'),
                   PRESENT_ABSENT('FY','N','VY','VZ'),
                   PRESENT_ABSENT('FZ','N','VY','VZ'),
                   PRESENT_ABSENT('N','FX','FY','FZ'),
                   PRESENT_ABSENT('VY','FX','FY','FZ'),
                   PRESENT_ABSENT('VZ','FX','FY','FZ'),),
#  rajout d un mot cle REPERE : / GLOBAL / LOCAL
           TOUT            =SIMP(statut='f',typ='TXM',into=("OUI",) ),
           GROUP_MA        =SIMP(statut='f',typ=grma,validators=NoRepeat(),max='**'),
           MAILLE          =SIMP(statut='f',typ=ma  ,validators=NoRepeat(),max='**'),
           TYPE_CHARGE     =SIMP(statut='f',typ='TXM',defaut="FORCE",into=("VENT","FORCE") ),
           FX              =SIMP(statut='f',typ=(fonction_sdaster,nappe_sdaster,formule) ),
           FY              =SIMP(statut='f',typ=(fonction_sdaster,nappe_sdaster,formule) ),
           FZ              =SIMP(statut='f',typ=(fonction_sdaster,nappe_sdaster,formule) ),
           N               =SIMP(statut='f',typ=(fonction_sdaster,nappe_sdaster,formule) ),
           VY              =SIMP(statut='f',typ=(fonction_sdaster,nappe_sdaster,formule) ),
           VZ              =SIMP(statut='f',typ=(fonction_sdaster,nappe_sdaster,formule) ),
         ),

         FORCE_TUYAU     =FACT(statut='f',max='**',
           fr="Applique une pression sur des éléments TUYAU, la valeur est fournie par l'intermédiaire d'un concept fonction",
           regles=(AU_MOINS_UN('TOUT','GROUP_MA','MAILLE'),
                   PRESENT_ABSENT('TOUT','GROUP_MA','MAILLE'),),
           TOUT            =SIMP(statut='f',typ='TXM',into=("OUI",) ),
           GROUP_MA        =SIMP(statut='f',typ=grma,validators=NoRepeat(),max='**'),
           MAILLE          =SIMP(statut='f',typ=ma  ,validators=NoRepeat(),max='**'),
           PRES            =SIMP(statut='f',typ=(fonction_sdaster,nappe_sdaster,formule) ),
         ),
         
         FORCE_COQUE     =FACT(statut='f',max='**',
           fr="Applique des forces surfaciques sur des éléments de types coques dont les valeurs sont fournies par"
               +" l'intermédiaires d'un concept fonction",
           regles=(AU_MOINS_UN('TOUT','GROUP_MA','MAILLE'),
                   PRESENT_ABSENT('TOUT','GROUP_MA','MAILLE'),
                   AU_MOINS_UN('FX','FY','FZ','MX','MY','MZ','PRES','F1','F2','F3','MF1','MF2'),
                   PRESENT_ABSENT('FX','PRES','F1','F2','F3','MF1','MF2'),
                   PRESENT_ABSENT('FY','PRES','F1','F2','F3','MF1','MF2'),
                   PRESENT_ABSENT('FZ','PRES','F1','F2','F3','MF1','MF2'),
                   PRESENT_ABSENT('MX','PRES','F1','F2','F3','MF1','MF2'),
                   PRESENT_ABSENT('MY','PRES','F1','F2','F3','MF1','MF2'),
                   PRESENT_ABSENT('MZ','PRES','F1','F2','F3','MF1','MF2'),
                   PRESENT_ABSENT('F1','PRES','FX','FY','FZ','MX','MY','MZ'),
                   PRESENT_ABSENT('F2','PRES','FX','FY','FZ','MX','MY','MZ'),
                   PRESENT_ABSENT('F3','PRES','FX','FY','FZ','MX','MY','MZ'),
                   PRESENT_ABSENT('MF1','PRES','FX','FY','FZ','MX','MY','MZ'),
                   PRESENT_ABSENT('MF2','PRES','FX','FY','FZ','MX','MY','MZ'),
                   PRESENT_ABSENT('PRES','FX','FY','FZ','MX','MY','MZ','F1','F2','F3','MF1','MF2'),),
#  rajout d un mot cle REPERE : / GLOBAL / LOCAL
           TOUT            =SIMP(statut='f',typ='TXM',into=("OUI",) ),
           GROUP_MA        =SIMP(statut='f',typ=grma,validators=NoRepeat(),max='**'),
           MAILLE          =SIMP(statut='f',typ=ma  ,validators=NoRepeat(),max='**'),
           FX              =SIMP(statut='f',typ=(fonction_sdaster,nappe_sdaster,formule) ),
           FY              =SIMP(statut='f',typ=(fonction_sdaster,nappe_sdaster,formule) ),
           FZ              =SIMP(statut='f',typ=(fonction_sdaster,nappe_sdaster,formule) ),
           MX              =SIMP(statut='f',typ=(fonction_sdaster,nappe_sdaster,formule) ),
           MY              =SIMP(statut='f',typ=(fonction_sdaster,nappe_sdaster,formule) ),
           MZ              =SIMP(statut='f',typ=(fonction_sdaster,nappe_sdaster,formule) ),
           F1              =SIMP(statut='f',typ=(fonction_sdaster,nappe_sdaster,formule) ),
           F2              =SIMP(statut='f',typ=(fonction_sdaster,nappe_sdaster,formule) ),
           F3              =SIMP(statut='f',typ=(fonction_sdaster,nappe_sdaster,formule) ),
           MF1             =SIMP(statut='f',typ=(fonction_sdaster,nappe_sdaster,formule) ),
           MF2             =SIMP(statut='f',typ=(fonction_sdaster,nappe_sdaster,formule) ),
           PRES            =SIMP(statut='f',typ=(fonction_sdaster,nappe_sdaster,formule) ),
           PLAN            =SIMP(statut='f',typ='TXM',defaut="MAIL",
                                 into=("SUP","INF","MOY","MAIL") ),
         ),

         LIAISON_COQUE   =FACT(statut='f',max='**',
           fr="Permet de représenter le raccord entre des éléments de coques au moyen des relations linéaires",
           GROUP_MA_1      =SIMP(statut='f',typ=grma,validators=NoRepeat(),max='**'),
           MAILLE_1        =SIMP(statut='f',typ=ma  ,validators=NoRepeat(),max='**'),
           GROUP_NO_1      =SIMP(statut='f',typ=grno,validators=NoRepeat(),max='**'),
           NOEUD_1         =SIMP(statut='f',typ=no  ,validators=NoRepeat(),max='**'),
           GROUP_MA_2      =SIMP(statut='f',typ=grma,validators=NoRepeat(),max='**'),
           MAILLE_2        =SIMP(statut='f',typ=ma  ,validators=NoRepeat(),max='**'),
           GROUP_NO_2      =SIMP(statut='f',typ=grno,validators=NoRepeat(),max='**'),
           NOEUD_2         =SIMP(statut='f',typ=no  ,validators=NoRepeat(),max='**'),
           NUME_LAGR       =SIMP(statut='f',typ='TXM',defaut="NORMAL",into=("NORMAL","APRES",) ),
         ),         
         

         VITE_FACE       =FACT(statut='f',max='**',
           fr="Impose des vitesses normales à une face (phénomène ACOUSTIQUE) dont les valeurs sont fournies par"
               +" l'intermédiaire d'un concept fonction",
           regles=(AU_MOINS_UN('GROUP_MA','MAILLE'),
                   PRESENT_ABSENT('GROUP_MA','MAILLE'),),
           GROUP_MA        =SIMP(statut='f',typ=grma,validators=NoRepeat(),max='**'),
           MAILLE          =SIMP(statut='f',typ=ma  ,validators=NoRepeat(),max='**'),
           VNOR            =SIMP(statut='o',typ=(fonction_sdaster,nappe_sdaster,formule) ),
         ),
         IMPE_FACE       =FACT(statut='f',max='**',
           fr="Applique à une face une impédance acoustique dont la valeur est fournie par l'intermédiaire"
               +" d'un concept fonction",
           regles=(AU_MOINS_UN('GROUP_MA','MAILLE'),
                   PRESENT_ABSENT('GROUP_MA','MAILLE'),),
           GROUP_MA        =SIMP(statut='f',typ=grma,validators=NoRepeat(),max='**'),
           MAILLE          =SIMP(statut='f',typ=ma  ,validators=NoRepeat(),max='**'),
           IMPE            =SIMP(statut='o',typ=(fonction_sdaster,nappe_sdaster,formule) ),
         ),
         ONDE_PLANE      =FACT(statut='f',max='**',
           fr="Impose un chargement sismique par onde plane dont la valeur est fournie par l'intermédiaire"
               +" d'un concept fonction",
           DIRECTION       =SIMP(statut='o',typ='R',max='**'),
           TYPE_ONDE       =SIMP(statut='o',typ='TXM' ),
           FONC_SIGNAL     =SIMP(statut='o',typ=(fonction_sdaster,nappe_sdaster,formule) ),
           DIST_ORIG       =SIMP(statut='o',typ='R' ),
         ),



         FLUX_THM_REP    =FACT(statut='f',max='**',
           fr="Applique à un domaine continue 2D ou 3D un flux de chaleur et/ou un apport de masse fluide (flux hydraulique)"
               +" dont les valeurs des flux sont fournies par l'intermédiaire d'un concept fonction",
           regles=(AU_MOINS_UN('TOUT','GROUP_MA','MAILLE'),
                   PRESENT_ABSENT('TOUT','GROUP_MA','MAILLE'),
                   AU_MOINS_UN('FLUN','FLUN_HYDR1','FLUN_HYDR2'),),
           TOUT            =SIMP(statut='f',typ='TXM',into=("OUI",) ),
           GROUP_MA        =SIMP(statut='f',typ=grma,validators=NoRepeat(),max='**'),
           MAILLE          =SIMP(statut='f',typ=ma  ,validators=NoRepeat(),max='**'),
           FLUN            =SIMP(statut='f',typ=(fonction_sdaster,nappe_sdaster,formule) ),
           FLUN_HYDR1      =SIMP(statut='f',typ=(fonction_sdaster,nappe_sdaster,formule) ),
           FLUN_HYDR2      =SIMP(statut='f',typ=(fonction_sdaster,nappe_sdaster,formule) ),
         ),

         INFO            =SIMP(statut='f',typ='I',defaut= 1,into=( 1 , 2) ),
)  ;


#& MODIF COMMANDE  DATE 22/06/2005   AUTEUR REZETTE C.REZETTE 
#            CONFIGURATION MANAGEMENT OF EDF VERSION
# ======================================================================
# COPYRIGHT (C) 1991 - 2001  EDF R&D                  WWW.CODE-ASTER.ORG
# THIS PROGRAM IS FREE SOFTWARE; YOU CAN REDISTRIBUTE IT AND/OR MODIFY
# IT UNDER THE TERMS OF THE GNU GENERAL PUBLIC LICENSE AS PUBLISHED BY
# THE FREE SOFTWARE FOUNDATION; EITHER VERSION 2 OF THE LICENSE, OR   
# (AT YOUR OPTION) ANY LATER VERSION.                                 
#
# THIS PROGRAM IS DISTRIBUTED IN THE HOPE THAT IT WILL BE USEFUL, BUT 
# WITHOUT ANY WARRANTY; WITHOUT EVEN THE IMPLIED WARRANTY OF          
# MERCHANTABILITY OR FITNESS FOR A PARTICULAR PURPOSE. SEE THE GNU    
# GENERAL PUBLIC LICENSE FOR MORE DETAILS.                            
#
# YOU SHOULD HAVE RECEIVED A COPY OF THE GNU GENERAL PUBLIC LICENSE   
# ALONG WITH THIS PROGRAM; IF NOT, WRITE TO EDF R&D CODE_ASTER,       
#    1 AVENUE DU GENERAL DE GAULLE, 92141 CLAMART CEDEX, FRANCE.      
# ======================================================================
AFFE_CHAR_OPS011=OPER(nom="AFFE_CHAR_OPS011",op= 190,sd_prod=char_ther,
                      fr="Affectation de charges et conditions limites thermiques spécifique à CARA_TORSION",
                      reentrant='n',
            UIinfo={"groupes":("Outils métier",)},
         regles=(AU_MOINS_UN('CARA_TORSION', ),),
         MODELE          =SIMP(statut='o',typ=modele_sdaster ),
         VERI_DDL        =SIMP(statut='f',typ='TXM',defaut="OUI",
                               into=("OUI","NON") ),
         CARA_TORSION    =FACT(statut='f',max='**',
           regles=(UN_PARMI('TOUT','GROUP_MA'),),
           TOUT            =SIMP(statut='f',typ='TXM',into=("OUI",) ),
           GROUP_MA        =SIMP(statut='f',typ=grma,validators=NoRepeat(),max='**'),
         ),
         INFO            =SIMP(statut='f',typ='I',defaut= 1,into=(1,2) ),
)  ;
#& MODIF COMMANDE  DATE 16/05/2006   AUTEUR REZETTE C.REZETTE 
#            CONFIGURATION MANAGEMENT OF EDF VERSION
# ======================================================================
# COPYRIGHT (C) 1991 - 2001  EDF R&D                  WWW.CODE-ASTER.ORG
# THIS PROGRAM IS FREE SOFTWARE; YOU CAN REDISTRIBUTE IT AND/OR MODIFY
# IT UNDER THE TERMS OF THE GNU GENERAL PUBLIC LICENSE AS PUBLISHED BY
# THE FREE SOFTWARE FOUNDATION; EITHER VERSION 2 OF THE LICENSE, OR
# (AT YOUR OPTION) ANY LATER VERSION.
#
# THIS PROGRAM IS DISTRIBUTED IN THE HOPE THAT IT WILL BE USEFUL, BUT
# WITHOUT ANY WARRANTY; WITHOUT EVEN THE IMPLIED WARRANTY OF
# MERCHANTABILITY OR FITNESS FOR A PARTICULAR PURPOSE. SEE THE GNU
# GENERAL PUBLIC LICENSE FOR MORE DETAILS.
#
# YOU SHOULD HAVE RECEIVED A COPY OF THE GNU GENERAL PUBLIC LICENSE
# ALONG WITH THIS PROGRAM; IF NOT, WRITE TO EDF R&D CODE_ASTER,
#    1 AVENUE DU GENERAL DE GAULLE, 92141 CLAMART CEDEX, FRANCE.
# ======================================================================
AFFE_CHAR_THER=OPER(nom="AFFE_CHAR_THER",op=34,sd_prod=char_ther
                    ,fr="Affectation de charges et conditions aux limites thermiques constantes",
                    reentrant='n',
            UIinfo={"groupes":("Modélisation",)},
      regles=(AU_MOINS_UN('TEMP_IMPO','SOURCE','FLUX_REP','ECHANGE',
                          'ECHANGE_PAROI','GRAD_TEMP_INIT','LIAISON_DDL','LIAISON_GROUP',
                          'LIAISON_UNIF','LIAISON_CHAMNO','RAYONNEMENT','LIAISON_MAIL' ),),
         MODELE          =SIMP(statut='o',typ=(modele_sdaster) ),

         TEMP_IMPO       =FACT(statut='f',max='**',
           regles=(AU_MOINS_UN('TOUT','GROUP_MA','MAILLE','GROUP_NO','NOEUD'),
                   AU_MOINS_UN('TEMP_SUP','TEMP','TEMP_INF'),),
           TOUT            =SIMP(statut='f',typ='TXM',into=("OUI",) ),
           GROUP_MA        =SIMP(statut='f',typ=grma,validators=NoRepeat(),max='**'),
           MAILLE          =SIMP(statut='f',typ=ma  ,validators=NoRepeat(),max='**'),
           GROUP_NO        =SIMP(statut='f',typ=grno,validators=NoRepeat(),max='**'),
           NOEUD           =SIMP(statut='f',typ=no  ,validators=NoRepeat(),max='**'),
           TEMP            =SIMP(statut='f',typ='R'),
           TEMP_INF        =SIMP(statut='f',typ='R'),
           TEMP_SUP        =SIMP(statut='f',typ='R'), ),

         FLUX_REP        =FACT(statut='f',max='**',
           regles=(AU_MOINS_UN('TOUT','GROUP_MA','MAILLE'),
                   PRESENT_ABSENT('TOUT','GROUP_MA','MAILLE'),
                   PRESENT_PRESENT('CARA_TORSION','GROUP_MA'),
                   AU_MOINS_UN('FLUN','FLUN_INF','FLUN_SUP','CARA_TORSION') ),
           TOUT            =SIMP(statut='f',typ='TXM',into=("OUI",) ),
           GROUP_MA        =SIMP(statut='f',typ=grma,validators=NoRepeat(),max='**'),
           MAILLE          =SIMP(statut='f',typ=ma  ,validators=NoRepeat(),max='**'),
           FLUN            =SIMP(statut='f',typ='R'),
           FLUN_INF        =SIMP(statut='f',typ='R'),
           FLUN_SUP        =SIMP(statut='f',typ='R'),
           CARA_TORSION    =SIMP(statut='f',typ=table_sdaster),
         ),


         RAYONNEMENT     =FACT(statut='f',max='**',
           fr="Attention, exprimer les températures en Celsius si rayonnement",
           regles=(AU_MOINS_UN('TOUT','GROUP_MA','MAILLE'),
                   PRESENT_ABSENT('TOUT','GROUP_MA','MAILLE'),),
           TOUT            =SIMP(statut='f',typ='TXM',into=("OUI",) ),
           GROUP_MA        =SIMP(statut='f',typ=grma,validators=NoRepeat(),max='**'),
           MAILLE          =SIMP(statut='f',typ=ma  ,validators=NoRepeat(),max='**'),
           SIGMA           =SIMP(statut='o',typ='R'),
           EPSILON         =SIMP(statut='o',typ='R'),
           TEMP_EXT        =SIMP(statut='o',typ='R'),
         ),

         ECHANGE         =FACT(statut='f',max='**',
           regles=(AU_MOINS_UN('TOUT','GROUP_MA','MAILLE'),
                   PRESENT_ABSENT('TOUT','GROUP_MA','MAILLE'),
                   AU_MOINS_UN('COEF_H','COEF_H_INF','COEF_H_SUP'),
                   ENSEMBLE('COEF_H','TEMP_EXT',),
                   ENSEMBLE('COEF_H_INF','TEMP_EXT_INF'),
                             ENSEMBLE('COEF_H_SUP','TEMP_EXT_SUP'),),
           TOUT            =SIMP(statut='f',typ='TXM',into=("OUI",) ),
           GROUP_MA        =SIMP(statut='f',typ=grma,validators=NoRepeat(),max='**'),
           MAILLE          =SIMP(statut='f',typ=ma  ,validators=NoRepeat(),max='**'),
           COEF_H          =SIMP(statut='f',typ='R'),
           TEMP_EXT        =SIMP(statut='f',typ='R'),
           COEF_H_INF      =SIMP(statut='f',typ='R'),
           TEMP_EXT_INF    =SIMP(statut='f',typ='R'),
           COEF_H_SUP      =SIMP(statut='f',typ='R'),
           TEMP_EXT_SUP    =SIMP(statut='f',typ='R'),
         ),

         SOURCE          =FACT(statut='f',max='**',
           regles=(UN_PARMI('SOUR','SOUR_CALCULEE',),
                   PRESENT_ABSENT('TOUT','GROUP_MA','MAILLE'),
                   PRESENT_ABSENT('SOUR_CALCULEE','TOUT','GROUP_MA','MAILLE'),),
           TOUT            =SIMP(statut='f',typ='TXM',into=("OUI",) ),
           GROUP_MA        =SIMP(statut='f',typ=grma,validators=NoRepeat(),max='**'),
           MAILLE          =SIMP(statut='f',typ=ma  ,validators=NoRepeat(),max='**'),
           SOUR            =SIMP(statut='f',typ='R'),
           SOUR_CALCULEE   =SIMP(statut='f',typ=(cham_elem) ),
         ),

         GRAD_TEMP_INIT  =FACT(statut='f',max='**',
           regles=(AU_MOINS_UN('TOUT','GROUP_MA','MAILLE'),
                   PRESENT_ABSENT('TOUT','GROUP_MA','MAILLE'),
                   AU_MOINS_UN('FLUX_X','FLUX_Y','FLUX_Z'),),
           TOUT            =SIMP(statut='f',typ='TXM',into=("OUI",) ),
           GROUP_MA        =SIMP(statut='f',typ=grma,validators=NoRepeat(),max='**'),
           MAILLE          =SIMP(statut='f',typ=ma  ,validators=NoRepeat(),max='**'),
           FLUX_X          =SIMP(statut='f',typ='R' ),
           FLUX_Y          =SIMP(statut='f',typ='R' ),
           FLUX_Z          =SIMP(statut='f',typ='R' ),
                         ),

         LIAISON_DDL     =FACT(statut='f',max='**',
           regles=(UN_PARMI('GROUP_NO','NOEUD', ),),
           GROUP_NO        =SIMP(statut='f',typ=grno,max='**'),
           NOEUD           =SIMP(statut='f',typ=no  ,max='**'),
           DDL             =SIMP(statut='f',typ='TXM',max='**',
                                 into=("TEMP","TEMP_INF","TEMP_SUP") ),
           COEF_MULT       =SIMP(statut='o',typ='R',max='**'),
           COEF_IMPO       =SIMP(statut='o',typ='R' ),
         ),

         LIAISON_GROUP   =FACT(statut='f',max='**',
           regles=(UN_PARMI('GROUP_MA_1','MAILLE_1','GROUP_NO_1','NOEUD_1'),
                   UN_PARMI('GROUP_MA_2','MAILLE_2','GROUP_NO_2','NOEUD_2'),
                             EXCLUS('GROUP_MA_1','GROUP_NO_2'),
                             EXCLUS('GROUP_MA_1','NOEUD_2'),
                   EXCLUS('GROUP_NO_1','GROUP_MA_2'),
                             EXCLUS('GROUP_NO_1','MAILLE_2'),
                             EXCLUS('MAILLE_1','GROUP_NO_2'),
                             EXCLUS('MAILLE_1','NOEUD_2'),
                             EXCLUS('NOEUD_1','GROUP_MA_2'),
                             EXCLUS('NOEUD_1','MAILLE_2'),
                             EXCLUS('SANS_NOEUD','SANS_GROUP_NO'),),
           GROUP_MA_1      =SIMP(statut='f',typ=grma,validators=NoRepeat(),max='**'),
           MAILLE_1        =SIMP(statut='f',typ=ma  ,validators=NoRepeat(),max='**'),
           GROUP_NO_1      =SIMP(statut='f',typ=grno,validators=NoRepeat(),max='**'),
           NOEUD_1         =SIMP(statut='f',typ=no  ,validators=NoRepeat(),max='**'),
           GROUP_MA_2      =SIMP(statut='f',typ=grma,validators=NoRepeat(),max='**'),
           MAILLE_2        =SIMP(statut='f',typ=ma  ,validators=NoRepeat(),max='**'),
           GROUP_NO_2      =SIMP(statut='f',typ=grno,validators=NoRepeat(),max='**'),
           NOEUD_2         =SIMP(statut='f',typ=no  ,validators=NoRepeat(),max='**'),
           SANS_NOEUD      =SIMP(statut='f',typ=no  ,validators=NoRepeat(),max='**'),
           SANS_GROUP_NO   =SIMP(statut='f',typ=grno,validators=NoRepeat(),max='**'),
           DDL_1           =SIMP(statut='f',typ='TXM',max='**',defaut="TEMP",
                                 into=("TEMP","TEMP_INF","TEMP_SUP") ),
           COEF_MULT_1     =SIMP(statut='o',typ='R',max='**'),
           DDL_2           =SIMP(statut='f',typ='TXM',max='**',defaut="TEMP",
                                 into=("TEMP","TEMP_INF","TEMP_SUP",) ),
           COEF_MULT_2     =SIMP(statut='o',typ='R',max='**'),
           COEF_IMPO       =SIMP(statut='o',typ='R' ),
           SOMMET          =SIMP(statut='f',typ='TXM',into=("OUI",) ),
           TRAN            =SIMP(statut='f',typ='R',max='**'),
           ANGL_NAUT       =SIMP(statut='f',typ='R',max='**'),
           CENTRE          =SIMP(statut='f',typ='R',max='**'),
         ),

         LIAISON_MAIL    =FACT(statut='f',max='**',
           regles=(AU_MOINS_UN('GROUP_MA_MAIT','MAILLE_MAIT'),
                   AU_MOINS_UN('GROUP_MA_ESCL','MAILLE_ESCL','GROUP_NO_ESCL',
                               'NOEUD_ESCL'),),
           GROUP_MA_MAIT   =SIMP(statut='f',typ=grma,validators=NoRepeat(),max='**'),
           MAILLE_MAIT     =SIMP(statut='f',typ=ma  ,validators=NoRepeat(),max='**'),
           GROUP_MA_ESCL   =SIMP(statut='f',typ=grma,validators=NoRepeat(),max='**'),
           MAILLE_ESCL     =SIMP(statut='f',typ=ma  ,validators=NoRepeat(),max='**'),
           GROUP_NO_ESCL   =SIMP(statut='f',typ=grno,validators=NoRepeat(),max='**'),
           NOEUD_ESCL      =SIMP(statut='f',typ=no  ,validators=NoRepeat(),max='**'),
           TRAN            =SIMP(statut='f',typ='R',max='**' ),
           ANGL_NAUT       =SIMP(statut='f',typ='R',max='**' ),
           CENTRE          =SIMP(statut='f',typ='R',max='**' ),
           ELIM_MULT       =SIMP(statut='f',typ='TXM',defaut="NON",into=("OUI","NON") ),
         ),

         ECHANGE_PAROI   =FACT(statut='f',max='**',
           regles=(UN_PARMI('GROUP_MA_1','MAILLE_1'),
                   UN_PARMI('GROUP_MA_2','MAILLE_2'),),
           GROUP_MA_1      =SIMP(statut='f',typ=grma,validators=NoRepeat(),max='**'),
           MAILLE_1        =SIMP(statut='f',typ=ma  ,validators=NoRepeat(),max='**'),
           GROUP_MA_2      =SIMP(statut='f',typ=grma,validators=NoRepeat(),max='**'),
           MAILLE_2        =SIMP(statut='f',typ=ma  ,validators=NoRepeat(),max='**'),
           COEF_H          =SIMP(statut='f',typ='R'),
           TRAN            =SIMP(statut='f',typ='R',min=2,max=3),
           ANGL_NAUT       =SIMP(statut='f',typ='R',max=3),
           CENTRE          =SIMP(statut='f',typ='R',min=2,max=3),
                         ),

         LIAISON_UNIF    =FACT(statut='f',max='**',
           regles=(UN_PARMI('GROUP_NO','NOEUD','GROUP_MA','MAILLE'),),
           GROUP_NO        =SIMP(statut='f',typ=grno,validators=NoRepeat(),max='**'),
           NOEUD           =SIMP(statut='f',typ=no  ,validators=NoRepeat(),max='**'),
           GROUP_MA        =SIMP(statut='f',typ=grma,validators=NoRepeat(),max='**'),
           MAILLE          =SIMP(statut='f',typ=ma  ,validators=NoRepeat(),max='**'),
           DDL             =SIMP(statut='f',typ='TXM',max='**',defaut="TEMP",
                                 into=("TEMP","TEMP_INF","TEMP_SUP") ),
         ),

         LIAISON_CHAMNO  =FACT(statut='f',max='**',
           CHAM_NO         =SIMP(statut='o',typ=cham_no_sdaster),# CO()# "il faut definir une structure de donnee generique chamno"
           COEF_IMPO       =SIMP(statut='o',typ='R' ),
           NUME_LAGR       =SIMP(statut='f',typ='TXM',defaut="NORMAL",into=("NORMAL","APRES") ),
         ),

         CONVECTION      =FACT(statut='f',max='**',
           VITESSE         =SIMP(statut='o',typ=(cham_no_sdaster) ),
         ),


         INFO            =SIMP(statut='f',typ='I',defaut= 1,into=(1,2) ),
)  ;
#& MODIF COMMANDE  DATE 21/02/2006   AUTEUR REZETTE C.REZETTE 
#            CONFIGURATION MANAGEMENT OF EDF VERSION
# ======================================================================
# COPYRIGHT (C) 1991 - 2001  EDF R&D                  WWW.CODE-ASTER.ORG
# THIS PROGRAM IS FREE SOFTWARE; YOU CAN REDISTRIBUTE IT AND/OR MODIFY
# IT UNDER THE TERMS OF THE GNU GENERAL PUBLIC LICENSE AS PUBLISHED BY
# THE FREE SOFTWARE FOUNDATION; EITHER VERSION 2 OF THE LICENSE, OR   
# (AT YOUR OPTION) ANY LATER VERSION.                                 
#
# THIS PROGRAM IS DISTRIBUTED IN THE HOPE THAT IT WILL BE USEFUL, BUT 
# WITHOUT ANY WARRANTY; WITHOUT EVEN THE IMPLIED WARRANTY OF          
# MERCHANTABILITY OR FITNESS FOR A PARTICULAR PURPOSE. SEE THE GNU    
# GENERAL PUBLIC LICENSE FOR MORE DETAILS.                            
#
# YOU SHOULD HAVE RECEIVED A COPY OF THE GNU GENERAL PUBLIC LICENSE   
# ALONG WITH THIS PROGRAM; IF NOT, WRITE TO EDF R&D CODE_ASTER,       
#    1 AVENUE DU GENERAL DE GAULLE, 92141 CLAMART CEDEX, FRANCE.      
# ======================================================================
AFFE_CHAR_THER_F=OPER(nom="AFFE_CHAR_THER_F",op=33,sd_prod=char_ther,
                     fr="Affectation de charges et conditions aux limites thermiques fonction d'un (ou plusieurs)"
                         +" paramètres (temps, ...)",
                     reentrant='n',
            UIinfo={"groupes":("Modélisation",)},
      regles=(AU_MOINS_UN('TEMP_IMPO','SOURCE','FLUX_REP','FLUX_NL','ECHANGE',
                          'ECHANGE_PAROI','LIAISON_DDL','LIAISON_GROUP','LIAISON_UNIF',
                          'GRAD_TEMP_INIT','RAYONNEMENT'),),
         MODELE          =SIMP(statut='o',typ=(modele_sdaster) ),

         TEMP_IMPO       =FACT(statut='f',max='**',
           regles=(AU_MOINS_UN('TOUT','GROUP_MA','MAILLE','GROUP_NO','NOEUD'),
                   AU_MOINS_UN('TEMP_SUP','TEMP','TEMP_INF','EVOL_THER'),
                   PRESENT_ABSENT('EVOL_THER','TEMP','TEMP_INF','TEMP_SUP'),),
           TOUT            =SIMP(statut='f',typ='TXM',into=("OUI",) ),
           GROUP_MA        =SIMP(statut='f',typ=grma,validators=NoRepeat(),max='**'),
           MAILLE          =SIMP(statut='f',typ=ma  ,validators=NoRepeat(),max='**'),
           GROUP_NO        =SIMP(statut='f',typ=grno,validators=NoRepeat(),max='**'),
           NOEUD           =SIMP(statut='f',typ=no  ,validators=NoRepeat(),max='**'),
           EVOL_THER       =SIMP(statut='f',typ=(evol_ther) ),
           DDL             =SIMP(statut='f',typ='TXM',into=("TEMP",) ),
           TEMP            =SIMP(statut='f',typ=(fonction_sdaster,nappe_sdaster,formule) ),
           TEMP_INF        =SIMP(statut='f',typ=(fonction_sdaster,nappe_sdaster,formule) ),
           TEMP_SUP        =SIMP(statut='f',typ=(fonction_sdaster,nappe_sdaster,formule) ),
         ),
         
         FLUX_REP        =FACT(statut='f',max='**',
           regles=(AU_MOINS_UN('TOUT','GROUP_MA','MAILLE'),
                   PRESENT_ABSENT('TOUT','GROUP_MA','MAILLE'),
                   AU_MOINS_UN('FLUN','FLUN_INF','FLUN_SUP','FLUX_X','FLUX_Y','FLUX_Z'),),
           TOUT            =SIMP(statut='f',typ='TXM',into=("OUI",) ),
           GROUP_MA        =SIMP(statut='f',typ=grma,validators=NoRepeat(),max='**'),
           MAILLE          =SIMP(statut='f',typ=ma  ,validators=NoRepeat(),max='**'),
           FLUN            =SIMP(statut='f',typ=(fonction_sdaster,nappe_sdaster,formule) ),
           FLUN_INF        =SIMP(statut='f',typ=(fonction_sdaster,nappe_sdaster,formule) ),
           FLUN_SUP        =SIMP(statut='f',typ=(fonction_sdaster,nappe_sdaster,formule) ),
           FLUX_X          =SIMP(statut='f',typ=(fonction_sdaster,nappe_sdaster,formule) ),
           FLUX_Y          =SIMP(statut='f',typ=(fonction_sdaster,nappe_sdaster,formule) ),
           FLUX_Z          =SIMP(statut='f',typ=(fonction_sdaster,nappe_sdaster,formule) ),
         ),

         FLUX_NL         =FACT(statut='f',max='**',
           regles=(AU_MOINS_UN('TOUT','GROUP_MA','MAILLE'),
                   PRESENT_ABSENT('TOUT','GROUP_MA','MAILLE'),),
           TOUT            =SIMP(statut='f',typ='TXM',into=("OUI",) ),
           GROUP_MA        =SIMP(statut='f',typ=grma,validators=NoRepeat(),max='**'),
           MAILLE          =SIMP(statut='f',typ=ma  ,validators=NoRepeat(),max='**'),
           FLUN            =SIMP(statut='o',typ=(fonction_sdaster,nappe_sdaster,formule) ),
         ), 
         

         RAYONNEMENT     =FACT(statut='f',max='**',
           fr="Attention, exprimer les températures en Celsius si rayonnement",
           regles=(AU_MOINS_UN('TOUT','GROUP_MA','MAILLE'),
                   PRESENT_ABSENT('TOUT','GROUP_MA','MAILLE'),),
           TOUT            =SIMP(statut='f',typ='TXM',into=("OUI",) ),
           GROUP_MA        =SIMP(statut='f',typ=grma,validators=NoRepeat(),max='**'),
           MAILLE          =SIMP(statut='f',typ=ma  ,validators=NoRepeat(),max='**'),
           SIGMA           =SIMP(statut='o',typ=(fonction_sdaster,nappe_sdaster,formule) ),
           EPSILON         =SIMP(statut='o',typ=(fonction_sdaster,nappe_sdaster,formule) ),
           TEMP_EXT        =SIMP(statut='o',typ=(fonction_sdaster,nappe_sdaster,formule) ),
         ),
         


         ECHANGE         =FACT(statut='f',max='**',
           regles=(AU_MOINS_UN('TOUT','GROUP_MA','MAILLE'),
                   PRESENT_ABSENT('TOUT','GROUP_MA','MAILLE'),
                   AU_MOINS_UN('COEF_H','COEF_H_INF','COEF_H_SUP'),
                   ENSEMBLE('COEF_H','TEMP_EXT'),
                   ENSEMBLE('COEF_H_INF','TEMP_EXT_INF'),
                   ENSEMBLE('COEF_H_SUP','TEMP_EXT_SUP'),),
           TOUT            =SIMP(statut='f',typ='TXM',into=("OUI",) ),
           GROUP_MA        =SIMP(statut='f',typ=grma,validators=NoRepeat(),max='**'),
           MAILLE          =SIMP(statut='f',typ=ma  ,validators=NoRepeat(),max='**'),
           COEF_H          =SIMP(statut='f',typ=(fonction_sdaster,nappe_sdaster,formule) ),
           TEMP_EXT        =SIMP(statut='f',typ=(fonction_sdaster,nappe_sdaster,formule) ),
           COEF_H_INF      =SIMP(statut='f',typ=(fonction_sdaster,nappe_sdaster,formule) ),
           TEMP_EXT_INF    =SIMP(statut='f',typ=(fonction_sdaster,nappe_sdaster,formule) ),
           COEF_H_SUP      =SIMP(statut='f',typ=(fonction_sdaster,nappe_sdaster,formule) ),
           TEMP_EXT_SUP    =SIMP(statut='f',typ=(fonction_sdaster,nappe_sdaster,formule) ),
         ),
         

         SOURCE          =FACT(statut='f',max='**',
           regles=(UN_PARMI('TOUT','GROUP_MA','MAILLE'),),
           TOUT            =SIMP(statut='f',typ='TXM',into=("OUI",) ),
           GROUP_MA        =SIMP(statut='f',typ=grma,validators=NoRepeat(),max='**'),
           MAILLE          =SIMP(statut='f',typ=ma  ,validators=NoRepeat(),max='**'),
           SOUR            =SIMP(statut='o',typ=(fonction_sdaster,nappe_sdaster,formule) ),
         ),
         
         GRAD_TEMP_INIT  =FACT(statut='f',max='**',
           regles=(AU_MOINS_UN('TOUT','GROUP_MA','MAILLE'),
                   PRESENT_ABSENT('TOUT','GROUP_MA','MAILLE'),
                   AU_MOINS_UN('FLUX_X','FLUX_Y','FLUX_Z'),),
           TOUT            =SIMP(statut='f',typ='TXM',into=("OUI",) ),
           GROUP_MA        =SIMP(statut='f',typ=grma,validators=NoRepeat(),max='**'),
           MAILLE          =SIMP(statut='f',typ=ma  ,validators=NoRepeat(),max='**'),
           FLUX_X          =SIMP(statut='f',typ=(fonction_sdaster,nappe_sdaster,formule) ),
           FLUX_Y          =SIMP(statut='f',typ=(fonction_sdaster,nappe_sdaster,formule) ),
           FLUX_Z          =SIMP(statut='f',typ=(fonction_sdaster,nappe_sdaster,formule) ),
         ),
         
         ECHANGE_PAROI   =FACT(statut='f',max='**',
           regles=(UN_PARMI('GROUP_MA_1','MAILLE_1'),
                        UN_PARMI('GROUP_MA_2','MAILLE_2'),),
           GROUP_MA_1      =SIMP(statut='f',typ=grma,validators=NoRepeat(),max='**'),
           MAILLE_1        =SIMP(statut='f',typ=ma  ,validators=NoRepeat(),max='**'),
           GROUP_MA_2      =SIMP(statut='f',typ=grma,validators=NoRepeat(),max='**'),
           MAILLE_2        =SIMP(statut='f',typ=ma  ,validators=NoRepeat(),max='**'),
           COEF_H          =SIMP(statut='o',typ=(fonction_sdaster,nappe_sdaster,formule) ),
           TRAN            =SIMP(statut='f',typ='R',min=2,max=3),
           ANGL_NAUT       =SIMP(statut='f',typ='R',max=3),
           CENTRE          =SIMP(statut='f',typ='R',min=2,max=3),
         ),

        LIAISON_DDL     =FACT(statut='f',max='**',
           regles=(UN_PARMI('GROUP_NO','NOEUD'),),
           GROUP_NO        =SIMP(statut='f',typ=grno,max='**'),
           NOEUD           =SIMP(statut='f',typ=no  ,max='**'),
           DDL             =SIMP(statut='f',typ='TXM',max='**',into=("TEMP","TEMP_INF","TEMP_SUP") ),
           COEF_MULT       =SIMP(statut='o',typ='R',max='**'),
           COEF_IMPO       =SIMP(statut='o',typ=(fonction_sdaster,nappe_sdaster,formule) ),
         ),

         LIAISON_GROUP   =FACT(statut='f',max='**',
           regles=(UN_PARMI('GROUP_MA_1','MAILLE_1','GROUP_NO_1','NOEUD_1'),
                   UN_PARMI('GROUP_MA_2','MAILLE_2','GROUP_NO_2','NOEUD_2'),
                             EXCLUS('GROUP_MA_1','GROUP_NO_2'),
                        EXCLUS('GROUP_MA_1','NOEUD_2'),
                   EXCLUS('GROUP_NO_1','GROUP_MA_2'),
                        EXCLUS('GROUP_NO_1','MAILLE_2'),
                        EXCLUS('MAILLE_1','GROUP_NO_2'),
                        EXCLUS('MAILLE_1','NOEUD_2'),
                        EXCLUS('NOEUD_1','GROUP_MA_2'),
                        EXCLUS('NOEUD_1','MAILLE_2'),
                        EXCLUS('SANS_NOEUD','SANS_GROUP_NO'),),
           GROUP_MA_1      =SIMP(statut='f',typ=grma,validators=NoRepeat(),max='**'),
           MAILLE_1        =SIMP(statut='f',typ=ma  ,validators=NoRepeat(),max='**'),
           GROUP_NO_1      =SIMP(statut='f',typ=grno,validators=NoRepeat(),max='**'),
           NOEUD_1         =SIMP(statut='f',typ=no  ,validators=NoRepeat(),max='**'),
           GROUP_MA_2      =SIMP(statut='f',typ=grma,validators=NoRepeat(),max='**'),
           MAILLE_2        =SIMP(statut='f',typ=ma  ,validators=NoRepeat(),max='**'),
           GROUP_NO_2      =SIMP(statut='f',typ=grno,validators=NoRepeat(),max='**'),
           NOEUD_2         =SIMP(statut='f',typ=no  ,validators=NoRepeat(),max='**'),
           SANS_NOEUD      =SIMP(statut='f',typ=no  ,validators=NoRepeat(),max='**'),
           SANS_GROUP_NO   =SIMP(statut='f',typ=grno,validators=NoRepeat(),max='**'),
           DDL_1           =SIMP(statut='f',typ='TXM',max='**',defaut="TEMP",
                                 into=("TEMP","TEMP_INF","TEMP_SUP") ),
           COEF_MULT_1     =SIMP(statut='o',typ='R',max='**'),
           DDL_2           =SIMP(statut='f',typ='TXM',max='**',defaut="TEMP",
                                 into=("TEMP","TEMP_INF","TEMP_SUP") ),
           COEF_MULT_2     =SIMP(statut='o',typ='R',max='**'),
           COEF_IMPO       =SIMP(statut='o',typ=(fonction_sdaster,nappe_sdaster,formule) ),
           SOMMET          =SIMP(statut='f',typ='TXM',into=("OUI",) ),
           TRAN            =SIMP(statut='f',typ='R',max='**'),
           ANGL_NAUT       =SIMP(statut='f',typ='R',max='**'),
           CENTRE          =SIMP(statut='f',typ='R',max='**'),
         ),

         LIAISON_UNIF    =FACT(statut='f',max='**',
           regles=(UN_PARMI('GROUP_NO','NOEUD','GROUP_MA','MAILLE'),),
           GROUP_NO        =SIMP(statut='f',typ=grno,validators=NoRepeat(),max='**'),
           NOEUD           =SIMP(statut='f',typ=no  ,validators=NoRepeat(),max='**'),
           GROUP_MA        =SIMP(statut='f',typ=grma,validators=NoRepeat(),max='**'),
           MAILLE          =SIMP(statut='f',typ=ma  ,validators=NoRepeat(),max='**'),
           DDL             =SIMP(statut='f',typ='TXM',defaut="TEMP",
                                 into=("TEMP","TEMP_INF","TEMP_SUP") ),
         ),

         CONVECTION      =FACT(statut='f',max='**',
           VITESSE         =SIMP(statut='o',typ=cham_no_sdaster ),
         ),

         INFO            =SIMP(statut='f',typ='I',defaut= 1,into=(1,2) ),
)  ;
#& MODIF COMMANDE  DATE 28/08/2006   AUTEUR CIBHHPD L.SALMONA 
#            CONFIGURATION MANAGEMENT OF EDF VERSION
# ======================================================================
# COPYRIGHT (C) 1991 - 2001  EDF R&D                  WWW.CODE-ASTER.ORG
# THIS PROGRAM IS FREE SOFTWARE; YOU CAN REDISTRIBUTE IT AND/OR MODIFY
# IT UNDER THE TERMS OF THE GNU GENERAL PUBLIC LICENSE AS PUBLISHED BY
# THE FREE SOFTWARE FOUNDATION; EITHER VERSION 2 OF THE LICENSE, OR
# (AT YOUR OPTION) ANY LATER VERSION.
#
# THIS PROGRAM IS DISTRIBUTED IN THE HOPE THAT IT WILL BE USEFUL, BUT
# WITHOUT ANY WARRANTY; WITHOUT EVEN THE IMPLIED WARRANTY OF
# MERCHANTABILITY OR FITNESS FOR A PARTICULAR PURPOSE. SEE THE GNU
# GENERAL PUBLIC LICENSE FOR MORE DETAILS.
#
# YOU SHOULD HAVE RECEIVED A COPY OF THE GNU GENERAL PUBLIC LICENSE
# ALONG WITH THIS PROGRAM; IF NOT, WRITE TO EDF R&D CODE_ASTER,
#    1 AVENUE DU GENERAL DE GAULLE, 92141 CLAMART CEDEX, FRANCE.
# ======================================================================
# RESPONSABLE VABHHTS J.PELLET
AFFE_MATERIAU=OPER(nom="AFFE_MATERIAU",op=6,sd_prod=cham_mater,
                   fr="Affecter des matériaux à des zones géométriques d'un maillage",
                         reentrant='n',
            UIinfo={"groupes":("Modélisation",)},
         MAILLAGE        =SIMP(statut='o',typ=maillage_sdaster),
         MODELE          =SIMP(statut='f',typ=modele_sdaster),

         #  affectation du nom du matériau (par mailles):
         #  ----------------------------------------------
         AFFE            =FACT(statut='o',max='**',
           regles=(UN_PARMI('TOUT','GROUP_MA','MAILLE'),),
           TOUT            =SIMP(statut='f',typ='TXM',into=("OUI",) ),
           GROUP_MA        =SIMP(statut='f',typ=grma,validators=NoRepeat(),max='**'),
           MAILLE          =SIMP(statut='f',typ=ma  ,validators=NoRepeat(),max='**'),
           MATER           =SIMP(statut='o',typ=mater_sdaster,max=30),
           TEMP_REF        =SIMP(statut='f',typ='R',defaut= 0.E+0 ),
         ),

         #  affectation du nom du matériau (par noeuds):
         #  ----------------------------------------------
         AFFE_NOEUD        =FACT(statut='f',max='**',
           regles=(UN_PARMI('TOUT','GROUP_MA','MAILLE'),),
           TOUT            =SIMP(statut='f',typ='TXM',into=("OUI",) ),
           GROUP_MA        =SIMP(statut='f',typ=grma,validators=NoRepeat(),max='**'),
           MAILLE          =SIMP(statut='f',typ=ma  ,validators=NoRepeat(),max='**'),
           MATER           =SIMP(statut='o',typ=mater_sdaster,max=1),
         ),

         #  affectation des variables de commande :
         #  --------------------------------------------------
         # un mot clé caché qui ne sert qu'à boucler sur les VARC possibles :
         LIST_NOM_VARC =SIMP(statut='c',typ='TXM', defaut=("CORR","IRRA","HYDR","SECH","EPSA","M_ACIER","M_ZIRC","NEUT1","NEUT2")),

         AFFE_VARC    =FACT(statut='f',max='**',
          regles=(PRESENT_ABSENT('TOUT','GROUP_MA','MAILLE'),
                  PRESENT_ABSENT('GROUP_MA','TOUT'),
                  PRESENT_ABSENT('MAILLE','TOUT'),
                  UN_PARMI('EVOL','CHAMP_GD'),),

          TOUT            =SIMP(statut='f',typ='TXM',into=("OUI",) ), # [défaut]
          GROUP_MA        =SIMP(statut='f',typ=grma,validators=NoRepeat(),max='**'),
          MAILLE          =SIMP(statut='f',typ=ma  ,validators=NoRepeat(),max='**'),

          CHAMP_GD      =SIMP(statut='f',typ=cham_gd_sdaster,),
          B_CHAMP_GD    =BLOC(condition="CHAMP_GD!=None",
              NOM_VARC    =SIMP(statut='o',typ='TXM', into=("CORR","IRRA","HYDR","SECH","M_ACIER","M_ZIRC","EPSA","NEUT1","NEUT2")),
          ),
          EVOL            =SIMP(statut='f',typ=evol_sdaster,),
          B_EVOL          =BLOC(condition="EVOL!=None",
              NOM_VARC    =SIMP(statut='o',typ='TXM', into=("CORR","IRRA","HYDR","SECH","M_ACIER","M_ZIRC","EPSA","NEUT1","NEUT2")),
              B_NOM_CORR    =BLOC(condition="NOM_VARC=='CORR'",NOM_CHAM=SIMP(statut='f',typ='TXM',defaut= 'CORR',),),
              B_NOM_IRRA    =BLOC(condition="NOM_VARC=='IRRA'",NOM_CHAM=SIMP(statut='f',typ='TXM',defaut= 'IRRA',),),
              B_NOM_HYDR    =BLOC(condition="NOM_VARC=='HYDR'",NOM_CHAM=SIMP(statut='f',typ='TXM',defaut= 'HYDR_ELNO_ELGA',),),
              B_NOM_SECH    =BLOC(condition="NOM_VARC=='SECH'",NOM_CHAM=SIMP(statut='f',typ='TXM',defaut= 'TEMP',),),
              B_NOM_EPSA    =BLOC(condition="NOM_VARC=='EPSA'",NOM_CHAM=SIMP(statut='f',typ='TXM',defaut= 'EPSA_ELNO',),),
              B_NOM_M_ACIER =BLOC(condition="NOM_VARC=='M_ACIER'",NOM_CHAM=SIMP(statut='f',typ='TXM',defaut= 'META_ELNO_TEMP',),),
              B_NOM_M_ZIRC  =BLOC(condition="NOM_VARC=='M_ZIRC'",NOM_CHAM=SIMP(statut='f',typ='TXM',defaut= 'META_ELNO_TEMP',),),
              B_NOM_NEUT1   =BLOC(condition="NOM_VARC=='NEUT1'",NOM_CHAM=SIMP(statut='f',typ='TXM',defaut= 'NEUT',),),
              B_NOM_NEUT2   =BLOC(condition="NOM_VARC=='NEUT2'",NOM_CHAM=SIMP(statut='f',typ='TXM',defaut= 'NEUT',),),
              PROL_DROITE   =SIMP(statut='f',typ='TXM',defaut="EXCLU",into=("CONSTANT","LINEAIRE","EXCLU") ),
              PROL_GAUCHE   =SIMP(statut='f',typ='TXM',defaut="EXCLU",into=("CONSTANT","LINEAIRE","EXCLU") ),
          ),
          VALE_REF          =SIMP(statut='f',typ='R'),
         ),

         #  mots clés cachés pour les variables de commande NEUTi :
         #  -------------------------------------------------------
         VARC_NEUT1   =FACT(statut='d',
           NOM_VARC        =SIMP(statut='c',typ='TXM',defaut="NEUT1"),
           GRANDEUR        =SIMP(statut='c',typ='TXM',defaut="NEUT_R"),
           CMP_GD          =SIMP(statut='c',typ='TXM',max=1,min=1,defaut=("X1")),
           CMP_VARC        =SIMP(statut='c',typ='TXM',max=1,min=1,defaut=("NEUT1")),
         ),
         VARC_NEUT2   =FACT(statut='d',
           NOM_VARC        =SIMP(statut='c',typ='TXM',defaut="NEUT2"),
           GRANDEUR        =SIMP(statut='c',typ='TXM',defaut="NEUT_R"),
           CMP_GD          =SIMP(statut='c',typ='TXM',max=1,min=1,defaut=("X1")),
           CMP_VARC        =SIMP(statut='c',typ='TXM',max=1,min=1,defaut=("NEUT2")),
         ),

         #  mots clés cachés pour variable de commande TEMP :
         #  --------------------------------------------------
         VARC_TEMP    =FACT(statut='d',
           NOM_VARC        =SIMP(statut='c',typ='TXM',defaut="TEMP"),
           GRANDEUR        =SIMP(statut='c',typ='TXM',defaut="TEMP_R"),
           CMP_GD          =SIMP(statut='c',typ='TXM',max=1,min=1,defaut=("TEMP",)),
           CMP_VARC        =SIMP(statut='c',typ='TXM',max=1,min=1,defaut=("TEMP",)),
         ),

         #  mots clés cachés pour variable de commande SECH :
         #  --------------------------------------------------
         VARC_SECH    =FACT(statut='d',
           NOM_VARC        =SIMP(statut='c',typ='TXM',defaut="SECH"),
           GRANDEUR        =SIMP(statut='c',typ='TXM',defaut="TEMP_R"),
           CMP_GD          =SIMP(statut='c',typ='TXM',max=1,min=1,defaut=("TEMP",)),
           CMP_VARC        =SIMP(statut='c',typ='TXM',max=1,min=1,defaut=("SECH",)),
           VALE_DEF        =SIMP(statut='c',typ='R',max=1,min=1,defaut=(0.,)),
         ),

         #  mots clés cachés pour variable de commande HYDR :
         #  --------------------------------------------------
         VARC_HYDR    =FACT(statut='d',
           NOM_VARC        =SIMP(statut='c',typ='TXM',defaut="HYDR"),
           GRANDEUR        =SIMP(statut='c',typ='TXM',defaut="HYDR_R"),
           CMP_GD          =SIMP(statut='c',typ='TXM',max=1,min=1,defaut=("HYDR",)),
           CMP_VARC        =SIMP(statut='c',typ='TXM',max=1,min=1,defaut=("HYDR",)),
           VALE_DEF        =SIMP(statut='c',typ='R',max=1,min=1,defaut=(0.,)),
         ),

         #  mots clés cachés pour variable de commande CORR :
         #  --------------------------------------------------
         VARC_CORR    =FACT(statut='d',
           NOM_VARC        =SIMP(statut='c',typ='TXM',defaut="CORR"),
           GRANDEUR        =SIMP(statut='c',typ='TXM',defaut="CORR_R"),
           CMP_GD          =SIMP(statut='c',typ='TXM',max=1,min=1,defaut=("CORR",)),
           CMP_VARC        =SIMP(statut='c',typ='TXM',max=1,min=1,defaut=("CORR",)),
         ),

         #  mots clés cachés pour variable de commande IRRA :
         #  --------------------------------------------------
         VARC_IRRA    =FACT(statut='d',
           NOM_VARC        =SIMP(statut='c',typ='TXM',defaut="IRRA"),
           GRANDEUR        =SIMP(statut='c',typ='TXM',defaut="IRRA_R"),
           CMP_GD          =SIMP(statut='c',typ='TXM',max=1,min=1,defaut=("IRRA",)),
           CMP_VARC        =SIMP(statut='c',typ='TXM',max=1,min=1,defaut=("IRRA",)),
           VALE_DEF        =SIMP(statut='c',typ='R',max=1,min=1,defaut=(0.,)),
         ),

         #  mots clés cachés pour variable de commande EPSA :
         #  --------------------------------------------------
         VARC_EPSA    =FACT(statut='d',
           NOM_VARC        =SIMP(statut='c',typ='TXM',defaut="EPSA"),
           GRANDEUR        =SIMP(statut='c',typ='TXM',defaut="EPSI_R"),
           CMP_GD          =SIMP(statut='c',typ='TXM',max=6,min=6,defaut=("EPXX","EPYY","EPZZ","EPXY","EPXZ","EPYZ",)),
           CMP_VARC        =SIMP(statut='c',typ='TXM',max=6,min=6,defaut=("EPSAXX","EPSAYY","EPSAZZ","EPSAXY","EPSAXZ","EPSAYZ",)),
           VALE_DEF        =SIMP(statut='c',typ='R',max=6,min=6,defaut=( 0.,    0.,    0.,    0.,    0.,    0.,   )),
         ),
         #  mots clés cachés pour variable de commande metallurgique ACIER :
         #  -----------------------------------------------------------------
         VARC_M_ACIER  =FACT(statut='d',
           NOM_VARC        =SIMP(statut='c',typ='TXM',defaut="M_ACIER"),
           GRANDEUR        =SIMP(statut='c',typ='TXM',defaut="VARI_R"),
           CMP_GD          =SIMP(statut='c',typ='TXM',max=7,min=7,defaut=("V1","V2","V3","V4","V5","V6","V7")),
           CMP_VARC        =SIMP(statut='c',typ='TXM',max=7,min=7,defaut=("PFERRITE","PPERLITE","PBAINITE",
                                                                          "PMARTENS","TAUSTE","TRANSF","TACIER",)),
           VALE_DEF        =SIMP(statut='c',typ='R',max=7,min=7,defaut=( 0.,    0.,    0.,    0.,    0.,    0.,   0.    )),
         ),
         #  mots clés cachés pour variable de commande metallurgique ZIRCALOY :
         #  --------------------------------------------------------------------
         VARC_M_ZIRC  =FACT(statut='d',
           NOM_VARC        =SIMP(statut='c',typ='TXM',defaut="M_ZIRC"),
           GRANDEUR        =SIMP(statut='c',typ='TXM',defaut="VARI_R"),
           CMP_GD          =SIMP(statut='c',typ='TXM',max=3,min=3,defaut=("V1","V2","V3")),
           CMP_VARC        =SIMP(statut='c',typ='TXM',max=3,min=3,defaut=("ALPHPUR","ALPHBETA","TZIRC",)),
           VALE_DEF        =SIMP(statut='c',typ='R',max=3,min=3,defaut=( 0.,    0.,    0.  )),
         ),
)  ;


#& MODIF COMMANDE  DATE 31/10/2006   AUTEUR A3BHHAE H.ANDRIAMBOLOLONA 
#            CONFIGURATION MANAGEMENT OF EDF VERSION
# ======================================================================
# COPYRIGHT (C) 1991 - 2001  EDF R&D                  WWW.CODE-ASTER.ORG
# THIS PROGRAM IS FREE SOFTWARE; YOU CAN REDISTRIBUTE IT AND/OR MODIFY
# IT UNDER THE TERMS OF THE GNU GENERAL PUBLIC LICENSE AS PUBLISHED BY
# THE FREE SOFTWARE FOUNDATION; EITHER VERSION 2 OF THE LICENSE, OR
# (AT YOUR OPTION) ANY LATER VERSION.
#
# THIS PROGRAM IS DISTRIBUTED IN THE HOPE THAT IT WILL BE USEFUL, BUT
# WITHOUT ANY WARRANTY; WITHOUT EVEN THE IMPLIED WARRANTY OF
# MERCHANTABILITY OR FITNESS FOR A PARTICULAR PURPOSE. SEE THE GNU
# GENERAL PUBLIC LICENSE FOR MORE DETAILS.
#
# YOU SHOULD HAVE RECEIVED A COPY OF THE GNU GENERAL PUBLIC LICENSE
# ALONG WITH THIS PROGRAM; IF NOT, WRITE TO EDF R&D CODE_ASTER,
#    1 AVENUE DU GENERAL DE GAULLE, 92141 CLAMART CEDEX, FRANCE.
# ======================================================================
# RESPONSABLE JMBHH01 J.M.PROIX
AFFE_MODELE=OPER(nom="AFFE_MODELE",op=18,sd_prod=modele_sdaster,
            UIinfo={"groupes":("Modélisation",)},
                 fr="Définir le phénomène physique modélisé et le type d'éléments finis sur le maillage",reentrant='n',
         regles=(AU_MOINS_UN('AFFE','AFFE_SOUS_STRUC'),),
         MAILLAGE        =SIMP(statut='o',typ=(maillage_sdaster) ),
         INFO            =SIMP(statut='f',typ='I',defaut=1,into=(1,2) ),
         VERIF           =SIMP(statut='f',typ='TXM',validators=NoRepeat(),max=2,into=("MAILLE","NOEUD") ),
         AFFE_SOUS_STRUC =FACT(statut='f',
           regles=(UN_PARMI('TOUT','SUPER_MAILLE'),),
           TOUT            =SIMP(statut='f',typ='TXM',into=("OUI",) ),
           SUPER_MAILLE    =SIMP(statut='f',typ=ma,validators=NoRepeat(),max='**'),
           PHENOMENE       =SIMP(statut='f',typ='TXM',defaut="MECANIQUE",into=("MECANIQUE",) ),
         ),
         AFFE            =FACT(statut='f',max='**',
           regles=(UN_PARMI('TOUT','GROUP_MA','GROUP_NO','MAILLE','NOEUD'),),
           TOUT            =SIMP(statut='f',typ='TXM',into=("OUI",) ),
           GROUP_MA        =SIMP(statut='f',typ=grma,validators=NoRepeat(),max='**'),
           GROUP_NO        =SIMP(statut='f',typ=grno,validators=NoRepeat(),max='**'),
           MAILLE          =SIMP(statut='f',typ=ma  ,validators=NoRepeat(),max='**'),
           NOEUD           =SIMP(statut='f',typ=no  ,validators=NoRepeat(),max='**'),
           PHENOMENE       =SIMP(statut='o',typ='TXM',
                                 into=("MECANIQUE","THERMIQUE","ACOUSTIQUE") ),
                b_mecanique     =BLOC( condition = "PHENOMENE=='MECANIQUE'",
                                        fr="modélisations mécaniques",
                    MODELISATION    =SIMP(statut='o',typ='TXM',validators=NoRepeat(),max='**',into=(
                                                                      "2D_DIS_T",
                                                                      "2D_DIS_TR",
                                                                      "2D_FLUI_ABSO",
                                                                      "2D_FLUI_PESA",
                                                                      "2D_FLUI_STRU",
                                                                      "2D_FLUIDE",
                                                                      "3D",
                                                                      "3D_ABSO",
                                                                      "3D_FAISCEAU",
                                                                      "3D_FLUI_ABSO",
                                                                      "3D_FLUIDE",
                                                                      "3D_INCO",
                                                                      "3D_SI",
                                                                      "3D_GRAD_EPSI",
                                                                      "3D_GRAD_VARI",
                                                                      "3D_XFEM",
                                                                      "AXIS",
                                                                      "AXIS_FLUI_STRU",
                                                                      "AXIS_FLUIDE",
                                                                      "AXIS_FOURIER",
                                                                      "AXIS_INCO",
                                                                      "AXIS_NS",
                                                                      "AXIS_SI",
                                                                      "AXIS_GRAD_VARI",
                                                                      "AXIS_JOINT",
                                                                      "AXIS_ELDI",
                                                                      "BARRE",
                                                                      "2D_BARRE",
                                                                      "C_PLAN",
                                                                      "C_PLAN_X",
                                                                      "C_PLAN_NS",
                                                                      "C_PLAN_SI",
                                                                      "C_PLAN_GRAD_EPSI",
                                                                      "C_PLAN_GRAD_VARI",
                                                                      "CABLE",
                                                                      "CABLE_POULIE",
                                                                      "COQUE_3D",
                                                                      "COQUE_AXIS",
                                                                      "COQUE_C_PLAN",
                                                                      "COQUE_D_PLAN",
                                                                      "D_PLAN",
                                                                      "D_PLAN_X",
                                                                      "D_PLAN_GRAD_EPSI",
                                                                      "D_PLAN_GRAD_VARI",
                                                                      "D_PLAN_NS",
                                                                      "PLAN_JOINT",
                                                                      "PLAN_ELDI",
                                                                      "D_PLAN_ABSO",
                                                                      "D_PLAN_INCO",
                                                                      "D_PLAN_SI",
                                                                      "DIS_T",
                                                                      "DIS_TR",
                                                                      "DKT",
                                                                      "DKTG",
                                                                      "DST",
                                                                      "FLUI_STRU",
                                                                      "GRILLE",
                                                                      "GRILLE_MEMBRANE",
                                                                      "POU_C_T",
                                                                      "POU_D_E",
                                                                      "POU_D_EM",
                                                                      "POU_D_T",
                                                                      "POU_D_T_GD",
                                                                      "POU_D_TG",
                                                                      "POU_D_TGM",
                                                                      "Q4G",
                                                                      "TUYAU_3M",
                                                                      "TUYAU_6M",
                                                                      "SHB8",
                                                                      "D_PLAN_HHM",
                                                                      "D_PLAN_HM",
                                                                      "D_PLAN_THH",
                                                                      "D_PLAN_THHM",
                                                                      "D_PLAN_THM",
                                                                      "D_PLAN_HHMD",
                                                                      "D_PLAN_HH2MD",
                                                                      "D_PLAN_HMD",
                                                                      "D_PLAN_THHD",
                                                                      "D_PLAN_THH2D",
                                                                      "D_PLAN_THVD",
                                                                      "D_PLAN_THH2MD",
                                                                      "D_PLAN_THHMD",
                                                                      "D_PLAN_THMD", 
                                                                      "D_PLAN_HHMS",
                                                                      "D_PLAN_HH2MS",
                                                                      "D_PLAN_HMS",
                                                                      "D_PLAN_THHS",
                                                                      "D_PLAN_THH2S",
                                                                      "D_PLAN_THVS",
                                                                      "D_PLAN_THH2MS",
                                                                      "D_PLAN_THHMS",
                                                                      "D_PLAN_THMS", 
                                                                      "D_PLAN_HM_P",
                                                                      "AXIS_THH",
                                                                      "AXIS_THHM",
                                                                      "AXIS_THM",
                                                                      "AXIS_HHM",
                                                                      "AXIS_HM",
                                                                      "AXIS_HH2MD",
                                                                      "AXIS_HHMD",
                                                                      "AXIS_HMD",
                                                                      "AXIS_THHD",
                                                                      "AXIS_THH2D",
                                                                      "AXIS_THVD",
                                                                      "AXIS_THHMD",
                                                                      "AXIS_THH2MD",
                                                                      "AXIS_THMD",
                                                                      "AXIS_HH2MS",
                                                                      "AXIS_HHMS",
                                                                      "AXIS_HMS",
                                                                      "AXIS_THHS",
                                                                      "AXIS_THH2S",
                                                                      "AXIS_THVS",
                                                                      "AXIS_THHMS",
                                                                      "AXIS_THH2MS",
                                                                      "AXIS_THMS",
                                                                      "3D_HHM" ,
                                                                      "3D_HM",
                                                                      "3D_THH",
                                                                      "3D_THV",
                                                                      "3D_THHM",
                                                                      "3D_THM",
                                                                      "3D_HHMD",
                                                                      "3D_HMD",
                                                                      "3D_THHD",
                                                                      "3D_THVD",
                                                                      "3D_THHMD",
                                                                      "3D_THMD",
                                                                      "3D_HHMS",
                                                                      "3D_HMS",
                                                                      "3D_THHS",
                                                                      "3D_THVS",
                                                                      "3D_THHMS",
                                                                      "3D_THMS",
                                                                      "3D_THH2MD",
                                                                      "3D_THH2MS",
                                                                      "3D_HH2MD",
                                                                      "3D_HH2MS",
                                                                      "3D_THH2S",
                                                                      "3D_THH2D",
                                                                     )  )  ),

                b_thermique     =BLOC( condition = "PHENOMENE=='THERMIQUE'",
                                        fr="modélisations thermiques",
                    MODELISATION    =SIMP(statut='o',typ='TXM',validators=NoRepeat(),max='**',into=(
                                                                      "3D",
                                                                      "3D_DIAG",
                                                                      "AXIS",
                                                                      "AXIS_DIAG",
                                                                      "AXIS_FOURIER",
                                                                      "COQUE",
                                                                      "COQUE_AXIS",
                                                                      "COQUE_PLAN",
                                                                      "PLAN",
                                                                      "PLAN_DIAG",
                                                                      ),),),

                b_acoustique    =BLOC( condition = "PHENOMENE=='ACOUSTIQUE'",
                                        fr="modélisations acoustiques",
                     MODELISATION    =SIMP(statut='o',typ='TXM',validators=NoRepeat(),max='**',into=(
                                                                       "3D",
                                                                       "PLAN"
                                                                       ), ),),

         ),
) ;
#& MODIF COMMANDE  DATE 22/06/2005   AUTEUR REZETTE C.REZETTE 
#            CONFIGURATION MANAGEMENT OF EDF VERSION
# ======================================================================
# COPYRIGHT (C) 1991 - 2001  EDF R&D                  WWW.CODE-ASTER.ORG
# THIS PROGRAM IS FREE SOFTWARE; YOU CAN REDISTRIBUTE IT AND/OR MODIFY
# IT UNDER THE TERMS OF THE GNU GENERAL PUBLIC LICENSE AS PUBLISHED BY
# THE FREE SOFTWARE FOUNDATION; EITHER VERSION 2 OF THE LICENSE, OR   
# (AT YOUR OPTION) ANY LATER VERSION.                                 
#
# THIS PROGRAM IS DISTRIBUTED IN THE HOPE THAT IT WILL BE USEFUL, BUT 
# WITHOUT ANY WARRANTY; WITHOUT EVEN THE IMPLIED WARRANTY OF          
# MERCHANTABILITY OR FITNESS FOR A PARTICULAR PURPOSE. SEE THE GNU    
# GENERAL PUBLIC LICENSE FOR MORE DETAILS.                            
#
# YOU SHOULD HAVE RECEIVED A COPY OF THE GNU GENERAL PUBLIC LICENSE   
# ALONG WITH THIS PROGRAM; IF NOT, WRITE TO EDF R&D CODE_ASTER,       
#    1 AVENUE DU GENERAL DE GAULLE, 92141 CLAMART CEDEX, FRANCE.      
# ======================================================================
AIDE=PROC(nom="AIDE",op=42,
       UIinfo={"groupes":("Modélisation",)},
       fr="Interroger et imprimer une documentation partielle sur les noms des concepts déjà définis et sur les couples"
           +" (type d'éléments, option) disponibles dans la version.",
       regles=(AU_MOINS_UN('CONCEPT','TYPE_ELEM', ),),
       UNITE       =SIMP(statut='f',typ='I',defaut=8),  
       TYPE_ELEM   =FACT(fr="couple type_elem option",statut='f',
         INITEL       =SIMP(statut='f',typ='TXM',defaut="NON",into=("OUI","NON",) ),
                        ),
       CONCEPT     =FACT(statut='f',max='**',
         NOM          =SIMP(fr="liste des noms de concept",statut='f',typ='TXM',validators=NoRepeat(),max='**',defaut="*"),
         OPTION       =SIMP(fr="option d'édition de concept",statut='f',typ='TXM',defaut="TOUT_TYPE",
                                 into=("TOUT_TYPE","CREER","A_CREER",) ),
         ),
) ;
#& MODIF COMMANDE  DATE 22/06/2005   AUTEUR REZETTE C.REZETTE 
#            CONFIGURATION MANAGEMENT OF EDF VERSION
# ======================================================================
# COPYRIGHT (C) 1991 - 2001  EDF R&D                  WWW.CODE-ASTER.ORG
# THIS PROGRAM IS FREE SOFTWARE; YOU CAN REDISTRIBUTE IT AND/OR MODIFY
# IT UNDER THE TERMS OF THE GNU GENERAL PUBLIC LICENSE AS PUBLISHED BY
# THE FREE SOFTWARE FOUNDATION; EITHER VERSION 2 OF THE LICENSE, OR   
# (AT YOUR OPTION) ANY LATER VERSION.                                 
#
# THIS PROGRAM IS DISTRIBUTED IN THE HOPE THAT IT WILL BE USEFUL, BUT 
# WITHOUT ANY WARRANTY; WITHOUT EVEN THE IMPLIED WARRANTY OF          
# MERCHANTABILITY OR FITNESS FOR A PARTICULAR PURPOSE. SEE THE GNU    
# GENERAL PUBLIC LICENSE FOR MORE DETAILS.                            
#
# YOU SHOULD HAVE RECEIVED A COPY OF THE GNU GENERAL PUBLIC LICENSE   
# ALONG WITH THIS PROGRAM; IF NOT, WRITE TO EDF R&D CODE_ASTER,       
#    1 AVENUE DU GENERAL DE GAULLE, 92141 CLAMART CEDEX, FRANCE.      
# ======================================================================
# RESPONSABLE VABHHTS J.PELLET
ASSE_MAILLAGE=OPER(nom="ASSE_MAILLAGE",op= 105,sd_prod=maillage_sdaster,
                   fr="Assembler deux maillages pour en former un nouveau",
                   reentrant='n',
                   UIinfo={"groupes":("Maillage",)},
         MAILLAGE_1 =  SIMP(statut='o',typ=maillage_sdaster,),
         MAILLAGE_2 =  SIMP(statut='o',typ=maillage_sdaster,),
         OPERATION  =  SIMP(statut='o',typ='TXM',into=("SOUS_STR","SUPERPOSE","COLLAGE"),),
         b_collage  =  BLOC(condition = "OPERATION == 'COLLAGE'",
           COLLAGE  =  FACT(statut='o',
              GROUP_MA_1     =SIMP(statut='o',typ=grma),
              GROUP_MA_2     =SIMP(statut='o',typ=grma),
                             ),
                           ),
)  ;
#& MODIF COMMANDE  DATE 18/04/2005   AUTEUR NICOLAS O.NICOLAS 
#            CONFIGURATION MANAGEMENT OF EDF VERSION
# ======================================================================
# COPYRIGHT (C) 1991 - 2001  EDF R&D                  WWW.CODE-ASTER.ORG
# THIS PROGRAM IS FREE SOFTWARE; YOU CAN REDISTRIBUTE IT AND/OR MODIFY
# IT UNDER THE TERMS OF THE GNU GENERAL PUBLIC LICENSE AS PUBLISHED BY
# THE FREE SOFTWARE FOUNDATION; EITHER VERSION 2 OF THE LICENSE, OR   
# (AT YOUR OPTION) ANY LATER VERSION.                                 
#
# THIS PROGRAM IS DISTRIBUTED IN THE HOPE THAT IT WILL BE USEFUL, BUT 
# WITHOUT ANY WARRANTY; WITHOUT EVEN THE IMPLIED WARRANTY OF          
# MERCHANTABILITY OR FITNESS FOR A PARTICULAR PURPOSE. SEE THE GNU    
# GENERAL PUBLIC LICENSE FOR MORE DETAILS.                            
#
# YOU SHOULD HAVE RECEIVED A COPY OF THE GNU GENERAL PUBLIC LICENSE   
# ALONG WITH THIS PROGRAM; IF NOT, WRITE TO EDF R&D CODE_ASTER,       
#    1 AVENUE DU GENERAL DE GAULLE, 92141 CLAMART CEDEX, FRANCE.      
# ======================================================================
ASSE_MATR_GENE=OPER(nom="ASSE_MATR_GENE",op= 128,sd_prod=matr_asse_gene_r,
                    fr="Assemblage des matrices généralisées de macro éléments pour construction de la matrice globale généralisée",
                    reentrant='n',
            UIinfo={"groupes":("Matrices/vecteurs",)},
         NUME_DDL_GENE   =SIMP(statut='o',typ=nume_ddl_gene ),
         METHODE          =SIMP(statut='f',typ='TXM',defaut="CLASSIQUE",into=("CLASSIQUE","INITIAL") ),
         b_option     =BLOC(condition = "METHODE == 'CLASSIQUE'",
           OPTION          =SIMP(statut='o',typ='TXM',into=("RIGI_GENE","MASS_GENE","AMOR_GENE") ),
           ),
)  ;
#& MODIF COMMANDE  DATE 22/06/2005   AUTEUR REZETTE C.REZETTE 
#            CONFIGURATION MANAGEMENT OF EDF VERSION
# ======================================================================
# COPYRIGHT (C) 1991 - 2001  EDF R&D                  WWW.CODE-ASTER.ORG
# THIS PROGRAM IS FREE SOFTWARE; YOU CAN REDISTRIBUTE IT AND/OR MODIFY
# IT UNDER THE TERMS OF THE GNU GENERAL PUBLIC LICENSE AS PUBLISHED BY
# THE FREE SOFTWARE FOUNDATION; EITHER VERSION 2 OF THE LICENSE, OR   
# (AT YOUR OPTION) ANY LATER VERSION.                                 
#
# THIS PROGRAM IS DISTRIBUTED IN THE HOPE THAT IT WILL BE USEFUL, BUT 
# WITHOUT ANY WARRANTY; WITHOUT EVEN THE IMPLIED WARRANTY OF          
# MERCHANTABILITY OR FITNESS FOR A PARTICULAR PURPOSE. SEE THE GNU    
# GENERAL PUBLIC LICENSE FOR MORE DETAILS.                            
#
# YOU SHOULD HAVE RECEIVED A COPY OF THE GNU GENERAL PUBLIC LICENSE   
# ALONG WITH THIS PROGRAM; IF NOT, WRITE TO EDF R&D CODE_ASTER,       
#    1 AVENUE DU GENERAL DE GAULLE, 92141 CLAMART CEDEX, FRANCE.      
# ======================================================================
# RESPONSABLE VABHHTS J.PELLET
def asse_matrice_prod(MATR_ELEM,**args):
  if AsType(MATR_ELEM) == matr_elem_depl_r : return matr_asse_depl_r
  if AsType(MATR_ELEM) == matr_elem_depl_c : return matr_asse_depl_c
  if AsType(MATR_ELEM) == matr_elem_temp_r : return matr_asse_temp_r
  if AsType(MATR_ELEM) == matr_elem_pres_c : return matr_asse_pres_c
  raise AsException("type de concept resultat non prevu")

ASSE_MATRICE=OPER(nom="ASSE_MATRICE",op=12,sd_prod=asse_matrice_prod,
                  fr="Construction d'une matrice assemblée",reentrant='n',
            UIinfo={"groupes":("Matrices/vecteurs",)},
         MATR_ELEM       =SIMP(statut='o',
                               typ=(matr_elem_depl_r,matr_elem_depl_c,matr_elem_temp_r,matr_elem_pres_c) ),
         NUME_DDL        =SIMP(statut='o',typ=nume_ddl_sdaster),
         CHAR_CINE       =SIMP(statut='f',typ=(char_cine_meca,char_cine_ther,char_cine_acou) ),
         INFO            =SIMP(statut='f',typ='I',into=(1,2) ),
)  ;
#& MODIF COMMANDE  DATE 21/02/2006   AUTEUR REZETTE C.REZETTE 
#            CONFIGURATION MANAGEMENT OF EDF VERSION
# ======================================================================
# COPYRIGHT (C) 1991 - 2001  EDF R&D                  WWW.CODE-ASTER.ORG
# THIS PROGRAM IS FREE SOFTWARE; YOU CAN REDISTRIBUTE IT AND/OR MODIFY
# IT UNDER THE TERMS OF THE GNU GENERAL PUBLIC LICENSE AS PUBLISHED BY
# THE FREE SOFTWARE FOUNDATION; EITHER VERSION 2 OF THE LICENSE, OR   
# (AT YOUR OPTION) ANY LATER VERSION.                                 
#
# THIS PROGRAM IS DISTRIBUTED IN THE HOPE THAT IT WILL BE USEFUL, BUT 
# WITHOUT ANY WARRANTY; WITHOUT EVEN THE IMPLIED WARRANTY OF          
# MERCHANTABILITY OR FITNESS FOR A PARTICULAR PURPOSE. SEE THE GNU    
# GENERAL PUBLIC LICENSE FOR MORE DETAILS.                            
#
# YOU SHOULD HAVE RECEIVED A COPY OF THE GNU GENERAL PUBLIC LICENSE   
# ALONG WITH THIS PROGRAM; IF NOT, WRITE TO EDF R&D CODE_ASTER,       
#    1 AVENUE DU GENERAL DE GAULLE, 92141 CLAMART CEDEX, FRANCE.      
# ======================================================================
# RESPONSABLE VABHHTS J.PELLET

ASSE_VECTEUR=OPER(nom="ASSE_VECTEUR",op=13,sd_prod=cham_no_sdaster,
                  fr="Construire un champ aux noeuds par assemblage de vecteurs élémentaires",reentrant='n',
            UIinfo={"groupes":("Matrices/vecteurs",)},
         VECT_ELEM       =SIMP(statut='o',typ=vect_elem,max='**'),
         NUME_DDL        =SIMP(statut='o',typ=nume_ddl_sdaster ),
         INFO            =SIMP(statut='f',typ='I',into=(1,2,) ),
)  ;
#& MODIF COMMANDE  DATE 21/02/2006   AUTEUR REZETTE C.REZETTE 
#            CONFIGURATION MANAGEMENT OF EDF VERSION
# ======================================================================
# COPYRIGHT (C) 1991 - 2001  EDF R&D                  WWW.CODE-ASTER.ORG
# THIS PROGRAM IS FREE SOFTWARE; YOU CAN REDISTRIBUTE IT AND/OR MODIFY
# IT UNDER THE TERMS OF THE GNU GENERAL PUBLIC LICENSE AS PUBLISHED BY
# THE FREE SOFTWARE FOUNDATION; EITHER VERSION 2 OF THE LICENSE, OR   
# (AT YOUR OPTION) ANY LATER VERSION.                                 
#
# THIS PROGRAM IS DISTRIBUTED IN THE HOPE THAT IT WILL BE USEFUL, BUT 
# WITHOUT ANY WARRANTY; WITHOUT EVEN THE IMPLIED WARRANTY OF          
# MERCHANTABILITY OR FITNESS FOR A PARTICULAR PURPOSE. SEE THE GNU    
# GENERAL PUBLIC LICENSE FOR MORE DETAILS.                            
#
# YOU SHOULD HAVE RECEIVED A COPY OF THE GNU GENERAL PUBLIC LICENSE   
# ALONG WITH THIS PROGRAM; IF NOT, WRITE TO EDF R&D CODE_ASTER,       
#    1 AVENUE DU GENERAL DE GAULLE, 92141 CLAMART CEDEX, FRANCE.      
# ======================================================================
ASSE_VECT_GENE=OPER(nom="ASSE_VECT_GENE",op= 140,sd_prod=vect_asse_gene,
                    fr="Projection des chargements sur la base modale d'une sous structure",
                    reentrant='n',
            UIinfo={"groupes":("Matrices/vecteurs",)},
         NUME_DDL_GENE   =SIMP(statut='o',typ=nume_ddl_gene ),
         METHODE          =SIMP(statut='f',typ='TXM',defaut="CLASSIQUE",into=("CLASSIQUE","INITIAL") ),
         b_nume     =BLOC(condition = "METHODE == 'CLASSIQUE'",
             CHAR_SOUS_STRUC =FACT(statut='o',max='**',
             SOUS_STRUC      =SIMP(statut='o',typ='TXM' ),
             VECT_ASSE       =SIMP(statut='o',typ=cham_no_sdaster ),
           ),
         ),
)  ;
#& MODIF COMMANDE  DATE 03/01/2006   AUTEUR REZETTE C.REZETTE 
#            CONFIGURATION MANAGEMENT OF EDF VERSION
# ======================================================================
# COPYRIGHT (C) 1991 - 2001  EDF R&D                  WWW.CODE-ASTER.ORG
# THIS PROGRAM IS FREE SOFTWARE; YOU CAN REDISTRIBUTE IT AND/OR MODIFY
# IT UNDER THE TERMS OF THE GNU GENERAL PUBLIC LICENSE AS PUBLISHED BY
# THE FREE SOFTWARE FOUNDATION; EITHER VERSION 2 OF THE LICENSE, OR   
# (AT YOUR OPTION) ANY LATER VERSION.                                 
#
# THIS PROGRAM IS DISTRIBUTED IN THE HOPE THAT IT WILL BE USEFUL, BUT 
# WITHOUT ANY WARRANTY; WITHOUT EVEN THE IMPLIED WARRANTY OF          
# MERCHANTABILITY OR FITNESS FOR A PARTICULAR PURPOSE. SEE THE GNU    
# GENERAL PUBLIC LICENSE FOR MORE DETAILS.                            
#
# YOU SHOULD HAVE RECEIVED A COPY OF THE GNU GENERAL PUBLIC LICENSE   
# ALONG WITH THIS PROGRAM; IF NOT, WRITE TO EDF R&D CODE_ASTER,       
#    1 AVENUE DU GENERAL DE GAULLE, 92141 CLAMART CEDEX, FRANCE.      
# ======================================================================
CALC_AMOR_MODAL=OPER(nom="CALC_AMOR_MODAL",op= 172,sd_prod=listr8_sdaster,
                     fr="Création d'une liste d'amortissements modaux calculés selon la règle du RCC-G",
                     reentrant='n',
            UIinfo={"groupes":("Résolution",)},
         ENER_SOL        =FACT(statut='o',
           regles=(UN_PARMI('GROUP_NO_RADIER','GROUP_MA_RADIER'),
                   PRESENT_ABSENT('COEF_GROUP','FONC_GROUP'),
#  Peut-on remplacer les deux règles suivantes par un ENSEMBLE_('KRX','KRY','KRZ')
                   PRESENT_PRESENT('KRX','KRY'),
                   PRESENT_PRESENT('KRX','KRZ'),
                   PRESENT_ABSENT('COOR_CENTRE','NOEUD_CENTRE'),
                   PRESENT_ABSENT('GROUP_NO_CENTRE','NOEUD_CENTRE'),
                   PRESENT_ABSENT('GROUP_NO_CENTRE','COOR_CENTRE'),),
           METHODE         =SIMP(statut='f',typ='TXM',defaut="DEPL",into=("DEPL","RIGI_PARASOL") ),
           MODE_MECA       =SIMP(statut='o',typ=mode_meca ),
           GROUP_NO_RADIER =SIMP(statut='f',typ=grno,validators=NoRepeat(),max='**'),
           GROUP_MA_RADIER =SIMP(statut='f',typ=grma,validators=NoRepeat(),max='**'),
           FONC_GROUP      =SIMP(statut='f',typ=(fonction_sdaster,nappe_sdaster,formule) ),
           COEF_GROUP      =SIMP(statut='f',typ='R',max='**'),
           KX              =SIMP(statut='o',typ='R' ),
           KY              =SIMP(statut='o',typ='R' ),
           KZ              =SIMP(statut='o',typ='R' ),
           KRX             =SIMP(statut='f',typ='R' ),
           KRY             =SIMP(statut='f',typ='R' ),
           KRZ             =SIMP(statut='f',typ='R' ),
           GROUP_NO_CENTRE =SIMP(statut='f',typ=grno),
           NOEUD_CENTRE    =SIMP(statut='f',typ=no),
           COOR_CENTRE     =SIMP(statut='f',typ='R',max=3),
         ),
         AMOR_INTERNE    =FACT(statut='o',
           ENER_POT        =SIMP(statut='o',typ=table_sdaster ),
           GROUP_MA        =SIMP(statut='o',typ=grma,validators=NoRepeat(),max='**'),
           AMOR_REDUIT     =SIMP(statut='o',typ='R',max='**'),
         ),
         AMOR_SOL        =FACT(statut='o',
           AMOR_REDUIT     =SIMP(statut='f',typ='R',defaut= 0.E+0 ),
           FONC_AMOR_GEO   =SIMP(statut='o',typ=(fonction_sdaster,nappe_sdaster,formule),max='**' ),
           HOMOGENE        =SIMP(statut='f',typ='TXM',defaut="OUI",into=("OUI","NON") ),
           SEUIL           =SIMP(statut='f',typ='R',defaut= 0.3 ),
         ),
)  ;
#& MODIF COMMANDE  DATE 16/05/2006   AUTEUR REZETTE C.REZETTE 
#            CONFIGURATION MANAGEMENT OF EDF VERSION
# ======================================================================
# COPYRIGHT (C) 1991 - 2001  EDF R&D                  WWW.CODE-ASTER.ORG
# THIS PROGRAM IS FREE SOFTWARE; YOU CAN REDISTRIBUTE IT AND/OR MODIFY
# IT UNDER THE TERMS OF THE GNU GENERAL PUBLIC LICENSE AS PUBLISHED BY
# THE FREE SOFTWARE FOUNDATION; EITHER VERSION 2 OF THE LICENSE, OR   
# (AT YOUR OPTION) ANY LATER VERSION.                                 
#
# THIS PROGRAM IS DISTRIBUTED IN THE HOPE THAT IT WILL BE USEFUL, BUT 
# WITHOUT ANY WARRANTY; WITHOUT EVEN THE IMPLIED WARRANTY OF          
# MERCHANTABILITY OR FITNESS FOR A PARTICULAR PURPOSE. SEE THE GNU    
# GENERAL PUBLIC LICENSE FOR MORE DETAILS.                            
#
# YOU SHOULD HAVE RECEIVED A COPY OF THE GNU GENERAL PUBLIC LICENSE   
# ALONG WITH THIS PROGRAM; IF NOT, WRITE TO EDF R&D CODE_ASTER,       
#    1 AVENUE DU GENERAL DE GAULLE, 92141 CLAMART CEDEX, FRANCE.      
# ======================================================================
# RESPONSABLE JMBHH01 J.M.PROIX

CALC_CHAM_ELEM=OPER(nom="CALC_CHAM_ELEM",op=38,sd_prod=cham_elem,
                    fr="Calculer un champ élémentaire en thermique et en accoustique à partir de champs déjà calculés",
                    reentrant='n',
            UIinfo={"groupes":("Post traitements",)},
         MODELE          =SIMP(statut='o',typ=modele_sdaster),
         CHAM_MATER      =SIMP(statut='o',typ=cham_mater),
         CARA_ELEM       =SIMP(statut='f',typ=cara_elem),

         regles=(EXCLUS('TOUT','GROUP_MA',),EXCLUS('TOUT','MAILLE',),),
         TOUT            =SIMP(statut='f',typ='TXM',into=("OUI",) ),
         GROUP_MA        =SIMP(statut='f',typ=grma,validators=NoRepeat(),max='**'),
         MAILLE          =SIMP(statut='f',typ=ma  ,validators=NoRepeat(),max='**'),

#
#
#  introduire un mot cle de type modelisation : mécanique,thermique,...
#

         OPTION          =SIMP(statut='o',typ='TXM',
                               into=("FLUX_ELGA_TEMP","FLUX_ELNO_TEMP",
                                     "PRES_ELNO_DBEL","PRES_ELNO_REEL","PRES_ELNO_IMAG",
                                     "COOR_ELGA"), ),

         b_thermique  =BLOC(condition="OPTION in ('FLUX_ELNO_TEMP','FLUX_ELGA_TEMP',)",
           TEMP            =SIMP(statut='o',typ=(cham_no_sdaster,)),
         ),

         b_acoustique  =BLOC(condition="OPTION in ('PRES_ELNO_DBEL','PRES_ELNO_REEL','PRES_ELNO_IMAG',)",
           PRES            =SIMP(statut='o',typ=(cham_no_sdaster,)),
         ),



         EXCIT           =FACT(statut='f',max='**',
               regles=(EXCLUS('FONC_MULT','COEF_MULT', ),),
               CHARGE          =SIMP(statut='o',typ=(char_meca,char_ther,char_acou)),
               FONC_MULT       =SIMP(statut='f',typ=(fonction_sdaster,nappe_sdaster,formule)),
               COEF_MULT       =SIMP(statut='f',typ='R'), ),

         INST            =SIMP(statut='f',typ='R',defaut= 0.E+0),
         ACCE            =SIMP(statut='f',typ=cham_no_sdaster),
         NUME_COUCHE     =SIMP(statut='f',typ='I',defaut= 1),
         NIVE_COUCHE     =SIMP(statut='f',typ='TXM',defaut="MOY",into=("SUP","INF","MOY") ),
         MODE_FOURIER    =SIMP(statut='f',typ='I',defaut= 0 ),
         ANGLE           =SIMP(statut='f',typ='I',defaut= 0),
)  ;
#& MODIF COMMANDE  DATE 21/02/2006   AUTEUR REZETTE C.REZETTE 
#            CONFIGURATION MANAGEMENT OF EDF VERSION
# ======================================================================
# COPYRIGHT (C) 1991 - 2001  EDF R&D                  WWW.CODE-ASTER.ORG
# THIS PROGRAM IS FREE SOFTWARE; YOU CAN REDISTRIBUTE IT AND/OR MODIFY
# IT UNDER THE TERMS OF THE GNU GENERAL PUBLIC LICENSE AS PUBLISHED BY
# THE FREE SOFTWARE FOUNDATION; EITHER VERSION 2 OF THE LICENSE, OR   
# (AT YOUR OPTION) ANY LATER VERSION.                                 
#
# THIS PROGRAM IS DISTRIBUTED IN THE HOPE THAT IT WILL BE USEFUL, BUT 
# WITHOUT ANY WARRANTY; WITHOUT EVEN THE IMPLIED WARRANTY OF          
# MERCHANTABILITY OR FITNESS FOR A PARTICULAR PURPOSE. SEE THE GNU    
# GENERAL PUBLIC LICENSE FOR MORE DETAILS.                            
#
# YOU SHOULD HAVE RECEIVED A COPY OF THE GNU GENERAL PUBLIC LICENSE   
# ALONG WITH THIS PROGRAM; IF NOT, WRITE TO EDF R&D CODE_ASTER,       
#    1 AVENUE DU GENERAL DE GAULLE, 92141 CLAMART CEDEX, FRANCE.      
# ======================================================================
# RESPONSABLE VABHHTS J.PELLET

CALC_CHAR_CINE=OPER(nom="CALC_CHAR_CINE",op= 102,sd_prod=cham_no_sdaster,
                    fr="Calcul des seconds membres associés à des charges cinématiques (conditions aux limites non dualisées)",
                    reentrant='n',
            UIinfo={"groupes":("Matrices/vecteurs",)},
         NUME_DDL        =SIMP(statut='o',typ=nume_ddl_sdaster ),
         CHAR_CINE       =SIMP(statut='o',typ=(char_cine_meca,char_cine_ther,char_cine_acou ),validators=NoRepeat(),max='**' ),
         INST            =SIMP(statut='f',typ='R',defaut= 0.E+0 ),
         INFO            =SIMP(statut='f',typ='I',defaut= 1,into=( 1 , 2 ) ),
)  ;
#& MODIF COMMANDE  DATE 21/02/2006   AUTEUR REZETTE C.REZETTE 
#            CONFIGURATION MANAGEMENT OF EDF VERSION
# ======================================================================
# COPYRIGHT (C) 1991 - 2001  EDF R&D                  WWW.CODE-ASTER.ORG
# THIS PROGRAM IS FREE SOFTWARE; YOU CAN REDISTRIBUTE IT AND/OR MODIFY
# IT UNDER THE TERMS OF THE GNU GENERAL PUBLIC LICENSE AS PUBLISHED BY
# THE FREE SOFTWARE FOUNDATION; EITHER VERSION 2 OF THE LICENSE, OR   
# (AT YOUR OPTION) ANY LATER VERSION.                                 
#
# THIS PROGRAM IS DISTRIBUTED IN THE HOPE THAT IT WILL BE USEFUL, BUT 
# WITHOUT ANY WARRANTY; WITHOUT EVEN THE IMPLIED WARRANTY OF          
# MERCHANTABILITY OR FITNESS FOR A PARTICULAR PURPOSE. SEE THE GNU    
# GENERAL PUBLIC LICENSE FOR MORE DETAILS.                            
#
# YOU SHOULD HAVE RECEIVED A COPY OF THE GNU GENERAL PUBLIC LICENSE   
# ALONG WITH THIS PROGRAM; IF NOT, WRITE TO EDF R&D CODE_ASTER,       
#    1 AVENUE DU GENERAL DE GAULLE, 92141 CLAMART CEDEX, FRANCE.      
# ======================================================================
def calc_char_seisme_prod(MATR_MASS,**args ):
  if AsType(MATR_MASS) == matr_asse_depl_r : return cham_no_sdaster
  raise AsException("type de concept resultat non prevu")

CALC_CHAR_SEISME=OPER(nom="CALC_CHAR_SEISME",op=  92,sd_prod=calc_char_seisme_prod,
                      reentrant='n',fr="Calcul du chargement sismique",
            UIinfo={"groupes":("Matrices/vecteurs",)},
         regles=(UN_PARMI('MONO_APPUI','MODE_STAT' ),),
         MATR_MASS       =SIMP(statut='o',typ=matr_asse_depl_r,fr="Matrice de masse" ),
         DIRECTION       =SIMP(statut='o',typ='R',max=6,fr="Directions du séisme imposé"),
         MONO_APPUI      =SIMP(statut='f',typ='TXM',into=("OUI",) ),         
         MODE_STAT       =SIMP(statut='f',typ=(mode_stat_depl,mode_stat_acce,mode_stat_forc,) ),
         b_mode_stat     =BLOC ( condition = "MODE_STAT != None",
           regles=(UN_PARMI('NOEUD','GROUP_NO' ),),
           NOEUD           =SIMP(statut='f',typ=no,validators=NoRepeat(),max='**'),
           GROUP_NO        =SIMP(statut='f',typ=grno,validators=NoRepeat(),max='**'),
         ),
         TITRE           =SIMP(statut='f',typ='TXM',max='**'),
)  ;
#& MODIF COMMANDE  DATE 07/11/2006   AUTEUR CIBHHLV L.VIVAN 
#            CONFIGURATION MANAGEMENT OF EDF VERSION
# ======================================================================
# COPYRIGHT (C) 1991 - 2001  EDF R&D                  WWW.CODE-ASTER.ORG
# THIS PROGRAM IS FREE SOFTWARE; YOU CAN REDISTRIBUTE IT AND/OR MODIFY
# IT UNDER THE TERMS OF THE GNU GENERAL PUBLIC LICENSE AS PUBLISHED BY
# THE FREE SOFTWARE FOUNDATION; EITHER VERSION 2 OF THE LICENSE, OR   
# (AT YOUR OPTION) ANY LATER VERSION.                                 
#
# THIS PROGRAM IS DISTRIBUTED IN THE HOPE THAT IT WILL BE USEFUL, BUT 
# WITHOUT ANY WARRANTY; WITHOUT EVEN THE IMPLIED WARRANTY OF          
# MERCHANTABILITY OR FITNESS FOR A PARTICULAR PURPOSE. SEE THE GNU    
# GENERAL PUBLIC LICENSE FOR MORE DETAILS.                            
#
# YOU SHOULD HAVE RECEIVED A COPY OF THE GNU GENERAL PUBLIC LICENSE   
# ALONG WITH THIS PROGRAM; IF NOT, WRITE TO EDF R&D CODE_ASTER,       
#    1 AVENUE DU GENERAL DE GAULLE, 92141 CLAMART CEDEX, FRANCE.      
# ======================================================================
# RESPONSABLE JMBHH01 J.M.PROIX
def calc_elem_prod(RESULTAT,**args):
   if AsType(RESULTAT) != None : return AsType(RESULTAT)
   raise AsException("type de concept resultat non prevu")

CALC_ELEM=OPER(nom="CALC_ELEM",op=58,sd_prod=calc_elem_prod,reentrant='f',
            UIinfo={"groupes":("Post traitements",)},
            fr="Compléter ou créer un résultat en calculant des champs par éléments (contraintes, déformations,... )",
     MODELE          =SIMP(statut='f',typ=modele_sdaster),
     CHAM_MATER      =SIMP(statut='f',typ=cham_mater),
     CARA_ELEM       =SIMP(statut='f',typ=cara_elem),

     RESULTAT        =SIMP(statut='o',typ=(evol_elas,dyna_trans,dyna_harmo,mode_meca,
                                mode_stat,mode_stat_depl,mode_stat_acce,mode_stat_forc,
                                evol_noli,mult_elas,fourier_elas,fourier_ther,
                                evol_ther,base_modale,
                                acou_harmo,mode_acou,mode_flamb) ,
                fr="Résultat d'une commande globale"),
                                           
     regles=(EXCLUS('TOUT_ORDRE','NUME_ORDRE','INST','FREQ','NUME_MODE',
                    'NOEUD_CMP','LIST_INST','LIST_FREQ','LIST_ORDRE','NOM_CAS'),
             CONCEPT_SENSIBLE("SEPARE"),
             DERIVABLE('RESULTAT'),),
     TOUT_ORDRE      =SIMP(statut='f',typ='TXM',into=("OUI",) ),
     NUME_ORDRE      =SIMP(statut='f',typ='I',validators=NoRepeat(),max='**'),
     NUME_MODE       =SIMP(statut='f',typ='I',validators=NoRepeat(),max='**'),
     NOEUD_CMP       =SIMP(statut='f',typ='TXM',validators=NoRepeat(),max='**'),
     NOM_CAS         =SIMP(statut='f',typ='TXM' ),

     INST            =SIMP(statut='f',typ='R',validators=NoRepeat(),max='**'),
     FREQ            =SIMP(statut='f',typ='R',validators=NoRepeat(),max='**'),
     LIST_INST       =SIMP(statut='f',typ=listr8_sdaster),
     LIST_FREQ       =SIMP(statut='f',typ=listr8_sdaster),
     PRECISION       =SIMP(statut='f',typ='R',defaut=1.0E-3 ),
     CRITERE         =SIMP(statut='f',typ='TXM',defaut="RELATIF",into=("RELATIF","ABSOLU",) ),
     LIST_ORDRE      =SIMP(statut='f',typ=listis_sdaster),
     
     TOUT            =SIMP(statut='f',typ='TXM',into=("OUI",) ),
     GROUP_MA        =SIMP(statut='f',typ=grma,validators=NoRepeat(),max='**',
                           fr="le calcul ne sera effectué que sur ces mailles là"),
     MAILLE          =SIMP(statut='f',typ=ma  ,validators=NoRepeat(),max='**',
                           fr="le calcul ne sera effectué que sur ces mailles là"),

#    definition d'un repere local 

     REPE_COQUE      =FACT(statut='f',max='**',
                           fr="définiton du lieu de post-traitement",
                           regles=EXCLUS('ANGL_REP','VECTEUR'),
          TOUT         =SIMP(statut='f',typ='TXM',into=("OUI",) ),
          GROUP_MA     =SIMP(statut='f',typ=grma,validators=NoRepeat(),max='**',),
          MAILLE       =SIMP(statut='f',typ=ma  ,validators=NoRepeat(),max='**',),

          NUME_COUCHE  =SIMP(statut='f',typ='I',defaut= 1,
                             fr="numero de couche dans l'épaisseur de la coque ou du tuyau" ),
          NIVE_COUCHE  =SIMP(statut='f',typ='TXM',defaut="MOY",into=("SUP","INF","MOY"),
                             fr="position dans l'épaisseur de la coque, ou de la couche" ),

          ANGLE        =SIMP(statut='f',typ='I',defaut= 0,
                             fr="angle de dépouillement pour les tuyaux, en degres à partir de la génératrice" ),

          PLAN         =SIMP(statut='f',typ='TXM',defaut="MAIL",into=("SUP","INF","MOY","MAIL"),
                               fr="Plan de calcul pour les plaques excentrées" ),

          ANGL_REP     =SIMP(statut='f',typ='R',min=2,max=2,
                           fr="définition du repere de post-traitement, par défaut ANGL_REP=(0.,0.)"),
          VECTEUR      =SIMP(statut='f',typ='R',min=3,max=3,
                           fr="définition du repere de post-traitement, par défaut VECTEUR=(1.,0.,0.)"),
                            ),

#    options pour des resultats lineaires 

     b_lineaire =BLOC( condition = "AsType(RESULTAT) in (evol_elas,dyna_trans,dyna_harmo,mode_meca,\
                                                               mode_stat,mode_stat_depl,mode_stat_acce,mode_stat_forc,\
                                                               mult_elas,fourier_elas,base_modale,mode_flamb)",
                                                               fr="options mecaniques lineaires",
          TYPE_OPTION =SIMP(statut='f',typ='TXM',defaut='TOUTES',fr="type d'options mecaniques lineaires",
                           into=("SIGM_MASSIF","SIGM_STRUCT","EPSI","ENER","CRIT","DERIVEES",
                                 "INDI_ERREUR","AUTRES","TOUTES"),
                           ),
          b_toutes=BLOC( condition = "TYPE_OPTION == 'TOUTES'",fr="toutes les options evol elas",
               OPTION =SIMP(statut='o',typ='TXM',validators=NoRepeat(),max='**',defaut="SIEF_ELNO_ELGA",
                              #  contraintes
                           into=( "SIEF_ELNO_ELGA","SIGM_ELNO_DEPL","SIEF_ELGA_DEPL",
                                  "SIPO_ELNO_DEPL","EFGE_ELNO_DEPL","EFGE_ELNO_CART","SIGM_ELNO_CART",
                                  "SIGM_ELNO_SIEF","SIPO_ELNO_SIEF","SIGM_ELNO_TUYO","ARCO_ELNO_SIGM",
                              # déformations
                                 "EPSI_ELNO_DEPL","EPSI_ELGA_DEPL","EPSG_ELGA_DEPL","EPSG_ELNO_DEPL",
                                 "EPME_ELNO_DEPL","EPME_ELGA_DEPL","DEGE_ELNO_DEPL","EPSI_ELNO_TUYO",
                                 "EPVC_ELNO","EPVC_ELGA",
                              #  ENER    
                                 "EPOT_ELEM_DEPL","ECIN_ELEM_DEPL","ENEL_ELGA","ENEL_ELNO_ELGA",
                                 "ETOT_ELGA","ETOT_ELNO_ELGA","ETOT_ELEM",
                              #  estimateurs erreur 
                                 "SIGM_NOZ1_ELGA","ERZ1_ELEM_SIGM","SIGM_NOZ2_ELGA","ERZ2_ELEM_SIGM",
                                 "SIRE_ELNO_DEPL","ERRE_ELEM_SIGM","ERRE_ELNO_ELEM",
                                 "QIRE_ELEM_SIGM","QIRE_ELNO_ELEM","QIZ1_ELEM_SIGM","QIZ2_ELEM_SIGM",
                                 "SING_ELEM","SING_ELNO_ELEM",
                              #  CRIT    
                                 "EQUI_ELNO_SIGM","EQUI_ELGA_SIGM","CRIT_ELNO_RUPT",
                                 "EQUI_ELNO_EPSI","EQUI_ELGA_EPSI","EQUI_ELNO_EPME","EQUI_ELGA_EPME",
                                 "ENDO_ELGA","ENDO_ELNO_ELGA",
                                 "ENDO_ELNO_SIGA","ENDO_ELNO_SINO","SIEQ_ELNO_TUYO","EPEQ_ELNO_TUYO",
                              #  derivees    
                                 "DEUL_ELGA_DEPL","DEDE_ELNO_DLDE","DESI_ELNO_DLSI",
                              #  autres      
                                 "VNOR_ELEM_DEPL","VALE_NCOU_MAXI","PRES_DBEL_DEPL"),),

               NOM_CHAM  =SIMP(statut='f',typ='TXM',fr="nom du champ pour VALE_NCOU_MAXI", ),
               NOM_CMP   =SIMP(statut='f',typ='TXM',fr="nom de la composante pour VALE_NCOU_MAXI",  ),
              
                b_erre_qi =BLOC(condition = "OPTION in ('QIRE_ELEM_SIGM','QIZ1_ELEM_SIGM','QIZ2_ELEM_SIGM') or \
                                        (type(OPTION)==type(()) and 'QIRE_ELEM_SIGM' in OPTION) or \
                                        (type(OPTION)==type(()) and 'QIZ1_ELEM_SIGM' in OPTION) or \
                                        (type(OPTION)==type(()) and 'QIZ2_ELEM_SIGM' in OPTION)",
                    RESU_DUAL=SIMP(statut='o',typ=evol_elas,fr="resultat du probleme dual"),),

               b_sing =BLOC(condition= "OPTION == 'SING_ELEM' or \
                               (type(OPTION)==type(()) and  'SING_ELEM' in OPTION)",
                    PREC_ERR=SIMP(statut='o',typ='R',val_min= 0.,val_max= 1.,
                                  fr="precision demandee pour calculer la carte de taille des elements"),),   
               
               EXCIT           =FACT(statut='f',max='**',
                                     fr="Charges contenant les températures, les efforts répartis pour les poutres...",
                                     regles=(EXCLUS('FONC_MULT','FONC_MULT_C','COEF_MULT','COEF_MULT_C'),),
                    CHARGE          =SIMP(statut='o',typ=char_meca ),
                    FONC_MULT       =SIMP(statut='f',typ=(fonction_sdaster,nappe_sdaster,formule)),
                    FONC_MULT_C     =SIMP(statut='f',typ=fonction_c),
                    COEF_MULT       =SIMP(statut='f',typ='R'),
                    COEF_MULT_C     =SIMP(statut='f',typ='C'),
                    PHAS_DEG        =SIMP(statut='f',typ='R'),
                    PUIS_PULS       =SIMP(statut='f',typ='I'),
                    TYPE_CHARGE     =SIMP(statut='f',typ='TXM',defaut="FIXE",into=("FIXE",),),),
                
                                
                            ),
#             fin bloc b_toutes

          b_sigm_massif =BLOC( condition = "TYPE_OPTION == 'SIGM_MASSIF'",
                                     fr="options de contraintes elasticite 2D et 3D",
              OPTION =SIMP(statut='o',typ='TXM',validators=NoRepeat(),max='**',defaut='SIEF_ELNO_ELGA',
                            fr="option de calcul des contraintes",
                           into=( "SIEF_ELNO_ELGA","SIGM_ELNO_DEPL","SIEF_ELGA_DEPL",),),
                           
                    b_charge =BLOC( condition = "OPTION in ('SIGM_ELNO_DEPL','SIEF_ELGA_DEPL',) or \
                                      (type(OPTION)==type(()) and  'SIGM_ELNO_DEPL' in OPTION ) or \
                                      (type(OPTION)==type(()) and  'SIEF_ELGA_DEPL' in OPTION ) ",
                                      fr="charge contenant les temperatures ou autre charge",
                         EXCIT           =FACT(statut='f',max='**',
                         CHARGE          =SIMP(statut='o',typ=char_meca ),),
                                    ),
                                  ),
                                  
          b_sigm_struct =BLOC( condition = "TYPE_OPTION == 'SIGM_STRUCT'",
                                      fr="options de contraintes elasticite poutres, coques, tuyaux",
               OPTION =SIMP(statut='o',typ='TXM',validators=NoRepeat(),max='**',defaut='SIEF_ELNO_ELGA',
                            fr="option de calcul des contraintes ou efforts generalises",
                            into=( "SIEF_ELNO_ELGA","SIGM_ELNO_DEPL","SIEF_ELGA_DEPL","SIGM_ELNO_TUYO",
                                   "SIPO_ELNO_DEPL","EFGE_ELNO_DEPL","EFGE_ELNO_CART","SIGM_ELNO_CART",
                                   "SIGM_ELNO_SIEF","SIPO_ELNO_SIEF"),),
                           
               b_charge =BLOC( condition = "OPTION in ('SIGM_ELNO_DEPL','SIEF_ELGA_DEPL',\
                                                       'SIPO_ELNO_DEPL','EFGE_ELNO_DEPL',) or \
                                            (type(OPTION)==type(()) and  'SIGM_ELNO_DEPL' in OPTION ) or \
                                            (type(OPTION)==type(()) and  'SIEF_ELGA_DEPL' in OPTION ) or \
                                            (type(OPTION)==type(()) and  'SIPO_ELNO_DEPL' in OPTION ) or \
                                            (type(OPTION)==type(()) and  'EFGE_ELNO_DEPL' in OPTION ) ",
                                            fr="charge contenant les temperatures ou les efforts répartis (poutres) ou autre",
                    EXCIT           =FACT(statut='f',max='**',
                                          regles=(EXCLUS('FONC_MULT','FONC_MULT_C','COEF_MULT','COEF_MULT_C'),),
                         CHARGE          =SIMP(statut='f',typ=char_meca ),
                         FONC_MULT       =SIMP(statut='f',typ=(fonction_sdaster,nappe_sdaster,formule)),
                         FONC_MULT_C     =SIMP(statut='f',typ=fonction_c),
                         COEF_MULT       =SIMP(statut='f',typ='R'),
                         COEF_MULT_C     =SIMP(statut='f',typ='C'),
                         PHAS_DEG        =SIMP(statut='f',typ='R'),
                         PUIS_PULS       =SIMP(statut='f',typ='I'),
                         TYPE_CHARGE     =SIMP(statut='f',typ='TXM',defaut="FIXE",into=("FIXE",),),),
                             ),
                          
                                 
                            ),
#          fin bloc contraintes struct

          b_epsi         =BLOC( condition = "TYPE_OPTION=='EPSI'",
               OPTION    =SIMP(statut='o',typ='TXM',validators=NoRepeat(),max='**',
                           into=("EPSI_ELNO_DEPL","EPSI_ELGA_DEPL","EPME_ELNO_DEPL","EPME_ELGA_DEPL",
                                 "DEGE_ELNO_DEPL","EPSI_ELNO_TUYO","EPVC_ELNO","EPVC_ELGA",),
                                 ),
b_charge =BLOC( condition = "OPTION in ('EPME_ELNO_DEPL','EPSI_ELGA_DEPL','EPME_ELGA_DEPL','EPSI_ELNO_DEPL','EPSI_ELNO_TUYO' ) or \
                                      (type(OPTION)==type(()) and  'EPSI_ELNO_DEPL' in OPTION ) or \
                                      (type(OPTION)==type(()) and  'EPSI_ELNO_TUYO' in OPTION ) or \
                                      (type(OPTION)==type(()) and  'EPSI_ELGA_DEPL' in OPTION ) or \
                                      (type(OPTION)==type(()) and  'EPME_ELNO_DEPL' in OPTION ) or \
                                      (type(OPTION)==type(()) and  'EPME_ELGA_DEPL' in OPTION ) ",
                                      fr="charge contenant les temperatures",
                    EXCIT           =FACT(statut='f',max='**',
                         CHARGE          =SIMP(statut='o',typ=(char_meca,char_ther,char_acou) ),),
                                 ),
                                       ),
          b_ener         =BLOC( condition = "TYPE_OPTION=='ENER'",
               OPTION    =SIMP(statut='o',typ='TXM',validators=NoRepeat(),max='**',
                           into=("EPOT_ELEM_DEPL","ECIN_ELEM_DEPL","ENEL_ELGA","ENEL_ELNO_ELGA",
                                 "ETOT_ELGA","ETOT_ELNO_ELGA","ETOT_ELEM",),
                                 ),
               b_charge =BLOC( condition = "OPTION in ('EPOT_ELEM_DEPL','ECIN_ELEM_DEPL','ENEL_ELGA','ENEL_ELNO_ELGA',) or \
                                      (type(OPTION)==type(()) and  'EPOT_ELEM_DEPL' in OPTION ) or \
                                      (type(OPTION)==type(()) and  'ENEL_ELGA' in OPTION ) or \
                                      (type(OPTION)==type(()) and  'ENEL_ELNO_ELGA' in OPTION ) or \
                                      (type(OPTION)==type(()) and  'ECIN_ELEM_DEPL' in OPTION ) ",
                                      fr="charge contenant les temperatures",
                    EXCIT           =FACT(statut='f',max='**',
                         CHARGE          =SIMP(statut='f',typ=(char_meca,char_ther,char_acou) ),),
                              ),
                                 ),
                                 
          b_crit         =BLOC( condition = "TYPE_OPTION=='CRIT'",
               OPTION    =SIMP(statut='o',typ='TXM',validators=NoRepeat(),max='**',
                           into=("EQUI_ELNO_SIGM","EQUI_ELGA_SIGM",
                                 "EQUI_ELNO_EPSI","EQUI_ELGA_EPSI","EQUI_ELNO_EPME","EQUI_ELGA_EPME",
                                 "ENDO_ELGA","ENDO_ELNO_ELGA",
                                 "ENDO_ELNO_SIGA","ENDO_ELNO_SINO","CRIT_ELNO_RUPT","SIEQ_ELNO_TUYO","EPEQ_ELNO_TUYO",
                                 ) ),
                EXCIT           =FACT(statut='f',max='**',fr="charge contenant les temperatures",
                     CHARGE          =SIMP(statut='o',typ=(char_meca,char_ther,char_acou) ),),
                                 ),
                                 
          b_derivees         =BLOC( condition = "TYPE_OPTION=='DERIVEES'",
                  OPTION    =SIMP(statut='o',typ='TXM',validators=NoRepeat(),max='**',
                           into=("DEUL_ELGA_DEPL","DEDE_ELNO_DLDE","DESI_ELNO_DLSI",
                                 ) ),),

          b_autres         =BLOC( condition = "TYPE_OPTION=='AUTRES'",
                  OPTION    =SIMP(statut='o',typ='TXM',validators=NoRepeat(),max='**',
                           into=("VALE_NCOU_MAXI","PRES_DBEL_DEPL","VNOR_ELEM_DEPL",
                                 ) ),
               b_maxi    =BLOC( condition = "OPTION=='VALE_NCOU_MAXI' or \
                                (type(OPTION)==type(()) and 'VALE_NCOU_MAXI' in OPTION)",
                    NOM_CHAM  =SIMP(statut='o',typ='TXM',fr="Nom du champ pour VALE_NCOU_MAXI" ),
                    NOM_CMP   =SIMP(statut='o',typ='TXM',fr="Nom de la composante pour VALE_NCOU_MAXI"),),
                                 ),

          b_indi_erreur        =BLOC( condition = "TYPE_OPTION=='INDI_ERREUR'",
               OPTION    =SIMP(statut='o',typ='TXM',validators=NoRepeat(),max='**',defaut="ERRE_ELEM_SIGM",
                           into=("SIGM_NOZ1_ELGA","ERZ1_ELEM_SIGM","SIGM_NOZ2_ELGA","ERZ2_ELEM_SIGM",
                                 "SIRE_ELNO_DEPL","ERRE_ELEM_SIGM","ERRE_ELNO_ELEM",
                                 "QIRE_ELEM_SIGM","QIRE_ELNO_ELEM","QIZ1_ELEM_SIGM","QIZ2_ELEM_SIGM",
                                 "SING_ELEM","SING_ELNO_ELEM",
                                 )),
               
               b_erre_qi =BLOC(condition = "OPTION in ('QIRE_ELEM_SIGM','QIZ1_ELEM_SIGM','QIZ2_ELEM_SIGM') or \
                                        (type(OPTION)==type(()) and 'QIRE_ELEM_SIGM' in OPTION) or \
                                        (type(OPTION)==type(()) and 'QIZ1_ELEM_SIGM' in OPTION) or \
                                        (type(OPTION)==type(()) and 'QIZ2_ELEM_SIGM' in OPTION)",
                    RESU_DUAL=SIMP(statut='o',typ=evol_elas,fr="resultat du probleme dual"),),

               b_sing =BLOC(condition= "OPTION == 'SING_ELEM' or \
                               (type(OPTION)==type(()) and  'SING_ELEM' in OPTION)",
                    PREC_ERR=SIMP(statut='o',typ='R',val_min= 0.,val_max=1.,
                                  fr="precision demandee pour calculer la carte de taille des elements" ),),     

               EXCIT           =FACT(statut='f',max='**',fr="charge contenant les temperatures",
                     CHARGE          =SIMP(statut='o',typ=(char_meca,char_ther,char_acou) ),),
                                 ),
                                 ),
#    fin bloc lineaire                                
                            
                                 
#    statique ou dynamique non lineaire : evol_noli                                
     b_noli          =BLOC( condition = "AsType(RESULTAT) == evol_noli",fr="options evol noli",
          TYPE_OPTION =SIMP(statut='f',typ='TXM',defaut='TOUTES',
                           into=("SIGM_MASSIF","SIGM_STRUCT","EPSI","ENER","CRIT",
                                 "VARI","INDI_ERREUR","TOUTES","AUTRES"),
                          ),
          b_toutes =BLOC( condition = "TYPE_OPTION == 'TOUTES'",fr="toutes les options evol elas",
               OPTION      =SIMP(statut='o',typ='TXM',validators=NoRepeat(),max='**',
                           into=( "SIEF_ELNO_ELGA",
                                  "SIGM_ELNO_TUYO","SIGM_ELNO_COQU","ARCO_ELNO_SIGM",
                                  "SIGM_ELNO_SIEF","SIPO_ELNO_SIEF","EFGE_ELNO_CART",
                                  # EPSI
                                  "EPSI_ELNO_DEPL","EPSI_ELGA_DEPL","EPSG_ELNO_DEPL","EPSG_ELGA_DEPL",
                                 "EPME_ELNO_DEPL","EPME_ELGA_DEPL","EPMG_ELNO_DEPL","EPMG_ELGA_DEPL",
                                 "DEGE_ELNO_DEPL","EPSI_ELNO_TUYO",
                                 "EPSP_ELNO","EPSP_ELGA",
                                 "EPFD_ELNO","EPFD_ELGA","EPVC_ELNO","EPVC_ELGA",
                                 "EPFP_ELNO","EPFP_ELGA", 
                                 "VARI_ELNO_ELGA","VARI_ELNO_TUYO","VARI_ELNO_COQU","CRIT_ELNO_RUPT",
                                 "EXTR_ELGA_VARI","EXTR_ELNO_VARI",
                                 # CRIT
                                 "EQUI_ELNO_SIGM","EQUI_ELGA_SIGM","SIEQ_ELNO_TUYO","EPEQ_ELNO_TUYO",
                                 "ERRE_ELEM_SIGM","ERRE_ELNO_ELEM","ERZ1_ELEM_SIGM","ERZ2_ELEM_SIGM",
                                 "QIRE_ELEM_SIGM","QIRE_ELNO_ELEM","QIZ1_ELEM_SIGM","QIZ2_ELEM_SIGM",
                                 "EQUI_ELNO_EPSI","EQUI_ELGA_EPSI","EQUI_ELNO_EPME","EQUI_ELGA_EPME",
                                 "DCHA_ELNO_SIGM","DCHA_ELGA_SIGM","RADI_ELNO_SIGM","RADI_ELGA_SIGM",
                                 "ENDO_ELGA","ENDO_ELNO_ELGA","INDI_LOCA_ELGA","SING_ELEM",
                                 "SING_ELNO_ELEM","ENDO_ELNO_SIGA","ENDO_ELNO_SINO",
                                 "PMPB_ELNO_SIEF","PMPB_ELGA_SIEF","ENEL_ELGA","ENEL_ELNO_ELGA",
                                 "ETOT_ELGA","ETOT_ELNO_ELGA","ETOT_ELEM","VALE_NCOU_MAXI"),
                               ),
               NORME =SIMP(statut='f',typ='TXM',defaut="VMIS",
                                 into=("VMIS","TOTAL","VMIS_CINE","TOTAL_CINE"),
                                 fr="Type de norme pour les options RADI_ et DCHA_"),
                                 
               NOM_CHAM  =SIMP(statut='f',typ='TXM',fr="Nom du champ pour VALE_NCOU_MAXI"),
               NOM_CMP   =SIMP(statut='f',typ='TXM',fr="Nom de la composante pour VALE_NCOU_MAXI"),
               
               b_erre_qi =BLOC(condition = "OPTION in ('QIRE_ELEM_SIGM','QIZ1_ELEM_SIGM','QIZ2_ELEM_SIGM') or \
                                        (type(OPTION)==type(()) and 'QIRE_ELEM_SIGM' in OPTION) or \
                                        (type(OPTION)==type(()) and 'QIZ1_ELEM_SIGM' in OPTION) or \
                                        (type(OPTION)==type(()) and 'QIZ2_ELEM_SIGM' in OPTION)",
                    RESU_DUAL=SIMP(statut='o',typ=(evol_elas,evol_noli),fr="resultat du probleme dual"),),

               b_sing =BLOC(condition= "OPTION == 'SING_ELEM' or \
                               (type(OPTION)==type(()) and  'SING_ELEM' in OPTION)",
                    PREC_ERR=SIMP(statut='o',typ='R',val_min= 0.,val_max=1.,
                                  fr="precision demandee pour calculer la carte de taille des elements" ),),     

               
               b_extr = BLOC( condition = "OPTION in ('EXTR_ELNO_VARI','EXTR_ELGA_VARI')",
                             NOM_VARI =SIMP(statut='o',typ='TXM',min= 1,max=1,fr="nom de la variable à extraire",
                         into=("DPORO","DRHOLQ","DPVP","SATLIQ","EVP","IND_ETA","D","IND_END","TEMP_MAX","GAMP","PCR",
                               "SEUIL_HYD","IND_HYD","PCOHE","COMP_ROC","SEUIL_ISO","ANG_DEV","X11","X22","X33","X12","X13","X23",
                               "DIST_DEV","DEV_SUR_CRIT","DIST_ISO","NB_ITER","ARRET","NB_REDE","SIGNE"),),
                            ),
               EXCIT           =FACT(statut='f',max='**',
                                      regles=(EXCLUS('FONC_MULT','FONC_MULT_C','COEF_MULT','COEF_MULT_C'),),
                    CHARGE          =SIMP(statut='o',typ=char_meca ),
                    FONC_MULT       =SIMP(statut='f',typ=(fonction_sdaster,nappe_sdaster,formule)),
                    FONC_MULT_C     =SIMP(statut='f',typ=fonction_c),
                    COEF_MULT       =SIMP(statut='f',typ='R'),
                    COEF_MULT_C     =SIMP(statut='f',typ='C'),
                    PHAS_DEG        =SIMP(statut='f',typ='R'),
                    PUIS_PULS       =SIMP(statut='f',typ='I'),
                    TYPE_CHARGE     =SIMP(statut='f',typ='TXM',defaut="FIXE",into=("FIXE",),),),
                         ),
                         
          b_sigm_massif =BLOC( condition = "TYPE_OPTION == 'SIGM_MASSIF'",
                                      fr="options de contraintes non lin 2D et 3D",
               OPTION =SIMP(statut='o',typ='TXM',validators=NoRepeat(),max='**',
                              #  contraintes
                           into=( "SIEF_ELNO_ELGA",),),
                            ),
                            
          b_sigm_struct =BLOC( condition = "TYPE_OPTION == 'SIGM_STRUCT'",
                                       fr="options de contraintes non lin poutres, coques",
               OPTION =SIMP(statut='o',typ='TXM',validators=NoRepeat(),max='**',
                              #  contraintes
                           into=( "SIEF_ELNO_ELGA","EFGE_ELNO_CART","SIGM_ELNO_TUYO","SIGM_ELNO_COQU",
                           "SIGM_ELNO_SIEF","SIPO_ELNO_SIEF",),),
                             ),
                             
          b_epsi         =BLOC( condition = "TYPE_OPTION=='EPSI'",
               OPTION    =SIMP(statut='o',typ='TXM',validators=NoRepeat(),max='**',
                           into=( "EPSI_ELNO_DEPL","EPSI_ELGA_DEPL","EPSG_ELNO_DEPL","EPSG_ELGA_DEPL",
                                 "EPME_ELNO_DEPL","EPME_ELGA_DEPL","EPMG_ELNO_DEPL","EPMG_ELGA_DEPL",
                                 "EPSP_ELNO","EPSP_ELGA","DEGE_ELNO_DEPL","EPVC_ELNO","EPVC_ELGA",
                                 "EPFD_ELNO","EPFD_ELGA","EPFP_ELNO","EPFP_ELGA"),
                                 ),
               EXCIT           =FACT(statut='f',max='**',fr="charge contenant les temperatures",
                    CHARGE          =SIMP(statut='o',typ=(char_meca,char_ther,char_acou) ),),
                                 ),
         b_epstuyo       =BLOC( condition = "OPTION == 'EPSI_ELNO_TUYO' or \
                                  (type(OPTION)==type(()) and  'EPSI_ELNO_TUYO' in OPTION) ",
              EXCIT           =FACT(statut='f',max='**',fr="charge contenant les temperatures",
                    CHARGE          =SIMP(statut='o',typ=(char_meca,char_ther,char_acou) ),),
                               ),
                                 
          b_vari         =BLOC( condition = "TYPE_OPTION=='VARI'",
                                       fr="Calcul et extraction des variables internes",
                   OPTION    =SIMP(statut='o',typ='TXM',validators=NoRepeat(),max='**',
                                   into=("VARI_ELNO_ELGA","VARI_ELNO_TUYO","VARI_ELNO_COQU",
                                         "EXTR_ELGA_VARI","EXTR_ELNO_VARI"),
                                 ),
          b_extr         =BLOC( condition = "OPTION in ('EXTR_ELNO_VARI','EXTR_ELGA_VARI')",
                   NOM_VARI =SIMP(statut='o',typ='TXM',min= 1,max=1,fr="nom de la variable à extraire",
                         into=("DPORO","DRHOLQ","DPVP","SATLIQ","EVP","IND_ETA","D","IND_END","TEMP_MAX","GAMP","PCR",
                               "SEUIL_HYD","IND_HYD","PCOHE","COMP_ROC","SEUIL_ISO","ANG_DEV","X11","X22","X33","X12","X13","X23",
                               "DIST_DEV","DEV_SUR_CRIT","DIST_ISO","NB_ITER","ARRET","NB_REDE","SIGNE"),),
                            ),
                           ),
                              
          b_ener         =BLOC( condition = "TYPE_OPTION=='ENER'",
               OPTION    =SIMP(statut='o',typ='TXM',validators=NoRepeat(),max='**',
                           into=("ETOT_ELGA","ETOT_ELNO_ELGA","ETOT_ELEM","ENEL_ELGA","ENEL_ELNO_ELGA",),
                                 ),
               EXCIT           =FACT(statut='f',max='**',fr="charge contenant les temperatures",
                    CHARGE          =SIMP(statut='o',typ=(char_meca,char_ther,char_acou) ),),
                                 ),
                                 
          b_crit         =BLOC( condition = "TYPE_OPTION=='CRIT'",
               OPTION    =SIMP(statut='o',typ='TXM',validators=NoRepeat(),max='**',
                           into=("EQUI_ELNO_SIGM","EQUI_ELGA_SIGM",
                                 "EQUI_ELNO_EPSI","EQUI_ELGA_EPSI","EQUI_ELNO_EPME","EQUI_ELGA_EPME",
                                 "ENDO_ELNO_SIGA","ENDO_ELNO_SINO","CRIT_ELNO_RUPT",
                                 "ENDO_ELGA","ENDO_ELNO_ELGA",
                                 "PMPB_ELNO_SIEF","PMPB_ELGA_SIEF","SIEQ_ELNO_TUYO","EPEQ_ELNO_TUYO",
                                 ) ),
                                 ),
                                 
          b_autres         =BLOC( condition = "TYPE_OPTION=='AUTRES'",
                  OPTION    =SIMP(statut='o',typ='TXM',validators=NoRepeat(),max='**',
                           into=("VALE_NCOU_MAXI",) ),
               b_maxi    =BLOC( condition = "OPTION=='VALE_NCOU_MAXI' or \
                                (type(OPTION)==type(()) and 'VALE_NCOU_MAXI' in OPTION)",
                    NOM_CHAM  =SIMP(statut='o',typ='TXM',fr="Nom du champ pour VALE_NCOU_MAXI" ),
                    NOM_CMP   =SIMP(statut='o',typ='TXM',fr="Nom de la composante pour VALE_NCOU_MAXI"),),
                                 ),


          b_indi_erreur         =BLOC( condition = "TYPE_OPTION=='INDI_ERREUR'",
               OPTION    =SIMP(statut='o',typ='TXM',validators=NoRepeat(),max='**',defaut="ERRE_ELEM_SIGM",
                           into=("ERRE_ELEM_SIGM","ERRE_ELNO_ELEM","ERZ1_ELEM_SIGM","ERZ2_ELEM_SIGM",
                                 "DCHA_ELNO_SIGM","DCHA_ELGA_SIGM","RADI_ELNO_SIGM","RADI_ELGA_SIGM",
                                 "QIRE_ELEM_SIGM","QIRE_ELNO_ELEM","QIZ1_ELEM_SIGM","QIZ2_ELEM_SIGM",
                                 "SING_ELEM","SING_ELNO_ELEM",) ),
               
               b_erre_qi =BLOC(condition = "OPTION in ('QIRE_ELEM_SIGM','QIZ1_ELEM_SIGM','QIZ2_ELEM_SIGM') or \
                                        (type(OPTION)==type(()) and 'QIRE_ELEM_SIGM' in OPTION) or \
                                        (type(OPTION)==type(()) and 'QIZ1_ELEM_SIGM' in OPTION) or \
                                        (type(OPTION)==type(()) and 'QIZ2_ELEM_SIGM' in OPTION)",
                RESU_DUAL    =SIMP(statut='o',typ=(evol_elas,evol_noli),fr="resultat du probleme dual")),

               b_sing =BLOC(condition= "OPTION == 'SING_ELEM' or \
                               (type(OPTION)==type(()) and  'SING_ELEM' in OPTION)",
                    PREC_ERR=SIMP(statut='o',typ='R',val_min= 0.,val_max=1.,
                                  fr="precision demandee pour calculer la carte de taille des elements" ),), 
               
               b_indic = BLOC( condition ="OPTION in ('DCHA_ELNO_SIGM','DCHA_ELGA_SIGM','RADI_ELNO_SIGM','RADI_ELGA_SIGM') or\
                                            (type(OPTION)==type(()) and 'DCHA_ELNO_SIGM' in OPTION) or\
                                            (type(OPTION)==type(()) and 'DCHA_ELGA_SIGM' in OPTION) or\
                                            (type(OPTION)==type(()) and 'RADI_ELNO_SIGM' in OPTION) or\
                                            (type(OPTION)==type(()) and 'RADI_ELGA_SIGM' in OPTION) ",
                    NORME =SIMP(statut='f',typ='TXM',defaut="VMIS",
                                 into=("VMIS","TOTAL","VMIS_CINE","TOTAL_CINE") ),
                                 ),
                                 ),
                                 ),
#          fin bloc evol_noli

#           thermique : evol_ther, fourier_ther                                
     b_ther          =BLOC( condition = "AsType(RESULTAT) in (evol_ther,fourier_ther,)" ,fr="options thermiques",
          OPTION          =SIMP(statut='o',typ='TXM',validators=NoRepeat(),max='**',
                           into=("DEUL_ELGA_TEMP","DETE_ELNO_DLTE","FLUX_ELGA_TEMP","FLUX_ELNO_TEMP",
                                  "HYDR_ELNO_ELGA","DURT_ELGA_META","DURT_ELNO_META",
                                  "SOUR_ELGA_ELEC","ERRE_ELEM_TEMP","ERRE_ELNO_ELEM",),),
               EXCIT           =FACT(statut='f',max='**',
                    regles=(EXCLUS('FONC_MULT','FONC_MULT_C','COEF_MULT','COEF_MULT_C'),),
                    CHARGE          =SIMP(statut='o',typ=char_ther ),
                    FONC_MULT       =SIMP(statut='f',typ=(fonction_sdaster,nappe_sdaster,formule)),
                    FONC_MULT_C     =SIMP(statut='f',typ=fonction_c),
                    COEF_MULT       =SIMP(statut='f',typ='R'),
                    COEF_MULT_C     =SIMP(statut='f',typ='C'),
                    PHAS_DEG        =SIMP(statut='f',typ='R'),
                    PUIS_PULS       =SIMP(statut='f',typ='I'),
                    TYPE_CHARGE     =SIMP(statut='f',typ='TXM',defaut="FIXE",into=("FIXE",),),
                                     ),
                                 ),
                                 
#    acoustique                                
     b_acou          =BLOC( condition = "AsType(RESULTAT) in (acou_harmo,mode_acou,)",fr="options acoustiques",
          OPTION          =SIMP(statut='o',typ='TXM',validators=NoRepeat(),max='**',
                           into=("PRES_ELNO_DBEL","PRES_ELNO_REEL","PRES_ELNO_IMAG",
                                 "INTE_ELNO_ACTI","INTE_ELNO_REAC",
                                 ),),
          EXCIT           =FACT(statut='f',max='**',
                regles=(EXCLUS('FONC_MULT','FONC_MULT_C','COEF_MULT','COEF_MULT_C'),),
                CHARGE          =SIMP(statut='o',typ=char_acou ),
                FONC_MULT       =SIMP(statut='f',typ=(fonction_sdaster,nappe_sdaster,formule)),
                FONC_MULT_C     =SIMP(statut='f',typ=fonction_c),
                COEF_MULT       =SIMP(statut='f',typ='R'),
                COEF_MULT_C     =SIMP(statut='f',typ='C'),
                PHAS_DEG        =SIMP(statut='f',typ='R'),
                PUIS_PULS       =SIMP(statut='f',typ='I'),
                TYPE_CHARGE     =SIMP(statut='f',typ='TXM',defaut="FIXE",into=("FIXE",),),),
                                 ),
             
     SENSIBILITE     =SIMP(statut='f',typ=(para_sensi,theta_geom),validators=NoRepeat(),max='**',
                           fr="Liste des paramètres de sensibilité.",
                           ang="List of sensitivity parameters"),
     INFO            =SIMP(statut='f',typ='I',defaut= 1,into=( 1 , 2) ),
     TITRE           =SIMP(statut='f',typ='TXM',max='**'),
) ;
#& MODIF COMMANDE  DATE 16/10/2006   AUTEUR JMBHH01 J.M.PROIX 
#            CONFIGURATION MANAGEMENT OF EDF VERSION
# ======================================================================
# COPYRIGHT (C) 1991 - 2001  EDF R&D                  WWW.CODE-ASTER.ORG
# THIS PROGRAM IS FREE SOFTWARE; YOU CAN REDISTRIBUTE IT AND/OR MODIFY
# IT UNDER THE TERMS OF THE GNU GENERAL PUBLIC LICENSE AS PUBLISHED BY
# THE FREE SOFTWARE FOUNDATION; EITHER VERSION 2 OF THE LICENSE, OR   
# (AT YOUR OPTION) ANY LATER VERSION.                                 
#
# THIS PROGRAM IS DISTRIBUTED IN THE HOPE THAT IT WILL BE USEFUL, BUT 
# WITHOUT ANY WARRANTY; WITHOUT EVEN THE IMPLIED WARRANTY OF          
# MERCHANTABILITY OR FITNESS FOR A PARTICULAR PURPOSE. SEE THE GNU    
# GENERAL PUBLIC LICENSE FOR MORE DETAILS.                            
#
# YOU SHOULD HAVE RECEIVED A COPY OF THE GNU GENERAL PUBLIC LICENSE   
# ALONG WITH THIS PROGRAM; IF NOT, WRITE TO EDF R&D CODE_ASTER,       
#    1 AVENUE DU GENERAL DE GAULLE, 92141 CLAMART CEDEX, FRANCE.      
# ======================================================================
def calc_fatigue_prod(TYPE_CALCUL,OPTION,**args):
  if TYPE_CALCUL == "CUMUL_DOMMAGE" : return cham_elem
  if TYPE_CALCUL == "FATIGUE_MULTI" and OPTION == "DOMA_ELGA": return cham_elem
  if TYPE_CALCUL == "FATIGUE_MULTI" and OPTION == "DOMA_NOEUD": return cham_no_sdaster
  raise AsException("type de calcul non prevu")

CALC_FATIGUE=OPER(nom="CALC_FATIGUE",op= 151,sd_prod=calc_fatigue_prod,reentrant='n',
                  fr="Calculer un champ de dommage de fatigue subit par une structure et déterminer le plan critique"
                      +" dans lequel le cisaillement est maximal.",
            UIinfo={"groupes":("Post traitements",)},

         TYPE_CALCUL = SIMP(statut='o',typ='TXM',
                               into=("CUMUL_DOMMAGE","FATIGUE_MULTI",) ),

         b_cumul_domma   =BLOC(condition = "TYPE_CALCUL == 'CUMUL_DOMMAGE'",
                               fr="Calcul d un champ de dommage subi par une structure.",
           regles=(PRESENT_PRESENT('DOMMAGE','MATER', ),),
           OPTION          =SIMP(statut='o',typ='TXM',
                                 into=("DOMA_ELNO_SIGM","DOMA_ELGA_SIGM",
                                       "DOMA_ELNO_EPSI","DOMA_ELGA_EPSI",
                                       "DOMA_ELNO_EPME","DOMA_ELGA_EPME") ),
           HISTOIRE        =FACT(statut='o',
             RESULTAT        =SIMP(statut='o',typ=(evol_elas,dyna_trans,
                                                   evol_noli) ),
             EQUI_GD         =SIMP(statut='f',typ='TXM',defaut="VMIS_SG",
                                 into=("VMIS_SG","INVA_2_SG") ),
           ),
           DOMMAGE         =SIMP(statut='o',typ='TXM',
                               into=("WOHLER","MANSON_COFFIN","TAHERI_MANSON",
                                     "TAHERI_MIXTE",) ),
           MATER           =SIMP(statut='o',typ=(mater_sdaster) ),
           TAHERI_NAPPE    =SIMP(statut='f',typ=(nappe_sdaster,formule) ),
           TAHERI_FONC     =SIMP(statut='f',typ=(fonction_sdaster,nappe_sdaster,formule) ),
         ),

         b_fatigue_multi   =BLOC(condition = "TYPE_CALCUL == 'FATIGUE_MULTI'",
                                 fr="Plan critique dans le cas de la fatigue multiaxiale à grand nombre de cycles.",
           TYPE_CHARGE   =SIMP(statut='o',typ='TXM',into=("PERIODIQUE","NON_PERIODIQUE") ),
           OPTION        =SIMP(statut='o',typ='TXM',into=("DOMA_ELGA","DOMA_NOEUD") ),
           RESULTAT      =SIMP(statut='o',typ=(evol_elas, evol_noli) ),
           CHAM_MATER    =SIMP(statut='o',typ=(cham_mater) ),
           GROUP_MA      =SIMP(statut='f',typ=grma,validators=NoRepeat(),max='**' ),
           MAILLE        =SIMP(statut='f',typ=ma  ,validators=NoRepeat(),max='**' ),
           GROUP_NO      =SIMP(statut='f',typ=grno,validators=NoRepeat(),max='**' ),
           NOEUD         =SIMP(statut='f',typ=no  ,validators=NoRepeat(),max='**' ),
           COEF_PREECROU =SIMP(statut='f',typ='R',defaut= 1.0E+0),
           b_period       =BLOC(condition = "TYPE_CHARGE == 'PERIODIQUE'",
               CRITERE       =SIMP(statut='o',typ='TXM',into=("MATAKE_MODI_AC","DANG_VAN_MODI_AC","VMIS_TRESCA") ),
               b_fati_p  =BLOC(condition = "(CRITERE == 'MATAKE_MODI_AC' or CRITERE == 'DANG_VAN_MODI_AC')",
                   METHODE       =SIMP(statut='o',typ='TXM',into=("CERCLE_EXACT",) ),
               ),
           ),
           b_non_period   =BLOC(condition = "TYPE_CHARGE == 'NON_PERIODIQUE'",
               CRITERE       =SIMP(statut='o',typ='TXM',
                                   into=("MATAKE_MODI_AV","DANG_VAN_MODI_AV","FATESOCI_MODI_AV","VMIS_TRESCA") ),
               b_fati_np  =BLOC(condition = 
                               "(CRITERE == 'MATAKE_MODI_AV' or CRITERE == 'DANG_VAN_MODI_AV' or CRITERE == 'FATESOCI_MODI_AV')",
                   PROJECTION    =SIMP(statut='o',typ='TXM',into=("UN_AXE", "DEUX_AXES") ),
                   DELTA_OSCI    =SIMP(statut='f',typ='R',defaut= 0.0E+0),  
               ),
           ),
           b_fati_grmano  =BLOC(condition = "(GROUP_MA != None or MAILLE != None or GROUP_NO != None or NOEUD != None)",
               MAILLAGE      =SIMP(statut='o',typ=maillage_sdaster ),
           ),
         ),

         INFO            =SIMP(statut='f',typ='I',defaut= 1,into=(1,2) ),
)  ;
#& MODIF COMMANDE  DATE 22/06/2005   AUTEUR REZETTE C.REZETTE 
#            CONFIGURATION MANAGEMENT OF EDF VERSION
# ======================================================================
# COPYRIGHT (C) 1991 - 2001  EDF R&D                  WWW.CODE-ASTER.ORG
# THIS PROGRAM IS FREE SOFTWARE; YOU CAN REDISTRIBUTE IT AND/OR MODIFY
# IT UNDER THE TERMS OF THE GNU GENERAL PUBLIC LICENSE AS PUBLISHED BY
# THE FREE SOFTWARE FOUNDATION; EITHER VERSION 2 OF THE LICENSE, OR   
# (AT YOUR OPTION) ANY LATER VERSION.                                 
#
# THIS PROGRAM IS DISTRIBUTED IN THE HOPE THAT IT WILL BE USEFUL, BUT 
# WITHOUT ANY WARRANTY; WITHOUT EVEN THE IMPLIED WARRANTY OF          
# MERCHANTABILITY OR FITNESS FOR A PARTICULAR PURPOSE. SEE THE GNU    
# GENERAL PUBLIC LICENSE FOR MORE DETAILS.                            
#
# YOU SHOULD HAVE RECEIVED A COPY OF THE GNU GENERAL PUBLIC LICENSE   
# ALONG WITH THIS PROGRAM; IF NOT, WRITE TO EDF R&D CODE_ASTER,       
#    1 AVENUE DU GENERAL DE GAULLE, 92141 CLAMART CEDEX, FRANCE.      
# ======================================================================
CALC_FLUI_STRU=OPER(nom="CALC_FLUI_STRU",op= 144,sd_prod=melasflu_sdaster,
                    reentrant='n',
                    fr="Calculer les paramètres modaux d'une structure soumise à un écoulement",
            UIinfo={"groupes":("Matrices/vecteurs",)},
         VITE_FLUI       =FACT(statut='f',
                               fr="Définir la plage de vitesse fluide étudiée",
           VITE_MIN        =SIMP(statut='f',typ='R' ),
           VITE_MAX        =SIMP(statut='f',typ='R' ),
           NB_POIN         =SIMP(statut='f',typ='I' ),
         ),
         BASE_MODALE     =FACT(statut='o',
                               
           regles=(AU_MOINS_UN('AMOR_REDUIT','AMOR_UNIF','AMOR_REDUIT_CONN'),),
           MODE_MECA       =SIMP(statut='o',typ=mode_meca ),
           NUME_ORDRE      =SIMP(statut='f',typ='I',max='**'),
           AMOR_REDUIT     =SIMP(statut='f',typ='R',max='**',val_min=0.E+00),
           AMOR_UNIF       =SIMP(statut='f',typ='R',val_min=0.E+00 ),
           AMOR_REDUIT_CONN=SIMP(statut='f',typ='R',max='**',val_min=0.E+00),
         ),
         TYPE_FLUI_STRU  =SIMP(statut='o',typ=type_flui_stru ),
         IMPRESSION      =FACT(statut='f',
                               fr="Choix des informations à imprimer dans le fichier RESULTAT",
           PARA_COUPLAGE   =SIMP(statut='f',typ='TXM',defaut="OUI",into=("OUI","NON") ),
           DEFORMEE        =SIMP(statut='f',typ='TXM',defaut="NON",into=("OUI","NON") ),
         ),
)  ;
#& MODIF COMMANDE  DATE 02/05/2006   AUTEUR MCOURTOI M.COURTOIS 
#            CONFIGURATION MANAGEMENT OF EDF VERSION
# ======================================================================
# COPYRIGHT (C) 1991 - 2001  EDF R&D                  WWW.CODE-ASTER.ORG
# THIS PROGRAM IS FREE SOFTWARE; YOU CAN REDISTRIBUTE IT AND/OR MODIFY
# IT UNDER THE TERMS OF THE GNU GENERAL PUBLIC LICENSE AS PUBLISHED BY
# THE FREE SOFTWARE FOUNDATION; EITHER VERSION 2 OF THE LICENSE, OR   
# (AT YOUR OPTION) ANY LATER VERSION.                                 
#
# THIS PROGRAM IS DISTRIBUTED IN THE HOPE THAT IT WILL BE USEFUL, BUT 
# WITHOUT ANY WARRANTY; WITHOUT EVEN THE IMPLIED WARRANTY OF          
# MERCHANTABILITY OR FITNESS FOR A PARTICULAR PURPOSE. SEE THE GNU    
# GENERAL PUBLIC LICENSE FOR MORE DETAILS.                            
#
# YOU SHOULD HAVE RECEIVED A COPY OF THE GNU GENERAL PUBLIC LICENSE   
# ALONG WITH THIS PROGRAM; IF NOT, WRITE TO EDF R&D CODE_ASTER,       
#    1 AVENUE DU GENERAL DE GAULLE, 92141 CLAMART CEDEX, FRANCE.      
# ======================================================================
def calc_fonc_interp_prod(FONCTION, NOM_PARA_FONC, **args):
   if   AsType(FONCTION) == nappe_sdaster:
      return nappe_sdaster
   elif AsType(FONCTION) == fonction_sdaster:
      return fonction_sdaster
   elif AsType(FONCTION) == fonction_c:
      return fonction_c
   elif AsType(FONCTION) == formule:
      if NOM_PARA_FONC != None:
         return nappe_sdaster
      return fonction_sdaster
   elif AsType(FONCTION) == para_sensi:
      return para_sensi
   raise AsException("type de concept resultat non prevu")

CALC_FONC_INTERP=OPER(nom="CALC_FONC_INTERP",op= 134,sd_prod=calc_fonc_interp_prod,
                      docu="U4.32.01-e",reentrant='n',
           fr="Définit une fonction (ou une nappe) à partir d'une fonction FORMULE à 1 ou 2 variables",
           UIinfo={"groupes":("Fonction",)},
         regles=(UN_PARMI('VALE_PARA','LIST_PARA'),),
         FONCTION        =SIMP(statut='o',typ=(formule,fonction_sdaster,nappe_sdaster,fonction_c) ),
         VALE_PARA       =SIMP(statut='f',typ='R',max='**'),
         LIST_PARA       =SIMP(statut='f',typ=listr8_sdaster ),
         NOM_RESU        =SIMP(statut='f',typ='TXM'),
         NOM_PARA        =SIMP(statut='f',typ='TXM'),
         INTERPOL        =SIMP(statut='f',typ='TXM',max=2,into=("NON","LIN","LOG") ),
         PROL_DROITE     =SIMP(statut='f',typ='TXM',into=("EXCLU","CONSTANT","LINEAIRE") ),
         PROL_GAUCHE     =SIMP(statut='f',typ='TXM',into=("EXCLU","CONSTANT","LINEAIRE") ),
         NOM_PARA_FONC   =SIMP(statut='f',typ='TXM'),
         b_eval_nappe    =BLOC(condition = "NOM_PARA_FONC != None",             
            regles=(UN_PARMI('VALE_PARA_FONC','LIST_PARA_FONC'),),
            VALE_PARA_FONC  =SIMP(statut='f',typ='R',max='**'),
            LIST_PARA_FONC  =SIMP(statut='f',typ=listr8_sdaster ),
            INTERPOL_FONC   =SIMP(statut='f',typ='TXM',max=2,into=("NON","LIN","LOG")),
            PROL_DROITE_FONC=SIMP(statut='f',typ='TXM',into=("EXCLU","CONSTANT","LINEAIRE") ),
            PROL_GAUCHE_FONC=SIMP(statut='f',typ='TXM',into=("EXCLU","CONSTANT","LINEAIRE") ),
         ),
         TITRE           =SIMP(statut='f',typ='TXM',max='**'),
         INFO            =SIMP(statut='f',typ='I',defaut= 1,into=( 1 , 2 ) ),
)  ;
#& MODIF COMMANDE  DATE 07/11/2006   AUTEUR DURAND C.DURAND 
#            CONFIGURATION MANAGEMENT OF EDF VERSION
# ======================================================================
# COPYRIGHT (C) 1991 - 2001  EDF R&D                  WWW.CODE-ASTER.ORG
# THIS PROGRAM IS FREE SOFTWARE; YOU CAN REDISTRIBUTE IT AND/OR MODIFY
# IT UNDER THE TERMS OF THE GNU GENERAL PUBLIC LICENSE AS PUBLISHED BY
# THE FREE SOFTWARE FOUNDATION; EITHER VERSION 2 OF THE LICENSE, OR   
# (AT YOUR OPTION) ANY LATER VERSION.                                 
#
# THIS PROGRAM IS DISTRIBUTED IN THE HOPE THAT IT WILL BE USEFUL, BUT 
# WITHOUT ANY WARRANTY; WITHOUT EVEN THE IMPLIED WARRANTY OF          
# MERCHANTABILITY OR FITNESS FOR A PARTICULAR PURPOSE. SEE THE GNU    
# GENERAL PUBLIC LICENSE FOR MORE DETAILS.                            
#
# YOU SHOULD HAVE RECEIVED A COPY OF THE GNU GENERAL PUBLIC LICENSE   
# ALONG WITH THIS PROGRAM; IF NOT, WRITE TO EDF R&D CODE_ASTER,       
#    1 AVENUE DU GENERAL DE GAULLE, 92141 CLAMART CEDEX, FRANCE.      
# ======================================================================
# RESPONSABLE MCOURTOI M.COURTOIS
from Macro.calc_fonction_ops import calc_fonction_ops
def calc_fonction_prod(self,DERIVE,EXTRACTION,INTEGRE,INVERSE,COMB,COMB_C,
                       ENVELOPPE,SPEC_OSCI,ASSE,FFT,COMPOSE,CORR_ACCE,PUISSANCE,
                       LISS_ENVELOP,ABS, **args):

   if (INTEGRE     != None): return fonction_sdaster
   if (DERIVE      != None): return fonction_sdaster
   if (INVERSE     != None): return fonction_sdaster
   if (COMB        != None): 
      type_vale=AsType(COMB[0]['FONCTION'])
      for mcfact in COMB :
          if(AsType(mcfact['FONCTION'])!=type_vale):
             raise AsException("CALC_FONCTION/COMB : pas de types hétérogènes nappe/fonction")
      return type_vale
   if (COMB_C      != None):
      vale=COMB_C[0]['FONCTION']
      if(AsType(vale) == nappe_sdaster):
         for mcfact in COMB_C[1:] :
             if(AsType(mcfact['FONCTION'])!=nappe_sdaster):
                raise AsException("CALC_FONCTION/COMB_C : pas de types hétérogènes nappe/fonction")
         return nappe_sdaster
      else:
         for mcfact in COMB_C :
             if(AsType(mcfact['FONCTION'])==nappe_sdaster):
                raise AsException("CALC_FONCTION/COMB_C : pas de types hétérogènes nappe/fonction")
         return fonction_c
   if (ENVELOPPE   != None): return AsType(ENVELOPPE[0]['FONCTION'])
   if (EXTRACTION  != None): return fonction_sdaster
   if (SPEC_OSCI   != None): return nappe_sdaster
   if (COMPOSE     != None): return fonction_sdaster
   if (ASSE        != None): return fonction_sdaster
   if (FFT         != None):
      vale=FFT[0]['FONCTION']
      if (AsType(vale) == fonction_sdaster )  : return fonction_c
      if (AsType(vale) == fonction_c) : return fonction_sdaster
   if (CORR_ACCE   != None): return fonction_sdaster
   if (LISS_ENVELOP!= None): return nappe_sdaster
   if (PUISSANCE   != None): return AsType(PUISSANCE[0]['FONCTION'])
   if (ABS         != None): return fonction_sdaster
   raise AsException("type de concept resultat non prevu")

CALC_FONCTION=MACRO(nom="CALC_FONCTION",op=calc_fonction_ops,sd_prod=calc_fonction_prod
                    ,fr="Effectue des opérations mathématiques sur des concepts de type fonction",
                     reentrant='n',
            UIinfo={"groupes":("Fonction",)},
         regles=(UN_PARMI('DERIVE','INTEGRE','SPEC_OSCI','COMB','COMB_C','ENVELOPPE',
                          'COMPOSE','EXTRACTION','ASSE','FFT','CORR_ACCE', 'PUISSANCE',
                          'LISS_ENVELOP','INVERSE','ABS'),),
         FFT             =FACT(statut='f',fr="Transformée de Fourier ou de son inverse",
           FONCTION        =SIMP(statut='o',typ=(fonction_sdaster,fonction_c) ),
           METHODE         =SIMP(statut='f',typ='TXM',defaut="PROL_ZERO",into=("PROL_ZERO","TRONCATURE") ),
           b_syme          =BLOC ( condition = " AsType(FONCTION)==fonction_c ",
             SYME           =SIMP(statut='f',typ='TXM',into=('OUI','NON'),defaut='OUI' ),  
           ),
         ),
         DERIVE          =FACT(statut='f',fr="Dérivée d une fonction",
           METHODE         =SIMP(statut='f',typ='TXM',defaut="DIFF_CENTREE",into=("DIFF_CENTREE",) ),
           FONCTION        =SIMP(statut='o',typ=fonction_sdaster ),
         ),
         INTEGRE         =FACT(statut='f',fr="Intégrale d'une fonction",
           METHODE         =SIMP(statut='f',typ='TXM',defaut="TRAPEZE",into=("SIMPSON","TRAPEZE") ),
           FONCTION        =SIMP(statut='o',typ=fonction_sdaster),
           COEF            =SIMP(statut='f',typ='R',defaut= 0.E+0,fr="Valeur de la constante d intégration" ),
         ),
         LISS_ENVELOP    = FACT(statut='f',fr="Lissage d une enveloppe",
           NAPPE           =SIMP(statut='o',typ=nappe_sdaster ),
           FREQ_MIN        =SIMP(statut='f',typ='R',defaut =0.2),
           FREQ_MAX        =SIMP(statut='f',typ='R',defaut =35.5),
           ELARG           =SIMP(statut='f',typ='R',defaut =0.1 ),
           TOLE_LISS       =SIMP(statut='f',typ='R',defaut =0.25 ),
         ),
         SPEC_OSCI       =FACT(statut='f',fr="Spectre d'oscillateur",
           METHODE         =SIMP(statut='f',typ='TXM',defaut="NIGAM",into=("NIGAM",) ),
           FONCTION        =SIMP(statut='o',typ=fonction_sdaster ),
           AMOR_REDUIT     =SIMP(statut='f',typ='R',max='**'),
           LIST_FREQ       =SIMP(statut='f',typ=listr8_sdaster ),
           FREQ            =SIMP(statut='f',typ='R',max='**'),
           NORME           =SIMP(statut='o',typ='R',fr="Valeur de la norme du spectre d oscillateur" ),
           NATURE          =SIMP(statut='f',typ='TXM',defaut="ACCE",into=("DEPL","VITE","ACCE") ),
           NATURE_FONC     =SIMP(statut='f',typ='TXM',defaut="ACCE",into=("DEPL","VITE","ACCE") ),
         ),
         ABS             =FACT(statut='f',fr="Valeur absolue d'une fonction",
           FONCTION        =SIMP(statut='o',typ=fonction_sdaster,),
         ),
         COMB            =FACT(statut='f',max='**',fr="Combinaison linéaire réelle de fonctions",
           FONCTION        =SIMP(statut='o',typ=(fonction_sdaster,nappe_sdaster) ),
           COEF            =SIMP(statut='o',typ='R',fr="Coefficient réel de la combinaison linéaire associée à la fonction" ),
         ),
         COMB_C          =FACT(statut='f',max='**',fr="Combinaison linéaire complexe de fonctions",
           regles=(UN_PARMI('COEF_R','COEF_C'),),
           FONCTION        =SIMP(statut='o',typ=(fonction_sdaster,fonction_c,nappe_sdaster) ),
           COEF_R          =SIMP(statut='f',typ='R',fr="Coefficient réel de la combinaison linéaire associée à la fonction" ),
           COEF_C          =SIMP(statut='f',typ='C',fr="Coefficient complexe de la combinaison linéaire associée à la fonction" ),
         ),
         b_comb          =BLOC ( condition = " (COMB != None) or (COMB_C != None)",
             LIST_PARA      =SIMP(statut='f',typ=listr8_sdaster ),  
         ),
         COMPOSE         =FACT(statut='f',fr="Composition de deux fonctions FONC_RESU(FONC_PARA)",
           FONC_RESU       =SIMP(statut='o',typ=fonction_sdaster),
           FONC_PARA       =SIMP(statut='o',typ=fonction_sdaster),
         ),
         EXTRACTION      =FACT(statut='f',fr="Extraction sur une fonction complexe",
           FONCTION        =SIMP(statut='o',typ=fonction_c),
           PARTIE          =SIMP(statut='o',typ='TXM',into=("REEL","IMAG","MODULE","PHASE"),fr="Partie à extraire"),
         ),
         ENVELOPPE       =FACT(statut='f',fr="Enveloppe d une famille de fonctions",
           FONCTION        =SIMP(statut='o',typ=(fonction_sdaster,nappe_sdaster),max='**' ),
           CRITERE         =SIMP(statut='f',typ='TXM',defaut="SUP",into=("SUP","INF"),fr="Type de l enveloppe" ),
         ),
         ASSE            =FACT(statut='f',fr="Concatenation de fonctions",
           FONCTION        =SIMP(statut='o',typ=fonction_sdaster,min=2,max=2 ),
           SURCHARGE       =SIMP(statut='f',typ='TXM',defaut="DROITE",into=("DROITE","GAUCHE")),
         ),
         CORR_ACCE     =FACT(statut='f',fr="Correction d un accelerogramme reel",
            CORR_DEPL       =SIMP(statut='f',typ='TXM',defaut="NON",into=("OUI","NON")),
            FONCTION        =SIMP(statut='o',typ=fonction_sdaster ),
         ),
         PUISSANCE       =FACT(statut='f',fr="Fonction élevée à une puissance",
            FONCTION      =SIMP(statut='o', typ=(fonction_sdaster,nappe_sdaster) ),
            EXPOSANT      =SIMP(statut='f', typ='I', defaut=1 ),
         ),
         INVERSE         =FACT(statut='f',fr="Inverse d'une fonction",
            FONCTION      =SIMP(statut='o', typ=fonction_sdaster),
         ),     
         NOM_PARA        =SIMP(statut='f',typ='TXM',into=C_PARA_FONCTION() ),
         NOM_RESU        =SIMP(statut='f',typ='TXM' ),
         INTERPOL        =SIMP(statut='f',typ='TXM',max=2,into=("NON","LIN","LOG") ),
         PROL_DROITE     =SIMP(statut='f',typ='TXM',into=("CONSTANT","LINEAIRE","EXCLU") ),
         PROL_GAUCHE     =SIMP(statut='f',typ='TXM',into=("CONSTANT","LINEAIRE","EXCLU") ),
         NOM_PARA_FONC   =SIMP(statut='f',typ='TXM',into=C_PARA_FONCTION() ),
         INTERPOL_FONC   =SIMP(statut='f',typ='TXM',max=2,into=("NON","LIN","LOG") ),
         PROL_DROITE_FONC=SIMP(statut='f',typ='TXM',into=("CONSTANT","LINEAIRE","EXCLU") ),
         PROL_GAUCHE_FONC=SIMP(statut='f',typ='TXM',into=("CONSTANT","LINEAIRE","EXCLU") ),
         INFO            =SIMP(statut='f',typ='I',defaut=1,into=(1,2) ),
)
#& MODIF COMMANDE  DATE 21/02/2006   AUTEUR REZETTE C.REZETTE 
#            CONFIGURATION MANAGEMENT OF EDF VERSION
# ======================================================================
# COPYRIGHT (C) 1991 - 2001  EDF R&D                  WWW.CODE-ASTER.ORG
# THIS PROGRAM IS FREE SOFTWARE; YOU CAN REDISTRIBUTE IT AND/OR MODIFY
# IT UNDER THE TERMS OF THE GNU GENERAL PUBLIC LICENSE AS PUBLISHED BY
# THE FREE SOFTWARE FOUNDATION; EITHER VERSION 2 OF THE LICENSE, OR   
# (AT YOUR OPTION) ANY LATER VERSION.                                 
#
# THIS PROGRAM IS DISTRIBUTED IN THE HOPE THAT IT WILL BE USEFUL, BUT 
# WITHOUT ANY WARRANTY; WITHOUT EVEN THE IMPLIED WARRANTY OF          
# MERCHANTABILITY OR FITNESS FOR A PARTICULAR PURPOSE. SEE THE GNU    
# GENERAL PUBLIC LICENSE FOR MORE DETAILS.                            
#
# YOU SHOULD HAVE RECEIVED A COPY OF THE GNU GENERAL PUBLIC LICENSE   
# ALONG WITH THIS PROGRAM; IF NOT, WRITE TO EDF R&D CODE_ASTER,       
#    1 AVENUE DU GENERAL DE GAULLE, 92141 CLAMART CEDEX, FRANCE.      
# ======================================================================
CALC_FORC_AJOU=OPER(nom="CALC_FORC_AJOU",op=199,sd_prod=vect_asse_gene,
                   fr="Calculer l'effet de surpression hydrodynamique due au mouvement d'entrainement de la structure"
                       +" en analyse sismique",
                   reentrant ='n',
            UIinfo={"groupes":("Matrices/vecteurs",)},

        regles=(EXCLUS('MODE_MECA','MODELE_GENE'),
                PRESENT_PRESENT( 'MODELE_GENE','NUME_DDL_GENE'),
                UN_PARMI('MONO_APPUI', 'NOEUD','GROUP_NO'),
                UN_PARMI('MONO_APPUI','MODE_STAT')),

         MODELE_FLUIDE   =SIMP(statut='o',typ=modele_sdaster ),
         MODELE_INTERFACE=SIMP(statut='o',typ=modele_sdaster ),
         CHAM_MATER      =SIMP(statut='o',typ=cham_mater ),
         CHARGE          =SIMP(statut='o',typ=char_ther ),
         MODE_MECA       =SIMP(statut='f',typ=mode_meca ),
         MODELE_GENE     =SIMP(statut='f',typ=modele_gene ),
         NUME_DDL_GENE   =SIMP(statut='f',typ=nume_ddl_gene ),
         DIST_REFE       =SIMP(statut='f',typ='R',defaut= 1.E-2 ),
         AVEC_MODE_STAT  =SIMP(statut='f',typ='TXM',defaut="OUI",into=("OUI","NON") ),
         NUME_MODE_MECA  =SIMP(statut='f',typ='I',validators=NoRepeat(),max='**'),
         POTENTIEL       =SIMP(statut='f',typ=evol_ther ),
         NOEUD_DOUBLE    =SIMP(statut='f',typ='TXM',defaut="NON",into=("OUI","NON") ),

         DIRECTION       =SIMP(statut='o',typ='R',max=3),
         MONO_APPUI      =SIMP(statut='f',typ='TXM',into=("OUI",),),
         NOEUD           =SIMP(statut='f',typ=no  ,validators=NoRepeat(),max='**'),
         GROUP_NO        =SIMP(statut='f',typ=grno,validators=NoRepeat(),max='**'),
         MODE_STAT       =SIMP(statut='f',typ=(mode_stat_depl,mode_stat_acce,mode_stat_forc,),),

         INFO            =SIMP(statut='f',typ='I',defaut= 1,into=( 1 , 2 ) ),

         SOLVEUR         =FACT(statut='d',
           METHODE         =SIMP(statut='f',typ='TXM',defaut="MULT_FRONT",into=("MULT_FRONT","LDLT","GCPC") ),
           b_mult_front    = BLOC ( condition = "METHODE == 'MULT_FRONT' ",fr="Paramètres de la méthode multi frontale",
             RENUM           =SIMP(statut='f',typ='TXM',defaut="METIS",into=("MD","MDA","METIS") ),
           ),
           b_ldlt          =BLOC( condition = "METHODE == 'LDLT' ",fr="Paramètres de la méthode LDLT",
             RENUM           =SIMP(statut='f',typ='TXM',defaut="RCMK",into=("RCMK","SANS") ),
           ),
           b_ldlt_mult     =BLOC( condition = "METHODE == 'LDLT' or METHODE == 'MULT_FRONT' ",
                                   fr="Paramètres relatifs à la non iversibilité de la matrice à factorise",
             NPREC           =SIMP(statut='f',typ='I',defaut= 8 ),
             STOP_SINGULIER  =SIMP(statut='f',typ='TXM',defaut="OUI",into=("OUI","NON") ),
           ),
           b_gcpc          =BLOC (condition = "METHODE == 'GCPC' ", fr="Paramètres de la méthode du gradient conjugué",
             PRE_COND        =SIMP(statut='f',typ='TXM',into=("LDLT_INC",),defaut="LDLT_INC" ),
             NIVE_REMPLISSAGE=SIMP(statut='f',typ='I',defaut=0),
             RENUM           =SIMP(statut='f',typ='TXM',defaut="RCMK",into=("SANS","RCMK") ),
             RESI_RELA       =SIMP(statut='f',typ='R',defaut= 1.E-6 ),
             NMAX_ITER       =SIMP(statut='f',typ='I',defaut= 0 ),
           ),
                           ),

           ) ;
#& MODIF COMMANDE  DATE 31/10/2006   AUTEUR REZETTE C.REZETTE 
#            CONFIGURATION MANAGEMENT OF EDF VERSION
# ======================================================================
# COPYRIGHT (C) 1991 - 2006  EDF R&D                  WWW.CODE-ASTER.ORG
# THIS PROGRAM IS FREE SOFTWARE; YOU CAN REDISTRIBUTE IT AND/OR MODIFY  
# IT UNDER THE TERMS OF THE GNU GENERAL PUBLIC LICENSE AS PUBLISHED BY  
# THE FREE SOFTWARE FOUNDATION; EITHER VERSION 2 OF THE LICENSE, OR     
# (AT YOUR OPTION) ANY LATER VERSION.                                                  
#                                                                       
# THIS PROGRAM IS DISTRIBUTED IN THE HOPE THAT IT WILL BE USEFUL, BUT   
# WITHOUT ANY WARRANTY; WITHOUT EVEN THE IMPLIED WARRANTY OF            
# MERCHANTABILITY OR FITNESS FOR A PARTICULAR PURPOSE. SEE THE GNU      
# GENERAL PUBLIC LICENSE FOR MORE DETAILS.                              
#                                                                       
# YOU SHOULD HAVE RECEIVED A COPY OF THE GNU GENERAL PUBLIC LICENSE     
# ALONG WITH THIS PROGRAM; IF NOT, WRITE TO EDF R&D CODE_ASTER,         
#    1 AVENUE DU GENERAL DE GAULLE, 92141 CLAMART CEDEX, FRANCE.        
# ======================================================================
CALC_G=OPER(nom="CALC_G",op=100,sd_prod=table_sdaster,
            fr="Calcul du taux de restitution d'énergie par la méthode theta en thermo-élasticité"
                        +" et les facteurs d'intensité de contraintes.",
                    reentrant='f',
            UIinfo={"groupes":("Post traitements",)},
         regles=(EXCLUS('COMP_ELAS','COMP_INCR'),
                 CONCEPT_SENSIBLE("ENSEMBLE"),
                 REUSE_SENSIBLE(),
                 DERIVABLE('RESULTAT'),
                 EXCLUS('TOUT_ORDRE','NUME_ORDRE','LIST_ORDRE','INST','LIST_INST',
                           'TOUT_MODE','NUME_MODE','LIST_MODE','FREQ','LIST_FREQ',),),

         THETA          =FACT(statut='o',
           THETA           =SIMP(statut='f',typ=(theta_geom,cham_no_sdaster),),
           FOND_FISS       =SIMP(statut='f',typ=fond_fiss,max=1),
           FISSURE         =SIMP(statut='f',typ=fiss_xfem,max=1),
           regles=(EXCLUS('FOND_FISS','FISSURE'),),
         b_theta        =BLOC(condition="THETA == None",fr="calcul de theta",
            regles=(UN_PARMI('R_INF','R_INF_FO'),
                 EXCLUS('MODULE','MODULE_FO'),
                 PRESENT_PRESENT('R_INF','R_SUP'),
                 PRESENT_PRESENT('R_INF_FO','R_SUP_FO'), ),
             NUME_FOND        =SIMP(statut='f',typ='I',defaut=1),
             R_INF           =SIMP(statut='f',typ='R'),
             R_SUP           =SIMP(statut='f',typ='R'),
             MODULE          =SIMP(statut='f',typ='R'),
             DIRE_THETA      =SIMP(statut='f',typ=cham_no_sdaster ),
             DIRECTION       =SIMP(statut='f',typ='R',max='**'),
             R_INF_FO        =SIMP(statut='f',typ=(fonction_sdaster,nappe_sdaster,formule)),
             R_SUP_FO        =SIMP(statut='f',typ=(fonction_sdaster,nappe_sdaster,formule)),             
             MODULE_FO       =SIMP(statut='f',typ=(fonction_sdaster,nappe_sdaster,formule)),
             ),
            ),

         RESULTAT        =SIMP(statut='o',typ=(evol_elas,evol_noli,dyna_trans,mode_meca),),

         TOUT_ORDRE      =SIMP(statut='f',typ='TXM',into=("OUI",) ),
         NUME_ORDRE      =SIMP(statut='f',typ='I',validators=NoRepeat(),max='**'),
         LIST_ORDRE      =SIMP(statut='f',typ=listis_sdaster),
         INST            =SIMP(statut='f',typ='R',validators=NoRepeat(),max='**'),
         LIST_INST       =SIMP(statut='f',typ=listr8_sdaster),
         TOUT_MODE       =SIMP(statut='f',typ='TXM',into=("OUI",) ),
         NUME_MODE       =SIMP(statut='f',typ='I',validators=NoRepeat(),max='**'),
         LIST_MODE       =SIMP(statut='f',typ=listis_sdaster),
         LIST_FREQ       =SIMP(statut='f',typ=listr8_sdaster),
         FREQ            =SIMP(statut='f',typ='R',validators=NoRepeat(),max='**'),
           
         b_acce_reel     =BLOC(condition="(INST != None)or(LIST_INST != None)or(FREQ != None)or(LIST_FREQ != None)",
           PRECISION       =SIMP(statut='f',typ='R',defaut=1.0E-6),
           CRITERE         =SIMP(statut='f',typ='TXM',defaut="RELATIF",into=("RELATIF","ABSOLU") ),
         ),
        
         EXCIT           =FACT(statut='f',max='**',
               CHARGE          =SIMP(statut='f',typ=(char_meca,char_cine_meca)),
               FONC_MULT       =SIMP(statut='f',typ=(fonction_sdaster,nappe_sdaster,formule)),
               TYPE_CHARGE     =SIMP(statut='f',typ='TXM',defaut="FIXE",into=("FIXE",) ),
         ),
         SYME_CHAR       =SIMP(statut='f',typ='TXM',defaut="SANS",into=("SYME","ANTI","SANS") ),
 
         COMP_ELAS       =FACT(statut='f',
               RELATION        =SIMP(statut='f',typ='TXM',defaut="ELAS",
                                     into=("ELAS","ELAS_VMIS_LINE","ELAS_VMIS_TRAC") ),
               ELAS            =SIMP(statut='f',typ='I',defaut=1,into=(1,) ),
               ELAS_VMIS_LINE  =SIMP(statut='f',typ='I',defaut=1,into=(1,) ),
               ELAS_VMIS_TRAC  =SIMP(statut='f',typ='I',defaut=1,into=(1,) ),
               DEFORMATION     =SIMP(statut='f',typ='TXM',defaut="PETIT",into=("PETIT","GREEN") ),
      regles=(PRESENT_ABSENT('TOUT','GROUP_MA','MAILLE'),),
               TOUT            =SIMP(statut='f',typ='TXM',into=("OUI",) ),
               GROUP_MA        =SIMP(statut='f',typ=grma,validators=NoRepeat(),max='**'),
               MAILLE          =SIMP(statut='f',typ=ma,validators=NoRepeat(),max='**'),
         ),  
         COMP_INCR       =FACT(statut='f',
               RELATION        =SIMP(statut='f',typ='TXM',defaut="ELAS",
                                     into=("ELAS","VMIS_ISOT_TRAC","VMIS_ISOT_LINE","VMIS_CINE_LINE") ),
               ELAS            =SIMP(statut='f',typ='I',defaut=1,into=(1,) ),
               VMIS_ISOT_TRAC  =SIMP(statut='f',typ='I',defaut=2,into=(2,) ),
               VMIS_ISOT_LINE  =SIMP(statut='f',typ='I',defaut=2,into=(2,) ),
               DEFORMATION     =SIMP(statut='f',typ='TXM',defaut="PETIT",into=("PETIT","PETIT_REAC") ),
      regles=(PRESENT_ABSENT('TOUT','GROUP_MA','MAILLE'),),
               TOUT            =SIMP(statut='f',typ='TXM',into=("OUI",) ),
               GROUP_MA        =SIMP(statut='f',typ=grma,validators=NoRepeat(),max='**'),
               MAILLE          =SIMP(statut='f',typ=ma,validators=NoRepeat(),max='**'),
         ),
         ETAT_INIT       =FACT(statut='f',
           SIGM            =SIMP(statut='f',typ=cham_elem),
           DEPL            =SIMP(statut='f',typ=cham_no_sdaster),
         ),
          
         LISSAGE         =FACT(statut='d',
           DEGRE           =SIMP(statut='f',typ='I',defaut=5,into=(0,1,2,3,4,5,6,7) ),
           LISSAGE_THETA   =SIMP(statut='f',typ='TXM',defaut="LEGENDRE",into=("LEGENDRE","LAGRANGE","LAGRANGE_REGU"),),
           LISSAGE_G       =SIMP(statut='f',typ='TXM',defaut="LEGENDRE",into=("LEGENDRE","LAGRANGE",
                                 "LAGRANGE_NO_NO","LAGRANGE_REGU"),),
         ),

         OPTION          =SIMP(statut='o',typ='TXM',max=1,defaut='CALC_G',
              into=("CALC_G","CALC_G_GLOB","CALC_K_G","K_G_MODA","G_MAX","G_MAX_GLOB","G_BILI",
                    "G_BILI_GLOB","G_LAGR","G_LAGR_GLOB","CALC_K_MAX"),),

         b_g_max    =BLOC(condition="(OPTION=='G_MAX') or (OPTION=='G_MAX_GLOB')",
           BORNES          =FACT(statut='o',max='**',
                NUME_ORDRE     =SIMP(statut='o',typ='I'),
                VALE_MIN       =SIMP(statut='o',typ='R'),
                VALE_MAX       =SIMP(statut='o',typ='R'),
                                ),
         ),
         b_k_max    =BLOC(condition="(OPTION=='CALC_K_MAX')",
           SIGNES          =FACT(statut='o',max=1,
                CHARGE_S       =SIMP(statut='o',typ='I',validators=NoRepeat(),max='**'),
                CHARGE_NS      =SIMP(statut='o',typ='I',validators=NoRepeat(),max='**'),
                                ),
         ),

         PROPAGATION     =SIMP(statut='f',typ='R'),
         THETA_LAGR      =SIMP(statut='f',typ=theta_geom),
         DIRE_THETA_LAGR =SIMP(statut='f',typ=cham_no_sdaster),
         SENSIBILITE     =SIMP(statut='f',typ=(para_sensi,theta_geom),validators=NoRepeat(),max='**',
                           fr="Liste des paramètres de sensibilité.",
                           ang="List of sensitivity parameters"),

         TITRE           =SIMP(statut='f',typ='TXM',max='**'),
         INFO            =SIMP(statut='f',typ='I',defaut=1,into=(1,2) ),
);
#& MODIF COMMANDE  DATE 10/10/2006   AUTEUR MCOURTOI M.COURTOIS 
#            CONFIGURATION MANAGEMENT OF EDF VERSION
# ======================================================================
# COPYRIGHT (C) 1991 - 2001  EDF R&D                  WWW.CODE-ASTER.ORG
# THIS PROGRAM IS FREE SOFTWARE; YOU CAN REDISTRIBUTE IT AND/OR MODIFY
# IT UNDER THE TERMS OF THE GNU GENERAL PUBLIC LICENSE AS PUBLISHED BY
# THE FREE SOFTWARE FOUNDATION; EITHER VERSION 2 OF THE LICENSE, OR   
# (AT YOUR OPTION) ANY LATER VERSION.                                 
#
# THIS PROGRAM IS DISTRIBUTED IN THE HOPE THAT IT WILL BE USEFUL, BUT 
# WITHOUT ANY WARRANTY; WITHOUT EVEN THE IMPLIED WARRANTY OF          
# MERCHANTABILITY OR FITNESS FOR A PARTICULAR PURPOSE. SEE THE GNU    
# GENERAL PUBLIC LICENSE FOR MORE DETAILS.                            
#
# YOU SHOULD HAVE RECEIVED A COPY OF THE GNU GENERAL PUBLIC LICENSE   
# ALONG WITH THIS PROGRAM; IF NOT, WRITE TO EDF R&D CODE_ASTER,       
#    1 AVENUE DU GENERAL DE GAULLE, 92141 CLAMART CEDEX, FRANCE.      
# ======================================================================
CALC_INTE_SPEC=OPER(nom="CALC_INTE_SPEC",op= 120,sd_prod=table_fonction,
                    fr="Calcul d'une matrice interspectrale à partir d'une fonction du temps",
                    reentrant='n',
            UIinfo={"groupes":("Fonction",)},
         INST_INIT       =SIMP(statut='f',typ='R',defaut= 0.E+0 ),
         INST_FIN        =SIMP(statut='o',typ='R' ),
         DUREE_ANALYSE   =SIMP(statut='f',typ='R' ),
         DUREE_DECALAGE  =SIMP(statut='f',typ='R' ),
         NB_POIN         =SIMP(statut='o',typ='I' ),
         FONCTION        =SIMP(statut='o',typ=(fonction_sdaster,nappe_sdaster,formule),max='**' ),
         TITRE           =SIMP(statut='f',typ='TXM',validators=NoRepeat(),max='**'),
         INFO            =SIMP(statut='f',typ='I',defaut=1,into=(1 , 2) ),
)  ;
#& MODIF COMMANDE  DATE 21/02/2006   AUTEUR REZETTE C.REZETTE 
#            CONFIGURATION MANAGEMENT OF EDF VERSION
# ======================================================================
# COPYRIGHT (C) 1991 - 2001  EDF R&D                  WWW.CODE-ASTER.ORG
# THIS PROGRAM IS FREE SOFTWARE; YOU CAN REDISTRIBUTE IT AND/OR MODIFY
# IT UNDER THE TERMS OF THE GNU GENERAL PUBLIC LICENSE AS PUBLISHED BY
# THE FREE SOFTWARE FOUNDATION; EITHER VERSION 2 OF THE LICENSE, OR   
# (AT YOUR OPTION) ANY LATER VERSION.                                 
#
# THIS PROGRAM IS DISTRIBUTED IN THE HOPE THAT IT WILL BE USEFUL, BUT 
# WITHOUT ANY WARRANTY; WITHOUT EVEN THE IMPLIED WARRANTY OF          
# MERCHANTABILITY OR FITNESS FOR A PARTICULAR PURPOSE. SEE THE GNU    
# GENERAL PUBLIC LICENSE FOR MORE DETAILS.                            
#
# YOU SHOULD HAVE RECEIVED A COPY OF THE GNU GENERAL PUBLIC LICENSE   
# ALONG WITH THIS PROGRAM; IF NOT, WRITE TO EDF R&D CODE_ASTER,       
#    1 AVENUE DU GENERAL DE GAULLE, 92141 CLAMART CEDEX, FRANCE.      
# ======================================================================
CALC_MATR_AJOU=OPER(nom="CALC_MATR_AJOU",op= 152,sd_prod=matr_asse_gene_r,
                    fr="Calcul des matrices de masse, d'amortissement ou de rigidité ajoutés",
                    reentrant='n',
            UIinfo={"groupes":("Matrices/vecteurs",)},
         regles=(EXCLUS('MODE_MECA','CHAM_NO','MODELE_GENE'),
                 PRESENT_ABSENT('NUME_DDL_GENE','CHAM_NO'),
                 PRESENT_PRESENT('MODELE_GENE','NUME_DDL_GENE'),),
         MODELE_FLUIDE   =SIMP(statut='o',typ=modele_sdaster ),
         MODELE_INTERFACE=SIMP(statut='o',typ=modele_sdaster ),
         CHAM_MATER      =SIMP(statut='o',typ=cham_mater ),
         CHARGE          =SIMP(statut='o',typ=char_ther ),
         MODE_MECA       =SIMP(statut='f',typ=mode_meca ),
         CHAM_NO         =SIMP(statut='f',typ=cham_no_sdaster ),
         MODELE_GENE     =SIMP(statut='f',typ=modele_gene ),
         NUME_DDL_GENE   =SIMP(statut='f',typ=nume_ddl_gene ),
         DIST_REFE       =SIMP(statut='f',typ='R',defaut= 1.E-2 ),
         AVEC_MODE_STAT  =SIMP(statut='f',typ='TXM',defaut="OUI",into=("OUI","NON") ),
         NUME_MODE_MECA  =SIMP(statut='f',typ='I',validators=NoRepeat(),max='**'),
         OPTION          =SIMP(statut='o',typ='TXM',into=("MASS_AJOU","AMOR_AJOU","RIGI_AJOU") ),
         POTENTIEL       =SIMP(statut='f',typ=evol_ther ),
         NOEUD_DOUBLE    =SIMP(statut='f',typ='TXM',defaut="NON",into=("OUI","NON") ),
         INFO            =SIMP(statut='f',typ='I',defaut= 1,into=( 1 , 2 ) ),

         SOLVEUR         =FACT(statut='d',
           METHODE         =SIMP(statut='f',typ='TXM',defaut="MULT_FRONT",into=("MULT_FRONT","LDLT","GCPC") ),
           b_mult_front    = BLOC ( condition = "METHODE == 'MULT_FRONT' ",fr="Paramètres de la méthode multi frontale",
             RENUM           =SIMP(statut='f',typ='TXM',defaut="METIS",into=("MD","MDA","METIS") ),
           ),
           b_ldlt          =BLOC( condition = "METHODE == 'LDLT' ",fr="Paramètres de la méthode LDLT",
             RENUM           =SIMP(statut='f',typ='TXM',defaut="RCMK",into=("RCMK","SANS") ),
           ),
           b_ldlt_mult     =BLOC( condition = "METHODE == 'LDLT' or METHODE == 'MULT_FRONT' ",
                                   fr="Paramètres relatifs à la non iversibilité de la matrice à factorise",
             NPREC           =SIMP(statut='f',typ='I',defaut= 8 ),
             STOP_SINGULIER  =SIMP(statut='f',typ='TXM',defaut="OUI",into=("OUI","NON") ),
           ),
           b_gcpc          =BLOC (condition = "METHODE == 'GCPC' ", fr="Paramètres de la méthode du gradient conjugué",
             PRE_COND        =SIMP(statut='f',typ='TXM',into=("LDLT_INC",),defaut="LDLT_INC" ),
             NIVE_REMPLISSAGE=SIMP(statut='f',typ='I',defaut=0),
             RENUM           =SIMP(statut='f',typ='TXM',defaut="RCMK",into=("SANS","RCMK") ),
             RESI_RELA       =SIMP(statut='f',typ='R',defaut= 1.E-6 ),
             NMAX_ITER       =SIMP(statut='f',typ='I',defaut= 0 ),
           ),
         ),
)  ;
#& MODIF COMMANDE  DATE 16/05/2006   AUTEUR REZETTE C.REZETTE 
#            CONFIGURATION MANAGEMENT OF EDF VERSION
# ======================================================================
# COPYRIGHT (C) 1991 - 2001  EDF R&D                  WWW.CODE-ASTER.ORG
# THIS PROGRAM IS FREE SOFTWARE; YOU CAN REDISTRIBUTE IT AND/OR MODIFY
# IT UNDER THE TERMS OF THE GNU GENERAL PUBLIC LICENSE AS PUBLISHED BY
# THE FREE SOFTWARE FOUNDATION; EITHER VERSION 2 OF THE LICENSE, OR
# (AT YOUR OPTION) ANY LATER VERSION.
#
# THIS PROGRAM IS DISTRIBUTED IN THE HOPE THAT IT WILL BE USEFUL, BUT
# WITHOUT ANY WARRANTY; WITHOUT EVEN THE IMPLIED WARRANTY OF
# MERCHANTABILITY OR FITNESS FOR A PARTICULAR PURPOSE. SEE THE GNU
# GENERAL PUBLIC LICENSE FOR MORE DETAILS.
#
# YOU SHOULD HAVE RECEIVED A COPY OF THE GNU GENERAL PUBLIC LICENSE
# ALONG WITH THIS PROGRAM; IF NOT, WRITE TO EDF R&D CODE_ASTER,
#    1 AVENUE DU GENERAL DE GAULLE, 92141 CLAMART CEDEX, FRANCE.
# ======================================================================
# RESPONSABLE VABHHTS J.PELLET
def calc_matr_elem_prod(OPTION,**args):
  if OPTION == "RIGI_MECA"        : return matr_elem_depl_r
  if OPTION == "RIGI_FLUI_STRU"   : return matr_elem_depl_r
  if OPTION == "RIGI_MECA_LAGR"   : return matr_elem_depl_r
  if OPTION == "MASS_ID_MDEP_R"   : return matr_elem_depl_r
  if OPTION == "MASS_ID_MDNS_R"   : return matr_elem_depl_r
  if OPTION == "MASS_ID_MTEM_R"   : return matr_elem_temp_r
  if OPTION == "MASS_ID_MTNS_R"   : return matr_elem_temp_r
  if OPTION == "MASS_MECA"        : return matr_elem_depl_r
  if OPTION == "MASS_FLUI_STRU"   : return matr_elem_depl_r
  if OPTION == "RIGI_GEOM"        : return matr_elem_depl_r
  if OPTION == "RIGI_ROTA"        : return matr_elem_depl_r
  if OPTION == "AMOR_MECA"        : return matr_elem_depl_r
  if OPTION == "IMPE_MECA"        : return matr_elem_depl_r
  if OPTION == "ONDE_FLUI"        : return matr_elem_depl_r
  if OPTION == "AMOR_MECA_ABSO"   : return matr_elem_depl_r
  if OPTION == "RIGI_MECA_HYST"   : return matr_elem_depl_c
  if OPTION == "RIGI_THER"        : return matr_elem_temp_r
  if OPTION == "MASS_THER"        : return matr_elem_temp_r
  if OPTION == "MASS_MECA_DIAG"   : return matr_elem_depl_r
  if OPTION == "RIGI_ACOU"        : return matr_elem_pres_c
  if OPTION == "MASS_ACOU"        : return matr_elem_pres_c
  if OPTION == "AMOR_ACOU"        : return matr_elem_pres_c
  raise AsException("type de concept resultat non prevu")

CALC_MATR_ELEM=OPER(nom="CALC_MATR_ELEM",op=   9,sd_prod=calc_matr_elem_prod
                    ,fr="Calcul des matrices élémentaires",reentrant='n',
            UIinfo={"groupes":("Matrices/vecteurs",)},

         OPTION          =SIMP(statut='o',typ='TXM',
                               into=("RIGI_MECA","MASS_MECA","RIGI_GEOM",
                                     "AMOR_MECA","RIGI_THER","MASS_THER","IMPE_MECA",
                                     "ONDE_FLUI","AMOR_MECA_ABSO","MASS_FLUI_STRU","RIGI_FLUI_STRU",
                                     "RIGI_ROTA","MASS_MECA_DIAG","RIGI_ACOU",
                                     "MASS_ID_MDEP_R","MASS_ID_MDNS_R","MASS_ID_MTEM_R","MASS_ID_MTNS_R",
                                     "MASS_ACOU","AMOR_ACOU","RIGI_MECA_HYST",
                                     "RIGI_MECA_LAGR") ),

         # mots clés facultatifs que l'on a du mal à mettre dans les blocs
         # sans gener MACRO_MATR_ASSE :
         #------------------------------------------------------------------
         INST=SIMP(statut='f',typ='R',defaut= 0.E+0 ),


         b_rigi_meca = BLOC( condition = "OPTION=='RIGI_MECA'",
           regles=(AU_MOINS_UN('MODELE','CHARGE' ),),
           MODELE          =SIMP(statut='f',typ=modele_sdaster ),
           b_modele        =BLOC(condition = "MODELE != None",
             CHAM_MATER      =SIMP(statut='f',typ=cham_mater ),
             CARA_ELEM       =SIMP(statut='f',typ=cara_elem ),
             MODE_FOURIER    =SIMP(statut='f',typ='I',defaut= 0 ),
           ),
           CHARGE          =SIMP(statut='f',typ=char_meca,validators=NoRepeat(),max='**' ),
         ),

         b_rigi_meca_lagr  =BLOC(condition = "OPTION=='RIGI_MECA_LAGR'",
           MODELE            =SIMP(statut='o',typ=modele_sdaster ),
           CHAM_MATER        =SIMP(statut='o',typ=cham_mater ),
           CHARGE            =SIMP(statut='f',typ=char_meca,validators=NoRepeat(),max='**'  ),
           THETA           =SIMP(statut='o',typ=theta_geom ),
           PROPAGATION     =SIMP(statut='f',typ='R',defaut= 0.E+0 ),
         ),

         b_mass_meca       =BLOC(condition = "(OPTION=='MASS_MECA') or (OPTION=='MASS_MECA_DIAG')",
           regles=(AU_MOINS_UN('MODELE','CHARGE'),),
           MODELE          =SIMP(statut='f',typ=modele_sdaster ),
           b_modele          =BLOC(condition = "MODELE != None",
             CHAM_MATER        =SIMP(statut='f',typ=cham_mater ),
             CARA_ELEM         =SIMP(statut='f',typ=cara_elem ),
           ),
           CHARGE          =SIMP(statut='f',typ=char_meca,validators=NoRepeat(),max='**'),
         ),

         b_mass_identite   =BLOC(condition = "(OPTION in ('MASS_ID_MDEP_R','MASS_ID_MTEM_R','MASS_ID_MDNS_R','MASS_ID_MTNS_R')) ",
           MODELE            =SIMP(statut='o',typ=modele_sdaster ),
           # j'ajoute ces 2 mot clés inutiles à cause de l'alarme pas assez subtile de MEDOME
           CHAM_MATER        =SIMP(statut='f',typ=cham_mater ),
           CARA_ELEM         =SIMP(statut='f',typ=cara_elem ),
         ),

         b_rigi_geom       =BLOC(condition = "OPTION=='RIGI_GEOM'",
           MODELE            =SIMP(statut='o',typ=modele_sdaster ),
           CARA_ELEM         =SIMP(statut='f',typ=cara_elem ),
           SIEF_ELGA         =SIMP(statut='o',typ=cham_elem ),
           MODE_FOURIER      =SIMP(statut='f',typ='I',defaut= 0 ),
         ),

         b_rigi_rota       =BLOC(condition = "OPTION=='RIGI_ROTA'",
           MODELE            =SIMP(statut='o',typ=modele_sdaster ),
           CHAM_MATER        =SIMP(statut='o',typ=cham_mater ),
           CHARGE            =SIMP(statut='o',typ=char_meca,validators=NoRepeat(),max='**' ),
         ),

         b_amor_meca       =BLOC(condition = "OPTION=='AMOR_MECA'",
           regles=(AU_MOINS_UN('CARA_ELEM','RIGI_MECA'),
                   ENSEMBLE('RIGI_MECA','MASS_MECA','CHAM_MATER'), ),
           MODELE            =SIMP(statut='o',typ=modele_sdaster ),
           CARA_ELEM         =SIMP(statut='f',typ=cara_elem ),
           CHAM_MATER        =SIMP(statut='f',typ=cham_mater ),
           RIGI_MECA         =SIMP(statut='f',typ=matr_elem_depl_r ),
           MASS_MECA         =SIMP(statut='f',typ=matr_elem_depl_r ),
           CHARGE            =SIMP(statut='f',typ=char_meca,validators=NoRepeat(),max='**'),
         ),
         
         b_amor_meca_abso  =BLOC(condition = "OPTION=='AMOR_MECA_ABSO'",
           regles=(AU_MOINS_UN('CARA_ELEM','RIGI_MECA'),
                   ENSEMBLE('RIGI_MECA','MASS_MECA','CHAM_MATER'), ),
           MODELE            =SIMP(statut='o',typ=modele_sdaster ),
           CARA_ELEM         =SIMP(statut='f',typ=cara_elem ),
           CHAM_MATER        =SIMP(statut='o',typ=cham_mater ),
           RIGI_MECA         =SIMP(statut='f',typ=matr_elem_depl_r ),
           MASS_MECA         =SIMP(statut='f',typ=matr_elem_depl_r ),
           CHARGE            =SIMP(statut='f',typ=char_meca,validators=NoRepeat(),max='**'),
         ),
         
         b_rigi_meca_hyst  =BLOC( condition = "OPTION=='RIGI_MECA_HYST'",
           MODELE            =SIMP(statut='o',typ=modele_sdaster ),
           CHARGE            =SIMP(statut='f',typ=char_meca ,validators=NoRepeat(),max='**' ),
           CHAM_MATER        =SIMP(statut='f',typ=cham_mater ),
           CARA_ELEM         =SIMP(statut='f',typ=cara_elem ),
           RIGI_MECA         =SIMP(statut='o',typ=matr_elem_depl_r ),
         ),

         b_rigi_ther       =BLOC(condition = "OPTION=='RIGI_THER'",
           regles=(AU_MOINS_UN('MODELE','CHARGE' ),),
           MODELE            =SIMP(statut='f',typ=modele_sdaster ),
           b_modele          =BLOC(condition = "MODELE != None",
             CHAM_MATER        =SIMP(statut='o',typ=cham_mater ),
             CARA_ELEM         =SIMP(statut='f',typ=cara_elem ),
             MODE_FOURIER      =SIMP(statut='f',typ='I',defaut= 0 ),
           ),
           CHARGE            =SIMP(statut='f',typ=char_ther,validators=NoRepeat(),max='**' ),
         ),

         b_mass_ther       =BLOC(condition = "OPTION=='MASS_THER'",
           MODELE            =SIMP(statut='o',typ=modele_sdaster ),
           CHAM_MATER        =SIMP(statut='o',typ=cham_mater ),
           CARA_ELEM         =SIMP(statut='f',typ=cara_elem ),
           CHARGE            =SIMP(statut='f',typ=char_ther ,validators=NoRepeat(),max='**' ),
         ),

         b_rigi_acou       =BLOC(condition = "OPTION=='RIGI_ACOU'",
           MODELE            =SIMP(statut='o',typ=modele_sdaster ),
           CHAM_MATER        =SIMP(statut='o',typ=cham_mater ),
           CHARGE            =SIMP(statut='f',typ=char_acou ,validators=NoRepeat(),max='**' ),
         ),

         b_mass_acou       =BLOC(condition = "(OPTION=='MASS_ACOU') or (OPTION=='AMOR_ACOU')",
           MODELE            =SIMP(statut='o',typ=modele_sdaster ),
           CHAM_MATER        =SIMP(statut='o',typ=cham_mater ),
           CHARGE            =SIMP(statut='f',typ=char_acou ,validators=NoRepeat(),max='**' ),
         ),

         b_rigi_flui       =BLOC(condition = "OPTION=='RIGI_FLUI_STRU'",
           MODELE            =SIMP(statut='o',typ=modele_sdaster ),
           CARA_ELEM         =SIMP(statut='o',typ=cara_elem ),
           CHAM_MATER        =SIMP(statut='o',typ=cham_mater ),
           CHARGE            =SIMP(statut='o',typ=char_meca ,validators=NoRepeat(),max='**' ),
         ),

         b_mass_flui       =BLOC(condition = "OPTION=='MASS_FLUI_STRU'",
           MODELE            =SIMP(statut='o',typ=modele_sdaster ),
           CARA_ELEM         =SIMP(statut='o',typ=cara_elem ),
           CHAM_MATER        =SIMP(statut='o',typ=cham_mater ),
           CHARGE            =SIMP(statut='o',typ=char_meca ,validators=NoRepeat(),max='**'),
         ),

         b_impe_meca       =BLOC(condition = "(OPTION=='IMPE_MECA') or (OPTION=='ONDE_FLUI')",
           MODELE            =SIMP(statut='o',typ=modele_sdaster ),
           CHAM_MATER        =SIMP(statut='o',typ=cham_mater ),
           CHARGE            =SIMP(statut='o',typ=char_meca,validators=NoRepeat(),max='**' ),
         ),
)  ;
#& MODIF COMMANDE  DATE 21/02/2006   AUTEUR REZETTE C.REZETTE 
#            CONFIGURATION MANAGEMENT OF EDF VERSION
# ======================================================================
# COPYRIGHT (C) 1991 - 2001  EDF R&D                  WWW.CODE-ASTER.ORG
# THIS PROGRAM IS FREE SOFTWARE; YOU CAN REDISTRIBUTE IT AND/OR MODIFY
# IT UNDER THE TERMS OF THE GNU GENERAL PUBLIC LICENSE AS PUBLISHED BY
# THE FREE SOFTWARE FOUNDATION; EITHER VERSION 2 OF THE LICENSE, OR   
# (AT YOUR OPTION) ANY LATER VERSION.                                 
#
# THIS PROGRAM IS DISTRIBUTED IN THE HOPE THAT IT WILL BE USEFUL, BUT 
# WITHOUT ANY WARRANTY; WITHOUT EVEN THE IMPLIED WARRANTY OF          
# MERCHANTABILITY OR FITNESS FOR A PARTICULAR PURPOSE. SEE THE GNU    
# GENERAL PUBLIC LICENSE FOR MORE DETAILS.                            
#
# YOU SHOULD HAVE RECEIVED A COPY OF THE GNU GENERAL PUBLIC LICENSE   
# ALONG WITH THIS PROGRAM; IF NOT, WRITE TO EDF R&D CODE_ASTER,       
#    1 AVENUE DU GENERAL DE GAULLE, 92141 CLAMART CEDEX, FRANCE.      
# ======================================================================
CALC_META=OPER(nom="CALC_META",op=194,sd_prod=evol_ther,reentrant='o',
            UIinfo={"groupes":("Post traitements",)},
               fr="Calcule l'évolution métallurgique à partir du résultat d'un calcul thermique",
         MODELE          =SIMP(statut='o',typ=modele_sdaster ),
         CHAM_MATER      =SIMP(statut='o',typ=cham_mater ),
         RESULTAT        =SIMP(statut='o',typ=evol_ther ),
         ETAT_INIT       =FACT(statut='o',
            regles=(UN_PARMI('EVOL_THER', 'META_INIT_ELNO'),),
            EVOL_THER       =SIMP(statut='f',typ=evol_ther ),
            META_INIT_ELNO  =SIMP(statut='f',typ=carte_sdaster ),
            b_etat     =BLOC(condition="EVOL_THER != None",
               regles=(UN_PARMI('NUME_INIT', 'INST_INIT',),),
               NUME_INIT       =SIMP(statut='f',typ='I'),
               INST_INIT       =SIMP(statut='f',typ='R'),
               b_inst     =BLOC(condition="INST_INIT != None",
                  PRECISION       =SIMP(statut='f',typ='R',defaut=1.0E-3),
                  CRITERE         =SIMP(statut='f',typ='TXM',defaut="RELATIF",into=("RELATIF","ABSOLU") )
               ),
            ),
         ),
         COMP_INCR       =FACT(statut='o',max='**',
           RELATION        =SIMP(statut='o',typ='TXM',into=("ACIER","ZIRC",) ),
           ACIER           =SIMP(statut='c',typ='I',defaut=7,into=(7,) ),
           ZIRC            =SIMP(statut='c',typ='I',defaut=3,into=(3,) ),
      regles=(PRESENT_ABSENT('TOUT','GROUP_MA','MAILLE'),),
           TOUT            =SIMP(statut='f',typ='TXM',into=("OUI",) ),
           GROUP_MA        =SIMP(statut='f',typ=grma),
           MAILLE          =SIMP(statut='f',typ=ma),
         ),
         OPTION          =SIMP(statut='f',typ='TXM'     
                             ,into=("META_ELNO_TEMP",) ),
)  ;
#& MODIF COMMANDE  DATE 24/10/2006   AUTEUR SMICHEL S.MICHEL-PONNELLE 
#            CONFIGURATION MANAGEMENT OF EDF VERSION
# ======================================================================
# COPYRIGHT (C) 1991 - 2001  EDF R&D                  WWW.CODE-ASTER.ORG
# THIS PROGRAM IS FREE SOFTWARE; YOU CAN REDISTRIBUTE IT AND/OR MODIFY
# IT UNDER THE TERMS OF THE GNU GENERAL PUBLIC LICENSE AS PUBLISHED BY
# THE FREE SOFTWARE FOUNDATION; EITHER VERSION 2 OF THE LICENSE, OR   
# (AT YOUR OPTION) ANY LATER VERSION.                                 
#
# THIS PROGRAM IS DISTRIBUTED IN THE HOPE THAT IT WILL BE USEFUL, BUT 
# WITHOUT ANY WARRANTY; WITHOUT EVEN THE IMPLIED WARRANTY OF          
# MERCHANTABILITY OR FITNESS FOR A PARTICULAR PURPOSE. SEE THE GNU    
# GENERAL PUBLIC LICENSE FOR MORE DETAILS.                            
#
# YOU SHOULD HAVE RECEIVED A COPY OF THE GNU GENERAL PUBLIC LICENSE   
# ALONG WITH THIS PROGRAM; IF NOT, WRITE TO EDF R&D CODE_ASTER,       
#    1 AVENUE DU GENERAL DE GAULLE, 92141 CLAMART CEDEX, FRANCE.      
# ======================================================================
# RESPONSABLE G8BHHXD X.DESROCHES
def calc_no_prod(RESULTAT,**args):
   if AsType(RESULTAT) != None : return AsType(RESULTAT)
   raise AsException("type de concept resultat non prevu")

CALC_NO=OPER(nom="CALC_NO",op= 106,sd_prod=calc_no_prod,reentrant='o',
            fr="Enrichir une SD Résultat par des champs aux noeuds calculés à partir de champs aux éléments évalués aux noeuds",
            UIinfo={"groupes":("Post traitements",)},
         RESULTAT        =SIMP(statut='o',typ=(evol_elas,dyna_trans,dyna_harmo,acou_harmo,mode_meca,
                                               mode_acou,mode_stat,mode_stat_depl,mode_stat_acce,
                                              mode_stat_forc,evol_ther,evol_noli,base_modale,
                                               mult_elas,fourier_elas,fourier_ther,mode_flamb ) ),
         SENSIBILITE     =SIMP(statut='f',typ=(para_sensi,theta_geom),validators=NoRepeat(),max='**',
                               fr="Liste des paramètres de sensibilité.",
                               ang="List of sensitivity parameters"),

         regles=(EXCLUS('TOUT_ORDRE','NUME_ORDRE','INST','FREQ','NUME_MODE',
                        'NOEUD_CMP','LIST_INST','LIST_FREQ','LIST_ORDRE','NOM_CAS'),
                 CONCEPT_SENSIBLE("SEPARE"),
                 DERIVABLE('RESULTAT'),),
         TOUT_ORDRE      =SIMP(statut='f',typ='TXM',into=("OUI",) ),
         NUME_ORDRE      =SIMP(statut='f',typ='I',validators=NoRepeat(),max='**'),
         NUME_MODE       =SIMP(statut='f',typ='I',validators=NoRepeat(),max='**'),
         NOEUD_CMP       =SIMP(statut='f',typ='TXM',validators=NoRepeat(),max='**'),
         NOM_CAS         =SIMP(statut='f',typ='TXM' ),
         INST            =SIMP(statut='f',typ='R',validators=NoRepeat(),max='**'),
         FREQ            =SIMP(statut='f',typ='R',validators=NoRepeat(),max='**'),
         LIST_INST       =SIMP(statut='f',typ=listr8_sdaster),
         LIST_FREQ       =SIMP(statut='f',typ=listr8_sdaster),
         PRECISION       =SIMP(statut='f',typ='R',defaut=1.0E-3 ),
         CRITERE         =SIMP(statut='f',typ='TXM',defaut="RELATIF",into=("RELATIF","ABSOLU") ),
         LIST_ORDRE      =SIMP(statut='f',typ=listis_sdaster),

         OPTION          =SIMP(statut='o',typ='TXM',validators=NoRepeat(),max='**',
                               into=("FORC_NODA","REAC_NODA",
                                     "DCHA_NOEU_SIGM",
                                     "DEGE_NOEU_DEPL",
                                     "DETE_NOEU_DLTE",
                                     "DEDE_NOEU_DLDE",
                                     "DESI_NOEU_DLSI",
                                     "DURT_NOEU_META",
                                     "EFGE_NOEU_CART","EFGE_NOEU_DEPL",
                                     "ENDO_NOEU_SINO",
                                     "ENEL_NOEU_ELGA",
                                     "EPMG_NOEU_DEPL",
                                     "EPSA_NOEU",
                                     "EPSG_NOEU_DEPL",
                                     "EPSI_NOEU_DEPL",
                                     "EPSP_NOEU"     ,"EPSP_NOEU_ZAC",
                                     "EPVC_NOEU","EPFD_NOEU","EPFP_NOEU","EPFP_NOEU",
                                     "EQUI_NOEU_EPME","EQUI_NOEU_EPSI","EQUI_NOEU_SIGM",
                                     "ERRE_NOEU_ELEM","QIRE_NOEU_ELEM",
                                     "FLUX_NOEU_TEMP",
                                     "HYDR_NOEU_ELGA",
                                     "INTE_NOEU_ACTI","INTE_NOEU_REAC",
                                     "META_NOEU_TEMP",
                                     "PMPB_NOEU_SIEF",
                                     "PRES_NOEU_DBEL","PRES_NOEU_IMAG","PRES_NOEU_REEL",
                                     "RADI_NOEU_SIGM",
                                     "SIEF_NOEU"     ,"SIEF_NOEU_ELGA",
                                     "SIGM_NOEU_CART","SIGM_NOEU_COQU","SIGM_NOEU_DEPL",
                                     "SIGM_NOEU_SIEF","SIGM_NOEU_ZAC",
                                     "SIPO_NOEU_DEPL","SIPO_NOEU_SIEF",
                                     "SIRE_NOEU_DEPL",
                                     "VARI_NOEU","EXTR_NOEU_VARI","VARI_NOEU_ELGA",) ),

         b_forc_reac     =BLOC(condition = """(OPTION == 'FORC_NODA') or (type(OPTION) == type(()) and 'FORC_NODA' in OPTION) or\
 (OPTION == 'REAC_NODA') or (type(OPTION) == type(()) and 'REAC_NODA' in OPTION)""",
             MODELE          =SIMP(statut='f',typ=modele_sdaster),
         ),

         CHAM_MATER      =SIMP(statut='f',typ=cham_mater),
         CARA_ELEM       =SIMP(statut='f',typ=cara_elem),
         EXCIT           =FACT(statut='f',max='**',
           CHARGE          =SIMP(statut='f',typ=(char_meca,char_ther,char_acou) ),
           FONC_MULT       =SIMP(statut='f',typ=(fonction_sdaster,nappe_sdaster,formule)),
           TYPE_CHARGE     =SIMP(statut='f',typ='TXM',defaut="FIXE_CSTE",
                                 into=("FIXE_CSTE","FIXE_PILO","SUIV") ),
         ),
         TOUT            =SIMP(statut='f',typ='TXM',into=("OUI",) ),
         GROUP_MA        =SIMP(statut='f',typ=grma,validators=NoRepeat(),max='**'),
         MAILLE          =SIMP(statut='f',typ=ma,validators=NoRepeat(),max='**'),
         GROUP_MA_RESU   =SIMP(statut='f',typ=grma,validators=NoRepeat(),max='**'),
         MAILLE_RESU     =SIMP(statut='f',typ=ma,validators=NoRepeat(),max='**'),
         GROUP_NO_RESU   =SIMP(statut='f',typ=grma,validators=NoRepeat(),max='**'),
         NOEUD_RESU      =SIMP(statut='f',typ=ma,validators=NoRepeat(),max='**'),
)  ;
#& MODIF COMMANDE  DATE 10/10/2006   AUTEUR REZETTE C.REZETTE 
#            CONFIGURATION MANAGEMENT OF EDF VERSION
# ======================================================================
# COPYRIGHT (C) 1991 - 2003  EDF R&D                  WWW.CODE-ASTER.ORG
# THIS PROGRAM IS FREE SOFTWARE; YOU CAN REDISTRIBUTE IT AND/OR MODIFY  
# IT UNDER THE TERMS OF THE GNU GENERAL PUBLIC LICENSE AS PUBLISHED BY  
# THE FREE SOFTWARE FOUNDATION; EITHER VERSION 2 OF THE LICENSE, OR     
# (AT YOUR OPTION) ANY LATER VERSION.                                                  
#                                                                       
# THIS PROGRAM IS DISTRIBUTED IN THE HOPE THAT IT WILL BE USEFUL, BUT   
# WITHOUT ANY WARRANTY; WITHOUT EVEN THE IMPLIED WARRANTY OF            
# MERCHANTABILITY OR FITNESS FOR A PARTICULAR PURPOSE. SEE THE GNU      
# GENERAL PUBLIC LICENSE FOR MORE DETAILS.                              
#                                                                       
# YOU SHOULD HAVE RECEIVED A COPY OF THE GNU GENERAL PUBLIC LICENSE     
# ALONG WITH THIS PROGRAM; IF NOT, WRITE TO EDF R&D CODE_ASTER,         
#    1 AVENUE DU GENERAL DE GAULLE, 92141 CLAMART CEDEX, FRANCE.        
# ======================================================================
# RESPONSABLE ASSIRE A.ASSIRE

from Macro.calc_precont_ops import calc_precont_ops


# ===========================================================================
#           CATALOGUE DE LA MACRO "CALC_PRECONT"
#           -----------------------------------------
# USAGE :
# 
#  
# ===========================================================================

CALC_PRECONT=MACRO(nom="CALC_PRECONT",op=calc_precont_ops,sd_prod=evol_noli,
                   fr="Imposer la tension définie par le BPEL dans les cables",
                   reentrant='f',UIinfo={"groupe":("Modélisation",)},
         reuse =SIMP(statut='f',typ='evol_noli'),
         MODELE           =SIMP(statut='o',typ=modele_sdaster),
         CHAM_MATER       =SIMP(statut='o',typ=cham_mater),
         CARA_ELEM        =SIMP(statut='o',typ=cara_elem),
         CABLE_BP         =SIMP(statut='o',typ=cabl_precont,validators=NoRepeat(),max='**'),
         CABLE_BP_INACTIF =SIMP(statut='f',typ=cabl_precont,validators=NoRepeat(),max='**'),
         INCREMENT        =FACT(statut='o',
           LIST_INST       =SIMP(statut='o',typ=listr8_sdaster),
           INST_INIT       =SIMP(statut='f',typ='R'),
           INST_FIN        =SIMP(statut='f',typ='R'),
           PRECISION       =SIMP(statut='f',typ='R',defaut=1.0E-3 ),
           # DEBUT DE BLOC POUR LA SUBDIVISION DES PAS DE TEMPS
           SUBD_METHODE    =SIMP( statut='f',typ='TXM',
              into =("AUCUNE","UNIFORME","EXTRAPOLE"),
              defaut="AUCUNE",
              fr="Méthode de subdivision des pas de temps en cas de non-convergence"
           ),
           b_subd_unif=BLOC(condition = "SUBD_METHODE == 'UNIFORME'",
             regles=(AU_MOINS_UN('SUBD_NIVEAU','SUBD_PAS_MINI'),),
             SUBD_COEF_PAS_1=SIMP(statut='f',typ='R',defaut=1.0,val_min=0.0,
                fr="Coefficient multiplicateur de la 1ère subdivision"),
             SUBD_PAS       =SIMP(statut='f',typ='I',defaut=4,val_min=2,
                fr="Nombre de subdivision d'un pas de temps"),
             SUBD_NIVEAU=SIMP(statut='f',typ='I',val_min=2,
                fr="Nombre maximum de niveau de subdivision d'un pas de temps"),
             SUBD_PAS_MINI=SIMP(statut='f',typ='R',val_min=0.0,
                fr="Pas de temps en dessous duquel on ne subdivise plus"),
           ),
           b_subd_extr=BLOC(condition = "SUBD_METHODE == 'EXTRAPOLE'",
             regles=(AU_MOINS_UN('SUBD_NIVEAU','SUBD_PAS_MINI'),),
             SUBD_OPTION    =SIMP(statut='f',typ='TXM',
                into =("IGNORE_PREMIERES","GARDE_DERNIERES",), 
                defaut="IGNORE_PREMIERES",
                fr="Technique d'extrapolation : les 1ere itérations sont ignorées ou les dernières sont gardées"),
             SUBD_ITER_IGNO =SIMP(statut='c',typ='I',defaut=3,val_min=0,
                fr="Les n premières itérations sont ignorées pour l'extrapolation"),
             SUBD_ITER_FIN  =SIMP(statut='c',typ='I',defaut=8,val_min=3,
                fr="Seules les n dernières itérations sont prises pour l'extrapolation"),
             SUBD_PAS       =SIMP(statut='c',typ='I',defaut=4,val_min=2,
                fr="Nombre de subdivision d'un pas de temps en cas divergence"),
             SUBD_NIVEAU=SIMP(statut='f',typ='I',val_min=2,
                fr="Nombre maximum de niveau de subdivision d'un pas de temps"),
             SUBD_PAS_MINI=SIMP(statut='f',typ='R',val_min=0.0,
                fr="Pas de temps en dessous duquel on ne subdivise plus"),
             SUBD_ITER_PLUS =SIMP(statut='c',typ='I',defaut=50,val_min=20,
                fr="% itération autorisée en plus"),
           ),
           # FIN DE BLOC POUR LA SUBDIVISION DES PAS DE TEMPS 
         ),

         NEWTON          =FACT(statut='d',
            REAC_INCR       =SIMP(statut='f',typ='I',defaut= 1 ),
            PREDICTION      =SIMP(statut='f',typ='TXM',into=("DEPL_CALCULE","TANGENTE","ELASTIQUE","EXTRAPOL") ),
            MATRICE         =SIMP(statut='f',typ='TXM',defaut="TANGENTE",into=("TANGENTE","ELASTIQUE") ),
            PAS_MINI_ELAS   =SIMP(statut='f',typ='R',defaut=0.0E+0),
            REAC_ITER       =SIMP(statut='f',typ='I',defaut=0),
            EVOL_NOLI       =SIMP(statut='f',typ=evol_noli),
          ),
         RECH_LINEAIRE   =FACT(statut='f',
           RESI_LINE_RELA  =SIMP(statut='f',typ='R',defaut= 1.0E-1 ),
           ITER_LINE_MAXI  =SIMP(statut='f',typ='I',defaut= 3),
         ),
          CONVERGENCE     =FACT(statut='d',
            RESI_GLOB_MAXI  =SIMP(statut='f',typ='R'),
            RESI_GLOB_RELA  =SIMP(statut='f',typ='R'),
            ITER_GLOB_MAXI  =SIMP(statut='f',typ='I',defaut=10),
            ITER_GLOB_ELAS  =SIMP(statut='f',typ='I',defaut=25),
            ARRET           =SIMP(statut='f',typ='TXM',defaut="OUI"),
          ),
          ETAT_INIT       =FACT(statut='f',
            regles=(AU_MOINS_UN('EVOL_NOLI','DEPL','SIGM','VARI','VARI_NON_LOCAL',),
                    EXCLUS('EVOL_NOLI','DEPL',),
                    EXCLUS('EVOL_NOLI','SIGM',),
                    EXCLUS('EVOL_NOLI','VARI',),
                    EXCLUS('EVOL_NOLI','VARI_NON_LOCAL',),
                    EXCLUS('NUME_ORDRE','INST'), ),
            DEPL            =SIMP(statut='f',typ=cham_no_sdaster),
            SIGM            =SIMP(statut='f',typ=(carte_sdaster,cham_elem)),
            VARI            =SIMP(statut='f',typ=cham_elem),
            VARI_NON_LOCAL  =SIMP(statut='f',typ=cham_no_sdaster),
            EVOL_NOLI       =SIMP(statut='f',typ=evol_noli),
            NUME_ORDRE      =SIMP(statut='f',typ='I'),
            INST            =SIMP(statut='f',typ='R'),
            PRECISION       =SIMP(statut='f',typ='R',defaut= 1.0E-3 ),
            CRITERE         =SIMP(statut='f',typ='TXM',defaut="RELATIF",into=("RELATIF","ABSOLU") ),
            NUME_DIDI       =SIMP(statut='f',typ='I'),
            INST_ETAT_INIT  =SIMP(statut='f',typ='R'),
          ),
          SOLVEUR         =FACT(statut='d',
            METHODE         =SIMP(statut='f',typ='TXM',defaut="MULT_FRONT",into=("MULT_FRONT","LDLT","GCPC") ),
            b_mult_front    =BLOC(condition = "METHODE == 'MULT_FRONT' ",fr="Paramètres de la méthode multi frontale",
              RENUM           =SIMP(statut='f',typ='TXM',defaut="METIS",into=("MD","MDA","METIS") ),
            ),
            b_ldlt         =BLOC(condition = "METHODE == 'LDLT' ",fr="Paramètres de la méthode LDLT",
              RENUM           =SIMP(statut='f',typ='TXM',defaut="RCMK",into=("RCMK","SANS") ),
            ),
            b_ldlt_mult    =BLOC(condition = "METHODE == 'LDLT' or METHODE == 'MULT_FRONT' ",
                                    fr="Paramètres relatifs à la non inversibilité de la matrice à factorise",
              NPREC           =SIMP(statut='f',typ='I',defaut= 8 ),
              STOP_SINGULIER  =SIMP(statut='f',typ='TXM',defaut="OUI",into=("OUI","NON","DECOUPE") ),
            ),
            b_gcpc         =BLOC(condition = "METHODE == 'GCPC' ", fr="Paramètres de la méthode du gradient conjugué",
              PRE_COND        =SIMP(statut='f',typ='TXM',into=("LDLT_INC",),defaut="LDLT_INC" ),
              NIVE_REMPLISSAGE=SIMP(statut='f',typ='I',defaut= 0 ),
              RENUM           =SIMP(statut='f',typ='TXM',defaut="RCMK",into=("SANS","RCMK") ),
              RESI_RELA       =SIMP(statut='f',typ='R',defaut= 1.E-6 ),
              NMAX_ITER       =SIMP(statut='f',typ='I',defaut= 0 ),
            ),
            SYME            =SIMP(statut='f',typ='TXM',defaut="NON",into=("OUI","NON") ),
          ),
            SOLV_NON_LOCAL  =FACT(statut='f',
              METHODE         =SIMP(statut='f',typ='TXM',defaut="MULT_FRONT",into=("MULT_FRONT","LDLT","GCPC") ),
              b_mult_front    =BLOC(condition = "METHODE == 'MULT_FRONT' ",fr="Paramètres de la méthode multi frontale",
                RENUM           =SIMP(statut='f',typ='TXM',defaut="METIS",into=("MD","MDA","METIS") ),
              ),
              b_ldlt         =BLOC(condition = "METHODE == 'LDLT' ",fr="Paramètres de la méthode LDLT",
                RENUM           =SIMP(statut='f',typ='TXM',defaut="RCMK",into=("RCMK","SANS") ),
              ),
              b_ldlt_mult    =BLOC(condition = "METHODE == 'LDLT' or METHODE == 'MULT_FRONT' ",
                                     fr="Paramètres relatifs à la non inversibilité de la matrice à factorise",
                NPREC           =SIMP(statut='f',typ='I',defaut= 8 ),
                STOP_SINGULIER  =SIMP(statut='f',typ='TXM',defaut="OUI",into=("OUI","NON") ),
              ),
              b_gcpc         =BLOC(condition = "METHODE == 'GCPC' ", fr="Paramètres de la méthode du gradient conjugué",
                PRE_COND        =SIMP(statut='f',typ='TXM',into=("LDLT_INC",),defaut="LDLT_INC" ),
                NIVE_REMPLISSAGE=SIMP(statut='f',typ='I',defaut= 0 ),
                RESI_RELA       =SIMP(statut='f',typ='R',defaut= 1.E-6 ),
                NMAX_ITER       =SIMP(statut='f',typ='I',defaut= 0 ),
              ),
              EPS             =SIMP(statut='f',typ='R',defaut= 0.E+0 ),
            ),
            LAGR_NON_LOCAL  =FACT(statut='f',
              ITER_DUAL_MAXI  =SIMP(statut='f',typ='I',defaut= 50),
              RESI_DUAL_ABSO  =SIMP(statut='o',typ='R'),
              RESI_PRIM_ABSO  =SIMP(statut='o',typ='R'),
              R               =SIMP(statut='f',typ='R',defaut= 1000.),
              ITER_PRIM_MAXI  =SIMP(statut='f',typ='I',defaut= 10),
            ),
          INFO            =SIMP(statut='f',typ='I',into=(1,2) ),
          TITRE           =SIMP(statut='f',typ='TXM',max='**' ),

          EXCIT           =FACT(statut='o',max='**',
            CHARGE          =SIMP(statut='o',typ=char_meca),
          ),

         COMP_INCR       =C_COMP_INCR(),
  )  ;
#& MODIF COMMANDE  DATE 10/10/2006   AUTEUR MCOURTOI M.COURTOIS 
#            CONFIGURATION MANAGEMENT OF EDF VERSION
# ======================================================================
# COPYRIGHT (C) 1991 - 2005  EDF R&D                  WWW.CODE-ASTER.ORG
# THIS PROGRAM IS FREE SOFTWARE; YOU CAN REDISTRIBUTE IT AND/OR MODIFY  
# IT UNDER THE TERMS OF THE GNU GENERAL PUBLIC LICENSE AS PUBLISHED BY  
# THE FREE SOFTWARE FOUNDATION; EITHER VERSION 2 OF THE LICENSE, OR     
# (AT YOUR OPTION) ANY LATER VERSION.                                                  
#                                                                       
# THIS PROGRAM IS DISTRIBUTED IN THE HOPE THAT IT WILL BE USEFUL, BUT   
# WITHOUT ANY WARRANTY; WITHOUT EVEN THE IMPLIED WARRANTY OF            
# MERCHANTABILITY OR FITNESS FOR A PARTICULAR PURPOSE. SEE THE GNU      
# GENERAL PUBLIC LICENSE FOR MORE DETAILS.                              
#                                                                       
# YOU SHOULD HAVE RECEIVED A COPY OF THE GNU GENERAL PUBLIC LICENSE     
# ALONG WITH THIS PROGRAM; IF NOT, WRITE TO EDF R&D CODE_ASTER,         
#    1 AVENUE DU GENERAL DE GAULLE, 92141 CLAMART CEDEX, FRANCE.        
# ======================================================================
# -*- coding: iso-8859-1 -*-

# RESPONSABLE MCOURTOI M.COURTOIS

def calc_table_prod(self, TABLE, ACTION, **kargs):
   """Typage du concept produit.
   """
   l_typ = [AsType(TABLE),]
   for mcf in ACTION:
      dmc = mcf.cree_dict_valeurs(mcf.mc_liste)
      if dmc.get('TABLE') != None:
         l_typ.append(AsType(dmc['TABLE']))
   # une table_fonction étant une table
   if table_fonction in l_typ:
      return table_fonction
   else:
      return table_sdaster


from Macro.calc_table_ops import calc_table_ops

CALC_TABLE=MACRO(nom="CALC_TABLE",op=calc_table_ops, sd_prod=calc_table_prod,
                 fr="Opérations sur une table",
                 reentrant='f',
   regles=(DERIVABLE('TABLE'),),
   TABLE  = SIMP(statut='o',typ=table_sdaster),
   ACTION = FACT(statut='o', max='**',
                    fr = "Suite des opérations à effectuer sur la table",
      OPERATION = SIMP(statut='o', typ='TXM',
                  into=('FILTRE', 'EXTR', 'RENOMME', 'TRI', 'COMB', 'OPER',)),
      
      b_filtre = BLOC(condition="OPERATION == 'FILTRE'",
                      fr="Sélectionne les lignes de la table vérifiant un critère",
         NOM_PARA  = SIMP(statut='o',typ='TXM'),
         CRIT_COMP = SIMP(statut='f',typ='TXM',defaut="EQ",
                          into=('EQ','NE','GT','LT','GE','LE','REGEXP',
                                'VIDE','NON_VIDE','MAXI','ABS_MAXI','MINI','ABS_MINI'),),
         b_vale = BLOC(condition = "(CRIT_COMP in ('EQ','NE','GT','LT','GE','LE'))",
            regles=(UN_PARMI('VALE','VALE_I','VALE_K','VALE_C',),),
            VALE   = SIMP(statut='f',typ='R'),
            VALE_I = SIMP(statut='f',typ='I'),
            VALE_C = SIMP(statut='f',typ='C'),
            VALE_K = SIMP(statut='f',typ='TXM'),
         ),
         b_regexp = BLOC(condition = "CRIT_COMP == 'REGEXP'",
            VALE_K = SIMP(statut='f',typ='TXM'),
         ),
         b_crit = BLOC(condition = "CRIT_COMP in ('EQ','NE')",
            CRITERE   = SIMP(statut='f',typ='TXM',defaut="RELATIF",into=("RELATIF","ABSOLU") ),
            PRECISION = SIMP(statut='f',typ='R',defaut= 1.0E-3 ),
         ),
      ),
      
      b_extr = BLOC(condition="OPERATION ==  'EXTR'",
                    fr="Extrait une ou plusieurs colonnes de la table",
         NOM_PARA = SIMP(statut='o',typ='TXM',validators=NoRepeat(),max='**',
                         fr="Noms des colonnes à extraire"),
      ),
   
      b_renomme = BLOC(condition="OPERATION == 'RENOMME'",
                       fr="Renomme un ou plusieurs paramètres de la table",
         NOM_PARA = SIMP(statut='o', typ='TXM', validators=NoRepeat(), min=2, max=2,
                         fr="Couple (ancien nom du paramètre, nouveau nom du paramètre)",),
      ),
   
      b_tri = BLOC(condition="OPERATION == 'TRI'",
                   fr="Ordonne les lignes de la table selon les valeurs d'un ou plusieurs paramètres",
         NOM_PARA = SIMP(statut='o',typ='TXM',validators=NoRepeat(),max='**'),
         ORDRE    = SIMP(statut='f',typ='TXM',defaut="CROISSANT",
                         into=("CROISSANT","DECROISSANT") ),
      ),
      
      b_comb = BLOC(condition="OPERATION == 'COMB'",
                    fr="Combine deux tables ayant éventuellement des paramètres communs",
         TABLE    = SIMP(statut='o',typ=table_sdaster,
                         fr="Table dont les colonnes vont venir surcharger la table initiale"),
         NOM_PARA = SIMP(statut='f',typ='TXM',max='**',
                         fr="Noms des paramètres dont les valeurs doivent etre identiques dans les deux tables "\
                            "pour que les colonnes soient combinées"),
      ),
      
      b_oper = BLOC(condition="OPERATION == 'OPER'",
                    fr="Applique une formule dans laquelle les variables sont les paramètres de la table",
         FORMULE  = SIMP(statut='o',typ=formule,
                         fr="Formule à appliquer aux colonnes de la table"),
         NOM_PARA = SIMP(statut='o',typ='TXM',
                         fr="Nom de la nouvelle colonne"),
      ),
   ),
   
   SENSIBILITE = SIMP(statut='f',typ=(para_sensi,theta_geom),max=1,
                      fr="Paramètre de sensibilité",
                      ang="Sensitivity parameter"),
   TITRE = SIMP(statut='f',typ='TXM',max='**',
                fr="Titre de la table produite"),
   INFO  = SIMP(statut='f',typ='I',defaut=1,into=(1,2) ),
)
#& MODIF COMMANDE  DATE 21/02/2006   AUTEUR REZETTE C.REZETTE 
#            CONFIGURATION MANAGEMENT OF EDF VERSION
# ======================================================================
# COPYRIGHT (C) 1991 - 2001  EDF R&D                  WWW.CODE-ASTER.ORG
# THIS PROGRAM IS FREE SOFTWARE; YOU CAN REDISTRIBUTE IT AND/OR MODIFY
# IT UNDER THE TERMS OF THE GNU GENERAL PUBLIC LICENSE AS PUBLISHED BY
# THE FREE SOFTWARE FOUNDATION; EITHER VERSION 2 OF THE LICENSE, OR   
# (AT YOUR OPTION) ANY LATER VERSION.                                 
#
# THIS PROGRAM IS DISTRIBUTED IN THE HOPE THAT IT WILL BE USEFUL, BUT 
# WITHOUT ANY WARRANTY; WITHOUT EVEN THE IMPLIED WARRANTY OF          
# MERCHANTABILITY OR FITNESS FOR A PARTICULAR PURPOSE. SEE THE GNU    
# GENERAL PUBLIC LICENSE FOR MORE DETAILS.                            
#
# YOU SHOULD HAVE RECEIVED A COPY OF THE GNU GENERAL PUBLIC LICENSE   
# ALONG WITH THIS PROGRAM; IF NOT, WRITE TO EDF R&D CODE_ASTER,       
#    1 AVENUE DU GENERAL DE GAULLE, 92141 CLAMART CEDEX, FRANCE.      
# ======================================================================
CALC_THETA=OPER(nom="CALC_THETA",op=54,sd_prod=theta_geom,reentrant='n',
            UIinfo={"groupes":("Post traitements",)},
                fr="Définir un champ theta pour le calcul du taux de restitution d'énergie"
                    +" ou des facteurs d'intensité de contraintes",
         regles=(UN_PARMI('THETA_2D','THETA_3D','THETA_BANDE'),
                 PRESENT_ABSENT('THETA_2D','DIRE_THETA'),
                 EXCLUS('DIRECTION','DIRE_THETA'),),
         OPTION          =SIMP(statut='f',typ='TXM',defaut="COURONNE",into=("COURONNE","BANDE") ),
         MODELE          =SIMP(statut='o',typ=(modele_sdaster) ),
         THETA_3D        =FACT(statut='f',max='**',
           regles=(UN_PARMI('TOUT','GROUP_NO','NOEUD'),
                   UN_PARMI('MODULE','MODULE_FO'),
                   ENSEMBLE('MODULE','R_INF','R_SUP'),
                   ENSEMBLE('MODULE_FO','R_INF_FO','R_SUP_FO'),),
           TOUT            =SIMP(statut='f',typ='TXM',into=("OUI",) ),
           GROUP_NO        =SIMP(statut='f',typ=grno,validators=NoRepeat(),max='**'),
           NOEUD           =SIMP(statut='f',typ=no  ,validators=NoRepeat(),max='**'),
           MODULE          =SIMP(statut='f',typ='R'),
           R_INF           =SIMP(statut='f',typ='R'),
           R_SUP           =SIMP(statut='f',typ='R'),
           MODULE_FO       =SIMP(statut='f',typ=(fonction_sdaster,nappe_sdaster,formule)),
           R_INF_FO        =SIMP(statut='f',typ=(fonction_sdaster,nappe_sdaster,formule)),
           R_SUP_FO        =SIMP(statut='f',typ=(fonction_sdaster,nappe_sdaster,formule)),
                         ),
         b_theta_3d     =BLOC(condition="THETA_3D != None",
           FOND_FISS       =SIMP(statut='f',typ=fond_fiss),),
         DIRE_THETA      =SIMP(statut='f',typ=cham_no_sdaster ),
         DIRECTION       =SIMP(statut='f',typ='R',max='**'),
         THETA_2D        =FACT(statut='f',max='**',
           regles=(UN_PARMI('GROUP_NO','NOEUD'),),
           GROUP_NO        =SIMP(statut='f',typ=grno,validators=NoRepeat(),max='**'),
           NOEUD           =SIMP(statut='f',typ=no  ,validators=NoRepeat(),max='**'),
           MODULE          =SIMP(statut='o',typ='R'),
           R_INF           =SIMP(statut='o',typ='R'),
           R_SUP           =SIMP(statut='o',typ='R'),
         ),
         THETA_BANDE     =FACT(statut='f',max='**',
           MODULE          =SIMP(statut='o',typ='R'),
           R_INF           =SIMP(statut='o',typ='R'),
           R_SUP           =SIMP(statut='o',typ='R'),
         ),
         GRAD_NOEU_THETA =SIMP(statut='f',typ='TXM',defaut="NON",into=("OUI","NON") ),
         IMPRESSION      =FACT(statut='f',
           UNITE           =SIMP(statut='f',typ='I',defaut=8),  
           FORMAT          =SIMP(statut='f',typ='TXM',defaut="EXCEL",into=("EXCEL","AGRAF") ),
         ),
)  ;
#& MODIF COMMANDE  DATE 16/05/2006   AUTEUR REZETTE C.REZETTE 
#            CONFIGURATION MANAGEMENT OF EDF VERSION
# ======================================================================
# COPYRIGHT (C) 1991 - 2001  EDF R&D                  WWW.CODE-ASTER.ORG
# THIS PROGRAM IS FREE SOFTWARE; YOU CAN REDISTRIBUTE IT AND/OR MODIFY
# IT UNDER THE TERMS OF THE GNU GENERAL PUBLIC LICENSE AS PUBLISHED BY
# THE FREE SOFTWARE FOUNDATION; EITHER VERSION 2 OF THE LICENSE, OR   
# (AT YOUR OPTION) ANY LATER VERSION.                                 
#
# THIS PROGRAM IS DISTRIBUTED IN THE HOPE THAT IT WILL BE USEFUL, BUT 
# WITHOUT ANY WARRANTY; WITHOUT EVEN THE IMPLIED WARRANTY OF          
# MERCHANTABILITY OR FITNESS FOR A PARTICULAR PURPOSE. SEE THE GNU    
# GENERAL PUBLIC LICENSE FOR MORE DETAILS.                            
#
# YOU SHOULD HAVE RECEIVED A COPY OF THE GNU GENERAL PUBLIC LICENSE   
# ALONG WITH THIS PROGRAM; IF NOT, WRITE TO EDF R&D CODE_ASTER,       
#    1 AVENUE DU GENERAL DE GAULLE, 92141 CLAMART CEDEX, FRANCE.      
# ======================================================================
# RESPONSABLE VABHHTS J.PELLET
def calc_vect_elem_prod(OPTION,**args):
  if OPTION == "CHAR_MECA" :      return vect_elem_depl_r
  if OPTION == "CHAR_MECA_LAGR" : return vect_elem_depl_r
  if OPTION == "CHAR_THER" :      return vect_elem_temp_r
  if OPTION == "CHAR_ACOU" :      return vect_elem_pres_c
  if OPTION == "FORC_NODA" :      return vect_elem_depl_r
  raise AsException("type de concept resultat non prevu")

CALC_VECT_ELEM=OPER(nom="CALC_VECT_ELEM",op=8,sd_prod=calc_vect_elem_prod,reentrant='n',
            UIinfo={"groupes":("Matrices/vecteurs",)},
                    fr="Calcul des seconds membres élémentaires",
         OPTION          =SIMP(statut='o',typ='TXM',into=("CHAR_MECA","CHAR_THER","CHAR_ACOU",
                                                           "FORC_NODA","CHAR_MECA_LAGR") ),
         b_char_meca     =BLOC(condition = "OPTION=='CHAR_MECA'",
           regles=(AU_MOINS_UN('CHARGE','MODELE'),),
           CHARGE          =SIMP(statut='f',typ=char_meca,validators=NoRepeat(),max='**'),
           MODELE          =SIMP(statut='f',typ=modele_sdaster),
           b_charge     =BLOC(condition = "CHARGE != None", fr="modèle ne contenant pas de sous-structure",
              CHAM_MATER   =SIMP(statut='f',typ=cham_mater),
              CARA_ELEM    =SIMP(statut='f',typ=cara_elem),
              INST         =SIMP(statut='f',typ='R',defaut= 0.E+0 ),
              MODE_FOURIER =SIMP(statut='f',typ='I',defaut= 0 ),
           ),  
           b_modele     =BLOC(condition = "(MODELE != None)",fr="modèle contenant une sous-structure",
              SOUS_STRUC      =FACT(statut='o',min=01,
                regles=(UN_PARMI('TOUT','MAILLE'),),
                CAS_CHARGE  =SIMP(statut='o',typ='TXM' ),
                TOUT        =SIMP(statut='f',typ='TXM',into=("OUI",) ),
                MAILLE      =SIMP(statut='f',typ=ma,validators=NoRepeat(),max='**',),
              ),
           ),
         ),
         b_char_ther     =BLOC(condition = "OPTION=='CHAR_THER'",
           CARA_ELEM        =SIMP(statut='f',typ=cara_elem),
           CHARGE           =SIMP(statut='o',typ=char_ther,validators=NoRepeat(),max='**'),
           INST             =SIMP(statut='f',typ='R',defaut= 0.E+0 ),
         ),
              
         b_char_acou     =BLOC(condition = "OPTION=='CHAR_ACOU'",
           CHAM_MATER        =SIMP(statut='o',typ=cham_mater),
           CHARGE            =SIMP(statut='o',typ=char_acou,validators=NoRepeat(),max='**'),
         ),
         
         b_forc_noda     =BLOC(condition = "OPTION=='FORC_NODA'",
           SIEF_ELGA         =SIMP(statut='o',typ=cham_elem),
           CARA_ELEM         =SIMP(statut='f',typ=cara_elem),
           MODELE            =SIMP(statut='f',typ=modele_sdaster),
         ),
         
         b_meca_lagr     =BLOC(condition = "OPTION=='CHAR_MECA_LAGR'",
           CHAM_MATER        =SIMP(statut='o',typ=cham_mater),
           THETA             =SIMP(statut='o',typ=theta_geom),
           PROPAGATION       =SIMP(statut='f',typ='R',defaut= 0.E+0 ),
           CHARGE            =SIMP(statut='f',typ=char_meca,validators=NoRepeat(),max='**'),
           INST              =SIMP(statut='f',typ='R',defaut= 0.E+0 ),
         ),
) ;
#& MODIF COMMANDE  DATE 12/09/2006   AUTEUR REZETTE C.REZETTE 
#            CONFIGURATION MANAGEMENT OF EDF VERSION
# ======================================================================
# COPYRIGHT (C) 1991 - 2001  EDF R&D                  WWW.CODE-ASTER.ORG
# THIS PROGRAM IS FREE SOFTWARE; YOU CAN REDISTRIBUTE IT AND/OR MODIFY
# IT UNDER THE TERMS OF THE GNU GENERAL PUBLIC LICENSE AS PUBLISHED BY
# THE FREE SOFTWARE FOUNDATION; EITHER VERSION 2 OF THE LICENSE, OR   
# (AT YOUR OPTION) ANY LATER VERSION.                                 
#
# THIS PROGRAM IS DISTRIBUTED IN THE HOPE THAT IT WILL BE USEFUL, BUT 
# WITHOUT ANY WARRANTY; WITHOUT EVEN THE IMPLIED WARRANTY OF          
# MERCHANTABILITY OR FITNESS FOR A PARTICULAR PURPOSE. SEE THE GNU    
# GENERAL PUBLIC LICENSE FOR MORE DETAILS.                            
#
# YOU SHOULD HAVE RECEIVED A COPY OF THE GNU GENERAL PUBLIC LICENSE   
# ALONG WITH THIS PROGRAM; IF NOT, WRITE TO EDF R&D CODE_ASTER,       
#    1 AVENUE DU GENERAL DE GAULLE, 92141 CLAMART CEDEX, FRANCE.      
# ======================================================================
# RESPONSABLE G8BHHXD X.DESROCHES
COMB_FOURIER=OPER(nom="COMB_FOURIER",op= 161,sd_prod=comb_fourier,
                  reentrant='n',fr="Recombiner les modes de Fourier d'une SD Résultat dans des directions particulières",
            UIinfo={"groupes":("Post traitements",)},
         RESULTAT        =SIMP(statut='o',typ=(fourier_elas,fourier_ther),),
         ANGL            =SIMP(statut='o',typ='R',max='**'),
         NOM_CHAM        =SIMP(statut='o',typ='TXM',validators=NoRepeat(),max=6,
             into=("DEPL","REAC_NODA","SIEF_ELGA_DEPL","EPSI_ELNO_DEPL","SIGM_ELNO_DEPL","TEMP","FLUX_ELNO_TEMP"),),
) ;
#& MODIF COMMANDE  DATE 22/06/2005   AUTEUR REZETTE C.REZETTE 
#            CONFIGURATION MANAGEMENT OF EDF VERSION
# ======================================================================
# COPYRIGHT (C) 1991 - 2001  EDF R&D                  WWW.CODE-ASTER.ORG
# THIS PROGRAM IS FREE SOFTWARE; YOU CAN REDISTRIBUTE IT AND/OR MODIFY
# IT UNDER THE TERMS OF THE GNU GENERAL PUBLIC LICENSE AS PUBLISHED BY
# THE FREE SOFTWARE FOUNDATION; EITHER VERSION 2 OF THE LICENSE, OR   
# (AT YOUR OPTION) ANY LATER VERSION.                                 
#
# THIS PROGRAM IS DISTRIBUTED IN THE HOPE THAT IT WILL BE USEFUL, BUT 
# WITHOUT ANY WARRANTY; WITHOUT EVEN THE IMPLIED WARRANTY OF          
# MERCHANTABILITY OR FITNESS FOR A PARTICULAR PURPOSE. SEE THE GNU    
# GENERAL PUBLIC LICENSE FOR MORE DETAILS.                            
#
# YOU SHOULD HAVE RECEIVED A COPY OF THE GNU GENERAL PUBLIC LICENSE   
# ALONG WITH THIS PROGRAM; IF NOT, WRITE TO EDF R&D CODE_ASTER,       
#    1 AVENUE DU GENERAL DE GAULLE, 92141 CLAMART CEDEX, FRANCE.      
# ======================================================================
# RESPONSABLE VABHHTS J.PELLET
def comb_matr_asse_prod(COMB_R,COMB_C,CALC_AMOR_GENE,**args):
  if COMB_C != None:
    type_mat = AsType(COMB_C[0]['MATR_ASSE'])
    if type_mat in  (matr_asse_depl_c,matr_asse_depl_r) : return matr_asse_depl_c
    if type_mat in  (matr_asse_gene_c,matr_asse_gene_r) : return matr_asse_gene_c    
    if type_mat in  (matr_asse_temp_c,matr_asse_temp_r) : return matr_asse_temp_c
    if type_mat in  (matr_asse_pres_c,matr_asse_pres_r) : return matr_asse_pres_c
  elif COMB_R != None:
    type_mat = AsType(COMB_R[0]['MATR_ASSE'])
    if type_mat in  (matr_asse_depl_c,matr_asse_depl_r) : return matr_asse_depl_r
    if type_mat in  (matr_asse_temp_c,matr_asse_temp_r) : return matr_asse_temp_r
    if type_mat in  (matr_asse_pres_c,matr_asse_pres_r) : return matr_asse_pres_r
    if type_mat in  (matr_asse_gene_c,matr_asse_gene_r) : return matr_asse_gene_r
  elif CALC_AMOR_GENE != None: return matr_asse_gene_r
  raise AsException("type de concept resultat non prevu")

COMB_MATR_ASSE=OPER(nom="COMB_MATR_ASSE",op=  31,sd_prod=comb_matr_asse_prod,
                    fr="Effectuer la combinaison linéaire de matrices assemblées",
                    reentrant='f',
            UIinfo={"groupes":("Résultats et champs",)},
         regles=(UN_PARMI('COMB_R','COMB_C','CALC_AMOR_GENE' ),),
         COMB_R          =FACT(statut='f',max='**',
           PARTIE          =SIMP(statut='f',typ='TXM',into=("REEL","IMAG") ),
           MATR_ASSE       =SIMP(statut='o',typ=(matr_asse_depl_r,matr_asse_depl_c,matr_asse_temp_r,matr_asse_temp_c
                                                ,matr_asse_pres_r,matr_asse_pres_c,matr_asse_gene_r,matr_asse_gene_c ) ),
           COEF_R          =SIMP(statut='o',typ='R' ),
         ),
         COMB_C          =FACT(statut='f',max='**',
           regles=(UN_PARMI('COEF_R','COEF_C' ),),
           MATR_ASSE       =SIMP(statut='o',typ=(matr_asse_depl_r,matr_asse_depl_c,matr_asse_temp_r,matr_asse_temp_c
                                                ,matr_asse_pres_r,matr_asse_pres_c,matr_asse_gene_r,matr_asse_gene_c ) ),
           COEF_R          =SIMP(statut='f',typ='R' ),
           COEF_C          =SIMP(statut='f',typ='C' ),
         ),
         CALC_AMOR_GENE   =FACT(statut='f',
           regles=(UN_PARMI('AMOR_REDUIT','LIST_AMOR' ),),
           MASS_GENE    = SIMP(statut='f', typ=matr_asse_gene_r),
           RIGI_GENE    = SIMP(statut='f', typ=matr_asse_gene_r),
           AMOR_REDUIT  = SIMP(statut='f',typ='R',max='**'),
           LIST_AMOR    = SIMP(statut='f',typ=listr8_sdaster ),
         ),         
         SANS_CMP        =SIMP(statut='f',typ='TXM',into=("LAGR",) ),
)  ;
#& MODIF COMMANDE  DATE 03/01/2006   AUTEUR REZETTE C.REZETTE 
#            CONFIGURATION MANAGEMENT OF EDF VERSION
# ======================================================================
# COPYRIGHT (C) 1991 - 2001  EDF R&D                  WWW.CODE-ASTER.ORG
# THIS PROGRAM IS FREE SOFTWARE; YOU CAN REDISTRIBUTE IT AND/OR MODIFY
# IT UNDER THE TERMS OF THE GNU GENERAL PUBLIC LICENSE AS PUBLISHED BY
# THE FREE SOFTWARE FOUNDATION; EITHER VERSION 2 OF THE LICENSE, OR   
# (AT YOUR OPTION) ANY LATER VERSION.                                 
#
# THIS PROGRAM IS DISTRIBUTED IN THE HOPE THAT IT WILL BE USEFUL, BUT 
# WITHOUT ANY WARRANTY; WITHOUT EVEN THE IMPLIED WARRANTY OF          
# MERCHANTABILITY OR FITNESS FOR A PARTICULAR PURPOSE. SEE THE GNU    
# GENERAL PUBLIC LICENSE FOR MORE DETAILS.                            
#
# YOU SHOULD HAVE RECEIVED A COPY OF THE GNU GENERAL PUBLIC LICENSE   
# ALONG WITH THIS PROGRAM; IF NOT, WRITE TO EDF R&D CODE_ASTER,       
#    1 AVENUE DU GENERAL DE GAULLE, 92141 CLAMART CEDEX, FRANCE.      
# ======================================================================
COMB_SISM_MODAL=OPER(nom="COMB_SISM_MODAL",op= 109,sd_prod=mode_stat,
                     fr="Réponse sismique par recombinaison modale par une méthode spectrale",
                     reentrant='n',
            UIinfo={"groupes":("Post traitements",)},
         regles=(EXCLUS('TOUT_ORDRE','NUME_ORDRE','FREQ','NUME_MODE','LIST_FREQ','LIST_ORDRE'),
                 UN_PARMI('AMOR_REDUIT','LIST_AMOR','AMOR_GENE' ),),
         MODE_MECA       =SIMP(statut='o',typ=mode_meca ),
         TOUT_ORDRE      =SIMP(statut='f',typ='TXM',into=("OUI",) ),
         NUME_ORDRE      =SIMP(statut='f',typ='I',validators=NoRepeat(),max='**'),
         LIST_ORDRE      =SIMP(statut='f',typ=listis_sdaster ),
         NUME_MODE       =SIMP(statut='f',typ='I',validators=NoRepeat(),max='**'),
         FREQ            =SIMP(statut='f',typ='R',validators=NoRepeat(),max='**'),
         LIST_FREQ       =SIMP(statut='f',typ=listr8_sdaster ),
         b_freq          =BLOC(condition = "FREQ != None or LIST_FREQ != None",
           PRECISION       =SIMP(statut='f',typ='R',defaut= 1.E-3 ),
           CRITERE         =SIMP(statut='f',typ='TXM',defaut="RELATIF",into=("RELATIF","ABSOLU") ),
         ),
         MODE_CORR       =SIMP(statut='f',typ=mode_stat_acce ),
         
         AMOR_REDUIT     =SIMP(statut='f',typ='R',max='**'),
         LIST_AMOR       =SIMP(statut='f',typ=listr8_sdaster ),
         AMOR_GENE       =SIMP(statut='f',typ=matr_asse_gene_r ),
         
         MASS_INER       =SIMP(statut='f',typ=table_sdaster ),
         CORR_FREQ       =SIMP(statut='f',typ='TXM',defaut="OUI",into=("OUI","NON") ),
         
         EXCIT           =FACT(statut='o',max='**',
           regles=(UN_PARMI('MONO_APPUI','NOEUD','GROUP_NO'),
                   UN_PARMI('AXE','TRI_AXE','TRI_SPEC' ),),
           
           MONO_APPUI      =SIMP(statut='f',typ='TXM',into=("OUI",) ),
           NOEUD           =SIMP(statut='f',typ=no  ,validators=NoRepeat(),max='**'),
           GROUP_NO        =SIMP(statut='f',typ=grno,validators=NoRepeat(),max='**'),
           AXE             =SIMP(statut='f',typ='R',max=3,fr="Excitation suivant un seul axe",),
           TRI_AXE         =SIMP(statut='f',typ='R',max=3,fr="Excitation suivant les trois axes mais avec le meme spectre",),
           TRI_SPEC        =SIMP(statut='f',typ='TXM',into=("OUI",),
                                 fr="Excitation suivant les trois axes  avec trois spectres"),
           b_axe           =BLOC(condition = "AXE != None",fr="Excitation suivant un seul axe",
             SPEC_OSCI       =SIMP(statut='o',typ=(fonction_sdaster,nappe_sdaster,formule),),
             ECHELLE         =SIMP(statut='f',typ='R',),
           ),
           b_tri_axe       =BLOC(condition = "TRI_AXE != None",fr="Excitation suivant les trois axes mais avec le meme spectre",
             SPEC_OSCI       =SIMP(statut='o',typ=(fonction_sdaster,nappe_sdaster,formule),),
             ECHELLE         =SIMP(statut='f',typ='R',),
           ),
           b_tri_spec      =BLOC(condition = "TRI_SPEC != None",fr="Excitation suivant les trois axes  avec trois spectres",
             SPEC_OSCI       =SIMP(statut='o',typ=(fonction_sdaster,nappe_sdaster,formule),min=3,max=3 ),
             ECHELLE         =SIMP(statut='f',typ='R',min=3,max=3),
           ),       
           NATURE          =SIMP(statut='f',typ='TXM',defaut="ACCE",into=("ACCE","VITE","DEPL") ),
         ),
         COMB_MODE       =FACT(statut='o',
           TYPE            =SIMP(statut='o',typ='TXM',into=("SRSS","CQC","DSC","ABS","DPC") ),
           DUREE           =SIMP(statut='f',typ='R' ),
         ),
         COMB_DIRECTION  =FACT(statut='f',
           TYPE            =SIMP(statut='f',typ='TXM',into=("QUAD","NEWMARK") ),
         ),
         COMB_MULT_APPUI =FACT(statut='f',max='**',
           regles=(UN_PARMI('TOUT','NOEUD','GROUP_NO' ),),
           TOUT            =SIMP(statut='f',typ='TXM',into=("OUI",) ),
           NOEUD           =SIMP(statut='f',typ=no  ,validators=NoRepeat(),max='**'),
           GROUP_NO        =SIMP(statut='f',typ=grno,validators=NoRepeat(),max='**'),
           TYPE_COMBI      =SIMP(statut='f',typ='TXM',into=("QUAD","LINE",) ),
         ),
         COMB_DEPL_APPUI=FACT(statut='f',max='**',
           regles=(UN_PARMI('TOUT','LIST_CAS'),),
           TOUT            =SIMP(statut='f',typ='TXM',into=("OUI",)),
           LIST_CAS       =SIMP(statut='f',typ='I',max='**'),
           TYPE_COMBI      =SIMP(statut='f',typ='TXM',into=("QUAD","LINE","ABS") ),
         ),
         DEPL_MULT_APPUI =FACT(statut='f',max='**',
           regles=(UN_PARMI('NOEUD','GROUP_NO'),
                   AU_MOINS_UN('DX','DY','DZ' ),),
           NOM_CAS         =SIMP(statut='o',typ='TXM',max='**'),
           NUME_CAS        =SIMP(statut='o',typ='I',max='**'),
           MODE_STAT       =SIMP(statut='f',typ=(mode_stat_depl,), ),
           NOEUD_REFE      =SIMP(statut='f',typ=no),
           NOEUD           =SIMP(statut='f',typ=no  ,validators=NoRepeat(),max='**'),
           GROUP_NO        =SIMP(statut='f',typ=grno,validators=NoRepeat(),max='**'),
           DX              =SIMP(statut='f',typ='R' ),
           DY              =SIMP(statut='f',typ='R' ),
           DZ              =SIMP(statut='f',typ='R' ),
         ),
         OPTION          =SIMP(statut='o',typ='TXM',validators=NoRepeat(),max=9,
                               into=("DEPL","VITE","ACCE_ABSOLU","SIGM_ELNO_DEPL","SIEF_ELGA_DEPL",
                                     "EFGE_ELNO_DEPL","REAC_NODA","FORC_NODA","EFGE_ELNO_CART",
                                     "SIPO_ELNO_DEPL") ),
         INFO            =SIMP(statut='f',typ='I',defaut= 1,into=( 1 , 2 ) ),
         IMPRESSION      =FACT(statut='f',max='**',
           regles=(EXCLUS('TOUT','NIVEAU'),),
           TOUT            =SIMP(statut='f',typ='TXM',into=("OUI",) ),
           NIVEAU          =SIMP(statut='f',typ='TXM',into=("SPEC_OSCI","MASS_EFFE","MAXI_GENE"),validators=NoRepeat(),max=3 ),
         ),
         TITRE           =SIMP(statut='f',typ='TXM',max='**'),
)  ;
#& MODIF COMMANDE  DATE 12/09/2006   AUTEUR REZETTE C.REZETTE 
# RESPONSABLE VABHHTS J.PELLET
#            CONFIGURATION MANAGEMENT OF EDF VERSION
# ======================================================================
# COPYRIGHT (C) 1991 - 2001  EDF R&D                  WWW.CODE-ASTER.ORG
# THIS PROGRAM IS FREE SOFTWARE; YOU CAN REDISTRIBUTE IT AND/OR MODIFY
# IT UNDER THE TERMS OF THE GNU GENERAL PUBLIC LICENSE AS PUBLISHED BY
# THE FREE SOFTWARE FOUNDATION; EITHER VERSION 2 OF THE LICENSE, OR
# (AT YOUR OPTION) ANY LATER VERSION.
#
# THIS PROGRAM IS DISTRIBUTED IN THE HOPE THAT IT WILL BE USEFUL, BUT
# WITHOUT ANY WARRANTY; WITHOUT EVEN THE IMPLIED WARRANTY OF
# MERCHANTABILITY OR FITNESS FOR A PARTICULAR PURPOSE. SEE THE GNU
# GENERAL PUBLIC LICENSE FOR MORE DETAILS.
#
# YOU SHOULD HAVE RECEIVED A COPY OF THE GNU GENERAL PUBLIC LICENSE
# ALONG WITH THIS PROGRAM; IF NOT, WRITE TO EDF R&D CODE_ASTER,
#    1 AVENUE DU GENERAL DE GAULLE, 92141 CLAMART CEDEX, FRANCE.
# ======================================================================
def crea_champ_prod(TYPE_CHAM,**args):
  if TYPE_CHAM[0:5] == "CART_" :
     return carte_sdaster
  elif TYPE_CHAM[0:5] == "NOEU_" :
     return cham_no_sdaster
  elif TYPE_CHAM[0:2] == "EL"    :
     return cham_elem
  else :
     raise AsException("type de concept resultat_sdaster non prevu")


CREA_CHAMP=OPER(nom="CREA_CHAMP",op= 195,sd_prod=crea_champ_prod,
                fr="Création d'un champ ",reentrant='n',
            UIinfo={"groupes":("Résultats et champs",)},
         TYPE_CHAM       =SIMP(statut='o',typ='TXM',into=C_TYPE_CHAM_INTO()),
      # TYPE_CHAM doit etre de la forme : CART_xx, NOEU_xx, ELEM_xx, ELGA_xx ou ELNO_xx
      # ou xx est le nom d'une grandeur définie dans le catalogue des grandeurs 
#        SI CREATION D'UN CHAM_NO, POUR IMPOSER LA NUMEROTATION DES DDLS :
#        ------------------------------------------------------------------
         regles=(EXCLUS('NUME_DDL','CHAM_NO',)),
         NUME_DDL        =SIMP(statut='f',typ=(nume_ddl_sdaster) ),
         CHAM_NO         =SIMP(statut='f',typ=(cham_no_sdaster) ),

#        SI CREATION D'UN CHAM_ELEM, POUR aider a l'allocation du champ :
#        (PAR DEFAUT : TOU_INI_ELNO/_ELGA/_ELEM)
#        ------------------------------------------------------------------
         OPTION         =SIMP(statut='f',typ='TXM'),

         OPERATION       =SIMP(statut='o',typ='TXM',into=("AFFE","ASSE","EVAL","EXTR","DISC","NORMALE","R2C","C2R") ),

#        ------------------------------------------------------------------
         b_norm          =BLOC(condition = "OPERATION == 'NORMALE'",
                               regles=(AU_MOINS_UN('GROUP_MA','MAILLE',),),
             MODELE          =SIMP(statut='o',typ=(modele_sdaster) ),
             GROUP_MA        =SIMP(statut='f',typ=grma ,validators=NoRepeat(),max='**'),
             MAILLE          =SIMP(statut='f',typ=ma   ,validators=NoRepeat(),max='**'),
                             ),
#        ------------------------------------------------------------------
         b_affe          =BLOC(condition = "OPERATION == 'AFFE'",
             regles=(UN_PARMI('MAILLAGE','MODELE'),),
             MAILLAGE        =SIMP(statut='f',typ=(maillage_sdaster) ),
             MODELE          =SIMP(statut='f',typ=(modele_sdaster) ),
             b_affe_modele   =BLOC(condition = "MODELE != None",
                 PROL_ZERO       =SIMP(statut='f',typ='TXM',defaut="NON",into=("OUI","NON",) ), ),
             AFFE            =FACT(statut='o',max='**',
                regles=(AU_MOINS_UN('TOUT','GROUP_MA','MAILLE','GROUP_NO','NOEUD',),
                        UN_PARMI('VALE','VALE_I','VALE_C','VALE_F', ),),
                TOUT            =SIMP(statut='f',typ='TXM',into=("OUI",) ),
                GROUP_MA        =SIMP(statut='f',typ=grma ,validators=NoRepeat(),max='**'),
                MAILLE          =SIMP(statut='f',typ=ma   ,validators=NoRepeat(),max='**'),
                GROUP_NO        =SIMP(statut='f',typ=grno ,validators=NoRepeat(),max='**'),
                NOEUD           =SIMP(statut='f',typ=no   ,validators=NoRepeat(),max='**'),
                NOM_CMP         =SIMP(statut='o',typ='TXM',max='**'),
                VALE            =SIMP(statut='f',typ='R',max='**' ),
                VALE_I          =SIMP(statut='f',typ='I',max='**' ),
                VALE_C          =SIMP(statut='f',typ='C',max='**' ),
                VALE_F          =SIMP(statut='f',typ=(fonction_sdaster,nappe_sdaster,formule),max='**'),
                                   ),
                             ),
#        ------------------------------------------------------------------
         b_asse          =BLOC(condition = "OPERATION == 'ASSE'",
             regles=(UN_PARMI('MAILLAGE','MODELE'),),
             MAILLAGE        =SIMP(statut='f',typ=(maillage_sdaster) ),
             MODELE          =SIMP(statut='f',typ=(modele_sdaster) ),
             b_asse_modele   =BLOC(condition = "MODELE != None",
                 PROL_ZERO       =SIMP(statut='f',typ='TXM',defaut="NON",into=("OUI","NON",) ), ),
             ASSE            =FACT(statut='o',max='**',
                regles=(AU_MOINS_UN('TOUT','GROUP_MA','GROUP_NO','MAILLE','NOEUD',),
                PRESENT_PRESENT('NOM_CMP_RESU','NOM_CMP', ),),
                TOUT            =SIMP(statut='f',typ='TXM',into=("OUI",) ),
                GROUP_MA        =SIMP(statut='f',typ=grma,validators=NoRepeat(),max='**'),
                GROUP_NO        =SIMP(statut='f',typ=grno,validators=NoRepeat(),max='**'),
                MAILLE          =SIMP(statut='f',typ=ma  ,validators=NoRepeat(),max='**'),
                NOEUD           =SIMP(statut='f',typ=no  ,validators=NoRepeat(),max='**'),
                CHAM_GD         =SIMP(statut='o',typ=cham_gd_sdaster),
                NOM_CMP         =SIMP(statut='f',typ='TXM',max='**' ),
                NOM_CMP_RESU    =SIMP(statut='f',typ='TXM',max='**' ),
                CUMUL           =SIMP(statut='f',typ='TXM',defaut="NON",into=("OUI","NON",) ),
                COEF_R          =SIMP(statut='f',typ='R',defaut= 1. ),
                COEF_C          =SIMP(statut='f',typ='C',max=1),
                                    ),
                             ),
#        ------------------------------------------------------------------
         b_eval          =BLOC(condition = "OPERATION == 'EVAL'",
             CHAM_F          =SIMP(statut='o',typ=cham_gd_sdaster),
             CHAM_PARA       =SIMP(statut='o',typ=cham_gd_sdaster,max='**'),
                             ),
#        ------------------------------------------------------------------
         b_r2c           =BLOC(condition = "OPERATION == 'R2C'",
             CHAM_GD          =SIMP(statut='o',typ=cham_gd_sdaster),
                             ),
#        ------------------------------------------------------------------
         b_c2r           =BLOC(condition = "OPERATION == 'C2R'",
             CHAM_GD          =SIMP(statut='o',typ=cham_gd_sdaster),
             PARTIE           =SIMP(statut='o',typ='TXM',into=('REEL','IMAG'),),
                             ),
#        ------------------------------------------------------------------
         b_disc          =BLOC(condition = "OPERATION == 'DISC'",
             MODELE          =SIMP(statut='f',typ=(modele_sdaster) ),
             PROL_ZERO       =SIMP(statut='f',typ='TXM',defaut="NON",into=("OUI","NON",) ),
             CHAM_GD         =SIMP(statut='o',typ=cham_gd_sdaster),
                             ),
#        ------------------------------------------------------------------
         b_extr          =BLOC(condition = "OPERATION == 'EXTR'",
             regles=(AU_MOINS_UN('MAILLAGE','FISSURE','RESULTAT','TABLE'),),
             MAILLAGE        =SIMP(statut='f',typ=(maillage_sdaster) ),
             FISSURE         =SIMP(statut='f',typ=(fiss_xfem) ),
             RESULTAT        =SIMP(statut='f',typ=(resultat_sdaster) ),
             TABLE           =SIMP(statut='f',typ=(table_sdaster),min=1,max=1),
             b_extr_maillage =BLOC(condition = "MAILLAGE != None and TABLE == None",
                 NOM_CHAM        =SIMP(statut='o',typ='TXM',into=("GEOMETRIE",)),
             ),
             b_extr_fissure  =BLOC(condition = "FISSURE != None",
                 NOM_CHAM        =SIMP(statut='o',typ='TXM',into=("LTNO","LNNO","GRLTNO","GRLNNO","STNO","STNOR","BASLOC")),
             ),
             b_extr_table    =BLOC(condition = "TABLE != None",
                      regles=( EXCLUS('MODELE','MAILLAGE'),
                               EXCLUS('PROL_ZERO','MAILLAGE'),),
                      MAILLAGE        =SIMP(statut='f',typ=(maillage_sdaster),),
                      MODELE          =SIMP(statut='f',typ=(modele_sdaster),),
                      OPTION          =SIMP(statut='f',typ='TXM'),
                      PROL_ZERO       =SIMP(statut='f',typ='TXM',defaut="NON",into=("OUI","NON",) ),
                 ),
             b_extr_resultat =BLOC(condition = "RESULTAT != None",
                 regles=(DERIVABLE('RESULTAT'),),
                 SENSIBILITE     =SIMP(statut='f',typ=(para_sensi,theta_geom),
                                   fr="Paramètre de sensibilité.",
                                   ang="Sensitivity parameter"),
                 NOM_CHAM        =SIMP(statut='o',typ='TXM',into=C_NOM_CHAM_INTO()),
                 TYPE_MAXI       =SIMP(statut='f',typ='TXM',into=("MAXI","MINI","MAXI_ABS","MINI_ABS","NORM_TRAN",) ),

                 # si TYPE_MAXI, on spécifie en général plusieurs numéros d'ordre :
                 b_type_maxi =BLOC(condition = "TYPE_MAXI != None",
                      TYPE_RESU       =SIMP(statut='o',typ='TXM',defaut="VALE",into=("VALE","INST",) ),

                      regles=(EXCLUS('TOUT_ORDRE','LIST_INST','LIST_FREQ','NUME_ORDRE','INST',
                                      'FREQ','NUME_MODE','NOEUD_CMP','NOM_CAS','ANGL'),),
                      TOUT_ORDRE      =SIMP(statut='f',typ='TXM',into=("OUI",) ),
                      LIST_INST       =SIMP(statut='f',typ=(listr8_sdaster) ),
                      LIST_FREQ       =SIMP(statut='f',typ=(listr8_sdaster) ),
                      NUME_ORDRE      =SIMP(statut='f',typ='I',max='**'),
                      INST            =SIMP(statut='f',typ='R',max='**'),
                      FREQ            =SIMP(statut='f',typ='R',max='**'),
                      NUME_MODE       =SIMP(statut='f',typ='I',max='**'),
                      NOEUD_CMP       =SIMP(statut='f',typ='TXM',max='**'),
                      NOM_CAS         =SIMP(statut='f',typ='TXM',max='**'),
                      ANGL            =SIMP(statut='f',typ='R',max='**'),
                 ),

                 # si .not. TYPE_MAXI, on ne doit spécifier qu'un seul numéro d'ordre :
                 b_non_type_maxi =BLOC(condition = "TYPE_MAXI == None",
                      regles=(EXCLUS('NUME_ORDRE','INST','FREQ','NUME_MODE','NOEUD_CMP','NOM_CAS','ANGL'),),
                      NUME_ORDRE      =SIMP(statut='f',typ='I'),
                      INST            =SIMP(statut='f',typ='R'),
                      FREQ            =SIMP(statut='f',typ='R'),
                      NUME_MODE       =SIMP(statut='f',typ='I'),
                      NOEUD_CMP       =SIMP(statut='f',typ='TXM',max=2),
                      NOM_CAS         =SIMP(statut='f',typ='TXM'),
                      ANGL            =SIMP(statut='f',typ='R'),

                      INTERPOL        =SIMP(statut='f',typ='TXM',defaut="NON",into=("NON","LIN",) ),
                 ),

                 PRECISION       =SIMP(statut='f',typ='R',defaut= 1.0E-3),
                 CRITERE         =SIMP(statut='f',typ='TXM',defaut="RELATIF",into=("RELATIF","ABSOLU",) ),

         ),  # fin bloc b_extr


               ),
# FIN DU CATALOGUE : INFO,TITRE ET TYPAGE DU RESULTAT :
#-----------------------------------------------------
         INFO            =SIMP(statut='f',typ='I',defaut= 1,into=(1,2,) ),
         TITRE           =SIMP(statut='f',typ='TXM',max='**' ),
)  ;
#& MODIF COMMANDE  DATE 03/01/2006   AUTEUR REZETTE C.REZETTE 
# RESPONSABLE MCOURTOI M.COURTOIS
#            CONFIGURATION MANAGEMENT OF EDF VERSION
# ======================================================================
# COPYRIGHT (C) 1991 - 2001  EDF R&D                  WWW.CODE-ASTER.ORG
# THIS PROGRAM IS FREE SOFTWARE; YOU CAN REDISTRIBUTE IT AND/OR MODIFY
# IT UNDER THE TERMS OF THE GNU GENERAL PUBLIC LICENSE AS PUBLISHED BY
# THE FREE SOFTWARE FOUNDATION; EITHER VERSION 2 OF THE LICENSE, OR
# (AT YOUR OPTION) ANY LATER VERSION.
#
# THIS PROGRAM IS DISTRIBUTED IN THE HOPE THAT IT WILL BE USEFUL, BUT
# WITHOUT ANY WARRANTY; WITHOUT EVEN THE IMPLIED WARRANTY OF
# MERCHANTABILITY OR FITNESS FOR A PARTICULAR PURPOSE. SEE THE GNU
# GENERAL PUBLIC LICENSE FOR MORE DETAILS.
#
# YOU SHOULD HAVE RECEIVED A COPY OF THE GNU GENERAL PUBLIC LICENSE
# ALONG WITH THIS PROGRAM; IF NOT, WRITE TO EDF R&D CODE_ASTER,
#    1 AVENUE DU GENERAL DE GAULLE, 92141 CLAMART CEDEX, FRANCE.
# ======================================================================
CREA_MAILLAGE=OPER(nom="CREA_MAILLAGE",op= 167,sd_prod=maillage_sdaster,
            reentrant='n',fr="Crée un maillage à partir d'un maillage existant",
            UIinfo={"groupes":("Maillage",)},
         regles=(EXCLUS('ECLA_PG','CREA_MAILLE'),
                 EXCLUS('ECLA_PG','CREA_GROUP_MA'),
                 EXCLUS('ECLA_PG','DETR_GROUP_MA'),
                 EXCLUS('ECLA_PG','MODI_MAILLE'),
                 EXCLUS('ECLA_PG','LINE_QUAD'),
                 EXCLUS('ECLA_PG','CREA_FISS'),
                 EXCLUS('ECLA_PG','COQU_VOLU'),
                 EXCLUS('LINE_QUAD','MODI_MAILLE'),
                 EXCLUS('LINE_QUAD','CREA_MAILLE'),
                 EXCLUS('LINE_QUAD','CREA_GROUP_MA'),
                 EXCLUS('LINE_QUAD','DETR_GROUP_MA'),
                 EXCLUS('LINE_QUAD','CREA_FISS'),
                 EXCLUS('LINE_QUAD','COQU_VOLU'),
                 EXCLUS('CREA_FISS','MODI_MAILLE'),
                 EXCLUS('CREA_FISS','CREA_MAILLE'),
                 EXCLUS('CREA_FISS','CREA_GROUP_MA'),
                 EXCLUS('CREA_FISS','DETR_GROUP_MA'),
                 EXCLUS('CREA_FISS','COQU_VOLU'),
                 EXCLUS('COQU_VOLU','MODI_MAILLE'),
                 EXCLUS('COQU_VOLU','CREA_MAILLE'),
                 EXCLUS('COQU_VOLU','CREA_GROUP_MA'),
                 EXCLUS('COQU_VOLU','DETR_GROUP_MA'),
                 ),
                 
         # le MAILLAGE est inutile si ECLA_PG
         MAILLAGE        =SIMP(statut='f',typ=maillage_sdaster ),
         
         CREA_POI1       =FACT(statut='f',max='**',fr="Création de mailles de type POI1 à partir de noeuds",
           regles=(AU_MOINS_UN('TOUT','GROUP_MA','MAILLE','GROUP_NO','NOEUD' ),),
           NOM_GROUP_MA    =SIMP(statut='f',typ=grma,validators=NoRepeat(),max='**'),
           TOUT            =SIMP(statut='f',typ='TXM',into=("OUI",) ),
           GROUP_MA        =SIMP(statut='f',typ=grma,validators=NoRepeat(),max='**'),
           MAILLE          =SIMP(statut='f',typ=ma  ,validators=NoRepeat(),max='**'),
           GROUP_NO        =SIMP(statut='f',typ=grno,validators=NoRepeat(),max='**'),
           NOEUD           =SIMP(statut='f',typ=no  ,validators=NoRepeat(),max='**'),
         ),
         CREA_MAILLE     =FACT(statut='f',max='**',fr="Duplication de mailles",
           regles=(AU_MOINS_UN('TOUT','MAILLE','GROUP_MA'),),
           TOUT            =SIMP(statut='f',typ='TXM',into=("OUI",) ),
           MAILLE          =SIMP(statut='f',typ=ma  ,validators=NoRepeat(),max='**'),
           GROUP_MA        =SIMP(statut='f',typ=grma,validators=NoRepeat(),max='**'),
           PREF_MAILLE     =SIMP(statut='o',typ='TXM' ),
           PREF_NUME       =SIMP(statut='f',typ='I' ),
         ),
         CREA_GROUP_MA   =FACT(statut='f',max='**',fr="Duplication de mailles et création de groupes de mailles",
           regles=(AU_MOINS_UN('TOUT','MAILLE','GROUP_MA' ),),
           NOM             =SIMP(statut='o',typ='TXM'),
           TOUT            =SIMP(statut='f',typ='TXM',into=("OUI",) ),
           MAILLE          =SIMP(statut='f',typ=ma  ,validators=NoRepeat(),max='**'),
           GROUP_MA        =SIMP(statut='f',typ=grma,validators=NoRepeat(),max='**'),
           PREF_MAILLE     =SIMP(statut='o',typ='TXM' ),
           PREF_NUME       =SIMP(statut='f',typ='I' ),
         ),
         DETR_GROUP_MA   =FACT(statut='f',fr="Destruction de groupes de mailles",
           GROUP_MA        =SIMP(statut='f',typ=grma,validators=NoRepeat(),max='**'),
           NB_MAILLE       =SIMP(statut='f',typ='I',defaut= 0,
                                 fr="Nombre minimal de mailles que doit contenir le groupe pour etre détruit",  ),
         ),
         COQU_VOLU   =FACT(statut='f',
                           fr="Creation de mailles volumiques à partir de mailles surfaciques",
           NOM             =SIMP(statut='o',typ='TXM'),
           GROUP_MA        =SIMP(statut='o',typ=grma,validators=NoRepeat(),max ='**'),
           EPAIS           =SIMP(statut='o',typ='R' ),
           PREF_MAILLE     =SIMP(statut='f',typ='TXM',defaut="MS" ),
           PREF_NOEUD      =SIMP(statut='f',typ='TXM',defaut="NS" ),
           PREF_NUME       =SIMP(statut='f',typ='I'  ,defaut=1 ),
           PLAN            =SIMP(statut='o',typ='TXM',into=("SUP","MOY","INF")),
           b_MOY =BLOC(condition = "PLAN == 'MOY'",
             TRANSLATION   =SIMP(statut='o',typ='TXM',into=("SUP","INF") ),
           ),
         ),
         MODI_MAILLE     =FACT(statut='f',max='**',fr="Modification du type de mailles",
           regles=(AU_MOINS_UN('TOUT','MAILLE','GROUP_MA' ),),
           TOUT            =SIMP(statut='f',typ='TXM',into=("OUI",) ),
           MAILLE          =SIMP(statut='f',typ=grma,validators=NoRepeat(),max='**'),
           GROUP_MA        =SIMP(statut='f',typ=ma  ,validators=NoRepeat(),max='**'),
           OPTION          =SIMP(statut='o',typ='TXM',into=("TRIA6_7","QUAD8_9","SEG3_4","QUAD_TRIA3"),
                                 fr="Choix de la transformation" ),
           b_NOS =BLOC(condition = "OPTION == 'TRIA6_7'  or  OPTION == 'QUAD8_9'  or  OPTION == 'SEG3_4'",
             PREF_NOEUD      =SIMP(statut='f',typ='TXM',defaut="NS"),
             PREF_NUME       =SIMP(statut='f',typ='I',defaut= 1 ),
           ),
           b_QTR =BLOC(condition = "OPTION == 'QUAD_TRIA3'",
             PREF_MAILLE     =SIMP(statut='f',typ='TXM',defaut="MS" ),
             PREF_NUME       =SIMP(statut='f',typ='I',defaut= 1 ),
           ),
         ),
         CREA_FISS = FACT(statut='f',max='**',fr="Creation d'une fissure potentielle avec elts de joint ou elts à disc",
           NOM             =SIMP(statut='o',typ='TXM'),
           GROUP_NO_1      =SIMP(statut='o',typ=grno),
           GROUP_NO_2      =SIMP(statut='o',typ=grno),
           PREF_MAILLE     =SIMP(statut='o',typ='TXM'),
           PREF_NUME       =SIMP(statut='f',typ='I',defaut=1 ),
         ),
         LINE_QUAD     =FACT(statut='f',fr="Passage linéaire -> quadratique",
           regles=(AU_MOINS_UN('TOUT','MAILLE','GROUP_MA' ),),
           TOUT            =SIMP(statut='f',typ='TXM',into=("OUI",) ),
           MAILLE          =SIMP(statut='f',typ=grma,validators=NoRepeat(),max='**'),
           GROUP_MA        =SIMP(statut='f',typ=ma  ,validators=NoRepeat(),max='**'),
           PREF_NOEUD      =SIMP(statut='f',typ='TXM',defaut="NS"),
           PREF_NUME       =SIMP(statut='f',typ='I',defaut= 1 ),
         ),
         QUAD_LINE     =FACT(statut='f',fr="Passage quadratique -> linéaire",
           regles=(AU_MOINS_UN('TOUT','MAILLE','GROUP_MA' ),),
           TOUT            =SIMP(statut='f',typ='TXM',into=("OUI",) ),
           MAILLE          =SIMP(statut='f',typ=grma,validators=NoRepeat(),max='**'),
           GROUP_MA        =SIMP(statut='f',typ=ma  ,validators=NoRepeat(),max='**'),
         ),
         REPERE          =FACT(statut='f',max='**',
                               fr="changement de repère servant à déterminer les caractéristiques d'une section de poutre",
           TABLE           =SIMP(statut='o',typ=table_sdaster,
                                 fr="Nom de la table contenant les caractéristiques de la section de poutre" ),
           NOM_ORIG        =SIMP(statut='f',typ='TXM',into=("CDG","TORSION"),fr="Origine du nouveau repère" ),
           NOM_ROTA        =SIMP(statut='f',typ='TXM',into=("INERTIE",),fr="Direction du repére"  ),
           b_cdg =BLOC(condition = "NOM_ORIG == 'CDG'",
             GROUP_MA        =SIMP(statut='f',typ=grma,
                                   fr="Nom du groupe de mailles dont le centre de gravité sera l origine du nouveau repère"),
           ),
         ),
         ECLA_PG         =FACT(statut='f',
                               fr="Eclatement des mailles en petites mailles contenant chacune un seul point de gauss",
           MODELE          =SIMP(statut='o',typ=modele_sdaster ),
           TOUT            =SIMP(statut='f',typ='TXM',into=("OUI",) ),
           MAILLE          =SIMP(statut='f',typ=ma  ,validators=NoRepeat(),max='**'),
           GROUP_MA        =SIMP(statut='f',typ=grma,validators=NoRepeat(),max='**'),
           SHRINK          =SIMP(statut='f',typ='R',defaut= 0.9, fr="Facteur de réduction" ),
           TAILLE_MIN      =SIMP(statut='f',typ='R',defaut= 0.0, fr="Taille minimale d'un coté" ),
           NOM_CHAM        =SIMP(statut='f',typ='TXM',validators=NoRepeat(),max='**',
                                 into=("SIEF_ELGA","VARI_ELGA","SIEF_ELGA_DEPL","FLUX_ELGA_TEMP",) ),
         ),
         TITRE           =SIMP(statut='f',typ='TXM',max='**'),
#
         INFO            =SIMP(statut='f',typ='I',defaut= 1,into=(1,2) ),
)  ;
#& MODIF COMMANDE  DATE 12/09/2006   AUTEUR REZETTE C.REZETTE 
#            CONFIGURATION MANAGEMENT OF EDF VERSION
# ======================================================================
# COPYRIGHT (C) 1991 - 2001  EDF R&D                  WWW.CODE-ASTER.ORG
# THIS PROGRAM IS FREE SOFTWARE; YOU CAN REDISTRIBUTE IT AND/OR MODIFY
# IT UNDER THE TERMS OF THE GNU GENERAL PUBLIC LICENSE AS PUBLISHED BY
# THE FREE SOFTWARE FOUNDATION; EITHER VERSION 2 OF THE LICENSE, OR
# (AT YOUR OPTION) ANY LATER VERSION.
#
# THIS PROGRAM IS DISTRIBUTED IN THE HOPE THAT IT WILL BE USEFUL, BUT
# WITHOUT ANY WARRANTY; WITHOUT EVEN THE IMPLIED WARRANTY OF
# MERCHANTABILITY OR FITNESS FOR A PARTICULAR PURPOSE. SEE THE GNU
# GENERAL PUBLIC LICENSE FOR MORE DETAILS.
#
# YOU SHOULD HAVE RECEIVED A COPY OF THE GNU GENERAL PUBLIC LICENSE
# ALONG WITH THIS PROGRAM; IF NOT, WRITE TO EDF R&D CODE_ASTER,
#    1 AVENUE DU GENERAL DE GAULLE, 92141 CLAMART CEDEX, FRANCE.
# ======================================================================
def crea_resu_prod(TYPE_RESU,**args):
  if TYPE_RESU == "EVOL_ELAS"    : return evol_elas
  if TYPE_RESU == "EVOL_NOLI"    : return evol_noli
  if TYPE_RESU == "EVOL_THER"    : return evol_ther
  if TYPE_RESU == "MULT_ELAS"    : return mult_elas
  if TYPE_RESU == "FOURIER_ELAS" : return fourier_elas
  if TYPE_RESU == "FOURIER_THER" : return fourier_ther
  if TYPE_RESU == "EVOL_VARC"    : return evol_varc
  if TYPE_RESU == "EVOL_CHAR"    : return evol_char
  raise AsException("type de concept resultat non prevu")

CREA_RESU=OPER(nom="CREA_RESU",op=124,sd_prod=crea_resu_prod,reentrant='f',
            UIinfo={"groupes":("Modélisation",)},
               fr="Créer ou enrichir une structure de donnees resultat à partir de champs aux noeuds",

         OPERATION =SIMP(statut='o',typ='TXM',into=("AFFE","ECLA_PG","PERM_CHAM","PROL_RTZ",),
                         fr="choix de la fonction a activer",),

         b_affe       =BLOC(condition = "OPERATION == 'AFFE'",

           TYPE_RESU    =SIMP(statut='o',position='global',typ='TXM',into=("MULT_ELAS","EVOL_ELAS","EVOL_NOLI","FOURIER_ELAS",
                                                                           "EVOL_THER","EVOL_VARC","EVOL_CHAR","FOURIER_THER") ),
           NOM_CHAM     =SIMP(statut='o',typ='TXM',into=C_NOM_CHAM_INTO()),

           AFFE         =FACT(statut='o',max='**',
             CHAM_GD       =SIMP(statut='o',typ=(cham_gd_sdaster)),
             MODELE        =SIMP(statut='f',typ=modele_sdaster),
             CHAM_MATER    =SIMP(statut='f',typ=cham_mater),
             CARA_ELEM     =SIMP(statut='f',typ=cara_elem),

             b_mult_elas     =BLOC(condition = "TYPE_RESU == 'MULT_ELAS' ",
                NOM_CAS         =SIMP(statut='f',typ='TXM' ),
             ),
             b_evol          =BLOC(condition = "((TYPE_RESU=='EVOL_ELAS') or (TYPE_RESU=='EVOL_NOLI') or (TYPE_RESU=='EVOL_THER')\
                                                                          or (TYPE_RESU=='EVOL_VARC') or (TYPE_RESU=='EVOL_CHAR'))",
                regles=(UN_PARMI('INST','LIST_INST'),),
                INST            =SIMP(statut='f',typ='R',validators=NoRepeat(),max='**'),
                LIST_INST       =SIMP(statut='f',typ=listr8_sdaster),
                NUME_INIT       =SIMP(statut='f',typ='I', val_min=1),
                NUME_FIN        =SIMP(statut='f',typ='I', val_min=1),
                PRECISION       =SIMP(statut='f',typ='R',defaut= 1.0E-3 ),
                CRITERE         =SIMP(statut='f',typ='TXM',defaut="RELATIF",into=("RELATIF","ABSOLU") ),
             ),
             b_fourier       =BLOC(condition = "((TYPE_RESU == 'FOURIER_ELAS') or (TYPE_RESU == 'FOURIER_THER')) ",
                NUME_MODE       =SIMP(statut='f',typ='I'),
                TYPE_MODE       =SIMP(statut='f',typ='TXM',defaut="SYME",into=("SYME","ANTI","TOUS") ),
             ),
           ),
         ),

         b_ecla_pg    =BLOC(condition = "OPERATION == 'ECLA_PG'",

           TYPE_RESU       =SIMP(statut='o',typ='TXM',into=("EVOL_ELAS","EVOL_NOLI","EVOL_THER"), ),

           ECLA_PG         =FACT(statut='o',
             regles=(EXCLUS('TOUT_ORDRE','NUME_ORDRE','INST','LIST_INST','LIST_ORDRE'),),
             NOM_CHAM        =SIMP(statut='o',typ='TXM',validators=NoRepeat(),max='**',
                                   into=("SIEF_ELGA","VARI_ELGA","SIEF_ELGA_DEPL","FLUX_ELGA_TEMP",) ),
             MODELE_INIT     =SIMP(statut='o',typ=modele_sdaster),
             TOUT            =SIMP(statut='f',typ='TXM',into=("OUI",) ),
             MAILLE          =SIMP(statut='f',typ=ma  ,validators=NoRepeat(),max='**'),
             GROUP_MA        =SIMP(statut='f',typ=grma,validators=NoRepeat(),max='**'),
             RESU_INIT       =SIMP(statut='o',typ=resultat_sdaster),
             MAILLAGE        =SIMP(statut='o',typ=maillage_sdaster),
             TOUT_ORDRE      =SIMP(statut='f',typ='TXM',into=("OUI",) ),
             NUME_ORDRE      =SIMP(statut='f',typ='I',validators=NoRepeat(),max='**'),
             LIST_ORDRE      =SIMP(statut='f',typ=listis_sdaster),
             INST            =SIMP(statut='f',typ='R',validators=NoRepeat(),max='**'),
             LIST_INST       =SIMP(statut='f',typ=listr8_sdaster),
             PRECISION       =SIMP(statut='f',typ='R',defaut= 1.0E-3),
             CRITERE         =SIMP(statut='f',typ='TXM',defaut="RELATIF",into=("RELATIF","ABSOLU",) ),
           ),
         ),

         b_perm_cham =BLOC(condition = "OPERATION == 'PERM_CHAM'",

           TYPE_RESU       =SIMP(statut='o',typ='TXM',into=("EVOL_NOLI",) ),
           NOM_CHAM        =SIMP(statut='f',typ='TXM',into=("DEPL","SIEF_ELGA","VARI_ELGA",),validators=NoRepeat(),max='**' ),
           RESU_INIT       =SIMP(statut='o',typ=evol_noli),
           INST_INIT       =SIMP(statut='f',typ='R'),
           PRECISION       =SIMP(statut='f',typ='R',defaut=1.0E-3),
           CRITERE         =SIMP(statut='f',typ='TXM',into=('RELATIF','ABSOLU'),defaut='RELATIF'),
           MAILLAGE_INIT   =SIMP(statut='o',typ=maillage_sdaster,),
           RESU_FINAL      =SIMP(statut='o',typ=evol_noli,),
           MAILLAGE_FINAL  =SIMP(statut='o',typ=maillage_sdaster,),
           PERM_CHAM       =FACT(statut='o',max='**',
              GROUP_MA_FINAL =SIMP(statut='o',typ=grma),
              GROUP_MA_INIT  =SIMP(statut='o',typ=grma),
              TRAN           =SIMP(statut='o',typ='R',max='**'),
              PRECISION      =SIMP(statut='f',typ='R',defaut=1.0E-3),
           ),
         ),

         b_prol_rtz   =BLOC(condition = "OPERATION == 'PROL_RTZ'",

           TYPE_RESU       =SIMP(statut='o',typ='TXM',into=("EVOL_THER",) ),

           PROL_RTZ        =FACT(statut='o',
              regles=(EXCLUS('INST','LIST_INST'),),
              MAILLAGE_FINAL  =SIMP(statut='o',typ=maillage_sdaster,),
              TABLE           =SIMP(statut='o',typ=table_sdaster,fr="Table issue de post_releve_t"),
              INST            =SIMP(statut='f',typ='R',validators=NoRepeat(),max='**'),
              LIST_INST       =SIMP(statut='f',typ=listr8_sdaster),
              b_acce_reel     =BLOC(condition="(INST != None)or(LIST_INST != None)",
                 PRECISION       =SIMP(statut='f',typ='R',defaut=1.0E-6),
                 CRITERE         =SIMP(statut='f',typ='TXM',defaut="RELATIF",into=("RELATIF","ABSOLU") ),
              ),
              PROL_DROITE     =SIMP(statut='f',typ='TXM',defaut="EXCLU",into=("CONSTANT","LINEAIRE","EXCLU",),),
              PROL_GAUCHE     =SIMP(statut='f',typ='TXM',defaut="EXCLU",into=("CONSTANT","LINEAIRE","EXCLU",),),
              REPERE          =SIMP(statut='o',typ='TXM',into=("CYLINDRIQUE",),),
              ORIGINE         =SIMP(statut='o',typ='R',min=3,max=3),
              AXE_Z           =SIMP(statut='o',typ='R',min=3,max=3),
           ),
         ),

)  ;
#& MODIF COMMANDE  DATE 10/10/2006   AUTEUR MCOURTOI M.COURTOIS 
#            CONFIGURATION MANAGEMENT OF EDF VERSION
# ======================================================================
# COPYRIGHT (C) 1991 - 2003  EDF R&D                  WWW.CODE-ASTER.ORG
# THIS PROGRAM IS FREE SOFTWARE; YOU CAN REDISTRIBUTE IT AND/OR MODIFY  
# IT UNDER THE TERMS OF THE GNU GENERAL PUBLIC LICENSE AS PUBLISHED BY  
# THE FREE SOFTWARE FOUNDATION; EITHER VERSION 2 OF THE LICENSE, OR     
# (AT YOUR OPTION) ANY LATER VERSION.                                                  
#                                                                       
# THIS PROGRAM IS DISTRIBUTED IN THE HOPE THAT IT WILL BE USEFUL, BUT   
# WITHOUT ANY WARRANTY; WITHOUT EVEN THE IMPLIED WARRANTY OF            
# MERCHANTABILITY OR FITNESS FOR A PARTICULAR PURPOSE. SEE THE GNU      
# GENERAL PUBLIC LICENSE FOR MORE DETAILS.                              
#                                                                       
# YOU SHOULD HAVE RECEIVED A COPY OF THE GNU GENERAL PUBLIC LICENSE     
# ALONG WITH THIS PROGRAM; IF NOT, WRITE TO EDF R&D CODE_ASTER,         
#    1 AVENUE DU GENERAL DE GAULLE, 92141 CLAMART CEDEX, FRANCE.        
# ======================================================================

def crea_table_prod(TYPE_TABLE, **args):
   """Typage du concept résultat
   """
   if TYPE_TABLE == 'TABLE_FONCTION':
      return table_fonction
   else:
      return table_sdaster

CREA_TABLE=OPER(nom="CREA_TABLE",op=36,sd_prod=crea_table_prod,
                fr="Création d'une table à partir d'une fonction ou de deux listes",
                reentrant='f',UIinfo={"groupes":("Table",)},

           regles=(EXCLUS('FONCTION','LISTE'),),

           LISTE=FACT(statut='f',max='**',
                 fr="Creation d'une table a partir de listes",
                 regles=(UN_PARMI('LISTE_I','LISTE_R','LISTE_K')), 
                        PARA     =SIMP(statut='o',typ='TXM'),
                        TYPE_K   =SIMP(statut='f',typ='TXM',defaut='K8',
                                    into=('K8','K16','K24')),
                        NUME_LIGN=SIMP(statut='f',typ='I',max='**'),
                        LISTE_I  =SIMP(statut='f',typ='I',max='**'),
                        LISTE_R  =SIMP(statut='f',typ='R',max='**'),
                        LISTE_K  =SIMP(statut='f',typ='TXM', max='**'),
           ),
           FONCTION=FACT(statut='f',
                    fr="Creation d'une table a partir d'une fonction",
                        FONCTION=SIMP(statut='o',typ=(fonction_c,fonction_sdaster)),
                        PARA=SIMP(statut='f',typ='TXM',min=2,max=2),
           ),
           b_fonction = BLOC(condition='FONCTION != None',
               regles=(CONCEPT_SENSIBLE('SEPARE'), REUSE_SENSIBLE(),
                       DERIVABLE('FONCTION'),),
               SENSIBILITE = SIMP(statut='f',typ=(para_sensi,theta_geom),validators=NoRepeat(),max='**',
                                    fr="Liste des paramètres de sensibilité.",
                                    ang="List of sensitivity parameters"),
           ),
           TYPE_TABLE = SIMP(statut='f', typ='TXM', defaut="TABLE",
                             into=('TABLE', 'TABLE_FONCTION'),),
           
           TITRE=SIMP(statut='f',typ='TXM',max='**'),
)  ;



#& MODIF COMMANDE  DATE 19/06/2006   AUTEUR VABHHTS J.PELLET 
#            CONFIGURATION MANAGEMENT OF EDF VERSION
# ======================================================================
# COPYRIGHT (C) 1991 - 2001  EDF R&D                  WWW.CODE-ASTER.ORG
# THIS PROGRAM IS FREE SOFTWARE; YOU CAN REDISTRIBUTE IT AND/OR MODIFY
# IT UNDER THE TERMS OF THE GNU GENERAL PUBLIC LICENSE AS PUBLISHED BY
# THE FREE SOFTWARE FOUNDATION; EITHER VERSION 2 OF THE LICENSE, OR
# (AT YOUR OPTION) ANY LATER VERSION.
#
# THIS PROGRAM IS DISTRIBUTED IN THE HOPE THAT IT WILL BE USEFUL, BUT
# WITHOUT ANY WARRANTY; WITHOUT EVEN THE IMPLIED WARRANTY OF
# MERCHANTABILITY OR FITNESS FOR A PARTICULAR PURPOSE. SEE THE GNU
# GENERAL PUBLIC LICENSE FOR MORE DETAILS.
#
# YOU SHOULD HAVE RECEIVED A COPY OF THE GNU GENERAL PUBLIC LICENSE
# ALONG WITH THIS PROGRAM; IF NOT, WRITE TO EDF R&D CODE_ASTER,
#    1 AVENUE DU GENERAL DE GAULLE, 92141 CLAMART CEDEX, FRANCE.
# ======================================================================
DEBUT=MACRO(nom="DEBUT",op=ops.build_debut ,repetable='n',
            UIinfo={"groupes":("Gestion du travail",)},
           fr="Ouverture d'une étude. Allocation des ressources mémoire et disque et fichiers",
          sd_prod=ops.DEBUT,

         PAR_LOT         =SIMP(fr="mode de traitement des commandes",statut='f',typ='TXM',
                           into=("OUI","NON"),defaut="OUI"),
         IMPR_MACRO      =SIMP(fr="affichage des sous-commandes produites par les macros dans le fichier mess",
                           statut='f',typ='TXM',into=("OUI","NON"),defaut="NON"),
#         FORMAT_HDF      =SIMP(fr="sauvegarde de la base GLOBALE au format HDF",statut='f',
#                               typ='TXM',defaut="NON",into=("OUI","NON",) ),
         BASE            =FACT(fr="définition des paramètres associés aux bases JEVEUX",
                               statut='f',min=1,max=2,
           FICHIER         =SIMP(fr="nom de la base",statut='o',typ='TXM',
                                 into=('GLOBALE','VOLATILE'),),
           TITRE           =SIMP(statut='f',typ='TXM'),
           CAS             =SIMP(statut='f',typ='TXM'),
           NMAX_ENRE       =SIMP(fr="nombre maximum d enregistrements",statut='f',typ='I'),
           LONG_ENRE       =SIMP(fr="longueur des enregistrements",statut='f',typ='I'),
           LONG_REPE       =SIMP(fr="longueur du répertoire",statut='f',typ='I'),
         ),
         IMPRESSION      =FACT(statut='f',min=1,max=3,
           FICHIER         =SIMP(statut='o',typ='TXM'),
           UNITE           =SIMP(statut='o',typ='I'),
         ),
         CATALOGUE       =FACT(statut='f',min=1,max=10,
           FICHIER         =SIMP(statut='o',typ='TXM'),
           TITRE           =SIMP(statut='f',typ='TXM'),
           UNITE           =SIMP(statut='f',typ='I'),
         ),
         CODE            =FACT(fr="définition d un nom pour l'ensemble d'une étude",
                               statut='f',min=1,max=1,
           NOM             =SIMP(statut='o',typ='TXM'),
           NIV_PUB_WEB     =SIMP(statut='o',typ='TXM',into=('INTERNET','INTRANET')),
           VISU_EFICAS     =SIMP(statut='f',typ='TXM',into=('OUI','NON'),defaut='OUI'),
           UNITE           =SIMP(statut='f',typ='I',defaut=15),
         ),
         ERREUR          =FACT(fr="comportement en cas d'erreur",statut='f',min=1,max=1,
           ERREUR_F        =SIMP(statut='f',typ='TXM',into=('ABORT','EXCEPTION'),defaut='ABORT'),
         ),
         DEBUG           =FACT(fr="option de déboggage reservée aux développeurs",
                               statut='f',min=1,max=1,
           JXVERI          =SIMP(fr="vérifie l intégrité de la segmentation mémoire",
                                 statut='f',typ='TXM',into=('OUI','NON'),defaut='NON'),
           SDVERI          =SIMP(fr="vérifie la conformité des SD produites par les commandes",
                                 statut='f',typ='TXM',into=('OUI','NON'),defaut='NON'),
           JEVEUX          =SIMP(fr="force les déchargement sur disque",
                                 statut='f',typ='TXM',into=('OUI','NON'),defaut='NON'),
           ENVIMA          =SIMP(fr="imprime les valeurs définies dans ENVIMA",
                                 statut='f',typ='TXM',into=('TEST',)),
         ),
         MEMOIRE         =FACT(fr="mode de gestion mémoire utilisé",statut='f',min=1,max=1,
           GESTION         =SIMP(statut='f',typ='TXM',into=('COMPACTE','RAPIDE'),defaut='RAPIDE'),
           TYPE_ALLOCATION =SIMP(statut='f',typ='I',into=(1,2,3,4),defaut=1),
           TAILLE          =SIMP(statut='f',typ='I'),
           TAILLE_BLOC     =SIMP(statut='f',typ='R',defaut=800.),
           PARTITION       =SIMP(statut='f',typ='R'),
         ),
         RESERVE_CPU     =FACT(fr="reserve de temps pour terminer une execution",statut='f',max=1,
           regles=(EXCLUS('VALE','POURCENTAGE'),),
           VALE            =SIMP(statut='f',typ='I',val_min=0),
           POURCENTAGE     =SIMP(statut='f',typ='R',val_min=0.,val_max=1.0),
#          valeur en pourcentage du temps maximum bornée à 180 secondes
           BORNE           =SIMP(statut='f',typ='I',val_min=0,defaut=180)
         ),
 );
#& MODIF COMMANDE  DATE 03/10/2005   AUTEUR NICOLAS O.NICOLAS 
#            CONFIGURATION MANAGEMENT OF EDF VERSION
# ======================================================================
# COPYRIGHT (C) 1991 - 2001  EDF R&D                  WWW.CODE-ASTER.ORG
# THIS PROGRAM IS FREE SOFTWARE; YOU CAN REDISTRIBUTE IT AND/OR MODIFY
# IT UNDER THE TERMS OF THE GNU GENERAL PUBLIC LICENSE AS PUBLISHED BY
# THE FREE SOFTWARE FOUNDATION; EITHER VERSION 2 OF THE LICENSE, OR   
# (AT YOUR OPTION) ANY LATER VERSION.                                 
#
# THIS PROGRAM IS DISTRIBUTED IN THE HOPE THAT IT WILL BE USEFUL, BUT 
# WITHOUT ANY WARRANTY; WITHOUT EVEN THE IMPLIED WARRANTY OF          
# MERCHANTABILITY OR FITNESS FOR A PARTICULAR PURPOSE. SEE THE GNU    
# GENERAL PUBLIC LICENSE FOR MORE DETAILS.                            
#
# YOU SHOULD HAVE RECEIVED A COPY OF THE GNU GENERAL PUBLIC LICENSE   
# ALONG WITH THIS PROGRAM; IF NOT, WRITE TO EDF R&D CODE_ASTER,       
#    1 AVENUE DU GENERAL DE GAULLE, 92141 CLAMART CEDEX, FRANCE.      
# ======================================================================
DEFI_BASE_MODALE=OPER(nom="DEFI_BASE_MODALE",op=  99,sd_prod=base_modale,
                     reentrant='f',
                     fr="Définit la base d'une sous-structuration dynamique ou d'une recombinaison modale",
            UIinfo={"groupes":("Matrices/vecteurs",)},
         regles=(UN_PARMI('CLASSIQUE','RITZ','DIAG_MASS','ORTHO_BASE'),),
         CLASSIQUE       =FACT(statut='f',
           INTERF_DYNA     =SIMP(statut='o',typ=interf_dyna_clas ),
           MODE_MECA       =SIMP(statut='o',typ=mode_meca,max='**' ),
           NMAX_MODE       =SIMP(statut='f',typ='I',defaut= 10 ),
         ),
         RITZ            =FACT(statut='f',max='**',
           regles=(UN_PARMI('MODE_STAT','MODE_MECA','MULT_ELAS','BASE_MODALE'),),
           MODE_MECA       =SIMP(statut='f',typ=mode_meca,max='**'  ),
           NMAX_MODE       =SIMP(statut='f',typ='I',defaut= 999 ),
           MODE_STAT       =SIMP(statut='f',typ=(mode_stat_depl,mode_stat_acce,mode_stat_forc,) ),
           MULT_ELAS       =SIMP(statut='f',typ=mult_elas ),
           BASE_MODALE     =SIMP(statut='f',typ=base_modale ),
         ),
         b_ritz          =BLOC(condition = "RITZ != None",
           INTERF_DYNA     =SIMP(statut='f',typ=interf_dyna_clas ),
           NUME_REF        =SIMP(statut='o',typ=nume_ddl_sdaster ),
           ORTHO           =SIMP(statut='f',typ='TXM',defaut="NON",into=("OUI","NON"),
                               fr="Reorthonormalisation de la base de Ritz" ),
           b_ortho          =BLOC(condition = "ORTHO == 'OUI' ",
             MATRICE          =SIMP(statut='o',typ=(matr_asse_depl_r,matr_asse_depl_c,matr_asse_gene_r,matr_asse_pres_r ) ),
               ),
         ),
        DIAG_MASS        =FACT(statut='f',max='**',
           MODE_MECA       =SIMP(statut='o',typ=mode_meca,max='**'  ),
           MODE_STAT       =SIMP(statut='o',typ=(mode_stat_depl,mode_stat_acce,mode_stat_forc,) ),
         ),
        ORTHO_BASE        =FACT(statut='f',max='**',
           BASE       =SIMP(statut='o',typ=(mode_meca,mode_stat_depl,mode_stat_acce,mode_stat_forc,mult_elas,base_modale)),
           MATRICE    =SIMP(statut='o',typ=(matr_asse_depl_r,matr_asse_depl_c,matr_asse_gene_r,matr_asse_pres_r ) ),
         ),
         TITRE           =SIMP(statut='f',typ='TXM',max='**'),
         INFO            =SIMP(statut='f',typ='I',defaut= 1,into=( 1 , 2) ),
)  ;
#& MODIF COMMANDE  DATE 22/06/2005   AUTEUR REZETTE C.REZETTE 
#            CONFIGURATION MANAGEMENT OF EDF VERSION
# ======================================================================
# COPYRIGHT (C) 1991 - 2003  EDF R&D                  WWW.CODE-ASTER.ORG
# THIS PROGRAM IS FREE SOFTWARE; YOU CAN REDISTRIBUTE IT AND/OR MODIFY  
# IT UNDER THE TERMS OF THE GNU GENERAL PUBLIC LICENSE AS PUBLISHED BY  
# THE FREE SOFTWARE FOUNDATION; EITHER VERSION 2 OF THE LICENSE, OR     
# (AT YOUR OPTION) ANY LATER VERSION.                                                  
#                                                                       
# THIS PROGRAM IS DISTRIBUTED IN THE HOPE THAT IT WILL BE USEFUL, BUT   
# WITHOUT ANY WARRANTY; WITHOUT EVEN THE IMPLIED WARRANTY OF            
# MERCHANTABILITY OR FITNESS FOR A PARTICULAR PURPOSE. SEE THE GNU      
# GENERAL PUBLIC LICENSE FOR MORE DETAILS.                              
#                                                                       
# YOU SHOULD HAVE RECEIVED A COPY OF THE GNU GENERAL PUBLIC LICENSE     
# ALONG WITH THIS PROGRAM; IF NOT, WRITE TO EDF R&D CODE_ASTER,         
#    1 AVENUE DU GENERAL DE GAULLE, 92141 CLAMART CEDEX, FRANCE.        
# ======================================================================

from Macro.defi_cable_bp_ops import defi_cable_bp_ops

# ===========================================================================
#           CATALOGUE DE LA MACRO "DEFI_CABLE_BP"
#           -----------------------------------------
#
# USAGE :
# Entrée :
#  - MAILLAGE
#  - MODELE
#  - CABLE
#  - CHAM_MATER
#  - CARA_ELEM
#  - GROUP_MA_BETON
#  - DEFI_CABLE
#  - TENSION_INIT
#  - RECUL_ANCRAGE
#  - RELAXATION
#  - CONE
#      RAYON
#      LONGUEUR
#      PRESENT          OUI ou NON deux fois
#  - TITRE
#  - INFO               1 / 2
#
# ===========================================================================

DEFI_CABLE_BP=MACRO(nom="DEFI_CABLE_BP",op=defi_cable_bp_ops,sd_prod=cabl_precont,
                   fr="Calculer les profils initiaux de tension le long des cables de précontrainte d'une structure en béton",
                   reentrant='n',UIinfo={"groupe":("Modélisation",)},
         regles=(ENSEMBLE('MAILLAGE','CONE'),),
         MAILLAGE        =SIMP(statut='f',typ=maillage_sdaster),
         MODELE          =SIMP(statut='o',typ=modele_sdaster ),
         CHAM_MATER      =SIMP(statut='o',typ=cham_mater ),
         CARA_ELEM       =SIMP(statut='o',typ=cara_elem ),
         GROUP_MA_BETON  =SIMP(statut='o',typ=grma,max='**'),
         DEFI_CABLE      =FACT(statut='o',max='**',
           regles=(UN_PARMI('MAILLE','GROUP_MA'),
                   UN_PARMI('NOEUD_ANCRAGE','GROUP_NO_ANCRAGE'),),
           MAILLE          =SIMP(statut='f',typ=ma,min=2,validators=NoRepeat(),max='**'),
           GROUP_MA        =SIMP(statut='f',typ=grma),
           NOEUD_ANCRAGE   =SIMP(statut='f',typ=no  ,validators=NoRepeat(),max=2),
           GROUP_NO_ANCRAGE=SIMP(statut='f',typ=grno,validators=NoRepeat(),max=2),
         ),
         TYPE_ANCRAGE    =SIMP(statut='o',typ='TXM',min=2,max=2,into=("ACTIF","PASSIF") ),
         TENSION_INIT    =SIMP(statut='o',typ='R',val_min=0.E+0 ),  
         RECUL_ANCRAGE   =SIMP(statut='o',typ='R',val_min=0.E+0 ),  
         RELAXATION      =FACT(statut='f',min=0,
           R_J             =SIMP(statut='o',typ='R',val_min=0.E+0 ),  
         ),
         CONE            =FACT(statut='f',
           RAYON             =SIMP(statut='o',typ='R',val_min=0.E+0 ),  
           LONGUEUR          =SIMP(statut='o',typ='R',val_min=0.E+0 ),  
           PRESENT           =SIMP(statut='o',typ='TXM',min=2,max=2,into=("OUI","NON") ),
         ),
         TITRE           =SIMP(statut='f',typ='TXM',max='**' ),  
         INFO            =SIMP(statut='f',typ='I',defaut= 1,into=( 1 , 2) ),
)  ;
#& MODIF COMMANDE  DATE 22/06/2005   AUTEUR REZETTE C.REZETTE 
#            CONFIGURATION MANAGEMENT OF EDF VERSION
# ======================================================================
# COPYRIGHT (C) 1991 - 2003  EDF R&D                  WWW.CODE-ASTER.ORG
# THIS PROGRAM IS FREE SOFTWARE; YOU CAN REDISTRIBUTE IT AND/OR MODIFY  
# IT UNDER THE TERMS OF THE GNU GENERAL PUBLIC LICENSE AS PUBLISHED BY  
# THE FREE SOFTWARE FOUNDATION; EITHER VERSION 2 OF THE LICENSE, OR     
# (AT YOUR OPTION) ANY LATER VERSION.                                                  
#                                                                       
# THIS PROGRAM IS DISTRIBUTED IN THE HOPE THAT IT WILL BE USEFUL, BUT   
# WITHOUT ANY WARRANTY; WITHOUT EVEN THE IMPLIED WARRANTY OF            
# MERCHANTABILITY OR FITNESS FOR A PARTICULAR PURPOSE. SEE THE GNU      
# GENERAL PUBLIC LICENSE FOR MORE DETAILS.                              
#                                                                       
# YOU SHOULD HAVE RECEIVED A COPY OF THE GNU GENERAL PUBLIC LICENSE     
# ALONG WITH THIS PROGRAM; IF NOT, WRITE TO EDF R&D CODE_ASTER,         
#    1 AVENUE DU GENERAL DE GAULLE, 92141 CLAMART CEDEX, FRANCE.        
# ======================================================================

DEFI_CABLE_OP=OPER(nom="DEFI_CABLE_OP",op= 180,sd_prod=cabl_precont,reentrant='n',
            fr="Définit les profils initiaux de tension d'une structure en béton le long des cables de précontrainte"
               +" (utilisée par la macro DEFI_CABLE_BP)",
            UIinfo={"groupes":("Modélisation",)},
         MODELE          =SIMP(statut='o',typ=modele_sdaster ),
         CHAM_MATER      =SIMP(statut='o',typ=cham_mater ),
         CARA_ELEM       =SIMP(statut='o',typ=cara_elem ),
         GROUP_MA_BETON  =SIMP(statut='o',typ=grma,max='**'),
         DEFI_CABLE      =FACT(statut='o',max='**',
           regles=(UN_PARMI('MAILLE','GROUP_MA'),
                   UN_PARMI('NOEUD_ANCRAGE','GROUP_NO_ANCRAGE'),),
           MAILLE          =SIMP(statut='f',typ=ma,min=2,validators=NoRepeat(),max='**'),
           GROUP_MA        =SIMP(statut='f',typ=grma),
           NOEUD_ANCRAGE   =SIMP(statut='f',typ=no  ,validators=NoRepeat(),max=2),
           GROUP_NO_ANCRAGE=SIMP(statut='f',typ=grno,validators=NoRepeat(),max=2),
           GROUP_NO_FUT    =SIMP(statut='f',typ=grno,validators=NoRepeat(),max=2),
         ),
         TYPE_ANCRAGE    =SIMP(statut='o',typ='TXM',min=2,max=2,into=("ACTIF","PASSIF") ),
         TENSION_INIT    =SIMP(statut='o',typ='R',val_min=0.E+0 ),  
         RECUL_ANCRAGE   =SIMP(statut='o',typ='R',val_min=0.E+0 ),  
         RELAXATION      =FACT(statut='f',min=0,
           R_J             =SIMP(statut='o',typ='R',val_min=0.E+0 ),  
         ),
         TITRE           =SIMP(statut='f',typ='TXM',max='**' ),  
         INFO            =SIMP(statut='f',typ='I',defaut= 1,into=( 1 , 2) ),
         CONE            =FACT(statut='f',min=0,
           RAYON             =SIMP(statut='o',typ='R',val_min=0.E+0 ),  
           LONGUEUR          =SIMP(statut='o',typ='R',val_min=0.E+0, defaut=0.E+0 ),  
           PRESENT           =SIMP(statut='o',typ='TXM',min=2,max=2,into=("OUI","NON") ),
         ),
)  ;
#& MODIF COMMANDE  DATE 05/09/2006   AUTEUR JOUMANA J.EL-GHARIB 
# RESPONSABLE JMBHH01 J.M.PROIX
#            CONFIGURATION MANAGEMENT OF EDF VERSION
# ======================================================================
# COPYRIGHT (C) 1991 - 2004  EDF R&D                  WWW.CODE-ASTER.ORG
# THIS PROGRAM IS FREE SOFTWARE; YOU CAN REDISTRIBUTE IT AND/OR MODIFY  
# IT UNDER THE TERMS OF THE GNU GENERAL PUBLIC LICENSE AS PUBLISHED BY  
# THE FREE SOFTWARE FOUNDATION; EITHER VERSION 2 OF THE LICENSE, OR     
# (AT YOUR OPTION) ANY LATER VERSION.                                                  
#                                                                       
# THIS PROGRAM IS DISTRIBUTED IN THE HOPE THAT IT WILL BE USEFUL, BUT   
# WITHOUT ANY WARRANTY; WITHOUT EVEN THE IMPLIED WARRANTY OF            
# MERCHANTABILITY OR FITNESS FOR A PARTICULAR PURPOSE. SEE THE GNU      
# GENERAL PUBLIC LICENSE FOR MORE DETAILS.                              
#                                                                       
# YOU SHOULD HAVE RECEIVED A COPY OF THE GNU GENERAL PUBLIC LICENSE     
# ALONG WITH THIS PROGRAM; IF NOT, WRITE TO EDF R&D CODE_ASTER,         
#    1 AVENUE DU GENERAL DE GAULLE, 92141 CLAMART CEDEX, FRANCE.        
# ======================================================================
DEFI_COMPOR=OPER(nom="DEFI_COMPOR",op=59,sd_prod=compor_sdaster,
                   fr="Définir le comportement d'un monocristal ou d'un polycristal",
                   reentrant='n',
            UIinfo={"groupes":("Modélisation",)},
                  regles=(EXCLUS('MONOCRISTAL','POLYCRISTAL'),),

          MONOCRISTAL    =FACT(statut='f', max='**',
             MATER           =SIMP(statut='o', typ=mater_sdaster, max=1),
             ECOULEMENT      =SIMP(statut='o', typ='TXM', max=1,
                   fr="Donner le nom du mot-clé facteur de DEFI_MATERIAU précisant le type d'écoulement viscoplastique"),
             ECRO_ISOT       =SIMP(statut='o', typ='TXM', max=1,
                   fr="Donner le nom du mot-clé facteur de DEFI_MATERIAU précisant le type d'écrouissage isotrope"),
             ECRO_CINE       =SIMP(statut='o', typ='TXM', max=1,
                   fr="Donner le nom du mot-clé facteur de DEFI_MATERIAU précisant le type d'écrouissage cinématique"),
             ELAS            =SIMP(statut='f', typ='TXM', max=1,
                   fr="Donner le nom du mot-clé facteur de DEFI_MATERIAU précisant le comportement élastique (un et un seul)"),
             FAMI_SYST_GLIS  =SIMP(statut='o',typ='TXM', max=1, 
                                into=('BASAL', 'PRISMATIQUE', 'OCTAEDRIQUE', 'PYRAMIDAL1',
                                'PYRAMIDAL2', 'CUBIQUE1', 'CUBIQUE2', 'MACLAGE', 'JOINT_GRAIN', 'RL', 'UNIAXIAL','BCC24'),),
                                ),
                                
                                
          POLYCRISTAL    =FACT(statut='f', max='**',
           regles=(UN_PARMI('ANGL_REP','ANGL_EULER'),),
             MONOCRISTAL     =SIMP(statut='o', typ=compor_sdaster, max=1),
             FRAC_VOL  =SIMP(statut='o', typ='R', max=1,fr="fraction volumique de la phase correspondant au monocristal"),
             ANGL_REP  =SIMP(statut='f',typ='R',max=3,fr="orientation du monocristal : 3 angles nautiques en degrés"),
             ANGL_EULER=SIMP(statut='f',typ='R',max=3,fr="orientation du monocristal : 3 angles d'Euler   en degrés"),
                                ),
                                
                                
          b_poly      =BLOC( condition = "POLYCRISTAL!='None'",
          LOCALISATION     =SIMP(statut='f', typ='TXM', max=1, into=('BZ', 'BETA', 'RL',),
                fr="Donner le nom de la règle de localisation"),
          
           b_beta      =BLOC( condition = "LOCALISATION=='BETA'",
             DL            =SIMP(statut='o',typ='R',max=1),
             DA            =SIMP(statut='o',typ='R',max=1),
             ),
             ),
                                
                                );
                   
#& MODIF COMMANDE  DATE 22/06/2005   AUTEUR REZETTE C.REZETTE 
#            CONFIGURATION MANAGEMENT OF EDF VERSION
# ======================================================================
# COPYRIGHT (C) 1991 - 2001  EDF R&D                  WWW.CODE-ASTER.ORG
# THIS PROGRAM IS FREE SOFTWARE; YOU CAN REDISTRIBUTE IT AND/OR MODIFY
# IT UNDER THE TERMS OF THE GNU GENERAL PUBLIC LICENSE AS PUBLISHED BY
# THE FREE SOFTWARE FOUNDATION; EITHER VERSION 2 OF THE LICENSE, OR   
# (AT YOUR OPTION) ANY LATER VERSION.                                 
#
# THIS PROGRAM IS DISTRIBUTED IN THE HOPE THAT IT WILL BE USEFUL, BUT 
# WITHOUT ANY WARRANTY; WITHOUT EVEN THE IMPLIED WARRANTY OF          
# MERCHANTABILITY OR FITNESS FOR A PARTICULAR PURPOSE. SEE THE GNU    
# GENERAL PUBLIC LICENSE FOR MORE DETAILS.                            
#
# YOU SHOULD HAVE RECEIVED A COPY OF THE GNU GENERAL PUBLIC LICENSE   
# ALONG WITH THIS PROGRAM; IF NOT, WRITE TO EDF R&D CODE_ASTER,       
#    1 AVENUE DU GENERAL DE GAULLE, 92141 CLAMART CEDEX, FRANCE.      
# ======================================================================
DEFI_CONSTANTE=OPER(nom="DEFI_CONSTANTE",op=   2,sd_prod=fonction_sdaster,
                    fr="Définir la valeur d'une grandeur invariante",
                    reentrant='n',
            UIinfo={"groupes":("Fonction",)},
         NOM_RESU        =SIMP(statut='f',typ='TXM',defaut="TOUTRESU"),
         VALE            =SIMP(statut='o',typ='R',),
         TITRE           =SIMP(statut='f',typ='TXM',max='**'),
)  ;
#& MODIF COMMANDE  DATE 22/06/2005   AUTEUR REZETTE C.REZETTE 
#            CONFIGURATION MANAGEMENT OF EDF VERSION
# ======================================================================
# COPYRIGHT (C) 1991 - 2001  EDF R&D                  WWW.CODE-ASTER.ORG
# THIS PROGRAM IS FREE SOFTWARE; YOU CAN REDISTRIBUTE IT AND/OR MODIFY
# IT UNDER THE TERMS OF THE GNU GENERAL PUBLIC LICENSE AS PUBLISHED BY
# THE FREE SOFTWARE FOUNDATION; EITHER VERSION 2 OF THE LICENSE, OR   
# (AT YOUR OPTION) ANY LATER VERSION.                                 
#
# THIS PROGRAM IS DISTRIBUTED IN THE HOPE THAT IT WILL BE USEFUL, BUT 
# WITHOUT ANY WARRANTY; WITHOUT EVEN THE IMPLIED WARRANTY OF          
# MERCHANTABILITY OR FITNESS FOR A PARTICULAR PURPOSE. SEE THE GNU    
# GENERAL PUBLIC LICENSE FOR MORE DETAILS.                            
#
# YOU SHOULD HAVE RECEIVED A COPY OF THE GNU GENERAL PUBLIC LICENSE   
# ALONG WITH THIS PROGRAM; IF NOT, WRITE TO EDF R&D CODE_ASTER,       
#    1 AVENUE DU GENERAL DE GAULLE, 92141 CLAMART CEDEX, FRANCE.      
# ======================================================================
DEFI_COQU_MULT=OPER(nom="DEFI_COQU_MULT",op=56,sd_prod=mater_sdaster,reentrant='n',
            UIinfo={"groupes":("Modélisation",)},
                    fr="Déterminer les caractéristiques matériaux homogénéisées d'une coque multicouche à partir"
                        +" des caractéristiques de chaque couche",
         COUCHE          =FACT(statut='o',max='**',
           EPAIS           =SIMP(statut='o',typ='R',val_min=0.E+0 ),
           MATER           =SIMP(statut='o',typ=(mater_sdaster) ),
           ORIENTATION     =SIMP(statut='f',typ='R',defaut= 0.E+0,
                                 val_min=-90.E+0,val_max=90.E+0   ),
         ),
         IMPRESSION      =FACT(statut='f',
           UNITE           =SIMP(statut='f',typ='I',defaut=8),  
         ),
)  ;
#& MODIF COMMANDE  DATE 22/06/2005   AUTEUR REZETTE C.REZETTE 
#            CONFIGURATION MANAGEMENT OF EDF VERSION
# ======================================================================
# COPYRIGHT (C) 1991 - 2003  EDF R&D                  WWW.CODE-ASTER.ORG
# THIS PROGRAM IS FREE SOFTWARE; YOU CAN REDISTRIBUTE IT AND/OR MODIFY  
# IT UNDER THE TERMS OF THE GNU GENERAL PUBLIC LICENSE AS PUBLISHED BY  
# THE FREE SOFTWARE FOUNDATION; EITHER VERSION 2 OF THE LICENSE, OR     
# (AT YOUR OPTION) ANY LATER VERSION.                                                  
#                                                                       
# THIS PROGRAM IS DISTRIBUTED IN THE HOPE THAT IT WILL BE USEFUL, BUT   
# WITHOUT ANY WARRANTY; WITHOUT EVEN THE IMPLIED WARRANTY OF            
# MERCHANTABILITY OR FITNESS FOR A PARTICULAR PURPOSE. SEE THE GNU      
# GENERAL PUBLIC LICENSE FOR MORE DETAILS.                              
#                                                                       
# YOU SHOULD HAVE RECEIVED A COPY OF THE GNU GENERAL PUBLIC LICENSE     
# ALONG WITH THIS PROGRAM; IF NOT, WRITE TO EDF R&D CODE_ASTER,         
#    1 AVENUE DU GENERAL DE GAULLE, 92141 CLAMART CEDEX, FRANCE.        
# ======================================================================
# RESPONSABLE D6BHHJP J.P.LEFEBVRE
def DEFIC_prod(self,ACTION,UNITE,**args):
  if ACTION == "ASSOCIER" or ACTION == "RESERVER":
    if UNITE != None :
      return
    else :
      return entier
  elif ACTION == "LIBERER"  :
    return
  else :
    raise AsException("ACTION non prevue : %s" % ACTION)

DEFI_FICHIER=MACRO(nom="DEFI_FICHIER",op=ops.build_DEFI_FICHIER,sd_prod=DEFIC_prod,reentrant='n',
                  UIinfo={"groupes":("Gestion du travail",)},
                  fr="Ouvre ou ferme un fichier associé à un numéro d'unité logique",

            ACTION        =SIMP(statut='f',typ='TXM',into=("ASSOCIER","LIBERER","RESERVER"),defaut="ASSOCIER"),

            b_associer    =BLOC(condition = "ACTION == 'ASSOCIER'",
                                fr="Paramètres pour l'ouverture du fichier",
                                regles=(AU_MOINS_UN('FICHIER','UNITE'),),
               UNITE      =SIMP(statut='f',typ='I' ,val_min=1),
               FICHIER    =SIMP(statut='f',typ='TXM',validators=LongStr(1,255)),
               TYPE       =SIMP(statut='f',typ='TXM',into=("ASCII","BINARY","LIBRE"),defaut="ASCII"),

               b_type_ascii  =BLOC(condition = "TYPE == 'ASCII'",fr="Paramètres pour le type ASCII",
                  ACCES      =SIMP(statut='f',typ='TXM',into=("NEW","APPEND","OLD"),defaut="NEW"),
               ),
               b_type_autre  =BLOC(condition = "TYPE != 'ASCII'",fr="Paramètres pour les types BINARY et LIBRE",
                  ACCES      =SIMP(statut='f',typ='TXM',into=("NEW","OLD"),defaut="NEW"),
               ),
            ),

            b_reserver    =BLOC(condition = "ACTION == 'RESERVER'",
                                fr="Paramètres pour la réservation de l'unité du fichier",
                                regles=(AU_MOINS_UN('FICHIER','UNITE'),),
               UNITE      =SIMP(statut='f',typ='I' ,val_min=1),
               FICHIER    =SIMP(statut='f',typ='TXM',validators=LongStr(1,255)),
               TYPE       =SIMP(statut='f',typ='TXM',into=("ASCII",),defaut="ASCII"),
               ACCES      =SIMP(statut='f',typ='TXM',into=("APPEND",),defaut="APPEND"),
            ),

            b_liberer    =BLOC(condition = "ACTION == 'LIBERER'",
                               fr="Paramètres pour la fermeture du fichier",
                               regles=(UN_PARMI('FICHIER','UNITE'),),
                  UNITE         =SIMP(statut='f',typ='I' ,val_min=1),
                  FICHIER   =SIMP(statut='f',typ='TXM',validators=LongStr(1,255)),
           ),

           INFO          =SIMP(statut='f',typ='I',into=(1,2) ),           
           )
#& MODIF COMMANDE  DATE 25/04/2006   AUTEUR CIBHHPD L.SALMONA 
#            CONFIGURATION MANAGEMENT OF EDF VERSION
# ======================================================================
# COPYRIGHT (C) 1991 - 2004  EDF R&D                  WWW.CODE-ASTER.ORG
# THIS PROGRAM IS FREE SOFTWARE; YOU CAN REDISTRIBUTE IT AND/OR MODIFY
# IT UNDER THE TERMS OF THE GNU GENERAL PUBLIC LICENSE AS PUBLISHED BY
# THE FREE SOFTWARE FOUNDATION; EITHER VERSION 2 OF THE LICENSE, OR
# (AT YOUR OPTION) ANY LATER VERSION.
#
# THIS PROGRAM IS DISTRIBUTED IN THE HOPE THAT IT WILL BE USEFUL, BUT
# WITHOUT ANY WARRANTY; WITHOUT EVEN THE IMPLIED WARRANTY OF
# MERCHANTABILITY OR FITNESS FOR A PARTICULAR PURPOSE. SEE THE GNU
# GENERAL PUBLIC LICENSE FOR MORE DETAILS.
#
# YOU SHOULD HAVE RECEIVED A COPY OF THE GNU GENERAL PUBLIC LICENSE
# ALONG WITH THIS PROGRAM; IF NOT, WRITE TO EDF R&D CODE_ASTER,
#    1 AVENUE DU GENERAL DE GAULLE, 92141 CLAMART CEDEX, FRANCE.
# ======================================================================

DEFI_FISS_XFEM=OPER(nom="DEFI_FISS_XFEM",op=  41,sd_prod=fiss_xfem,reentrant='n',
            UIinfo={"groupes":("Modélisation",)},
               fr="Définition des caratéristiques d'une fissure avec X-FEM",

    MODELE                =SIMP(statut='o',typ=modele_sdaster),
    DEFI_FISS             =FACT(statut='o',max=01,
      regles              =(UN_PARMI('GROUP_MA_FISS','FONC_LT'),
                            ENSEMBLE('FONC_LT','FONC_LN'),
                            ENSEMBLE('GROUP_MA_FISS','GROUP_MA_FOND')),
      FONC_LT             =SIMP(statut='f',typ=(fonction_sdaster,formule) ),
      FONC_LN             =SIMP(statut='f',typ=(fonction_sdaster,formule) ),
      GROUP_MA_FISS       =SIMP(statut='f',typ=grma,max=01),
      GROUP_MA_FOND       =SIMP(statut='f',typ=grma),
    ),
    GROUP_MA_ENRI         =SIMP(statut='o',typ=grma,max=01),
    RAYON_ENRI            =SIMP(statut='f',typ='R',defaut=0.E+0),
    ORIE_FOND             =FACT(statut='f',max=01,
      PFON_INI            =SIMP(statut='o',typ='R',max=03),
      VECT_ORIE           =SIMP(statut='o',typ='R',max=03),
      PT_ORIGIN           =SIMP(statut='o',typ='R',max=03),
    ),
    CONTACT               =FACT(statut='f',max=01,
      NOM_CHAM            =SIMP(statut='f',typ='TXM',defaut="DEPL",into=("DEPL",) ),
      FROTTEMENT          =SIMP(statut='f',typ='TXM',defaut="SANS",into=("SANS","COULOMB",) ),
      INTEGRATION         =SIMP(statut='f',typ='TXM',defaut="FPG4",into=("GAUSS","FPG4","FPG6","FPG7",) ),
      COEF_REGU_CONT      =SIMP(statut='f',typ='R',defaut=100.E+0),
      MODL_AXIS           =SIMP(statut='f',typ='TXM',into=("NON",)),
      ITER_CONT_MAXI      =SIMP(statut='f',typ='I',defaut=30),
      CONTACT_INIT        =SIMP(statut='f',typ='TXM',defaut="NON",into=("OUI","NON",) ),
      ALGO_LAGR           =SIMP(statut='f',typ='TXM',defaut="VERSION1",into=("NON","VERSION1","VERSION2" , ) ),
      COEF_ECHELLE        =SIMP(statut='f',typ='R',defaut=1.E+6),
      b_frottement    =BLOC(condition = "FROTTEMENT == 'COULOMB' ",fr="Paramères du frottement de Coulomb",
           COULOMB        =SIMP(statut='o',typ='R',),
           ITER_FROT_MAXI =SIMP(statut='f',typ='I',defaut=2),
           COEF_REGU_FROT =SIMP(statut='f',typ='R',defaut=100.E+0),
           SEUIL_INIT     =SIMP(statut='f',typ='R',defaut=0.E+0),),
    ),
    INFO                  =SIMP(statut='f',typ='I',defaut= 1,into=(1,2,3,) ),
)  ;
#& MODIF COMMANDE  DATE 22/06/2005   AUTEUR REZETTE C.REZETTE 
#            CONFIGURATION MANAGEMENT OF EDF VERSION
# ======================================================================
# COPYRIGHT (C) 1991 - 2001  EDF R&D                  WWW.CODE-ASTER.ORG
# THIS PROGRAM IS FREE SOFTWARE; YOU CAN REDISTRIBUTE IT AND/OR MODIFY
# IT UNDER THE TERMS OF THE GNU GENERAL PUBLIC LICENSE AS PUBLISHED BY
# THE FREE SOFTWARE FOUNDATION; EITHER VERSION 2 OF THE LICENSE, OR   
# (AT YOUR OPTION) ANY LATER VERSION.                                 
#
# THIS PROGRAM IS DISTRIBUTED IN THE HOPE THAT IT WILL BE USEFUL, BUT 
# WITHOUT ANY WARRANTY; WITHOUT EVEN THE IMPLIED WARRANTY OF          
# MERCHANTABILITY OR FITNESS FOR A PARTICULAR PURPOSE. SEE THE GNU    
# GENERAL PUBLIC LICENSE FOR MORE DETAILS.                            
#
# YOU SHOULD HAVE RECEIVED A COPY OF THE GNU GENERAL PUBLIC LICENSE   
# ALONG WITH THIS PROGRAM; IF NOT, WRITE TO EDF R&D CODE_ASTER,       
#    1 AVENUE DU GENERAL DE GAULLE, 92141 CLAMART CEDEX, FRANCE.      
# ======================================================================
DEFI_FLUI_STRU=OPER(nom="DEFI_FLUI_STRU",op= 143,sd_prod=type_flui_stru,
                    reentrant='n',fr="Définit les caractéristiques nécessaires à l'étude dynamique d'une structure sous écoulement",
            UIinfo={"groupes":("Maillage",)},
         regles=(  UN_PARMI('FAISCEAU_TRANS','GRAPPE','FAISCEAU_AXIAL','COQUE_COAX',),),
         FAISCEAU_TRANS  =FACT(statut='f',max='**',
           regles=(  ENSEMBLE('CSTE_CONNORS','NB_CONNORS','RHO_TUBE'),),
           COUPLAGE        =SIMP(statut='f',typ='TXM',into=("OUI","NON") ),
           CARA_ELEM       =SIMP(statut='f',typ=cara_elem ),
           PROF_VITE_FLUI  =SIMP(statut='o',typ=(fonction_sdaster,nappe_sdaster,formule) ),
           PROF_RHO_F_INT  =SIMP(statut='f',typ=(fonction_sdaster,nappe_sdaster,formule) ),
           PROF_RHO_F_EXT  =SIMP(statut='f',typ=(fonction_sdaster,nappe_sdaster,formule) ),
           NOM_CMP         =SIMP(statut='f',typ='TXM',into=("DX","DY","DZ") ),
           COEF_MASS_AJOU  =SIMP(statut='f',typ='R' ),
           TYPE_PAS        =SIMP(statut='f',typ='TXM',into=("CARRE_LIGN","TRIA_LIGN") ),
           TYPE_RESEAU     =SIMP(statut='f',typ='I' ),
           UNITE_CD        =SIMP(statut='f',typ='I',defaut=70),
           UNITE_CK        =SIMP(statut='f',typ='I',defaut=71),            
           PAS             =SIMP(statut='f',typ='R' ),
           CSTE_CONNORS    =SIMP(statut='f',typ='R',min=2,max=2,val_min=0.E+00),
           NB_CONNORS      =SIMP(statut='f',typ='I',val_min=2,),
           RHO_TUBE        =SIMP(statut='f',typ='R' ),
         ),
         GRAPPE          =FACT(statut='f',
           regles=(ENSEMBLE('GRAPPE_2','NOEUD','CARA_ELEM','MODELE','RHO_FLUI',),
                   PRESENT_PRESENT('COEF_MASS_AJOU','GRAPPE_2', ),),
#  peut on créer un bloc a partir de la valeur de couplage  
           COUPLAGE        =SIMP(statut='o',typ='TXM',into=("OUI","NON") ),
           GRAPPE_2        =SIMP(statut='f',typ='TXM',
                                 into=("ASC_CEN","ASC_EXC","DES_CEN","DES_EXC") ),
           NOEUD           =SIMP(statut='f',typ=no),
           CARA_ELEM       =SIMP(statut='f',typ=cara_elem ),
           MODELE          =SIMP(statut='f',typ=modele_sdaster ),
           COEF_MASS_AJOU  =SIMP(statut='f',typ='R' ),
           RHO_FLUI        =SIMP(statut='f',typ='R' ),
           UNITE_CA        =SIMP(statut='f',typ='I',defaut=70),
           UNITE_KA        =SIMP(statut='f',typ='I',defaut=71),            
         ),
         FAISCEAU_AXIAL  =FACT(statut='f',max='**',
           regles=(UN_PARMI('GROUP_MA','TRI_GROUP_MA'),
                   UN_PARMI('CARA_ELEM','RAYON_TUBE'),
                   ENSEMBLE('RAYON_TUBE','COOR_TUBE'),
                   PRESENT_ABSENT('RAYON_TUBE','TRI_GROUP_MA'),
                   ENSEMBLE('CARA_PAROI','VALE_PAROI'),
                   ENSEMBLE('LONG_TYPG','LARG_TYPG','EPAI_TYPG','RUGO_TYPG','COEF_TRAI_TYPG','COEF_DPOR_TYPG',
                            'COOR_GRILLE','TYPE_GRILLE', ),),
#  on doit pouvoir mettre des blocs conditionnels mais pas assez d infos pour le faire                            
           GROUP_MA        =SIMP(statut='f',typ=grma,validators=NoRepeat(),max='**'),
           TRI_GROUP_MA    =SIMP(statut='f',typ='TXM' ),
           VECT_X          =SIMP(statut='f',typ='R',max=3),
           PROF_RHO_FLUI   =SIMP(statut='f',typ=(fonction_sdaster,nappe_sdaster,formule) ),
           PROF_VISC_CINE  =SIMP(statut='f',typ=(fonction_sdaster,nappe_sdaster,formule) ),
           CARA_ELEM       =SIMP(statut='f',typ=cara_elem ),
           RAYON_TUBE      =SIMP(statut='f',typ='R' ),
           COOR_TUBE       =SIMP(statut='f',typ='R',max='**'),
           PESANTEUR       =SIMP(statut='f',typ='R',min=4,max=4),
           RUGO_TUBE       =SIMP(statut='f',typ='R' ),
           CARA_PAROI      =SIMP(statut='f',typ='TXM',validators=NoRepeat(),max=5,
                                 into=("YC","ZC","R","HY","HZ") ),
           VALE_PAROI      =SIMP(statut='f',typ='R',max=5),
           ANGL_VRIL       =SIMP(statut='f',typ='R' ),
           LONG_TYPG       =SIMP(statut='f',typ='R',max='**',val_min=0.E+0),
           LARG_TYPG       =SIMP(statut='f',typ='R',max='**',val_min=0.E+0),
           EPAI_TYPG       =SIMP(statut='f',typ='R',max='**',val_min=0.E+0),
           RUGO_TYPG       =SIMP(statut='f',typ='R',max='**',val_min=0.E+0),
           COEF_TRAI_TYPG  =SIMP(statut='f',typ='R',max='**',val_min=0.E+0),
           COEF_DPOR_TYPG  =SIMP(statut='f',typ='R',max='**'),
           COOR_GRILLE     =SIMP(statut='f',typ='R',max='**'),
           TYPE_GRILLE     =SIMP(statut='f',typ='I',max='**'),
         ),
         COQUE_COAX      =FACT(statut='f',
           MASS_AJOU       =SIMP(statut='f',typ='TXM',defaut="OUI",into=("OUI","NON") ),
           GROUP_MA_INT    =SIMP(statut='o',typ=grma),
           GROUP_MA_EXT    =SIMP(statut='o',typ=grma),
           VECT_X          =SIMP(statut='o',typ='R',max='**'),
           CARA_ELEM       =SIMP(statut='o',typ=cara_elem ),
           MATER_INT       =SIMP(statut='o',typ=mater_sdaster ),
           MATER_EXT       =SIMP(statut='o',typ=mater_sdaster ),
           RHO_FLUI        =SIMP(statut='o',typ='R' ),
           VISC_CINE       =SIMP(statut='o',typ='R' ),
           RUGOSITE        =SIMP(statut='o',typ='R' ),
           PDC_MOY_1       =SIMP(statut='o',typ='R' ),
           PDC_DYN_1       =SIMP(statut='o',typ='R' ),
           PDC_MOY_2       =SIMP(statut='o',typ='R' ),
           PDC_DYN_2       =SIMP(statut='o',typ='R' ),
         ),
         INFO            =SIMP(statut='f',typ='I',defaut= 1,into=( 1 , 2) ),
)  ;
#& MODIF COMMANDE  DATE 22/06/2005   AUTEUR REZETTE C.REZETTE 
#            CONFIGURATION MANAGEMENT OF EDF VERSION
# ======================================================================
# COPYRIGHT (C) 1991 - 2001  EDF R&D                  WWW.CODE-ASTER.ORG
# THIS PROGRAM IS FREE SOFTWARE; YOU CAN REDISTRIBUTE IT AND/OR MODIFY
# IT UNDER THE TERMS OF THE GNU GENERAL PUBLIC LICENSE AS PUBLISHED BY
# THE FREE SOFTWARE FOUNDATION; EITHER VERSION 2 OF THE LICENSE, OR   
# (AT YOUR OPTION) ANY LATER VERSION.                                 
#
# THIS PROGRAM IS DISTRIBUTED IN THE HOPE THAT IT WILL BE USEFUL, BUT 
# WITHOUT ANY WARRANTY; WITHOUT EVEN THE IMPLIED WARRANTY OF          
# MERCHANTABILITY OR FITNESS FOR A PARTICULAR PURPOSE. SEE THE GNU    
# GENERAL PUBLIC LICENSE FOR MORE DETAILS.                            
#
# YOU SHOULD HAVE RECEIVED A COPY OF THE GNU GENERAL PUBLIC LICENSE   
# ALONG WITH THIS PROGRAM; IF NOT, WRITE TO EDF R&D CODE_ASTER,       
#    1 AVENUE DU GENERAL DE GAULLE, 92141 CLAMART CEDEX, FRANCE.      
# ======================================================================
DEFI_FONC_ELEC=OPER(nom="DEFI_FONC_ELEC",op=64,sd_prod=fonction_sdaster,reentrant='n',
            UIinfo={"groupes":("Outils métier",)},
                    fr="Définir une fonction du temps intervenant dans le calcul des forces de LAPLACE",
      regles=(UN_PARMI('COUR_PRIN','COUR'),
              EXCLUS('COUR','COUR_SECO'), ),
         FREQ            =SIMP(statut='f',typ='R',defaut= 50.),
         SIGNAL          =SIMP(statut='f',typ='TXM',defaut="COMPLET",into=("COMPLET","CONTINU") ),
         COUR            =FACT(statut='f',max='**',
         fr="Définition du courant de court-circuit",
           regles=(UN_PARMI('PHI_CC_1','INTC_CC_1'),
                   UN_PARMI('PHI_CC_2','INTC_CC_2'),),
           INTE_CC_1       =SIMP(statut='o',typ='R'),
           TAU_CC_1        =SIMP(statut='o',typ='R'),
           PHI_CC_1        =SIMP(statut='f',typ='R'),
           INTC_CC_1       =SIMP(statut='f',typ='R'),
           INTE_CC_2       =SIMP(statut='o',typ='R'),
           TAU_CC_2        =SIMP(statut='o',typ='R'),
           PHI_CC_2        =SIMP(statut='f',typ='R'),
           INTC_CC_2       =SIMP(statut='f',typ='R'),
           INST_CC_INIT    =SIMP(statut='o',typ='R'),
           INST_CC_FIN     =SIMP(statut='o',typ='R'),
         ),
         COUR_PRIN       =FACT(statut='f',
         fr="Définition du courant de court-circuit avec réenclenchement",
           regles=(UN_PARMI('PHI_CC_1','INTC_CC_1'),),
           INTE_CC_1       =SIMP(statut='o',typ='R'),
           TAU_CC_1        =SIMP(statut='o',typ='R'),
           PHI_CC_1        =SIMP(statut='f',typ='R'),
           INTC_CC_1       =SIMP(statut='f',typ='R'),
           INTE_RENC_1     =SIMP(statut='f',typ='R'),
           TAU_RENC_1      =SIMP(statut='f',typ='R'),
           PHI_RENC_1      =SIMP(statut='f',typ='R'),
           INST_CC_INIT    =SIMP(statut='o',typ='R'),
           INST_CC_FIN     =SIMP(statut='o',typ='R'),
           INST_RENC_INIT  =SIMP(statut='f',typ='R',defaut= 0.0E+0),
           INST_RENC_FIN   =SIMP(statut='f',typ='R',defaut= 0.0E+0),
         ),
         COUR_SECO       =FACT(statut='f',max='**',
         fr="Définition du courant de court-circuit avec un intervalle de temps différent de celui de COUR_PRIN",
           regles=(UN_PARMI('PHI_CC_2','INTC_CC_2'),),
           INTE_CC_2       =SIMP(statut='o',typ='R'),
           TAU_CC_2        =SIMP(statut='o',typ='R'),
           PHI_CC_2        =SIMP(statut='f',typ='R'),
           INTC_CC_2       =SIMP(statut='f',typ='R'),
           INTE_RENC_2     =SIMP(statut='f',typ='R'),
           TAU_RENC_2      =SIMP(statut='f',typ='R'),
           PHI_RENC_2      =SIMP(statut='f',typ='R'),
           DIST            =SIMP(statut='f',typ='R',defaut=1.0E+0),
         ),
         INFO            =SIMP(statut='f',typ='I',defaut=1,into=(1,2) ),
)  ;
#& MODIF COMMANDE  DATE 22/06/2005   AUTEUR REZETTE C.REZETTE 
#            CONFIGURATION MANAGEMENT OF EDF VERSION
# ======================================================================
# COPYRIGHT (C) 1991 - 2001  EDF R&D                  WWW.CODE-ASTER.ORG
# THIS PROGRAM IS FREE SOFTWARE; YOU CAN REDISTRIBUTE IT AND/OR MODIFY
# IT UNDER THE TERMS OF THE GNU GENERAL PUBLIC LICENSE AS PUBLISHED BY
# THE FREE SOFTWARE FOUNDATION; EITHER VERSION 2 OF THE LICENSE, OR   
# (AT YOUR OPTION) ANY LATER VERSION.                                 
#
# THIS PROGRAM IS DISTRIBUTED IN THE HOPE THAT IT WILL BE USEFUL, BUT 
# WITHOUT ANY WARRANTY; WITHOUT EVEN THE IMPLIED WARRANTY OF          
# MERCHANTABILITY OR FITNESS FOR A PARTICULAR PURPOSE. SEE THE GNU    
# GENERAL PUBLIC LICENSE FOR MORE DETAILS.                            
#
# YOU SHOULD HAVE RECEIVED A COPY OF THE GNU GENERAL PUBLIC LICENSE   
# ALONG WITH THIS PROGRAM; IF NOT, WRITE TO EDF R&D CODE_ASTER,       
#    1 AVENUE DU GENERAL DE GAULLE, 92141 CLAMART CEDEX, FRANCE.      
# ======================================================================
DEFI_FONC_FLUI=OPER(nom="DEFI_FONC_FLUI",op= 142,sd_prod=fonction_sdaster,
                    reentrant='n',
            fr="Définit un profil de vitesse d'écoulement fluide le long d'une poutre",
            UIinfo={"groupes":("Fonction",)},
         MAILLAGE        =SIMP(statut='o',typ=(maillage_sdaster) ),
         NOEUD_INIT      =SIMP(statut='o',typ=no),
         NOEUD_FIN       =SIMP(statut='o',typ=no),
         VITE            =FACT(statut='o',
           VALE            =SIMP(statut='f',typ='R',defaut= 1. ),
           PROFIL          =SIMP(statut='o',typ='TXM',into=("UNIFORME","LEONARD") ),
           NB_BAV          =SIMP(statut='f',typ='I',defaut= 0,into=( 0 , 2 , 3 ) ),
         ),
         INTERPOL        =SIMP(statut='f',typ='TXM',max=2,defaut="LIN",
                               into=("NON","LIN","LOG") ),
         PROL_DROITE     =SIMP(statut='f',typ='TXM',defaut="EXCLU",
                               into=("CONSTANT","LINEAIRE","EXCLU") ),
         PROL_GAUCHE     =SIMP(statut='f',typ='TXM' ,defaut="EXCLU",
                               into=("CONSTANT","LINEAIRE","EXCLU") ),
         INFO            =SIMP(statut='f',typ='I',defaut= 1,into=( 1 , 2 ) ),
         TITRE           =SIMP(statut='f',typ='TXM',max='**'),
)  ;
#& MODIF COMMANDE  DATE 22/06/2005   AUTEUR REZETTE C.REZETTE 
#            CONFIGURATION MANAGEMENT OF EDF VERSION
# ======================================================================
# COPYRIGHT (C) 1991 - 2001  EDF R&D                  WWW.CODE-ASTER.ORG
# THIS PROGRAM IS FREE SOFTWARE; YOU CAN REDISTRIBUTE IT AND/OR MODIFY
# IT UNDER THE TERMS OF THE GNU GENERAL PUBLIC LICENSE AS PUBLISHED BY
# THE FREE SOFTWARE FOUNDATION; EITHER VERSION 2 OF THE LICENSE, OR   
# (AT YOUR OPTION) ANY LATER VERSION.                                 
#
# THIS PROGRAM IS DISTRIBUTED IN THE HOPE THAT IT WILL BE USEFUL, BUT 
# WITHOUT ANY WARRANTY; WITHOUT EVEN THE IMPLIED WARRANTY OF          
# MERCHANTABILITY OR FITNESS FOR A PARTICULAR PURPOSE. SEE THE GNU    
# GENERAL PUBLIC LICENSE FOR MORE DETAILS.                            
#
# YOU SHOULD HAVE RECEIVED A COPY OF THE GNU GENERAL PUBLIC LICENSE   
# ALONG WITH THIS PROGRAM; IF NOT, WRITE TO EDF R&D CODE_ASTER,       
#    1 AVENUE DU GENERAL DE GAULLE, 92141 CLAMART CEDEX, FRANCE.      
# ======================================================================
# RESPONSABLE MCOURTOI M.COURTOIS
def defi_fonction_prod(VALE,VALE_PARA,VALE_C,NOEUD_PARA,**args):
  if VALE       != None  : return fonction_sdaster
  if VALE_C     != None  : return fonction_c
  if VALE_PARA  != None  : return fonction_sdaster
  if NOEUD_PARA != None  : return fonction_sdaster
  raise AsException("type de concept resultat non prevu")

DEFI_FONCTION=OPER(nom="DEFI_FONCTION",op=3,sd_prod=defi_fonction_prod
                    ,fr="Définit une fonction réelle ou complexe d'une variable réelle",
                     reentrant='n',
            UIinfo={"groupes":("Fonction",)},
         regles=(UN_PARMI('VALE','VALE_C','VALE_PARA','NOEUD_PARA'),),
         NOM_PARA        =SIMP(statut='o',typ='TXM',into=C_PARA_FONCTION() ),
         NOM_RESU        =SIMP(statut='f',typ='TXM',defaut="TOUTRESU"),
         VALE            =SIMP(statut='f',typ='R',min=2,max='**',
                               fr ="Fonction réelle définie par une liste de couples (abscisse,ordonnée)"),
         VALE_C          =SIMP(statut='f',typ='R',min=2,max='**',
                               fr ="Fonction complexe définie par une liste de couples"),
         VALE_PARA       =SIMP(statut='f',typ=listr8_sdaster,
                               fr ="Fonction réelle définie par deux concepts de type listr8" ),
         b_vale_para     =BLOC(condition = "VALE_PARA != None",
           VALE_FONC       =SIMP(statut='o',typ=listr8_sdaster ),
         ),
         NOEUD_PARA      =SIMP(statut='f',typ=no,max='**',
                               fr ="Fonction réelle définie par une liste de noeuds et un maillage"),
         b_noeud_para    =BLOC(condition = "NOEUD_PARA != None",
           MAILLAGE        =SIMP(statut='o',typ=maillage_sdaster ),
           VALE_Y          =SIMP(statut='o',typ='R',max='**'),
         ),

         INTERPOL        =SIMP(statut='f',typ='TXM',max=2,defaut="LIN",into=("NON","LIN","LOG") ),
         PROL_DROITE     =SIMP(statut='f',typ='TXM',defaut="EXCLU",into=("CONSTANT","LINEAIRE","EXCLU") ),
         PROL_GAUCHE     =SIMP(statut='f',typ='TXM',defaut="EXCLU",into=("CONSTANT","LINEAIRE","EXCLU") ),
         VERIF           =SIMP(statut='f',typ='TXM',defaut="CROISSANT",into=("CROISSANT","NON") ),
         INFO            =SIMP(statut='f',typ='I',defaut= 1,into=( 1 , 2) ),
         TITRE           =SIMP(statut='f',typ='TXM',max='**'),
)  ;
#& MODIF COMMANDE  DATE 09/05/2006   AUTEUR GALENNE E.GALENNE 
#            CONFIGURATION MANAGEMENT OF EDF VERSION
# ======================================================================
# COPYRIGHT (C) 1991 - 2001  EDF R&D                  WWW.CODE-ASTER.ORG
# THIS PROGRAM IS FREE SOFTWARE; YOU CAN REDISTRIBUTE IT AND/OR MODIFY
# IT UNDER THE TERMS OF THE GNU GENERAL PUBLIC LICENSE AS PUBLISHED BY
# THE FREE SOFTWARE FOUNDATION; EITHER VERSION 2 OF THE LICENSE, OR   
# (AT YOUR OPTION) ANY LATER VERSION.                                 
#
# THIS PROGRAM IS DISTRIBUTED IN THE HOPE THAT IT WILL BE USEFUL, BUT 
# WITHOUT ANY WARRANTY; WITHOUT EVEN THE IMPLIED WARRANTY OF          
# MERCHANTABILITY OR FITNESS FOR A PARTICULAR PURPOSE. SEE THE GNU    
# GENERAL PUBLIC LICENSE FOR MORE DETAILS.                            
#
# YOU SHOULD HAVE RECEIVED A COPY OF THE GNU GENERAL PUBLIC LICENSE   
# ALONG WITH THIS PROGRAM; IF NOT, WRITE TO EDF R&D CODE_ASTER,       
#    1 AVENUE DU GENERAL DE GAULLE, 92141 CLAMART CEDEX, FRANCE.      
# ======================================================================
DEFI_FOND_FISS=OPER(nom="DEFI_FOND_FISS",op=55,sd_prod=fond_fiss,reentrant='n',
            UIinfo={"groupes":("Post traitements",)},
                    fr="Définition de lèvres et d'un fond de fissure en 3D",
         regles=(UN_PARMI('FOND_FISS','FOND_FERME','FOND_INF'),
                 EXCLUS('FOND_FERME','DTAN_ORIG'),
                 EXCLUS('FOND_FERME','DTAN_EXTR'),
                      EXCLUS('FOND_FERME','VECT_GRNO_ORIG'),
                      EXCLUS('FOND_FERME','VECT_GRNO_EXTR'),
                 UN_PARMI('LEVRE_SUP','NORMALE'),
                      EXCLUS('LEVRE_INF','NORMALE'),
                 ENSEMBLE('DTAN_ORIG','DTAN_EXTR'),
                 ENSEMBLE('FOND_SUP','FOND_INF'),
                 EXCLUS('FOND_INF','FOND_FISS'),
                 EXCLUS('FOND_INF','FOND_FERME'),
                      ENSEMBLE('VECT_GRNO_ORIG','VECT_GRNO_EXTR'),
                      EXCLUS('DTAN_ORIG','VECT_GRNO_ORIG'),
                      EXCLUS('DTAN_EXTR','VECT_GRNO_EXTR') ,),
           MAILLAGE        =SIMP(statut='o',typ=maillage_sdaster ),
           FOND_FISS       =FACT(statut='f',
             regles=(UN_PARMI('GROUP_NO','NOEUD','GROUP_MA','MAILLE'),
                     EXCLUS('NOEUD_ORIG','GROUP_NO_ORIG'),
                          EXCLUS('NOEUD_EXTR','GROUP_NO_EXTR'),),
             GROUP_NO        =SIMP(statut='f',typ=grno,validators=NoRepeat(),max='**'),
             NOEUD           =SIMP(statut='f',typ=no  ,validators=NoRepeat(),max='**'),
             GROUP_MA        =SIMP(statut='f',typ=grma,validators=NoRepeat(),max='**'),
             MAILLE          =SIMP(statut='f',typ=ma  ,validators=NoRepeat(),max='**'),
#  à mettre à jour le max vaut-il 1  
             NOEUD_ORIG      =SIMP(statut='f',typ=no,),
             GROUP_NO_ORIG   =SIMP(statut='f',typ=grno,),
             NOEUD_EXTR      =SIMP(statut='f',typ=no,),
             GROUP_NO_EXTR   =SIMP(statut='f',typ=grno,),
           ),
           FOND_FERME      =FACT(statut='f',
             regles=(UN_PARMI('GROUP_NO','NOEUD','GROUP_MA','MAILLE'),
                          EXCLUS('NOEUD_ORIG','GROUP_NO_ORIG'),),
             GROUP_NO        =SIMP(statut='f',typ=grno,validators=NoRepeat(),max='**'),
             NOEUD           =SIMP(statut='f',typ=no  ,validators=NoRepeat(),max='**'),
             GROUP_MA        =SIMP(statut='f',typ=grma,validators=NoRepeat(),max='**'),
             MAILLE          =SIMP(statut='f',typ=ma  ,validators=NoRepeat(),max='**'),
             NOEUD_ORIG      =SIMP(statut='f',typ=no,),
             GROUP_NO_ORIG   =SIMP(statut='f',typ=grno,),
             MAILLE_ORIG     =SIMP(statut='f',typ=ma,),
             GROUP_MA_ORIG   =SIMP(statut='f',typ=ma,),
           ),
           FOND_INF       =FACT(statut='f',
             GROUP_NO        =SIMP(statut='f',typ=grno,validators=NoRepeat(),max='**'),
             NOEUD           =SIMP(statut='f',typ=no  ,validators=NoRepeat(),max='**'),
             GROUP_MA        =SIMP(statut='f',typ=grma,validators=NoRepeat(),max='**'),
             MAILLE          =SIMP(statut='f',typ=ma  ,validators=NoRepeat(),max='**'),
             NOEUD_ORIG      =SIMP(statut='f',typ=no,),
             GROUP_NO_ORIG   =SIMP(statut='f',typ=grno,),
             MAILLE_ORIG     =SIMP(statut='f',typ=ma,),
             GROUP_MA_ORIG   =SIMP(statut='f',typ=ma,),
           ),
           FOND_SUP       =FACT(statut='f',
             GROUP_NO        =SIMP(statut='f',typ=grno,validators=NoRepeat(),max='**'), 
             NOEUD           =SIMP(statut='f',typ=no  ,validators=NoRepeat(),max='**'),
             GROUP_MA        =SIMP(statut='f',typ=grma,validators=NoRepeat(),max='**'),
             MAILLE          =SIMP(statut='f',typ=ma  ,validators=NoRepeat(),max='**'),
             NOEUD_ORIG      =SIMP(statut='f',typ=no,),
             GROUP_NO_ORIG   =SIMP(statut='f',typ=grno,),
             MAILLE_ORIG     =SIMP(statut='f',typ=ma,),
             GROUP_MA_ORIG   =SIMP(statut='f',typ=ma,),
           ),
           LEVRE_SUP       =FACT(statut='f',
             regles=(UN_PARMI('GROUP_MA','MAILLE'),),
             GROUP_MA        =SIMP(statut='f',typ=grma,validators=NoRepeat(),max='**'),
             MAILLE          =SIMP(statut='f',typ=ma  ,validators=NoRepeat(),max='**'),
           ),
           LEVRE_INF       =FACT(statut='f',
             regles=(UN_PARMI('GROUP_MA','MAILLE', ),),
             GROUP_MA        =SIMP(statut='f',typ=grma,validators=NoRepeat(),max='**'),
             MAILLE          =SIMP(statut='f',typ=ma  ,validators=NoRepeat(),max='**'),
           ),
           NORMALE         =SIMP(statut='f',typ='R',max='**'),
           PREC_NORM       =SIMP(statut='f',typ='R',defaut=0.1),
           DTAN_ORIG       =SIMP(statut='f',typ='R',max='**'),
           DTAN_EXTR       =SIMP(statut='f',typ='R',max='**'),
           VECT_GRNO_ORIG  =SIMP(statut='f',typ=grno,validators=NoRepeat(),max=2),
           VECT_GRNO_EXTR  =SIMP(statut='f',typ=grno,validators=NoRepeat(),max=2),
           INFO            =SIMP(statut='f',typ='I',defaut=1,into=(1,2) ),
)  ;
#& MODIF COMMANDE  DATE 04/07/2005   AUTEUR REZETTE C.REZETTE 
#            CONFIGURATION MANAGEMENT OF EDF VERSION
# ======================================================================
# COPYRIGHT (C) 1991 - 2001  EDF R&D                  WWW.CODE-ASTER.ORG
# THIS PROGRAM IS FREE SOFTWARE; YOU CAN REDISTRIBUTE IT AND/OR MODIFY
# IT UNDER THE TERMS OF THE GNU GENERAL PUBLIC LICENSE AS PUBLISHED BY
# THE FREE SOFTWARE FOUNDATION; EITHER VERSION 2 OF THE LICENSE, OR
# (AT YOUR OPTION) ANY LATER VERSION.
#
# THIS PROGRAM IS DISTRIBUTED IN THE HOPE THAT IT WILL BE USEFUL, BUT
# WITHOUT ANY WARRANTY; WITHOUT EVEN THE IMPLIED WARRANTY OF
# MERCHANTABILITY OR FITNESS FOR A PARTICULAR PURPOSE. SEE THE GNU
# GENERAL PUBLIC LICENSE FOR MORE DETAILS.
#
# YOU SHOULD HAVE RECEIVED A COPY OF THE GNU GENERAL PUBLIC LICENSE
# ALONG WITH THIS PROGRAM; IF NOT, WRITE TO EDF R&D CODE_ASTER,
#    1 AVENUE DU GENERAL DE GAULLE, 92141 CLAMART CEDEX, FRANCE.
# ======================================================================
# RESPONSABLE VABHHTS J.PELLET
def defi_group_prod(MAILLAGE,**args):
  if AsType(MAILLAGE) == maillage_sdaster : return maillage_sdaster
  if AsType(MAILLAGE) == squelette : return squelette
  raise AsException("type de concept resultat non prevu")

DEFI_GROUP=OPER(nom="DEFI_GROUP",op= 104,sd_prod=defi_group_prod,
                fr="Définition de nouveaux groupes de noeuds et/ou de mailles dans un concept maillage",
                reentrant='o',
            UIinfo={"groupes":("Maillage",)},
         regles=(AU_MOINS_UN('CREA_GROUP_MA','CREA_GROUP_NO','DETR_GROUP_NO','DETR_GROUP_MA'),),
         MAILLAGE        =SIMP(statut='o',typ=(maillage_sdaster,squelette) ),
         DETR_GROUP_MA   =FACT(statut='f',max='**',
           NOM             =SIMP(statut='o',typ=grma,validators=NoRepeat(),max='**'),),
         DETR_GROUP_NO   =FACT(statut='f',max='**',
           NOM             =SIMP(statut='o',typ=grno,validators=NoRepeat(),max='**'),),
         CREA_GROUP_MA   =FACT(statut='f',max='**',

regles=(UN_PARMI('TOUT','GROUP_MA','MAILLE','INTERSEC','UNION','DIFFE','OPTION'),),
#  quel est le concept attendu deriere NOM
           NOM             =SIMP(statut='o',typ=grma),
           TOUT            =SIMP(statut='f',typ='TXM',into=("OUI",) ),
           GROUP_MA        =SIMP(statut='f',typ=grma),
           MAILLE          =SIMP(statut='f',typ=ma  ,validators=NoRepeat(),max='**'),
           INTERSEC        =SIMP(statut='f',typ=grma,validators=NoRepeat(),max='**'),
           UNION           =SIMP(statut='f',typ=grma,validators=NoRepeat(),max='**'),
           DIFFE           =SIMP(statut='f',typ=grma,validators=NoRepeat(),max='**'),
           OPTION          =SIMP(statut='f',typ='TXM',into=("FACE_NORMALE","SPHERE","CYLINDRE","BANDE","APPUI_LACHE") ),
           b_group_ma      =BLOC(condition = "GROUP_MA != None",
             regles=(EXCLUS('POSITION','NUME_INIT'),),
             NUME_INIT       =SIMP(statut='f',typ='I'),
             POSITION        =SIMP(statut='f',typ='TXM',into=("INIT","FIN","MILIEU") ),
             b_nume_init   =BLOC(condition = "NUME_INIT != None",
               NUME_FIN        =SIMP(statut='f',typ='I' ),
             ),
           ),
           b_face_normale  =BLOC(condition = "OPTION == 'FACE_NORMALE'",
             regles=(UN_PARMI('ANGL_NAUT','VECT_NORMALE'),),
             ANGL_NAUT       =SIMP(statut='f',typ='R',max=2),
             VECT_NORMALE    =SIMP(statut='f',typ='R',max=3),
             ANGL_PREC       =SIMP(statut='f',typ='R',defaut= 0.5 ),
             VERI_SIGNE      =SIMP(statut='f',typ='TXM',defaut="OUI",into=("OUI","NON") ),
           ),
           b_sphere        =BLOC(condition = "OPTION == 'SPHERE'",
             regles=(UN_PARMI('POINT','NOEUD_CENTRE','GROUP_NO_CENTRE'),),
             POINT           =SIMP(statut='f',typ='R',max=3),
             NOEUD_CENTRE    =SIMP(statut='f',typ=no),
             GROUP_NO_CENTRE =SIMP(statut='f',typ=grno),
             RAYON           =SIMP(statut='o',typ='R' ),
           ),
           b_cylindre      =BLOC(condition = "OPTION == 'CYLINDRE'",
             regles=(UN_PARMI('POINT','NOEUD_CENTRE','GROUP_NO_CENTRE'),
                     UN_PARMI('ANGL_NAUT','VECT_NORMALE'),),
             POINT           =SIMP(statut='f',typ='R',max=3),
             NOEUD_CENTRE    =SIMP(statut='f',typ=no),
             GROUP_NO_CENTRE =SIMP(statut='f',typ=grno),
             RAYON           =SIMP(statut='o',typ='R' ),
             ANGL_NAUT       =SIMP(statut='f',typ='R',max=2),
             VECT_NORMALE    =SIMP(statut='f',typ='R',max=3),
           ),
           b_bande         =BLOC(condition = "OPTION == 'BANDE'",
             regles=(UN_PARMI('POINT','NOEUD_CENTRE','GROUP_NO_CENTRE'),
                     UN_PARMI('ANGL_NAUT','VECT_NORMALE'),),
             POINT           =SIMP(statut='f',typ='R' ,max=3),
             NOEUD_CENTRE    =SIMP(statut='f',typ=no  ,validators=NoRepeat(),max=1),
             GROUP_NO_CENTRE =SIMP(statut='f',typ=grno,validators=NoRepeat(),max=1),
             DIST            =SIMP(statut='o',typ='R' ),
             ANGL_NAUT       =SIMP(statut='f',typ='R',max=2),
             VECT_NORMALE    =SIMP(statut='f',typ='R',max=3),
           ),
           b_app_lache         =BLOC(condition = "OPTION == 'APPUI_LACHE'",
             regles=(UN_PARMI('NOEUD','GROUP_NO'),),
             NOEUD           =SIMP(statut='f',typ=no  ,validators=NoRepeat(),max='**'),
             GROUP_NO        =SIMP(statut='f',typ=grno,validators=NoRepeat(),max='**'),
           ),
         ),
         CREA_GROUP_NO   =FACT(statut='f',max='**',
           OPTION          =SIMP(statut='f',typ='TXM',into=("ENV_SPHERE","ENV_CYLINDRE","PLAN",
                                               "SEGM_DROI_ORDO","NOEUD_ORDO","TUNNEL") ),

           b_option =BLOC(condition = "OPTION == None" ,
                          regles=(UN_PARMI('TOUT_GROUP_MA','GROUP_MA','GROUP_NO','NOEUD',
                                                           'INTERSEC','UNION','DIFFE'),),
              TOUT_GROUP_MA   =SIMP(statut='f',typ='TXM',into=("OUI",) ),
              GROUP_MA        =SIMP(statut='f',typ=grma,validators=NoRepeat(),max='**'),
              GROUP_NO        =SIMP(statut='f',typ=grno,validators=NoRepeat(),max='**'),
              NOEUD           =SIMP(statut='f',typ=no  ,validators=NoRepeat(),max='**'),
              INTERSEC        =SIMP(statut='f',typ=grno,validators=NoRepeat(),max='**'),
              UNION           =SIMP(statut='f',typ=grno,validators=NoRepeat(),max='**'),
              DIFFE           =SIMP(statut='f',typ=grno,validators=NoRepeat(),max='**'),

              b_nom_group_ma  =BLOC(condition = "GROUP_MA != None",
                NOM           = SIMP(statut='f',typ=grma,validators=NoRepeat(),max='**'),
                CRIT_NOEUD    = SIMP(statut='f',typ='TXM',defaut="TOUS",
                                  into=("TOUS","SOMMET","MILIEU","CENTRE"),),
              ),
              b_group_no      =BLOC(condition = "GROUP_NO != None",
                                    regles=(EXCLUS('POSITION','NUME_INIT'),),
                NUME_INIT       =SIMP(statut='f',typ='I'),
                POSITION        =SIMP(statut='f',typ='TXM',into=("INIT","FIN","MILIEU") ),
                b_nume_init     =BLOC(condition = "NUME_INIT != None",
                  NUME_FIN        =SIMP(statut='f',typ='I' ),
                ),
              ),
              b_nom =BLOC(condition = "GROUP_MA == None and TOUT_GROUP_MA == None" ,
                NOM             =SIMP(statut='o',typ=geom),
              ),
           ),

           b_env_sphere    =BLOC(condition = "OPTION == 'ENV_SPHERE'",
             regles=(UN_PARMI('POINT','NOEUD_CENTRE','GROUP_NO_CENTRE'),),
             NOM             =SIMP(statut='o',typ=geom),
             POINT           =SIMP(statut='f',typ='R' ,max=3),
             NOEUD_CENTRE    =SIMP(statut='f',typ=no  ,validators=NoRepeat(),max=1),
             GROUP_NO_CENTRE =SIMP(statut='f',typ=grno,validators=NoRepeat(),max=1),
             RAYON           =SIMP(statut='o',typ='R' ),
             PRECISION       =SIMP(statut='o',typ='R' ),
           ),
           b_env_cylindre  =BLOC(condition = "OPTION == 'ENV_CYLINDRE'",
             regles=(UN_PARMI('POINT','NOEUD_CENTRE','GROUP_NO_CENTRE'),
                     UN_PARMI('ANGL_NAUT','VECT_NORMALE'),),
             NOM             =SIMP(statut='o',typ=geom),
             POINT           =SIMP(statut='f',typ='R' ,max=3),
             NOEUD_CENTRE    =SIMP(statut='f',typ=no  ,validators=NoRepeat(),max=1),
             GROUP_NO_CENTRE =SIMP(statut='f',typ=grno,validators=NoRepeat(),max=1),
             RAYON           =SIMP(statut='o',typ='R' ),
             ANGL_NAUT       =SIMP(statut='f',typ='R',max=3),
             VECT_NORMALE    =SIMP(statut='f',typ='R',max=3),
             PRECISION       =SIMP(statut='o',typ='R' ),
           ),
           b_env_plan      =BLOC(condition = "OPTION == 'PLAN'",
             regles=(UN_PARMI('POINT','NOEUD_CENTRE','GROUP_NO_CENTRE'),
                     UN_PARMI('ANGL_NAUT','VECT_NORMALE'),),
             NOM             =SIMP(statut='o',typ=geom),
             POINT           =SIMP(statut='f',typ='R' ,max=3),
             NOEUD_CENTRE    =SIMP(statut='f',typ=no  ,validators=NoRepeat(),max=1),
             GROUP_NO_CENTRE =SIMP(statut='f',typ=grno,validators=NoRepeat(),max=1),
             ANGL_NAUT       =SIMP(statut='f',typ='R' ,max=3),
             VECT_NORMALE    =SIMP(statut='f',typ='R' ,max=3),
             PRECISION       =SIMP(statut='o',typ='R' ),
           ),
           b_segm_droi_ordo=BLOC(condition = "OPTION == 'SEGM_DROI_ORDO'",
             regles=(AU_MOINS_UN('NOEUD','GROUP_NO'),
                     UN_PARMI('NOEUD_ORIG','GROUP_NO_ORIG'),
                     UN_PARMI('NOEUD_EXTR','GROUP_NO_EXTR'),),
             NOM             =SIMP(statut='o',typ=geom),
             NOEUD           =SIMP(statut='f',typ=no  ,validators=NoRepeat(),max='**'),
             GROUP_NO        =SIMP(statut='f',typ=grno,validators=NoRepeat(),max='**'),
             NOEUD_ORIG      =SIMP(statut='f',typ=no),
             GROUP_NO_ORIG   =SIMP(statut='f',typ=grno),
             NOEUD_EXTR      =SIMP(statut='f',typ=no),
             GROUP_NO_EXTR   =SIMP(statut='f',typ=grno),
             PRECISION       =SIMP(statut='o',typ='R' ),
             CRITERE         =SIMP(statut='o',typ='TXM',into=("ABSOLU","RELATIF") ),
           ),
           b_noeud_ordo    =BLOC(condition = "OPTION == 'NOEUD_ORDO'",
             regles=(EXCLUS('NOEUD_ORIG','GROUP_NO_ORIG'),
                     EXCLUS('NOEUD_EXTR','GROUP_NO_EXTR'),),
             NOM             =SIMP(statut='o',typ=geom),
             GROUP_MA        =SIMP(statut='o',typ=grma,validators=NoRepeat(),max='**'),
             NOEUD_ORIG      =SIMP(statut='f',typ=no),
             GROUP_NO_ORIG   =SIMP(statut='f',typ=grno),
             NOEUD_EXTR      =SIMP(statut='f',typ=no),
             GROUP_NO_EXTR   =SIMP(statut='f',typ=grno),
           ),
           b_tunnel    =BLOC(condition = "OPTION == 'TUNNEL'",
             regles=(AU_MOINS_UN ('TOUT','GROUP_MA','MAILLE'),
                     EXCLUS('NOEUD_ORIG','GROUP_NO_ORIG'),
                     AU_MOINS_UN ('GROUP_MA_AXE','MAILLE_AXE'),),
             NOM             =SIMP(statut='o',typ=geom),
             TOUT            =SIMP(statut='f',typ='TXM',into=("OUI",) ),
             GROUP_MA        =SIMP(statut='f',typ=grma,validators=NoRepeat(),max='**'),
             MAILLE          =SIMP(statut='f',typ=ma  ,validators=NoRepeat(),max='**'),
             GROUP_MA_AXE    =SIMP(statut='f',typ=grma,validators=NoRepeat(),max='**'),
             MAILLE_AXE      =SIMP(statut='f',typ=ma  ,validators=NoRepeat(),max='**'),
             NOEUD_ORIG      =SIMP(statut='f',typ=no),
             GROUP_NO_ORIG   =SIMP(statut='f',typ=grno),
             RAYON           =SIMP(statut='o',typ='R'),
             LONGUEUR        =SIMP(statut='f',typ='R'),
           ),
         ),
         ALARME          =SIMP(statut='f',typ='TXM',defaut="OUI",into=("OUI","NON") ),
         INFO            =SIMP(statut='f',typ='I',into=( 1 , 2 ) ),
)  ;
#& MODIF COMMANDE  DATE 26/06/2006   AUTEUR CIBHHLV L.VIVAN 
#            CONFIGURATION MANAGEMENT OF EDF VERSION
# ======================================================================
# COPYRIGHT (C) 1991 - 2001  EDF R&D                  WWW.CODE-ASTER.ORG
# THIS PROGRAM IS FREE SOFTWARE; YOU CAN REDISTRIBUTE IT AND/OR MODIFY
# IT UNDER THE TERMS OF THE GNU GENERAL PUBLIC LICENSE AS PUBLISHED BY
# THE FREE SOFTWARE FOUNDATION; EITHER VERSION 2 OF THE LICENSE, OR   
# (AT YOUR OPTION) ANY LATER VERSION.                                 
#
# THIS PROGRAM IS DISTRIBUTED IN THE HOPE THAT IT WILL BE USEFUL, BUT 
# WITHOUT ANY WARRANTY; WITHOUT EVEN THE IMPLIED WARRANTY OF          
# MERCHANTABILITY OR FITNESS FOR A PARTICULAR PURPOSE. SEE THE GNU    
# GENERAL PUBLIC LICENSE FOR MORE DETAILS.                            
#
# YOU SHOULD HAVE RECEIVED A COPY OF THE GNU GENERAL PUBLIC LICENSE   
# ALONG WITH THIS PROGRAM; IF NOT, WRITE TO EDF R&D CODE_ASTER,       
#    1 AVENUE DU GENERAL DE GAULLE, 92141 CLAMART CEDEX, FRANCE.      
# ======================================================================
DEFI_INTERF_DYNA=OPER(nom="DEFI_INTERF_DYNA",op=  98,sd_prod=interf_dyna_clas,
                      reentrant='n',
            UIinfo={"groupes":("Matrices/vecteurs",)},
            fr="Définir les interfaces d'une structure et leur affecter un type",
         NUME_DDL        =SIMP(statut='o',typ=nume_ddl_sdaster ),
         INTERFACE       =FACT(statut='o',max='**',
           regles=(ENSEMBLE('NOM','TYPE'),
#  erreur doc U sur la condition qui suit
                   UN_PARMI('NOEUD','GROUP_NO'),),
           NOM             =SIMP(statut='f',typ='TXM' ),
           TYPE            =SIMP(statut='f',typ='TXM',into=("MNEAL","CRAIGB","CB_HARMO","AUCUN") ),
           NOEUD           =SIMP(statut='f',typ=no,max='**'),
           GROUP_NO        =SIMP(statut='f',typ=grno,max='**'),
#           DDL_ACTIF       =SIMP(statut='f',typ='TXM',max='**'),
           MASQUE          =SIMP(statut='f',typ='TXM',max='**'),
         ),
         FREQ            =SIMP(statut='f',typ='R',defaut= 1.),
         INFO            =SIMP(statut='f',typ='I',defaut= 1,into=( 1 , 2) ),
)  ;
#& MODIF COMMANDE  DATE 10/10/2006   AUTEUR MCOURTOI M.COURTOIS 
#            CONFIGURATION MANAGEMENT OF EDF VERSION
# ======================================================================
# COPYRIGHT (C) 1991 - 2001  EDF R&D                  WWW.CODE-ASTER.ORG
# THIS PROGRAM IS FREE SOFTWARE; YOU CAN REDISTRIBUTE IT AND/OR MODIFY
# IT UNDER THE TERMS OF THE GNU GENERAL PUBLIC LICENSE AS PUBLISHED BY
# THE FREE SOFTWARE FOUNDATION; EITHER VERSION 2 OF THE LICENSE, OR   
# (AT YOUR OPTION) ANY LATER VERSION.                                 
#
# THIS PROGRAM IS DISTRIBUTED IN THE HOPE THAT IT WILL BE USEFUL, BUT 
# WITHOUT ANY WARRANTY; WITHOUT EVEN THE IMPLIED WARRANTY OF          
# MERCHANTABILITY OR FITNESS FOR A PARTICULAR PURPOSE. SEE THE GNU    
# GENERAL PUBLIC LICENSE FOR MORE DETAILS.                            
#
# YOU SHOULD HAVE RECEIVED A COPY OF THE GNU GENERAL PUBLIC LICENSE   
# ALONG WITH THIS PROGRAM; IF NOT, WRITE TO EDF R&D CODE_ASTER,       
#    1 AVENUE DU GENERAL DE GAULLE, 92141 CLAMART CEDEX, FRANCE.      
# ======================================================================
from Macro.defi_inte_spec_ops import defi_inte_spec_ops

DEFI_INTE_SPEC=MACRO(nom="DEFI_INTE_SPEC",op= defi_inte_spec_ops,sd_prod=table_fonction,
                     reentrant='n',
                     fr="Définit une matrice interspectrale",
                     UIinfo={"groupes":("Fonction",)},

         DIMENSION       =SIMP(statut='f',typ='I',defaut= 1 ),

         PAR_FONCTION    =FACT(statut='f',max='**',
           NUME_ORDRE_I    =SIMP(statut='o',typ='I' ),
           NUME_ORDRE_J    =SIMP(statut='o',typ='I' ),
           FONCTION        =SIMP(statut='o',typ=fonction_c ),
         ),
         KANAI_TAJIMI    =FACT(statut='f',max='**',
           regles=(EXCLUS('VALE_R','VALE_C'),),
           NUME_ORDRE_I    =SIMP(statut='o',typ='I' ),
           NUME_ORDRE_J    =SIMP(statut='o',typ='I' ),
           FREQ_MIN        =SIMP(statut='f',typ='R',defaut= 0.E+0 ),
           FREQ_MAX        =SIMP(statut='f',typ='R',defaut= 100. ),
           PAS             =SIMP(statut='f',typ='R',defaut= 1. ),
           AMOR_REDUIT     =SIMP(statut='f',typ='R',defaut= 0.6 ),
           FREQ_MOY        =SIMP(statut='f',typ='R',defaut= 5. ),
           VALE_R          =SIMP(statut='f',typ='R' ),
           VALE_C          =SIMP(statut='f',typ='C' ),
           INTERPOL        =SIMP(statut='f',typ='TXM',max=2,defaut="LIN",into=("NON","LIN","LOG") ),
           PROL_DROITE     =SIMP(statut='f',typ='TXM',defaut="EXCLU",into=("CONSTANT","LINEAIRE","EXCLU") ),
           PROL_GAUCHE     =SIMP(statut='f',typ='TXM',defaut="EXCLU",into=("CONSTANT","LINEAIRE","EXCLU") ),
         ),
         CONSTANT        =FACT(statut='f',max='**',
           regles=(EXCLUS('VALE_R','VALE_C'),),
           NUME_ORDRE_I    =SIMP(statut='o',typ='I' ),
           NUME_ORDRE_J    =SIMP(statut='o',typ='I' ),
           FREQ_MIN        =SIMP(statut='f',typ='R',defaut= 0.E+0 ),
           FREQ_MAX        =SIMP(statut='f',typ='R',defaut= 100. ),
           PAS             =SIMP(statut='f',typ='R',defaut= 1. ),
           VALE_R          =SIMP(statut='f',typ='R' ),
           VALE_C          =SIMP(statut='f',typ='C' ),
           INTERPOL        =SIMP(statut='f',typ='TXM',max=2,defaut="LIN",into=("NON","LIN","LOG") ),
           PROL_DROITE     =SIMP(statut='f',typ='TXM',defaut="EXCLU",into=("CONSTANT","LINEAIRE","EXCLU") ),
           PROL_GAUCHE     =SIMP(statut='f',typ='TXM',defaut="EXCLU",into=("CONSTANT","LINEAIRE","EXCLU") ),
         ),
         TITRE           =SIMP(statut='f',typ='TXM',max='**'),
         INFO            =SIMP(statut='f',typ='I',defaut= 1,into=( 1 , 2) ),               
)  ;
#& MODIF COMMANDE  DATE 22/06/2005   AUTEUR REZETTE C.REZETTE 
#            CONFIGURATION MANAGEMENT OF EDF VERSION
# ======================================================================
# COPYRIGHT (C) 1991 - 2001  EDF R&D                  WWW.CODE-ASTER.ORG
# THIS PROGRAM IS FREE SOFTWARE; YOU CAN REDISTRIBUTE IT AND/OR MODIFY
# IT UNDER THE TERMS OF THE GNU GENERAL PUBLIC LICENSE AS PUBLISHED BY
# THE FREE SOFTWARE FOUNDATION; EITHER VERSION 2 OF THE LICENSE, OR   
# (AT YOUR OPTION) ANY LATER VERSION.                                 
#
# THIS PROGRAM IS DISTRIBUTED IN THE HOPE THAT IT WILL BE USEFUL, BUT 
# WITHOUT ANY WARRANTY; WITHOUT EVEN THE IMPLIED WARRANTY OF          
# MERCHANTABILITY OR FITNESS FOR A PARTICULAR PURPOSE. SEE THE GNU    
# GENERAL PUBLIC LICENSE FOR MORE DETAILS.                            
#
# YOU SHOULD HAVE RECEIVED A COPY OF THE GNU GENERAL PUBLIC LICENSE   
# ALONG WITH THIS PROGRAM; IF NOT, WRITE TO EDF R&D CODE_ASTER,       
#    1 AVENUE DU GENERAL DE GAULLE, 92141 CLAMART CEDEX, FRANCE.      
# ======================================================================
# RESPONSABLE VABHHTS J.PELLET
DEFI_LIST_ENTI=OPER(nom="DEFI_LIST_ENTI",op=22,sd_prod=listis_sdaster,
                    fr="Définir une liste d'entier strictement croissante",
                    reentrant='n',
            UIinfo={"groupes":("Fonction",)},
         regles=(UN_PARMI('VALE','DEBUT'),
                 EXCLUS('VALE','INTERVALLE'),),
         VALE            =SIMP(statut='f',typ='I',max='**'),
         DEBUT           =SIMP(statut='f',typ='I'),
         INTERVALLE      =FACT(statut='f',max='**',
           regles=(UN_PARMI('NOMBRE','PAS'),),
           JUSQU_A         =SIMP(statut='o',typ='I'),
           NOMBRE          =SIMP(statut='f',typ='I',val_min=1,),
           PAS             =SIMP(statut='f',typ='I',val_min=1,),
         ),
         INFO            =SIMP(statut='f',typ='I',defaut=1,into=(1,2)),
         TITRE           =SIMP(statut='f',typ='TXM',max='**'),
)  ;
#& MODIF COMMANDE  DATE 22/06/2005   AUTEUR REZETTE C.REZETTE 
#            CONFIGURATION MANAGEMENT OF EDF VERSION
# ======================================================================
# COPYRIGHT (C) 1991 - 2001  EDF R&D                  WWW.CODE-ASTER.ORG
# THIS PROGRAM IS FREE SOFTWARE; YOU CAN REDISTRIBUTE IT AND/OR MODIFY
# IT UNDER THE TERMS OF THE GNU GENERAL PUBLIC LICENSE AS PUBLISHED BY
# THE FREE SOFTWARE FOUNDATION; EITHER VERSION 2 OF THE LICENSE, OR   
# (AT YOUR OPTION) ANY LATER VERSION.                                 
#
# THIS PROGRAM IS DISTRIBUTED IN THE HOPE THAT IT WILL BE USEFUL, BUT 
# WITHOUT ANY WARRANTY; WITHOUT EVEN THE IMPLIED WARRANTY OF          
# MERCHANTABILITY OR FITNESS FOR A PARTICULAR PURPOSE. SEE THE GNU    
# GENERAL PUBLIC LICENSE FOR MORE DETAILS.                            
#
# YOU SHOULD HAVE RECEIVED A COPY OF THE GNU GENERAL PUBLIC LICENSE   
# ALONG WITH THIS PROGRAM; IF NOT, WRITE TO EDF R&D CODE_ASTER,       
#    1 AVENUE DU GENERAL DE GAULLE, 92141 CLAMART CEDEX, FRANCE.      
# ======================================================================
# RESPONSABLE VABHHTS J.PELLET
DEFI_LIST_REEL=OPER(nom="DEFI_LIST_REEL",op=24,sd_prod=listr8_sdaster,
                    fr="Définir une liste de réels strictement croissante",
                    reentrant='n',
            UIinfo={"groupes":("Fonction",)},
         regles=(UN_PARMI('VALE','DEBUT',),
                 EXCLUS('VALE','INTERVALLE'),
                 ENSEMBLE('DEBUT','INTERVALLE')),
         VALE            =SIMP(statut='f',typ='R',max='**'),
         DEBUT           =SIMP(statut='f',typ='R'),
         INTERVALLE      =FACT(statut='f',max='**',
           regles=(UN_PARMI('NOMBRE','PAS'),),
           JUSQU_A         =SIMP(statut='o',typ='R'),
           NOMBRE          =SIMP(statut='f',typ='I'),
           PAS             =SIMP(statut='f',typ='R'),
         ),
         INFO            =SIMP(statut='f',typ='I',defaut=1,into=(1,2)),
         TITRE           =SIMP(statut='f',typ='TXM',max='**'),
)  ;
#& MODIF COMMANDE  DATE 31/10/2006   AUTEUR A3BHHAE H.ANDRIAMBOLOLONA 
#            CONFIGURATION MANAGEMENT OF EDF VERSION
# ======================================================================
# COPYRIGHT (C) 1991 - 2001  EDF R&D                  WWW.CODE-ASTER.ORG
# THIS PROGRAM IS FREE SOFTWARE; YOU CAN REDISTRIBUTE IT AND/OR MODIFY
# IT UNDER THE TERMS OF THE GNU GENERAL PUBLIC LICENSE AS PUBLISHED BY
# THE FREE SOFTWARE FOUNDATION; EITHER VERSION 2 OF THE LICENSE, OR   
# (AT YOUR OPTION) ANY LATER VERSION.                                 
#
# THIS PROGRAM IS DISTRIBUTED IN THE HOPE THAT IT WILL BE USEFUL, BUT 
# WITHOUT ANY WARRANTY; WITHOUT EVEN THE IMPLIED WARRANTY OF          
# MERCHANTABILITY OR FITNESS FOR A PARTICULAR PURPOSE. SEE THE GNU    
# GENERAL PUBLIC LICENSE FOR MORE DETAILS.                            
#
# YOU SHOULD HAVE RECEIVED A COPY OF THE GNU GENERAL PUBLIC LICENSE   
# ALONG WITH THIS PROGRAM; IF NOT, WRITE TO EDF R&D CODE_ASTER,       
#    1 AVENUE DU GENERAL DE GAULLE, 92141 CLAMART CEDEX, FRANCE.      
# ======================================================================
# RESPONSABLE VABHHTS J.PELLET
DEFI_MAILLAGE=OPER(nom="DEFI_MAILLAGE",op=  88,sd_prod=maillage_sdaster,
                   fr="Définition d'un nouveau maillage à partir de macro-éléments",
                   reentrant='n',
            UIinfo={"groupes":("Maillage",)},
         DEFI_SUPER_MAILLE =FACT(statut='o',max='**',
           MACR_ELEM_STAT  =SIMP(statut='o',typ=macr_elem_stat,max='**' ),
           SUPER_MAILLE    =SIMP(statut='f',typ=ma,max='**'),
           TRAN            =SIMP(statut='f',typ='R',max=3),
           ANGL_NAUT       =SIMP(statut='f',typ='R',max=3),
           b_angl_naut     =BLOC(condition = "ANGL_NAUT != None",
             CENTRE          =SIMP(statut='f',typ='R',max=3),
           ),
         ),
         RECO_GLOBAL     =FACT(statut='f',max='**',
           regles=(UN_PARMI('TOUT','SUPER_MAILLE'),),
           TOUT            =SIMP(statut='f',typ='TXM',into=("OUI",) ),
           SUPER_MAILLE    =SIMP(statut='f',typ=ma,max='**'),
           CRITERE         =SIMP(statut='f',typ='TXM',defaut="RELATIF",into=("RELATIF","ABSOLU") ),
           PRECISION       =SIMP(statut='f',typ='R',defaut= 1.E-3 ),
         ),
         RECO_SUPER_MAILLE =FACT(statut='f',max='**',
           SUPER_MAILLE    =SIMP(statut='o',typ=ma,max='**'),
           GROUP_NO        =SIMP(statut='o',typ=grno,max='**'),
           OPTION          =SIMP(statut='f',typ='TXM',defaut="GEOMETRIQUE",into=("GEOMETRIQUE","NOEUD_A_NOEUD","INVERSE") ),
           geometrique     =BLOC(condition = "OPTION == 'GEOMETRIQUE'",
             CRITERE         =SIMP(statut='f',typ='TXM',defaut="RELATIF",into=("RELATIF","ABSOLU") ),
             PRECISION       =SIMP(statut='f',typ='R',defaut= 1.E-3 ),
           ),
         ),
         DEFI_NOEUD      =FACT(statut='f',max='**',
           regles=(UN_PARMI('TOUT','NOEUD_INIT'),),
           TOUT            =SIMP(statut='f',typ='TXM',into=("OUI",),
                                 fr="Renommage de tous les noeuds" ),
           NOEUD_INIT      =SIMP(statut='f',typ=no,
                                 fr="Renommage d un seul noeud"),                     
           b_tout          =BLOC(condition = "TOUT != None",
             PREFIXE         =SIMP(statut='f',typ='TXM' ),
             INDEX           =SIMP(statut='o',typ='I',max='**'),
           ),
           b_noeud_init    =BLOC(condition = "NOEUD_INIT != None",
             SUPER_MAILLE    =SIMP(statut='o',typ=ma),
             NOEUD_FIN       =SIMP(statut='o',typ=no),
           ),        
         ),
         DEFI_GROUP_NO   =FACT(statut='f',max='**',
           regles=(UN_PARMI('TOUT','SUPER_MAILLE'),
                AU_MOINS_UN('INDEX','GROUP_NO_FIN'),
                   ENSEMBLE('GROUP_NO_INIT','GROUP_NO_FIN'),),
#  la regle ancien catalogue AU_MOINS_UN__: ( INDEX , GROUP_NO_FIN ) incoherente avec doc U           
           TOUT            =SIMP(statut='f',typ='TXM',into=("OUI",),
                                 fr="Création de plusieurs groupes de noeuds" ),
           SUPER_MAILLE    =SIMP(statut='f',typ=ma,
                                 fr="Création de plusieurs groupes de noeuds"),
           GROUP_NO_INIT   =SIMP(statut='f',typ=grno,
                                 fr="Création d un seul groupe de noeuds"),
           PREFIXE         =SIMP(statut='f',typ='TXM' ),
           INDEX           =SIMP(statut='f',typ='I',max='**'),
           GROUP_NO_FIN    =SIMP(statut='f',typ=grno),
         ),
)  ;
#& MODIF COMMANDE  DATE 07/11/2006   AUTEUR MARKOVIC D.MARKOVIC 
#            CONFIGURATION MANAGEMENT OF EDF VERSION
# ======================================================================
# COPYRIGHT (C) 1991 - 2001  EDF R&D                  WWW.CODE-ASTER.ORG
# THIS PROGRAM IS FREE SOFTWARE; YOU CAN REDISTRIBUTE IT AND/OR MODIFY
# IT UNDER THE TERMS OF THE GNU GENERAL PUBLIC LICENSE AS PUBLISHED BY
# THE FREE SOFTWARE FOUNDATION; EITHER VERSION 2 OF THE LICENSE, OR
# (AT YOUR OPTION) ANY LATER VERSION.
#
# THIS PROGRAM IS DISTRIBUTED IN THE HOPE THAT IT WILL BE USEFUL, BUT
# WITHOUT ANY WARRANTY; WITHOUT EVEN THE IMPLIED WARRANTY OF
# MERCHANTABILITY OR FITNESS FOR A PARTICULAR PURPOSE. SEE THE GNU
# GENERAL PUBLIC LICENSE FOR MORE DETAILS.
#
# YOU SHOULD HAVE RECEIVED A COPY OF THE GNU GENERAL PUBLIC LICENSE
# ALONG WITH THIS PROGRAM; IF NOT, WRITE TO EDF R&D CODE_ASTER,
#    1 AVENUE DU GENERAL DE GAULLE, 92141 CLAMART CEDEX, FRANCE.
# ======================================================================
DEFI_MATERIAU=OPER(nom="DEFI_MATERIAU",op=5,sd_prod=mater_sdaster,
                   fr="Définition des paramètres décrivant le comportement d un matériau",
                   reentrant='n',
            UIinfo={"groupes":("Modélisation",)},
       regles=(EXCLUS('ELAS','ELAS_FO','ELAS_FLUI','ELAS_ISTR','ELAS_ISTR_FO','ELAS_ORTH',
                      'ELAS_ORTH_FO','ELAS_COQUE','ELAS_COQUE_FO',
                      'ELAS_HYPER',),
               EXCLUS('THER','THER_FO','THER_ORTH','THER_NL'),
               EXCLUS('ECRO_LINE','ECRO_LINE_FO','ECRO_PUIS'),
               EXCLUS('TAHERI','TAHERI_FO'),
               EXCLUS('ROUSSELIER','ROUSSELIER_FO'),
               PRESENT_PRESENT('ROUSSELIER','TRACTION'),
               PRESENT_PRESENT('ROUSSELIER_FO','TRACTION'),
               EXCLUS('CIN1_CHAB','CIN1_CHAB_FO'),
               EXCLUS('CIN2_CHAB','CIN2_CHAB_FO'),
               EXCLUS('VISCOCHAB','VISCOCHAB_FO'),
               EXCLUS('LEMAITRE','LEMAITRE_FO','ZIRC_CYRA2','ZIRC_EPRI','VISC_IRRA_LOG',
               'LEMA_SEUIL','LEMA_SEUIL_FO','LEMAITRE_IRRA','LMARC_IRRA',),
               EXCLUS('LMARC','LMARC_FO'),
               EXCLUS('VMIS_POUTRE','VMIS_POUTRE_FO'),
               EXCLUS('VENDOCHAB','VENDOCHAB_FO'),
               PRESENT_PRESENT('BPEL_ACIER','ELAS'),
               EXCLUS('RCCM','RCCM_FO'),
               EXCLUS('WEIBULL','WEIBULL_FO'),
               PRESENT_PRESENT('BARCELONE','CAM_CLAY','ELAS'),
               PRESENT_PRESENT('CAM_CLAY','ELAS'),
               PRESENT_PRESENT('LAIGLE','ELAS'),
               PRESENT_PRESENT('DRUCK_PRAGER','ELAS'),
               PRESENT_PRESENT('HOEK_BROWN','ELAS'),
               EXCLUS('MAZARS','MAZARS_FO'),
               PRESENT_PRESENT('BAZANT_FD','ELAS_FO'),
               PRESENT_PRESENT('JOINT_BA','ELAS'),
               PRESENT_PRESENT('CABLE','ELAS'),
               EXCLUS('GLRC_DAMAGE','GLRC_DM'),
               ),
#
# comportement élastique
#
           ELAS            =FACT(statut='f',
             E               =SIMP(statut='o',typ='R',val_min=0.E+0),
             NU              =SIMP(statut='o',typ='R',val_min=-1.E+0,val_max=0.5E+0),
             RHO             =SIMP(statut='f',typ='R'),
             ALPHA           =SIMP(statut='f',typ='R'),
             AMOR_ALPHA      =SIMP(statut='f',typ='R'),
             AMOR_BETA       =SIMP(statut='f',typ='R'),
             AMOR_HYST       =SIMP(statut='f',typ='R'),
           ),
           ELAS_FO         =FACT(statut='f',
             regles=(PRESENT_PRESENT('ALPHA','TEMP_DEF_ALPHA'),),
             E               =SIMP(statut='o',typ=(fonction_sdaster,nappe_sdaster,formule)),
             NU              =SIMP(statut='o',typ=(fonction_sdaster,nappe_sdaster,formule)),
             RHO             =SIMP(statut='f',typ='R'),
             TEMP_DEF_ALPHA  =SIMP(statut='f',typ='R'),
             PRECISION       =SIMP(statut='f',typ='R',defaut= 1.),
             ALPHA           =SIMP(statut='f',typ=(fonction_sdaster,nappe_sdaster,formule)),
             AMOR_ALPHA      =SIMP(statut='f',typ=(fonction_sdaster,nappe_sdaster,formule)),
             AMOR_BETA       =SIMP(statut='f',typ=(fonction_sdaster,nappe_sdaster,formule)),
             AMOR_HYST       =SIMP(statut='f',typ=(fonction_sdaster,nappe_sdaster,formule)),
             K_DESSIC        =SIMP(statut='f',typ='R',defaut= 0.E+0 ),
             B_ENDOGE        =SIMP(statut='f',typ='R',defaut= 0.E+0 ),
             FONC_DESORP     =SIMP(statut='f',typ=(fonction_sdaster,nappe_sdaster,formule)),
             VERI_P          =SIMP(statut='c',typ='TXM',max='**',defaut=("TEMP","INST","HYDR","SECH","NEUT1","NEUT2",) ),
           ),
           ELAS_FLUI       =FACT(statut='f',
             E               =SIMP(statut='o',typ='R'),
             NU              =SIMP(statut='o',typ='R'),
             RHO             =SIMP(statut='o',typ='R'),
             PROF_RHO_F_INT  =SIMP(statut='o',typ=(fonction_sdaster,nappe_sdaster,formule)),
             PROF_RHO_F_EXT  =SIMP(statut='o',typ=(fonction_sdaster,nappe_sdaster,formule)),
             COEF_MASS_AJOU  =SIMP(statut='o',typ=(fonction_sdaster,nappe_sdaster,formule)),
             VERI_P          =SIMP(statut='c',typ='TXM',max='**',defaut=("ABSC",) ),
           ),
           ELAS_ISTR       =FACT(statut='f',
             E_L             =SIMP(statut='o',typ='R'),
             E_N             =SIMP(statut='o',typ='R'),
             NU_LT           =SIMP(statut='o',typ='R'),
             NU_LN           =SIMP(statut='o',typ='R'),
             G_LN            =SIMP(statut='o',typ='R'),
             RHO             =SIMP(statut='f',typ='R'),
             ALPHA_L         =SIMP(statut='f',typ='R',defaut= 0.E+0 ),
             ALPHA_N         =SIMP(statut='f',typ='R',defaut= 0.E+0 ),
           ),
           ELAS_ISTR_FO    =FACT(statut='f',
             regles=(
                      PRESENT_PRESENT('ALPHA_L','TEMP_DEF_ALPHA'),
                      PRESENT_PRESENT('ALPHA_N','TEMP_DEF_ALPHA'),
                    ),
             E_L             =SIMP(statut='o',typ=(fonction_sdaster,nappe_sdaster,formule)),
             E_N             =SIMP(statut='o',typ=(fonction_sdaster,nappe_sdaster,formule)),
             NU_LT           =SIMP(statut='o',typ=(fonction_sdaster,nappe_sdaster,formule)),
             NU_LN           =SIMP(statut='o',typ=(fonction_sdaster,nappe_sdaster,formule)),
             G_LN            =SIMP(statut='o',typ=(fonction_sdaster,nappe_sdaster,formule)),
             RHO             =SIMP(statut='f',typ='R'),
             TEMP_DEF_ALPHA  =SIMP(statut='f',typ='R'),
             PRECISION       =SIMP(statut='f',typ='R',defaut= 1.),
             ALPHA_L         =SIMP(statut='f',typ=(fonction_sdaster,nappe_sdaster,formule)),
             ALPHA_N         =SIMP(statut='f',typ=(fonction_sdaster,nappe_sdaster,formule)),
             VERI_P          =SIMP(statut='c',typ='TXM',max='**',defaut=("TEMP","INST")),
           ),
           ELAS_ORTH       =FACT(statut='f',
             E_L             =SIMP(statut='o',typ='R'),
             E_T             =SIMP(statut='o',typ='R'),
             E_N             =SIMP(statut='f',typ='R'),
             NU_LT           =SIMP(statut='o',typ='R'),
             NU_LN           =SIMP(statut='f',typ='R'),
             NU_TN           =SIMP(statut='f',typ='R'),
             G_LT            =SIMP(statut='o',typ='R'),
             G_LN            =SIMP(statut='f',typ='R'),
             G_TN            =SIMP(statut='f',typ='R'),
             RHO             =SIMP(statut='f',typ='R'),
             ALPHA_L         =SIMP(statut='f',typ='R',defaut= 0.E+0 ),
             ALPHA_T         =SIMP(statut='f',typ='R',defaut= 0.E+0 ),
             ALPHA_N         =SIMP(statut='f',typ='R',defaut= 0.E+0 ),
             XT              =SIMP(statut='f',typ='R',defaut= 1. ),
             XC              =SIMP(statut='f',typ='R',defaut= 1. ),
             YT              =SIMP(statut='f',typ='R',defaut= 1. ),
             YC              =SIMP(statut='f',typ='R',defaut= 1. ),
             S_LT            =SIMP(statut='f',typ='R',defaut= 1. ),
             AMOR_ALPHA      =SIMP(statut='f',typ='R'),
             AMOR_BETA       =SIMP(statut='f',typ='R'),
             AMOR_HYST       =SIMP(statut='f',typ='R'),
           ),
           ELAS_ORTH_FO    =FACT(statut='f',
             regles=(
                      PRESENT_PRESENT('ALPHA_L','TEMP_DEF_ALPHA'),
                      PRESENT_PRESENT('ALPHA_N','TEMP_DEF_ALPHA'),
                      PRESENT_PRESENT('ALPHA_T','TEMP_DEF_ALPHA'),
                    ),
             E_L             =SIMP(statut='o',typ=(fonction_sdaster,nappe_sdaster,formule)),
             E_T             =SIMP(statut='o',typ=(fonction_sdaster,nappe_sdaster,formule)),
             E_N             =SIMP(statut='o',typ=(fonction_sdaster,nappe_sdaster,formule)),
             NU_LT           =SIMP(statut='o',typ=(fonction_sdaster,nappe_sdaster,formule)),
             NU_LN           =SIMP(statut='o',typ=(fonction_sdaster,nappe_sdaster,formule)),
             NU_TN           =SIMP(statut='o',typ=(fonction_sdaster,nappe_sdaster,formule)),
             G_LT            =SIMP(statut='o',typ=(fonction_sdaster,nappe_sdaster,formule)),
             G_LN            =SIMP(statut='o',typ=(fonction_sdaster,nappe_sdaster,formule)),
             G_TN            =SIMP(statut='o',typ=(fonction_sdaster,nappe_sdaster,formule)),
             RHO             =SIMP(statut='f',typ='R'),
             TEMP_DEF_ALPHA  =SIMP(statut='f',typ='R'),
             PRECISION       =SIMP(statut='f',typ='R',defaut= 1. ),
             ALPHA_L         =SIMP(statut='f',typ=(fonction_sdaster,nappe_sdaster,formule)),
             ALPHA_T         =SIMP(statut='f',typ=(fonction_sdaster,nappe_sdaster,formule)),
             ALPHA_N         =SIMP(statut='f',typ=(fonction_sdaster,nappe_sdaster,formule)),
             VERI_P          =SIMP(statut='c',typ='TXM',max='**',defaut=("TEMP","INST",) ),
             AMOR_ALPHA      =SIMP(statut='f',typ=(fonction_sdaster,nappe_sdaster,formule)),
             AMOR_BETA       =SIMP(statut='f',typ=(fonction_sdaster,nappe_sdaster,formule)),
             AMOR_HYST       =SIMP(statut='f',typ=(fonction_sdaster,nappe_sdaster,formule)),
           ),
           ELAS_HYPER      =FACT(statut='f',
                                 regles=(UN_PARMI('K','NU'),),
             C10             =SIMP(statut='f',typ='R',defaut=0.0),        
             C01             =SIMP(statut='o',typ='R'),            
             C20             =SIMP(statut='f',typ='R',defaut=0.0),            
             K               =SIMP(statut='f',typ='R'), 
             RHO             =SIMP(statut='f',typ='R',defaut=0.0),  
             NU              =SIMP(statut='f',typ='R',val_min=-1.E+0,val_max=0.5E+0),          
           ),
           ELAS_COQUE      =FACT(statut='f',
             regles=(EXCLUS('MEMB_L','M_LLLL',),
                     PRESENT_PRESENT('MEMB_L','MEMB_LT', 'MEMB_T','MEMB_G_LT','FLEX_L','FLEX_LT',
                                     'FLEX_T','FLEX_G_LT','CISA_L','CISA_T',),
                     PRESENT_PRESENT('M_LLLL','M_LLTT','M_LLLT','M_TTTT','M_TTLT','M_LTLT','F_LLLL',
                                     'F_LLTT','F_LLLT','F_TTTT','F_TTLT','F_LTLT','MF_LLLL',
                                     'MF_LLTT','MF_LLLT','MF_TTTT','MF_TTLT','MF_LTLT','MC_LLLZ',
                                     'MC_LLTZ','MC_TTLZ','MC_TTTZ','MC_LTLZ','MC_LTTZ','FC_LLLZ',
                                     'FC_LLTZ','FC_TTLZ','FC_TTTZ','FC_LTLZ','FC_LTTZ','C_LZLZ',
                                     'C_LZTZ','C_TZTZ'),),
             MEMB_L          =SIMP(statut='f',typ='R'),
             MEMB_LT         =SIMP(statut='f',typ='R'),
             MEMB_T          =SIMP(statut='f',typ='R'),
             MEMB_G_LT       =SIMP(statut='f',typ='R'),
             FLEX_L          =SIMP(statut='f',typ='R'),
             FLEX_LT         =SIMP(statut='f',typ='R'),
             FLEX_T          =SIMP(statut='f',typ='R'),
             FLEX_G_LT       =SIMP(statut='f',typ='R'),
             CISA_L          =SIMP(statut='f',typ='R'),
             CISA_T          =SIMP(statut='f',typ='R'),
             M_LLLL          =SIMP(statut='f',typ='R'),
             M_LLTT          =SIMP(statut='f',typ='R'),
             M_LLLT          =SIMP(statut='f',typ='R'),
             M_TTTT          =SIMP(statut='f',typ='R'),
             M_TTLT          =SIMP(statut='f',typ='R'),
             M_LTLT          =SIMP(statut='f',typ='R'),
             F_LLLL          =SIMP(statut='f',typ='R'),
             F_LLTT          =SIMP(statut='f',typ='R'),
             F_LLLT          =SIMP(statut='f',typ='R'),
             F_TTTT          =SIMP(statut='f',typ='R'),
             F_TTLT          =SIMP(statut='f',typ='R'),
             F_LTLT          =SIMP(statut='f',typ='R'),
             MF_LLLL         =SIMP(statut='f',typ='R'),
             MF_LLTT         =SIMP(statut='f',typ='R'),
             MF_LLLT         =SIMP(statut='f',typ='R'),
             MF_TTTT         =SIMP(statut='f',typ='R'),
             MF_TTLT         =SIMP(statut='f',typ='R'),
             MF_LTLT         =SIMP(statut='f',typ='R'),
             MC_LLLZ         =SIMP(statut='f',typ='R'),
             MC_LLTZ         =SIMP(statut='f',typ='R'),
             MC_TTLZ         =SIMP(statut='f',typ='R'),
             MC_TTTZ         =SIMP(statut='f',typ='R'),
             MC_LTLZ         =SIMP(statut='f',typ='R'),
             MC_LTTZ         =SIMP(statut='f',typ='R'),
             FC_LLLZ         =SIMP(statut='f',typ='R'),
             FC_LLTZ         =SIMP(statut='f',typ='R'),
             FC_TTLZ         =SIMP(statut='f',typ='R'),
             FC_TTTZ         =SIMP(statut='f',typ='R'),
             FC_LTLZ         =SIMP(statut='f',typ='R'),
             FC_LTTZ         =SIMP(statut='f',typ='R'),
             C_LZLZ          =SIMP(statut='f',typ='R'),
             C_LZTZ          =SIMP(statut='f',typ='R'),
             C_TZTZ          =SIMP(statut='f',typ='R'),
             RHO             =SIMP(statut='f',typ='R'),
             ALPHA           =SIMP(statut='f',typ='R'),
           ),
           ELAS_COQUE_FO   =FACT(statut='f',
             regles=(EXCLUS('MEMB_L','M_LLLL',),
                     PRESENT_PRESENT('MEMB_L','MEMB_LT','MEMB_T','MEMB_G_LT','FLEX_L','FLEX_LT',
                                     'FLEX_T','FLEX_G_LT','CISA_L','CISA_T',),
                     PRESENT_PRESENT('M_LLLL','M_LLTT','M_LLLT','M_TTTT','M_TTLT','M_LTLT','F_LLLL',
                                     'F_LLTT','F_LLLT','F_TTTT','F_TTLT','F_LTLT','MF_LLLL','MF_LLTT',
                                     'MF_LLLT','MF_TTTT','MF_TTLT','MF_LTLT','MC_LLLZ','MC_LLTZ',
                                     'MC_TTLZ','MC_TTTZ','MC_LTLZ','MC_LTTZ','FC_LLLZ','FC_LLTZ',
                                     'FC_TTLZ','FC_TTTZ','FC_LTLZ','FC_LTTZ','C_LZLZ','C_LZTZ','C_TZTZ'),),
             MEMB_L          =SIMP(statut='f',typ=(fonction_sdaster,nappe_sdaster,formule)),
             MEMB_LT         =SIMP(statut='f',typ=(fonction_sdaster,nappe_sdaster,formule)),
             MEMB_T          =SIMP(statut='f',typ=(fonction_sdaster,nappe_sdaster,formule)),
             MEMB_G_LT       =SIMP(statut='f',typ=(fonction_sdaster,nappe_sdaster,formule)),
             FLEX_L          =SIMP(statut='f',typ=(fonction_sdaster,nappe_sdaster,formule)),
             FLEX_LT         =SIMP(statut='f',typ=(fonction_sdaster,nappe_sdaster,formule)),
             FLEX_T          =SIMP(statut='f',typ=(fonction_sdaster,nappe_sdaster,formule)),
             FLEX_G_LT       =SIMP(statut='f',typ=(fonction_sdaster,nappe_sdaster,formule)),
             CISA_L          =SIMP(statut='f',typ=(fonction_sdaster,nappe_sdaster,formule)),
             CISA_T          =SIMP(statut='f',typ=(fonction_sdaster,nappe_sdaster,formule)),
             M_LLLL          =SIMP(statut='f',typ=(fonction_sdaster,nappe_sdaster,formule)),
             M_LLTT          =SIMP(statut='f',typ=(fonction_sdaster,nappe_sdaster,formule)),
             M_LLLT          =SIMP(statut='f',typ=(fonction_sdaster,nappe_sdaster,formule)),
             M_TTTT          =SIMP(statut='f',typ=(fonction_sdaster,nappe_sdaster,formule)),
             M_TTLT          =SIMP(statut='f',typ=(fonction_sdaster,nappe_sdaster,formule)),
             M_LTLT          =SIMP(statut='f',typ=(fonction_sdaster,nappe_sdaster,formule)),
             F_LLLL          =SIMP(statut='f',typ=(fonction_sdaster,nappe_sdaster,formule)),
             F_LLTT          =SIMP(statut='f',typ=(fonction_sdaster,nappe_sdaster,formule)),
             F_LLLT          =SIMP(statut='f',typ=(fonction_sdaster,nappe_sdaster,formule)),
             F_TTTT          =SIMP(statut='f',typ=(fonction_sdaster,nappe_sdaster,formule)),
             F_TTLT          =SIMP(statut='f',typ=(fonction_sdaster,nappe_sdaster,formule)),
             F_LTLT          =SIMP(statut='f',typ=(fonction_sdaster,nappe_sdaster,formule)),
             MF_LLLL         =SIMP(statut='f',typ=(fonction_sdaster,nappe_sdaster,formule)),
             MF_LLTT         =SIMP(statut='f',typ=(fonction_sdaster,nappe_sdaster,formule)),
             MF_LLLT         =SIMP(statut='f',typ=(fonction_sdaster,nappe_sdaster,formule)),
             MF_TTTT         =SIMP(statut='f',typ=(fonction_sdaster,nappe_sdaster,formule)),
             MF_TTLT         =SIMP(statut='f',typ=(fonction_sdaster,nappe_sdaster,formule)),
             MF_LTLT         =SIMP(statut='f',typ=(fonction_sdaster,nappe_sdaster,formule)),
             MC_LLLZ         =SIMP(statut='f',typ=(fonction_sdaster,nappe_sdaster,formule)),
             MC_LLTZ         =SIMP(statut='f',typ=(fonction_sdaster,nappe_sdaster,formule)),
             MC_TTLZ         =SIMP(statut='f',typ=(fonction_sdaster,nappe_sdaster,formule)),
             MC_TTTZ         =SIMP(statut='f',typ=(fonction_sdaster,nappe_sdaster,formule)),
             MC_LTLZ         =SIMP(statut='f',typ=(fonction_sdaster,nappe_sdaster,formule)),
             MC_LTTZ         =SIMP(statut='f',typ=(fonction_sdaster,nappe_sdaster,formule)),
             FC_LLLZ         =SIMP(statut='f',typ=(fonction_sdaster,nappe_sdaster,formule)),
             FC_LLTZ         =SIMP(statut='f',typ=(fonction_sdaster,nappe_sdaster,formule)),
             FC_TTLZ         =SIMP(statut='f',typ=(fonction_sdaster,nappe_sdaster,formule)),
             FC_TTTZ         =SIMP(statut='f',typ=(fonction_sdaster,nappe_sdaster,formule)),
             FC_LTLZ         =SIMP(statut='f',typ=(fonction_sdaster,nappe_sdaster,formule)),
             FC_LTTZ         =SIMP(statut='f',typ=(fonction_sdaster,nappe_sdaster,formule)),
             C_LZLZ          =SIMP(statut='f',typ=(fonction_sdaster,nappe_sdaster,formule)),
             C_LZTZ          =SIMP(statut='f',typ=(fonction_sdaster,nappe_sdaster,formule)),
             C_TZTZ          =SIMP(statut='f',typ=(fonction_sdaster,nappe_sdaster,formule)),
             RHO             =SIMP(statut='f',typ='R'),
             ALPHA           =SIMP(statut='f',typ=(fonction_sdaster,nappe_sdaster,formule)),
             VERI_P          =SIMP(statut='c',typ='TXM',max='**',defaut=("TEMP","INST") ),
           ),
           APPUI_ELAS      =FACT(statut='f',
             E_N             =SIMP(statut='o',typ='R'),
             E_TAN           =SIMP(statut='f',typ='R',defaut= 0.E+0),
           ),
           CABLE           =FACT(statut='f',
             EC_SUR_E        =SIMP(statut='f',typ='R',defaut= 1.E-4 ),
           ),
#
# comportement mécanique non linéaire
#
           TRACTION        =FACT(statut='f',
             SIGM            =SIMP(statut='o',typ=(fonction_sdaster,nappe_sdaster,formule)),
             VERI_P          =SIMP(statut='c',typ='TXM',max='**',defaut=("EPSI","TEMP","HYDR","SECH",) ),
           ),
           ECRO_LINE       =FACT(statut='f',
             D_SIGM_EPSI     =SIMP(statut='o',typ='R',),
             SY              =SIMP(statut='o',typ='R',),
           ),
           ECRO_LINE_FO    =FACT(statut='f',
             D_SIGM_EPSI     =SIMP(statut='o',typ=(fonction_sdaster,nappe_sdaster,formule)),
             SY              =SIMP(statut='o',typ=(fonction_sdaster,nappe_sdaster,formule)),
             VERI_P          =SIMP(statut='c',typ='TXM',max='**',defaut=("TEMP",) ),
           ),
           ECRO_PUIS       =FACT(statut='f',
             SY              =SIMP(statut='o',typ='R',),  
             A_PUIS          =SIMP(statut='o',typ='R',val_min=0.0),
             N_PUIS          =SIMP(statut='o',typ='R',val_min=1.E-6),
           ),
           ECRO_PUIS_FO    =FACT(statut='f',
             SY              =SIMP(statut='o',typ=(fonction_sdaster,nappe_sdaster,formule)),
             A_PUIS          =SIMP(statut='o',typ=(fonction_sdaster,nappe_sdaster,formule)),
             N_PUIS          =SIMP(statut='o',typ=(fonction_sdaster,nappe_sdaster,formule)),
             VERI_P          =SIMP(statut='c',typ='TXM',max='**',defaut=("TEMP",) ),
           ),
           BETON_ECRO_LINE =FACT(statut='f',
             D_SIGM_EPSI     =SIMP(statut='o',typ='R'),
             SYT             =SIMP(statut='o',typ='R'),
             SYC             =SIMP(statut='f',typ='R'),
           ),
           BETON_REGLE_PR =FACT(statut='f',
             D_SIGM_EPSI     =SIMP(statut='o',typ='R'),
             SYT             =SIMP(statut='o',typ='R'),
             SYC             =SIMP(statut='f',typ='R'),
             EPSC            =SIMP(statut='f',typ='R'),
             N               =SIMP(statut='f',typ='R'),
           ),
           ENDO_ORTH_BETON  =FACT(statut='f',
             ALPHA            =SIMP(statut='f',typ='R',defaut=0.9),
             K0               =SIMP(statut='o',typ='R'),
             K1               =SIMP(statut='o',typ='R'),
             K2               =SIMP(statut='f',typ='R',defaut=7.E-4),
             ECROB            =SIMP(statut='o',typ='R'),
             ECROD            =SIMP(statut='o',typ='R'),
           ),
           PRAGER          =FACT(statut='f',
             C               =SIMP(statut='o',typ='R'),
           ),
           PRAGER_FO       =FACT(statut='f',
             C               =SIMP(statut='o',typ=(fonction_sdaster,nappe_sdaster,formule)),
             VERI_P          =SIMP(statut='c',typ='TXM',max='**',defaut=("TEMP",) ),
           ),
           ECRO_FLEJOU     =FACT(statut='f',
             EP              =SIMP(statut='o',typ='R'),
             SY              =SIMP(statut='o',typ='R'),
             SU              =SIMP(statut='o',typ='R'),
             PUISS           =SIMP(statut='o',typ='R'),
           ),
           TAHERI          =FACT(statut='f',
             R_0             =SIMP(statut='o',typ='R'),
             ALPHA           =SIMP(statut='o',typ='R'),
             M               =SIMP(statut='o',typ='R'),
             A               =SIMP(statut='o',typ='R'),
             B               =SIMP(statut='o',typ='R'),
             C1              =SIMP(statut='o',typ='R'),
             C_INF           =SIMP(statut='o',typ='R'),
             S               =SIMP(statut='o',typ='R'),
           ),
           TAHERI_FO       =FACT(statut='f',
             R_0             =SIMP(statut='o',typ=(fonction_sdaster,nappe_sdaster,formule)),
             ALPHA           =SIMP(statut='o',typ=(fonction_sdaster,nappe_sdaster,formule)),
             M               =SIMP(statut='o',typ=(fonction_sdaster,nappe_sdaster,formule)),
             A               =SIMP(statut='o',typ=(fonction_sdaster,nappe_sdaster,formule)),
             B               =SIMP(statut='o',typ=(fonction_sdaster,nappe_sdaster,formule)),
             C1              =SIMP(statut='o',typ=(fonction_sdaster,nappe_sdaster,formule)),
             C_INF           =SIMP(statut='o',typ=(fonction_sdaster,nappe_sdaster,formule)),
             S               =SIMP(statut='o',typ=(fonction_sdaster,nappe_sdaster,formule)),
             VERI_P          =SIMP(statut='c',typ='TXM',max='**',defaut=("TEMP",) ),
           ),
           ROUSSELIER      =FACT(statut='f',
             D               =SIMP(statut='o',typ='R'),
             SIGM_1          =SIMP(statut='o',typ='R'),
             PORO_INIT       =SIMP(statut='o',typ='R'),
             PORO_CRIT       =SIMP(statut='f',typ='R',defaut= 1. ),
             PORO_ACCE       =SIMP(statut='f',typ='R',defaut= 1. ),
             PORO_LIMI       =SIMP(statut='f',typ='R',defaut= 0.999 ),
             D_SIGM_EPSI_NORM=SIMP(statut='f',typ='R',defaut= 1. ),
             AN              =SIMP(statut='f',typ='R',defaut= 0. ),
           ),
           ROUSSELIER_FO   =FACT(statut='f',
             D               =SIMP(statut='o',typ=(fonction_sdaster,nappe_sdaster,formule)),
             SIGM_1          =SIMP(statut='o',typ=(fonction_sdaster,nappe_sdaster,formule)),
             PORO_INIT       =SIMP(statut='o',typ=(fonction_sdaster,nappe_sdaster,formule)),
             PORO_CRIT       =SIMP(statut='f',typ='R',defaut= 1. ),
             PORO_ACCE       =SIMP(statut='f',typ='R',defaut= 1. ),
             PORO_LIMI       =SIMP(statut='f',typ='R',defaut= 0.999 ),
             D_SIGM_EPSI_NORM=SIMP(statut='f',typ='R',defaut= 1. ),
             AN              =SIMP(statut='f',typ='R',defaut= 0. ),
             VERI_P          =SIMP(statut='c',typ='TXM',max='**',defaut=("TEMP",) ),
           ),
           VISC_SINH      =FACT(statut='f',
             SIGM_0          =SIMP(statut='o',typ='R'),
             EPSI_0          =SIMP(statut='o',typ='R'),
             M               =SIMP(statut='o',typ='R'),
           ),
           CIN1_CHAB  =FACT(statut='f',
             R_0             =SIMP(statut='o',typ='R'),
             R_I             =SIMP(statut='f',typ='R'),
             B               =SIMP(statut='f',typ='R',defaut= 0.0E+0),
             C_I             =SIMP(statut='o',typ='R'),
             K               =SIMP(statut='f',typ='R',defaut= 1.0E+0),
             W               =SIMP(statut='f',typ='R',defaut= 0.0E+0),
             G_0             =SIMP(statut='o',typ='R'),
             A_I             =SIMP(statut='f',typ='R',defaut= 1.0E+0),
           ),
           CIN1_CHAB_FO  =FACT(statut='f',
             R_0             =SIMP(statut='o',typ=(fonction_sdaster,nappe_sdaster,formule)),
             R_I             =SIMP(statut='o',typ=(fonction_sdaster,nappe_sdaster,formule)),
             B               =SIMP(statut='o',typ=(fonction_sdaster,nappe_sdaster,formule)),
             C_I             =SIMP(statut='o',typ=(fonction_sdaster,nappe_sdaster,formule)),
             K               =SIMP(statut='o',typ=(fonction_sdaster,nappe_sdaster,formule)),
             W               =SIMP(statut='o',typ=(fonction_sdaster,nappe_sdaster,formule)),
             G_0             =SIMP(statut='o',typ=(fonction_sdaster,nappe_sdaster,formule)),
             A_I             =SIMP(statut='o',typ=(fonction_sdaster,nappe_sdaster,formule)),
             VERI_P          =SIMP(statut='c',typ='TXM',max='**',defaut=("TEMP",)),
           ),
           CIN2_CHAB  =FACT(statut='f',
             R_0             =SIMP(statut='o',typ='R'),
             R_I             =SIMP(statut='f',typ='R'),
             B               =SIMP(statut='f',typ='R',defaut= 0.E+0 ),
             C1_I            =SIMP(statut='o',typ='R'),
             C2_I            =SIMP(statut='o',typ='R'),
             K               =SIMP(statut='f',typ='R',defaut= 1.),
             W               =SIMP(statut='f',typ='R',defaut= 0.E+0 ),
             G1_0            =SIMP(statut='o',typ='R'),
             G2_0            =SIMP(statut='o',typ='R'),
             A_I             =SIMP(statut='f',typ='R',defaut= 1.E+0 ),
           ),
           CIN2_CHAB_FO  =FACT(statut='f',
             R_0             =SIMP(statut='o',typ=(fonction_sdaster,nappe_sdaster,formule)),
             R_I             =SIMP(statut='o',typ=(fonction_sdaster,nappe_sdaster,formule)),
             B               =SIMP(statut='o',typ=(fonction_sdaster,nappe_sdaster,formule)),
             C1_I            =SIMP(statut='o',typ=(fonction_sdaster,nappe_sdaster,formule)),
             C2_I            =SIMP(statut='o',typ=(fonction_sdaster,nappe_sdaster,formule)),
             K               =SIMP(statut='o',typ=(fonction_sdaster,nappe_sdaster,formule)),
             W               =SIMP(statut='o',typ=(fonction_sdaster,nappe_sdaster,formule)),
             G1_0            =SIMP(statut='o',typ=(fonction_sdaster,nappe_sdaster,formule)),
             G2_0            =SIMP(statut='o',typ=(fonction_sdaster,nappe_sdaster,formule)),
             A_I             =SIMP(statut='o',typ=(fonction_sdaster,nappe_sdaster,formule)),
             VERI_P          =SIMP(statut='c',typ='TXM',max='**',defaut=("TEMP",) ),
           ),
           VISCOCHAB       =FACT(statut='f',
             K_0             =SIMP(statut='o',typ='R'),
             A_K             =SIMP(statut='o',typ='R'),
             A_R             =SIMP(statut='o',typ='R'),
             K               =SIMP(statut='o',typ='R'),
             N               =SIMP(statut='o',typ='R'),
             ALP             =SIMP(statut='o',typ='R'),
             B               =SIMP(statut='o',typ='R'),
             M_R             =SIMP(statut='o',typ='R'),
             G_R             =SIMP(statut='o',typ='R'),
             MU              =SIMP(statut='o',typ='R'),
             Q_M             =SIMP(statut='o',typ='R'),
             Q_0             =SIMP(statut='o',typ='R'),
             QR_0            =SIMP(statut='o',typ='R'),
             ETA             =SIMP(statut='o',typ='R'),
             C1              =SIMP(statut='o',typ='R'),
             M_1             =SIMP(statut='o',typ='R'),
             D1              =SIMP(statut='o',typ='R'),
             G_X1            =SIMP(statut='o',typ='R'),
             G1_0            =SIMP(statut='o',typ='R'),
             C2              =SIMP(statut='o',typ='R'),
             M_2             =SIMP(statut='o',typ='R'),
             D2              =SIMP(statut='o',typ='R'),
             G_X2            =SIMP(statut='o',typ='R'),
             G2_0            =SIMP(statut='o',typ='R'),
             A_I             =SIMP(statut='o',typ='R'),
           ),
           VISCOCHAB_FO    =FACT(statut='f',
             K_0             =SIMP(statut='o',typ=(fonction_sdaster,nappe_sdaster,formule)),
             A_K             =SIMP(statut='o',typ=(fonction_sdaster,nappe_sdaster,formule)),
             A_R             =SIMP(statut='o',typ=(fonction_sdaster,nappe_sdaster,formule)),
             K               =SIMP(statut='o',typ=(fonction_sdaster,nappe_sdaster,formule)),
             N               =SIMP(statut='o',typ=(fonction_sdaster,nappe_sdaster,formule)),
             ALP             =SIMP(statut='o',typ=(fonction_sdaster,nappe_sdaster,formule)),
             B               =SIMP(statut='o',typ=(fonction_sdaster,nappe_sdaster,formule)),
             M_R             =SIMP(statut='o',typ=(fonction_sdaster,nappe_sdaster,formule)),
             G_R             =SIMP(statut='o',typ=(fonction_sdaster,nappe_sdaster,formule)),
             MU              =SIMP(statut='o',typ=(fonction_sdaster,nappe_sdaster,formule)),
             Q_M             =SIMP(statut='o',typ=(fonction_sdaster,nappe_sdaster,formule)),
             Q_0             =SIMP(statut='o',typ=(fonction_sdaster,nappe_sdaster,formule)),
             QR_0            =SIMP(statut='o',typ=(fonction_sdaster,nappe_sdaster,formule)),
             ETA             =SIMP(statut='o',typ=(fonction_sdaster,nappe_sdaster,formule)),
             C1              =SIMP(statut='o',typ=(fonction_sdaster,nappe_sdaster,formule)),
             M_1             =SIMP(statut='o',typ=(fonction_sdaster,nappe_sdaster,formule)),
             D1              =SIMP(statut='o',typ=(fonction_sdaster,nappe_sdaster,formule)),
             G_X1            =SIMP(statut='o',typ=(fonction_sdaster,nappe_sdaster,formule)),
             G1_0            =SIMP(statut='o',typ=(fonction_sdaster,nappe_sdaster,formule)),
             C2              =SIMP(statut='o',typ=(fonction_sdaster,nappe_sdaster,formule)),
             M_2             =SIMP(statut='o',typ=(fonction_sdaster,nappe_sdaster,formule)),
             D2              =SIMP(statut='o',typ=(fonction_sdaster,nappe_sdaster,formule)),
             G_X2            =SIMP(statut='o',typ=(fonction_sdaster,nappe_sdaster,formule)),
             G2_0            =SIMP(statut='o',typ=(fonction_sdaster,nappe_sdaster,formule)),
             A_I             =SIMP(statut='o',typ=(fonction_sdaster,nappe_sdaster,formule)),
             VERI_P          =SIMP(statut='c',typ='TXM',max='**',defaut=("TEMP",) ),
           ),
           LEMAITRE        =FACT(statut='f',
             N               =SIMP(statut='o',typ='R'),
             UN_SUR_K        =SIMP(statut='o',typ='R'),
             UN_SUR_M        =SIMP(statut='f',typ='R',defaut= 0.E+0 ),
           ),
           LEMAITRE_IRRA    =FACT(statut='f',
             N               =SIMP(statut='o',typ='R'),
             UN_SUR_K        =SIMP(statut='o',typ='R'),
             UN_SUR_M        =SIMP(statut='f',typ='R',defaut= 0.E+0 ),
             QSR_K           =SIMP(statut='f',typ='R',defaut= 0.E+0 ),
             BETA            =SIMP(statut='f',typ='R',defaut= 0.E+0 ),
             PHI_ZERO        =SIMP(statut='f',typ='R',defaut= 1.E+20),
             L               =SIMP(statut='f',typ='R',defaut= 0.E+0 ),
             GRAN_A          =SIMP(statut='f',typ='R',defaut= 0.E+0 ),
             GRAN_B          =SIMP(statut='f',typ='R',defaut= 0.E+0 ),
             GRAN_S          =SIMP(statut='f',typ='R',defaut= 0.E+0 ),
           ),
           LMARC_IRRA       =FACT(statut='f',
             DE_0            =SIMP(statut='o',typ='R'),
             R_0             =SIMP(statut='o',typ='R'),
             N               =SIMP(statut='o',typ='R'),
             K               =SIMP(statut='o',typ='R'),
             Y_I             =SIMP(statut='o',typ='R'),
             Y_0             =SIMP(statut='o',typ='R'),
             B               =SIMP(statut='o',typ='R'),
             A_0             =SIMP(statut='o',typ='R'),
             RM              =SIMP(statut='o',typ='R'),
             M               =SIMP(statut='o',typ='R'),
             P               =SIMP(statut='o',typ='R'),
             P1              =SIMP(statut='o',typ='R'),
             P2              =SIMP(statut='o',typ='R'),
             M11             =SIMP(statut='o',typ='R'),
             M22             =SIMP(statut='o',typ='R'),
             M33             =SIMP(statut='o',typ='R'),
             M66             =SIMP(statut='o',typ='R'),
             N11             =SIMP(statut='o',typ='R'),
             N22             =SIMP(statut='o',typ='R'),
             N33             =SIMP(statut='o',typ='R'),
             N66             =SIMP(statut='o',typ='R'),
             Q11             =SIMP(statut='o',typ='R'),
             Q22             =SIMP(statut='o',typ='R'),
             Q33             =SIMP(statut='o',typ='R'),
             Q66             =SIMP(statut='o',typ='R'),
             R11             =SIMP(statut='o',typ='R'),
             R22             =SIMP(statut='o',typ='R'),
             R33             =SIMP(statut='o',typ='R'),
             R66             =SIMP(statut='o',typ='R'),
             GRAN_A          =SIMP(statut='f',typ='R',defaut= 0.E+0 ),
             GRAN_B          =SIMP(statut='f',typ='R',defaut= 0.E+0 ),
             GRAN_S          =SIMP(statut='f',typ='R',defaut= 0.E+0 ),
           ),
           ZIRC_CYRA2      =FACT(statut='f',
             EPSI_FAB        =SIMP(statut='o',typ=(fonction_sdaster,nappe_sdaster,formule)),
             TEMP_RECUIT     =SIMP(statut='o',typ=(fonction_sdaster,nappe_sdaster,formule)),
             FLUX_PHI        =SIMP(statut='o',typ=(fonction_sdaster,nappe_sdaster,formule)),
             VERI_P          =SIMP(statut='c',typ='TXM',max='**',defaut=("INST",) ),
           ),
          VISC_IRRA_LOG    =FACT(statut='f',
             A               =SIMP(statut='f',typ='R',defaut= 1.28E-1),
             B               =SIMP(statut='f',typ='R',defaut= 0.01159),
             CSTE_TPS        =SIMP(statut='f',typ='R',defaut= 0.3540),
             ENER_ACT        =SIMP(statut='f',typ='R',defaut= 5000.),
             FLUX_PHI        =SIMP(statut='o',typ='R',),
           ),
          GRAN_IRRA_LOG    =FACT(statut='f',
             A               =SIMP(statut='f',typ='R',defaut= 1.28E-1),
             B               =SIMP(statut='f',typ='R',defaut= 0.01159),
             CSTE_TPS        =SIMP(statut='f',typ='R',defaut= 0.3540),
             ENER_ACT        =SIMP(statut='f',typ='R',defaut= 5000.),
             FLUX_PHI        =SIMP(statut='o',typ='R',),
             GRAN_A          =SIMP(statut='f',typ='R',defaut= 0.E+0),
             GRAN_B          =SIMP(statut='f',typ='R',defaut= 0.E+0),
             GRAN_S          =SIMP(statut='f',typ='R',defaut= 0.E+0),
           ),
          LEMA_SEUIL   =FACT(statut='f',
             A               =SIMP(statut='o',typ='R',),
             S               =SIMP(statut='o',typ='R',),
           ),
          LEMA_SEUIL_FO=FACT(statut='f',
             A               =SIMP(statut='o',typ=(fonction_sdaster,nappe_sdaster,formule)),
             S               =SIMP(statut='o',typ=(fonction_sdaster,nappe_sdaster,formule)),
             VERI_P          =SIMP(statut='c',typ='TXM',max='**',defaut=("TEMP",) ),
           ),
          IRRAD3M=FACT(statut='f',
                     R02      =SIMP(statut='o',typ=(fonction_sdaster,nappe_sdaster,formule)),
                     EPSI_U   =SIMP(statut='o',typ=(fonction_sdaster,nappe_sdaster,formule)),
                     RM       =SIMP(statut='o',typ=(fonction_sdaster,nappe_sdaster,formule)),
                     AI0      =SIMP(statut='o',typ='R',val_min=0.0),
                     ZETA     =SIMP(statut='f',typ=(fonction_sdaster,nappe_sdaster,formule)),
                     ETAI_S   =SIMP(statut='o',typ='R',val_min=0.0),
                     R        =SIMP(statut='o',typ=(fonction_sdaster,nappe_sdaster,formule)),
                     ALPHA    =SIMP(statut='o',typ='R',val_min=0.0),
                     PHI0     =SIMP(statut='o',typ='R',val_min=0.0),
                     KAPPA    =SIMP(statut='f',typ='R',val_min=0.0,defaut=0.8,val_max=1.0),
             VERI_P           =SIMP(statut='c',typ='TXM',max='**',defaut=("TEMP","IRRA") ),
           ),
           ZIRC_EPRI       =FACT(statut='f',
             FLUX_PHI        =SIMP(statut='o',typ='R'),
             R_P             =SIMP(statut='o',typ='R'),
             THETA_MAX       =SIMP(statut='o',typ='R'),
           ),
           LEMAITRE_FO     =FACT(statut='f',
             N               =SIMP(statut='o',typ=(fonction_sdaster,nappe_sdaster,formule)),
             UN_SUR_K        =SIMP(statut='o',typ=(fonction_sdaster,nappe_sdaster,formule)),
             UN_SUR_M        =SIMP(statut='o',typ=(fonction_sdaster,nappe_sdaster,formule)),
             VERI_P          =SIMP(statut='c',typ='TXM',max='**',defaut=("TEMP",) ),
           ),
           LMARC           =FACT(statut='f',
             DE_0            =SIMP(statut='o',typ='R'),
             R_0             =SIMP(statut='o',typ='R'),
             N               =SIMP(statut='o',typ='R'),
             K               =SIMP(statut='o',typ='R'),
             Y_I             =SIMP(statut='o',typ='R'),
             Y_0             =SIMP(statut='o',typ='R'),
             B               =SIMP(statut='o',typ='R'),
             A_0             =SIMP(statut='o',typ='R'),
             RM              =SIMP(statut='o',typ='R'),
             M               =SIMP(statut='o',typ='R'),
             P               =SIMP(statut='o',typ='R'),
             P1              =SIMP(statut='o',typ='R'),
             P2              =SIMP(statut='o',typ='R'),
             M11             =SIMP(statut='o',typ='R'),
             M22             =SIMP(statut='o',typ='R'),
             M33             =SIMP(statut='o',typ='R'),
             M66             =SIMP(statut='o',typ='R'),
             N11             =SIMP(statut='o',typ='R'),
             N22             =SIMP(statut='o',typ='R'),
             N33             =SIMP(statut='o',typ='R'),
             N66             =SIMP(statut='o',typ='R'),
             Q11             =SIMP(statut='o',typ='R'),
             Q22             =SIMP(statut='o',typ='R'),
             Q33             =SIMP(statut='o',typ='R'),
             Q66             =SIMP(statut='o',typ='R'),
             R11             =SIMP(statut='o',typ='R'),
             R22             =SIMP(statut='o',typ='R'),
             R33             =SIMP(statut='o',typ='R'),
             R66             =SIMP(statut='o',typ='R'),
           ),
           LMARC_FO        =FACT(statut='f',
             DE_0            =SIMP(statut='o',typ=(fonction_sdaster,nappe_sdaster,formule)),
             R_0             =SIMP(statut='o',typ=(fonction_sdaster,nappe_sdaster,formule)),
             N               =SIMP(statut='o',typ=(fonction_sdaster,nappe_sdaster,formule)),
             K               =SIMP(statut='o',typ=(fonction_sdaster,nappe_sdaster,formule)),
             Y_I             =SIMP(statut='o',typ=(fonction_sdaster,nappe_sdaster,formule)),
             Y_0             =SIMP(statut='o',typ=(fonction_sdaster,nappe_sdaster,formule)),
             B               =SIMP(statut='o',typ=(fonction_sdaster,nappe_sdaster,formule)),
             A_0             =SIMP(statut='o',typ=(fonction_sdaster,nappe_sdaster,formule)),
             RM              =SIMP(statut='o',typ=(fonction_sdaster,nappe_sdaster,formule)),
             M               =SIMP(statut='o',typ=(fonction_sdaster,nappe_sdaster,formule)),
             P               =SIMP(statut='o',typ=(fonction_sdaster,nappe_sdaster,formule)),
             P1              =SIMP(statut='o',typ=(fonction_sdaster,nappe_sdaster,formule)),
             P2              =SIMP(statut='o',typ=(fonction_sdaster,nappe_sdaster,formule)),
             M11             =SIMP(statut='o',typ=(fonction_sdaster,nappe_sdaster,formule)),
             M22             =SIMP(statut='o',typ=(fonction_sdaster,nappe_sdaster,formule)),
             M33             =SIMP(statut='o',typ=(fonction_sdaster,nappe_sdaster,formule)),
             M66             =SIMP(statut='o',typ=(fonction_sdaster,nappe_sdaster,formule)),
             N11             =SIMP(statut='o',typ=(fonction_sdaster,nappe_sdaster,formule)),
             N22             =SIMP(statut='o',typ=(fonction_sdaster,nappe_sdaster,formule)),
             N33             =SIMP(statut='o',typ=(fonction_sdaster,nappe_sdaster,formule)),
             N66             =SIMP(statut='o',typ=(fonction_sdaster,nappe_sdaster,formule)),
             Q11             =SIMP(statut='o',typ=(fonction_sdaster,nappe_sdaster,formule)),
             Q22             =SIMP(statut='o',typ=(fonction_sdaster,nappe_sdaster,formule)),
             Q33             =SIMP(statut='o',typ=(fonction_sdaster,nappe_sdaster,formule)),
             Q66             =SIMP(statut='o',typ=(fonction_sdaster,nappe_sdaster,formule)),
             R11             =SIMP(statut='o',typ=(fonction_sdaster,nappe_sdaster,formule)),
             R22             =SIMP(statut='o',typ=(fonction_sdaster,nappe_sdaster,formule)),
             R33             =SIMP(statut='o',typ=(fonction_sdaster,nappe_sdaster,formule)),
             R66             =SIMP(statut='o',typ=(fonction_sdaster,nappe_sdaster,formule)),
             VERI_P          =SIMP(statut='c',typ='TXM',max='**',defaut=("TEMP",) ),
           ),
           VMIS_POUTRE     =FACT(statut='f',
             NP              =SIMP(statut='o',typ='R'),
             MEY             =SIMP(statut='o',typ='R'),
             MPY             =SIMP(statut='o',typ='R'),
             CAY             =SIMP(statut='o',typ='R'),
             CBY             =SIMP(statut='o',typ='R'),
             MEZ             =SIMP(statut='o',typ='R'),
             MPZ             =SIMP(statut='o',typ='R'),
             CAZ             =SIMP(statut='o',typ='R'),
             CBZ             =SIMP(statut='o',typ='R'),
             MPX             =SIMP(statut='o',typ='R'),
           ),
           VMIS_POUTRE_FO  =FACT(statut='f',
             NP              =SIMP(statut='o',typ=(fonction_sdaster,nappe_sdaster,formule)),
             MEY             =SIMP(statut='o',typ=(fonction_sdaster,nappe_sdaster,formule)),
             MPY             =SIMP(statut='o',typ=(fonction_sdaster,nappe_sdaster,formule)),
             CAY             =SIMP(statut='o',typ=(fonction_sdaster,nappe_sdaster,formule)),
             CBY             =SIMP(statut='o',typ=(fonction_sdaster,nappe_sdaster,formule)),
             MEZ             =SIMP(statut='o',typ=(fonction_sdaster,nappe_sdaster,formule)),
             MPZ             =SIMP(statut='o',typ=(fonction_sdaster,nappe_sdaster,formule)),
             CAZ             =SIMP(statut='o',typ=(fonction_sdaster,nappe_sdaster,formule)),
             CBZ             =SIMP(statut='o',typ=(fonction_sdaster,nappe_sdaster,formule)),
             MPX             =SIMP(statut='o',typ=(fonction_sdaster,nappe_sdaster,formule)),
             VERI_P          =SIMP(statut='c',typ='TXM',max='**',defaut=("TEMP",) ),
           ),
           ARME            =FACT(statut='f',
             KYE             =SIMP(statut='o',typ='R'),
             DLE             =SIMP(statut='o',typ='R'),
             KYP             =SIMP(statut='o',typ='R'),
             DLP             =SIMP(statut='o',typ='R'),
             KYG             =SIMP(statut='o',typ='R'),
           ),
           ASSE_CORN       =FACT(statut='f',
             NU_1            =SIMP(statut='o',typ='R'),
             MU_1            =SIMP(statut='o',typ='R'),
             DXU_1           =SIMP(statut='o',typ='R'),
             DRYU_1          =SIMP(statut='o',typ='R'),
             C_1             =SIMP(statut='o',typ='R'),
             NU_2            =SIMP(statut='o',typ='R'),
             MU_2            =SIMP(statut='o',typ='R'),
             DXU_2           =SIMP(statut='o',typ='R'),
             DRYU_2          =SIMP(statut='o',typ='R'),
             C_2             =SIMP(statut='o',typ='R'),
             KY              =SIMP(statut='o',typ='R'),
             KZ              =SIMP(statut='o',typ='R'),
             KRX             =SIMP(statut='o',typ='R'),
             KRZ             =SIMP(statut='o',typ='R'),
             R_P0            =SIMP(statut='f',typ='R',defaut= 1.E+4 ),
           ),
           DIS_CONTACT     =FACT(statut='f',
             RIGI_NOR        =SIMP(statut='f',typ='R' ),
             DIST_1          =SIMP(statut='f',typ='R',defaut= 0.E+0 ),
             DIST_2          =SIMP(statut='f',typ='R',defaut= 0.E+0 ),
             RIGI_TAN        =SIMP(statut='f',typ='R',defaut= 0.E+0 ),
             AMOR_NOR        =SIMP(statut='f',typ='R' ),
             AMOR_TAN        =SIMP(statut='f',typ='R' ),
             COULOMB         =SIMP(statut='f',typ='R',defaut= 0.E+0 ),
             JEU             =SIMP(statut='f',typ='R',defaut= 0.E+0 ),
             KT_ULTM         =SIMP(statut='f',typ='R',defaut= 0.E+0 ),
             EFFO_N_INIT     =SIMP(statut='f',typ=(fonction_sdaster,nappe_sdaster,formule)),
             regles=(EXCLUS('RIGI_N_FO','RIGI_N_IRRA',),
                     EXCLUS('RELA_MZ','ANGLE_1'),
                     PRESENT_PRESENT('ANGLE_1','ANGLE_2','ANGLE_3','ANGLE_4',
                                     'MOMENT_1','MOMENT_2','MOMENT_3','MOMENT_4'),),
             RIGI_N_IRRA     =SIMP(statut='f',typ=(fonction_sdaster,nappe_sdaster,formule)),
             RIGI_N_FO       =SIMP(statut='f',typ=(fonction_sdaster,nappe_sdaster,formule)),
             RELA_MZ         =SIMP(statut='f',typ=(fonction_sdaster,nappe_sdaster,formule)),
             ANGLE_1         =SIMP(statut='f',typ=(fonction_sdaster,nappe_sdaster,formule)),
             ANGLE_2         =SIMP(statut='f',typ=(fonction_sdaster,nappe_sdaster,formule)),
             ANGLE_3         =SIMP(statut='f',typ=(fonction_sdaster,nappe_sdaster,formule)),
             ANGLE_4         =SIMP(statut='f',typ=(fonction_sdaster,nappe_sdaster,formule)),
             MOMENT_1        =SIMP(statut='f',typ=(fonction_sdaster,nappe_sdaster,formule)),
             MOMENT_2        =SIMP(statut='f',typ=(fonction_sdaster,nappe_sdaster,formule)),
             MOMENT_3        =SIMP(statut='f',typ=(fonction_sdaster,nappe_sdaster,formule)),
             MOMENT_4        =SIMP(statut='f',typ=(fonction_sdaster,nappe_sdaster,formule)),
             C_PRAGER_MZ     =SIMP(statut='f',typ='R',defaut= 0.E+0 ),
             VERI_P          =SIMP(statut='c',typ='TXM',max='**',defaut=("DRZ","INST","TEMP",) ),
           ),
           DIS_GRICRA    =FACT(statut='f',
             KN_AX       =SIMP(statut='o',typ='R' ),
             KT_AX       =SIMP(statut='o',typ='R' ),
             COUL_AX     =SIMP(statut='o',typ='R' ),
             F_SER       =SIMP(statut='f',typ='R' ),
             F_SER_FO    =SIMP(statut='f',typ=(fonction_sdaster,nappe_sdaster,formule)),
             ET_AX       =SIMP(statut='f',typ='R',defaut=1.e-7 ),
             ET_ROT      =SIMP(statut='f',typ='R',defaut=1.e-7 ),
             ANG1        =SIMP(statut='f',typ='R' ),
             ANG2        =SIMP(statut='f',typ='R' ),
             PEN1        =SIMP(statut='f',typ='R' ),
             PEN2        =SIMP(statut='f',typ='R' ),
             PEN3        =SIMP(statut='f',typ='R' ),
             ANG1_FO     =SIMP(statut='f',typ=(fonction_sdaster,nappe_sdaster,formule)),
             ANG2_FO     =SIMP(statut='f',typ=(fonction_sdaster,nappe_sdaster,formule)),
             PEN1_FO     =SIMP(statut='f',typ=(fonction_sdaster,nappe_sdaster,formule)),
             PEN2_FO     =SIMP(statut='f',typ=(fonction_sdaster,nappe_sdaster,formule)),
             PEN3_FO     =SIMP(statut='f',typ=(fonction_sdaster,nappe_sdaster,formule)),
             regles=(EXCLUS('ANG1','ANG1_FO',),
                     UN_PARMI('ANG1','ANG1_FO',),
                     EXCLUS('F_SER','F_SER_FO',),
                     UN_PARMI('F_SER','F_SER_FO',),
                     PRESENT_PRESENT('ANG1','ANG2','PEN1','PEN2','PEN3',),
                     PRESENT_PRESENT('ANG1_FO','ANG2_FO','PEN1_FO','PEN2_FO','PEN3_FO',),
                                     ),
             VERI_P      =SIMP(statut='c',typ='TXM',max='**',defaut=("DRZ","INST","TEMP",) ),
           ),
           NADAI_B         =FACT(statut='f',
             F_C             =SIMP(statut='o',typ='R'),
             F_T             =SIMP(statut='o',typ='R'),
             CRIT_E_C        =SIMP(statut='o',typ='R'),
             EPSP_P_C        =SIMP(statut='o',typ='R'),
             EPSP_R_C        =SIMP(statut='o',typ='R'),
             EPSI_R_T        =SIMP(statut='o',typ='R'),
             FAC_T_C         =SIMP(statut='o',typ='R'),
           ),
           BETON_DOUBLE_DP =FACT(statut='f',
             F_C             =SIMP(statut='o',typ=(fonction_sdaster,nappe_sdaster,formule)),
             F_T             =SIMP(statut='o',typ=(fonction_sdaster,nappe_sdaster,formule)),
             COEF_BIAX       =SIMP(statut='o',typ=(fonction_sdaster,nappe_sdaster,formule)),
             ENER_COMP_RUPT  =SIMP(statut='o',typ=(fonction_sdaster,nappe_sdaster,formule)),
             ENER_TRAC_RUPT  =SIMP(statut='o',typ=(fonction_sdaster,nappe_sdaster,formule)),
             COEF_ELAS_COMP  =SIMP(statut='o',typ='R'),
             LONG_CARA       =SIMP(statut='f',typ='R'),
             ECRO_COMP_P_PIC =SIMP(statut='f',typ='TXM',defaut="LINEAIRE",into=("LINEAIRE","PARABOLE") ),
             ECRO_TRAC_P_PIC =SIMP(statut='f',typ='TXM',defaut="LINEAIRE",into=("LINEAIRE","EXPONENT") ),
             VERI_P          =SIMP(statut='c',typ='TXM',max='**',defaut=("TEMP","INST","HYDR","SECH",) ),
           ),
           LABORD_1D=FACT(statut='f',min=0 ,
             Y01             =SIMP(statut='o',typ='R'),
             Y02             =SIMP(statut='o',typ='R'),
             A1              =SIMP(statut='o',typ='R'),
             A2              =SIMP(statut='o',typ='R'),
             B1              =SIMP(statut='o',typ='R'),
             B2              =SIMP(statut='o',typ='R'),
             BETA1           =SIMP(statut='o',typ='R'),
             BETA2           =SIMP(statut='o',typ='R'),
             SIGF            =SIMP(statut='o',typ='R'),
           ),
         MAZARS=FACT(statut='f',min=0 ,
             EPSD0           =SIMP(statut='o',typ='R'),
             BETA            =SIMP(statut='o',typ='R'),
             AC              =SIMP(statut='o',typ='R'),
             BC              =SIMP(statut='o',typ='R'),
             AT              =SIMP(statut='o',typ='R'),
             BT              =SIMP(statut='o',typ='R'),
           ),
         MAZARS_FO=FACT(statut='f',min=0 ,
             EPSD0           =SIMP(statut='o',typ=(fonction_sdaster,nappe_sdaster,formule)),
             BETA            =SIMP(statut='o',typ='R'),
             AC              =SIMP(statut='o',typ=(fonction_sdaster,nappe_sdaster,formule)),
             BC              =SIMP(statut='o',typ=(fonction_sdaster,nappe_sdaster,formule)),
             AT              =SIMP(statut='o',typ=(fonction_sdaster,nappe_sdaster,formule)),
             BT              =SIMP(statut='o',typ=(fonction_sdaster,nappe_sdaster,formule)),
             VERI_P          =SIMP(statut='c',typ='TXM',max='**',defaut=("TEMP","SECH","HYDR") ),
           ),
         JOINT_BA=FACT(statut='f',min=0 ,max=1,
             HPEN            =SIMP(statut='o',typ='R',defaut= 1.E+0,val_min=0.E+0),
             GTT             =SIMP(statut='o',typ='R',val_min=0.E+0),
             GAMD0           =SIMP(statut='o',typ='R',val_min=1.E-4,val_max=1.E-1),
             AD1             =SIMP(statut='o',typ='R',val_min=0.E+0),
             BD1             =SIMP(statut='o',typ='R',defaut= 5.E-1,val_min=1.E-1),
             GAMD2           =SIMP(statut='o',typ='R',val_min=1.E-4,val_max=1.E+0),
             AD2             =SIMP(statut='o',typ='R',val_min=0.E+0),
             BD2             =SIMP(statut='o',typ='R',defaut= 1.E+0,val_min=1.E-1),
             VIFROT          =SIMP(statut='o',typ='R',val_min=0.E+0),
             FA              =SIMP(statut='o',typ='R',val_min=0.E+0),
             FC              =SIMP(statut='o',typ='R',val_min=0.E+0),
             EPSTR0          =SIMP(statut='o',typ='R',val_min=1.E-4,val_max=1.E+0),
             ADN             =SIMP(statut='o',typ='R',val_min=0.E+0),
             BDN             =SIMP(statut='o',typ='R',defaut= 1.E+0,val_min=1.E-1),
           ),
          VENDOCHAB       =FACT(statut='f',
             S_VP            =SIMP(statut='o',typ='R'),
             SEDVP1          =SIMP(statut='o',typ='R'),
             SEDVP2          =SIMP(statut='o',typ='R'),
             N_VP            =SIMP(statut='o',typ='R'),
             M_VP            =SIMP(statut='o',typ='R'),
             K_VP            =SIMP(statut='o',typ='R'),
             R_D             =SIMP(statut='o',typ='R'),
             A_D             =SIMP(statut='o',typ='R'),
             K_D             =SIMP(statut='o',typ='R'),
           ),
           VENDOCHAB_FO    =FACT(statut='f',
             S_VP            =SIMP(statut='o',typ=(fonction_sdaster,nappe_sdaster,formule)),
             SEDVP1          =SIMP(statut='o',typ=(fonction_sdaster,nappe_sdaster,formule)),
             SEDVP2          =SIMP(statut='o',typ=(fonction_sdaster,nappe_sdaster,formule)),
             N_VP            =SIMP(statut='o',typ=(fonction_sdaster,nappe_sdaster,formule)),
             M_VP            =SIMP(statut='o',typ=(fonction_sdaster,nappe_sdaster,formule)),
             K_VP            =SIMP(statut='o',typ=(fonction_sdaster,nappe_sdaster,formule)),
             R_D             =SIMP(statut='o',typ=(fonction_sdaster,nappe_sdaster,formule)),
             A_D             =SIMP(statut='o',typ=(fonction_sdaster,nappe_sdaster,formule)),
             K_D             =SIMP(statut='o',typ=(fonction_sdaster,nappe_sdaster,formule)),
             VERI_P          =SIMP(statut='c',typ='TXM',max='**',defaut=("TEMP","X",) ),
           ),
           PINTO_MENEGOTTO =FACT(statut='f',
             SY              =SIMP(statut='o',typ='R'),
             EPSI_ULTM       =SIMP(statut='o',typ='R'),
             SIGM_ULTM       =SIMP(statut='o',typ='R'),
             ELAN            =SIMP(statut='f',typ='R',defaut= 4. ),
             EPSP_HARD       =SIMP(statut='o',typ='R'),
             R_PM            =SIMP(statut='f',typ='R',defaut= 20. ),
             EP_SUR_E        =SIMP(statut='f',typ='R'),
             A1_PM           =SIMP(statut='f',typ='R',defaut= 18.5 ),
             A2_PM           =SIMP(statut='f',typ='R',defaut= 0.15 ),
             A6_PM           =SIMP(statut='f',typ='R',defaut= 620. ),
             C_PM            =SIMP(statut='f',typ='R',defaut= 0.5 ),
             A_PM            =SIMP(statut='f',typ='R',defaut= 6.0E-3 ),
           ),
           BPEL_BETON      =FACT(statut='f',
             PERT_FLUA       =SIMP(statut='f',typ='R',defaut= 0.E+0 ),
             PERT_RETR       =SIMP(statut='f',typ='R',defaut= 0.E+0 ),
           ),
           BPEL_ACIER      =FACT(statut='f',
            regles=(PRESENT_PRESENT('RELAX_1000','F_PRG',),
                     PRESENT_PRESENT('MU0_RELAX','F_PRG',),),
             RELAX_1000      =SIMP(statut='f',typ='R',defaut= 0.E+0 ),
             MU0_RELAX       =SIMP(statut='f',typ='R',defaut= 0.E+0 ),
             F_PRG           =SIMP(statut='f',typ='R'),
             FROT_COURB      =SIMP(statut='f',typ='R',defaut=0.E+0),
             FROT_LINE       =SIMP(statut='f',typ='R',defaut=0.E+0),
           ),
           CAM_CLAY      =FACT(statut='f',
             PORO            =SIMP(statut='o',typ='R'),
             LAMBDA          =SIMP(statut='o',typ='R'),
             KAPA            =SIMP(statut='o',typ='R'),
             M               =SIMP(statut='o',typ='R'),
             PRES_CRIT       =SIMP(statut='o',typ='R'),
             PA              =SIMP(statut='o',typ='R'),
           ),
           BARCELONE      =FACT(statut='f',
             R             =SIMP(statut='o',typ='R'),
             BETA          =SIMP(statut='o',typ='R'),
             KC            =SIMP(statut='o',typ='R'),
             PC0_INIT      =SIMP(statut='o',typ='R'),
             KAPAS         =SIMP(statut='o',typ='R'),
             LAMBDAS       =SIMP(statut='o',typ='R'),
             ALPHAB        =SIMP(statut='f',typ='R'),
           ),
           CJS             =FACT(statut='f',
             BETA_CJS        =SIMP(statut='o',typ='R'),
             RM              =SIMP(statut='o',typ='R'),
             N_CJS           =SIMP(statut='f',typ='R',defaut= 0.E+0 ),
             KP              =SIMP(statut='f',typ='R',defaut= 0.E+0 ),
             RC              =SIMP(statut='f',typ='R',defaut= 0.E+0 ),
             A_CJS           =SIMP(statut='f',typ='R',defaut= 0.E+0 ),
             B_CJS           =SIMP(statut='f',typ='R',defaut= 1.0E+25 ),
             C_CJS           =SIMP(statut='f',typ='R',defaut= 0.E+0 ),
             GAMMA_CJS       =SIMP(statut='o',typ='R'),
             MU_CJS          =SIMP(statut='f',typ='R',defaut= 0.E+0 ),
             PCO             =SIMP(statut='f',typ='R',defaut= 0.E+0 ),
             PA              =SIMP(statut='o',typ='R'),
             Q_INIT          =SIMP(statut='f',typ='R',defaut= 0.E+0 ),
             R_INIT          =SIMP(statut='f',typ='R',defaut= 0.E+0 ),
           ),
           ECRO_ASYM_LINE  =FACT(statut='f',
             DC_SIGM_EPSI    =SIMP(statut='o',typ='R'),
             SY_C            =SIMP(statut='o',typ='R'),
             DT_SIGM_EPSI    =SIMP(statut='o',typ='R'),
             SY_T            =SIMP(statut='o',typ='R'),
           ),
           GRANGER_FP      =FACT(statut='f',
             J1              =SIMP(statut='f',typ='R'),
             J2              =SIMP(statut='f',typ='R'),
             J3              =SIMP(statut='f',typ='R'),
             J4              =SIMP(statut='f',typ='R'),
             J5              =SIMP(statut='f',typ='R'),
             J6              =SIMP(statut='f',typ='R'),
             J7              =SIMP(statut='f',typ='R'),
             J8              =SIMP(statut='f',typ='R'),
             TAUX_1          =SIMP(statut='f',typ='R'),
             TAUX_2          =SIMP(statut='f',typ='R'),
             TAUX_3          =SIMP(statut='f',typ='R'),
             TAUX_4          =SIMP(statut='f',typ='R'),
             TAUX_5          =SIMP(statut='f',typ='R'),
             TAUX_6          =SIMP(statut='f',typ='R'),
             TAUX_7          =SIMP(statut='f',typ='R'),
             TAUX_8          =SIMP(statut='f',typ='R'),
             QSR_K           =SIMP(statut='f',typ='R'),
           ),
           GRANGER_FP_INDT =FACT(statut='f',
             J1              =SIMP(statut='f',typ='R'),
             J2              =SIMP(statut='f',typ='R'),
             J3              =SIMP(statut='f',typ='R'),
             J4              =SIMP(statut='f',typ='R'),
             J5              =SIMP(statut='f',typ='R'),
             J6              =SIMP(statut='f',typ='R'),
             J7              =SIMP(statut='f',typ='R'),
             J8              =SIMP(statut='f',typ='R'),
             TAUX_1          =SIMP(statut='f',typ='R'),
             TAUX_2          =SIMP(statut='f',typ='R'),
             TAUX_3          =SIMP(statut='f',typ='R'),
             TAUX_4          =SIMP(statut='f',typ='R'),
             TAUX_5          =SIMP(statut='f',typ='R'),
             TAUX_6          =SIMP(statut='f',typ='R'),
             TAUX_7          =SIMP(statut='f',typ='R'),
             TAUX_8          =SIMP(statut='f',typ='R'),
           ),
           V_GRANGER_FP    =FACT(statut='f',
             QSR_VEIL        =SIMP(statut='f',typ='R'),
             FONC_V          =SIMP(statut='f',typ=(fonction_sdaster,nappe_sdaster,formule)),
             VERI_P          =SIMP(statut='c',typ='TXM',max='**',defaut=("INST",) ),
           ),
           BAZANT_FD      =FACT(statut='f',
             LAM_VISC      =SIMP(statut='o',typ='R'),
           ),
           BETON_UMLV_FP   =FACT(statut='f',min=0 ,
             K_RS            =SIMP(statut='o',typ='R'),
             ETA_RS          =SIMP(statut='o',typ='R'),
             K_IS            =SIMP(statut='o',typ='R'),
             ETA_IS          =SIMP(statut='o',typ='R'),
             K_RD            =SIMP(statut='o',typ='R'),
             ETA_RD          =SIMP(statut='o',typ='R'),
             ETA_ID          =SIMP(statut='o',typ='R'),
             ETA_FD          =SIMP(statut='f',typ='R'),
           ),
           GLRC_DAMAGE       =FACT(statut='f',min=0,max=1,
             FMEX1           =SIMP(statut='o',typ=(fonction_sdaster)),
             FMEY1           =SIMP(statut='o',typ=(fonction_sdaster)),
             FMEX2           =SIMP(statut='o',typ=(fonction_sdaster)),
             FMEY2           =SIMP(statut='o',typ=(fonction_sdaster)),
             DFMEX1           =SIMP(statut='o',typ=(fonction_sdaster)),
             DFMEY1           =SIMP(statut='o',typ=(fonction_sdaster)),
             DFMEX2           =SIMP(statut='o',typ=(fonction_sdaster)),
             DFMEY2           =SIMP(statut='o',typ=(fonction_sdaster)),
             DDFMEX1           =SIMP(statut='o',typ=(fonction_sdaster)),
             DDFMEY1           =SIMP(statut='o',typ=(fonction_sdaster)),
             DDFMEX2           =SIMP(statut='o',typ=(fonction_sdaster)),
             DDFMEY2           =SIMP(statut='o',typ=(fonction_sdaster)),
             
             CX1             =SIMP(statut='o',typ='R',val_min=0.E+0),
             CY1             =SIMP(statut='o',typ='R',val_min=0.E+0),
             CXY1            =SIMP(statut='o',typ='R',val_min=0.E+0),
             CX2             =SIMP(statut='o',typ='R',val_min=0.E+0),
             CY2             =SIMP(statut='o',typ='R',val_min=0.E+0),
             CXY2            =SIMP(statut='o',typ='R',val_min=0.E+0),
             MF1             =SIMP(statut='o',typ='R',val_min=0.E+0),
             MF2             =SIMP(statut='o',typ='R',val_max=0.E+0),
             QP1             =SIMP(statut='o',typ='R',val_min=0.E+0),
             QP2             =SIMP(statut='o',typ='R',val_min=0.E+0),
             GAMMA           =SIMP(statut='o',typ='R',val_min=0.E+0),
             VERI_P          =SIMP(statut='c',typ='TXM',max='**',defaut=("X ",) ),
           ),
           GLRC_DM         =FACT(statut='f',min=0,max=1,
             GAMMA_T         =SIMP(statut='o',typ='R',val_min=0.E+0,val_max=1.E+0),
             GAMMA_F         =SIMP(statut='o',typ='R',val_min=0.E+0,val_max=1.E+0),
             SYT             =SIMP(statut='o',typ='R',val_min=0.E+0), 
             SYF             =SIMP(statut='o',typ='R',val_min=0.E+0), 
             EF              =SIMP(statut='f',typ='R',val_min=0.E+0), 
             NUF             =SIMP(statut='f',typ='R',val_min=0.E+0,val_max=0.5+0), 
           ),
           GLRC_ACIER        =FACT(statut='f',min=0,max=1,
             AX              =SIMP(statut='o',typ='R',val_min=0.E+0),
             AY              =SIMP(statut='o',typ='R',val_min=0.E+0),
             E               =SIMP(statut='o',typ='R',val_min=0.E+0),
             ENROB           =SIMP(statut='o',typ='R',val_min=0.E+0),
           ),
           GATT_MONERIE    =FACT(statut='f',min=0,max=1,
             D_GRAIN         =SIMP(statut='o',typ='R',val_min=0.E+0),
             PORO_INIT       =SIMP(statut='o',typ='R',val_min=0.E+0),
             EPSI_01         =SIMP(statut='o',typ='R',defaut= 2.7252E-10,val_min=0.E+0),
             EPSI_02         =SIMP(statut='o',typ='R',defaut= 9.1440E-41,val_min=0.E+0),
           ),
           CORR_ACIER   =FACT(statut='f',min=0 ,max=1,
             D_CORR           =SIMP(statut='o',typ='R'),
             ECRO_K           =SIMP(statut='o',typ='R'),
             ECRO_M           =SIMP(statut='o',typ='R'),
             SY              =SIMP(statut='o',typ='R'),
             ),
#
# comportement thermique
#
           THER_NL         =FACT(statut='f',
             regles=(UN_PARMI('BETA','RHO_CP', ),),
             LAMBDA          =SIMP(statut='o',typ=(fonction_sdaster,nappe_sdaster,formule)),
             BETA            =SIMP(statut='f',typ=(fonction_sdaster,nappe_sdaster,formule)),
             RHO_CP          =SIMP(statut='f',typ=(fonction_sdaster,nappe_sdaster,formule)),
             VERI_P          =SIMP(statut='c',typ='TXM',max='**',defaut=("TEMP",) ),
           ),
           THER_HYDR       =FACT(statut='f',
             LAMBDA          =SIMP(statut='o',typ=(fonction_sdaster,nappe_sdaster,formule)),
             BETA            =SIMP(statut='f',typ=(fonction_sdaster,nappe_sdaster,formule)),
             AFFINITE        =SIMP(statut='o',typ=(fonction_sdaster,nappe_sdaster,formule)),
             CHALHYDR        =SIMP(statut='o',typ='R'),
             QSR_K           =SIMP(statut='o',typ='R'),
             VERI_P          =SIMP(statut='c',typ='TXM',max='**',defaut=("HYDR","TEMP",) ),
           ),
           THER            =FACT(statut='f',
             LAMBDA          =SIMP(statut='o',typ='R'),
             RHO_CP          =SIMP(statut='f',typ='R'),
           ),
           THER_FO         =FACT(statut='f',
             LAMBDA          =SIMP(statut='o',typ=(fonction_sdaster,nappe_sdaster,formule)),
             RHO_CP          =SIMP(statut='f',typ=(fonction_sdaster,nappe_sdaster,formule)),
             VERI_P          =SIMP(statut='c',typ='TXM',max='**',defaut=("INST",) ),
           ),
           THER_ORTH       =FACT(statut='f',
             LAMBDA_L        =SIMP(statut='o',typ='R'),
             LAMBDA_T        =SIMP(statut='o',typ='R'),
             LAMBDA_N        =SIMP(statut='f',typ='R'),
             RHO_CP          =SIMP(statut='f',typ='R'),
           ),
           THER_COQUE      =FACT(statut='f',
             COND_LMM        =SIMP(statut='o',typ='R'),
             COND_TMM        =SIMP(statut='o',typ='R'),
             COND_LMP        =SIMP(statut='o',typ='R'),
             COND_TMP        =SIMP(statut='o',typ='R'),
             COND_LPP        =SIMP(statut='o',typ='R'),
             COND_TPP        =SIMP(statut='o',typ='R'),
             COND_LSI        =SIMP(statut='o',typ='R'),
             COND_TSI        =SIMP(statut='o',typ='R'),
             COND_NMM        =SIMP(statut='o',typ='R'),
             COND_NMP        =SIMP(statut='o',typ='R'),
             COND_NPP        =SIMP(statut='o',typ='R'),
             COND_NSI        =SIMP(statut='o',typ='R'),
             CMAS_MM         =SIMP(statut='f',typ='R'),
             CMAS_MP         =SIMP(statut='f',typ='R'),
             CMAS_PP         =SIMP(statut='f',typ='R'),
             CMAS_SI         =SIMP(statut='f',typ='R'),
           ),
           THER_COQUE_FO   =FACT(statut='f',
             COND_LMM        =SIMP(statut='o',typ=(fonction_sdaster,nappe_sdaster,formule)),
             COND_TMM        =SIMP(statut='o',typ=(fonction_sdaster,nappe_sdaster,formule)),
             COND_LMP        =SIMP(statut='o',typ=(fonction_sdaster,nappe_sdaster,formule)),
             COND_TMP        =SIMP(statut='o',typ=(fonction_sdaster,nappe_sdaster,formule)),
             COND_LPP        =SIMP(statut='o',typ=(fonction_sdaster,nappe_sdaster,formule)),
             COND_TPP        =SIMP(statut='o',typ=(fonction_sdaster,nappe_sdaster,formule)),
             COND_LSI        =SIMP(statut='o',typ=(fonction_sdaster,nappe_sdaster,formule)),
             COND_TSI        =SIMP(statut='o',typ=(fonction_sdaster,nappe_sdaster,formule)),
             COND_NMM        =SIMP(statut='o',typ=(fonction_sdaster,nappe_sdaster,formule)),
             COND_NMP        =SIMP(statut='o',typ=(fonction_sdaster,nappe_sdaster,formule)),
             COND_NPP        =SIMP(statut='o',typ=(fonction_sdaster,nappe_sdaster,formule)),
             COND_NSI        =SIMP(statut='o',typ=(fonction_sdaster,nappe_sdaster,formule)),
             CMAS_MM         =SIMP(statut='f',typ=(fonction_sdaster,nappe_sdaster,formule)),
             CMAS_MP         =SIMP(statut='f',typ=(fonction_sdaster,nappe_sdaster,formule)),
             CMAS_PP         =SIMP(statut='f',typ=(fonction_sdaster,nappe_sdaster,formule)),
             CMAS_SI         =SIMP(statut='f',typ=(fonction_sdaster,nappe_sdaster,formule)),
           ),
           SECH_GRANGER    =FACT(statut='f',
             A               =SIMP(statut='o',typ='R'),
             B               =SIMP(statut='o',typ='R'),
             QSR_K           =SIMP(statut='o',typ='R'),
             TEMP_0_C        =SIMP(statut='o',typ='R'),
           ),
           SECH_MENSI      =FACT(statut='f',
             A               =SIMP(statut='o',typ='R'),
             B               =SIMP(statut='o',typ='R'),
           ),
           SECH_BAZANT     =FACT(statut='f',
             D1              =SIMP(statut='o',typ='R'),
             ALPHA_BAZANT    =SIMP(statut='o',typ='R'),
             N               =SIMP(statut='o',typ='R'),
             FONC_DESORP     =SIMP(statut='o',typ=(fonction_sdaster,nappe_sdaster,formule)),
             VERI_P          =SIMP(statut='c',typ='TXM',max='**',defaut=("TEMP",) ),
           ),
           SECH_NAPPE      =FACT(statut='f',
             FONCTION        =SIMP(statut='o',typ=(nappe_sdaster,formule)),
             VERI_P          =SIMP(statut='c',typ='TXM',max='**',defaut=("TEMP","TSEC",) ),
           ),
#
# comportement métallurgique
#
           META_ACIER      =FACT(statut='f',
             TRC             =SIMP(statut='o',typ=(table_sdaster) ),
             AR3             =SIMP(statut='o',typ='R'),
             ALPHA           =SIMP(statut='o',typ='R'),
             MS0             =SIMP(statut='o',typ='R'),
             AC1             =SIMP(statut='o',typ='R'),
             AC3             =SIMP(statut='o',typ='R'),
             TAUX_1          =SIMP(statut='o',typ='R'),
             TAUX_3          =SIMP(statut='o',typ='R'),
             LAMBDA0         =SIMP(statut='f',typ='R'),
             QSR_K           =SIMP(statut='f',typ='R'),
             D10             =SIMP(statut='f',typ='R'),
             WSR_K           =SIMP(statut='f',typ='R'),
           ),
           META_ZIRC       =FACT(statut='f',
             TDEQ            =SIMP(statut='o',typ='R'),
             N               =SIMP(statut='o',typ='R'),
             K               =SIMP(statut='o',typ='R'),
             TDC             =SIMP(statut='o',typ='R'),
             AC              =SIMP(statut='o',typ='R'),
             M               =SIMP(statut='o',typ='R'),
             QSR_K           =SIMP(statut='f',typ='R'),
             TDR             =SIMP(statut='o',typ='R'),
             AR              =SIMP(statut='o',typ='R'),
             BR              =SIMP(statut='o',typ='R'),
           ),
           DURT_META       =FACT(statut='f',
             F1_DURT         =SIMP(statut='o',typ='R'),
             F2_DURT         =SIMP(statut='o',typ='R'),
             F3_DURT         =SIMP(statut='o',typ='R'),
             F4_DURT         =SIMP(statut='o',typ='R'),
             C_DURT          =SIMP(statut='o',typ='R'),
           ),
           ELAS_META       =FACT(statut='f',
             E               =SIMP(statut='o',typ='R'),
             NU              =SIMP(statut='o',typ='R'),
             F_ALPHA         =SIMP(statut='o',typ='R'),
             C_ALPHA         =SIMP(statut='o',typ='R'),
             PHASE_REFE      =SIMP(statut='o',typ='TXM',into=("CHAUD","FROID")),
             EPSF_EPSC_TREF  =SIMP(statut='o',typ='R'),
             PRECISION       =SIMP(statut='f',typ='R',defaut= 1.0E+0),
             F1_SY           =SIMP(statut='f',typ='R'),
             F2_SY           =SIMP(statut='f',typ='R'),
             F3_SY           =SIMP(statut='f',typ='R'),
             F4_SY           =SIMP(statut='f',typ='R'),
             C_SY            =SIMP(statut='f',typ='R'),
             SY_MELANGE      =SIMP(statut='f',typ=(fonction_sdaster,nappe_sdaster,formule)),
             F1_S_VP         =SIMP(statut='f',typ='R'),
             F2_S_VP         =SIMP(statut='f',typ='R'),
             F3_S_VP         =SIMP(statut='f',typ='R'),
             F4_S_VP         =SIMP(statut='f',typ='R'),
             C_S_VP          =SIMP(statut='f',typ='R' ),
             S_VP_MELANGE    =SIMP(statut='f',typ=(fonction_sdaster,nappe_sdaster,formule)),
             VERI_P          =SIMP(statut='c',typ='TXM',max='**',defaut=("META",)),
           ),
           ELAS_META_FO    =FACT(statut='f',
             regles=(
                      PRESENT_PRESENT('F_ALPHA','TEMP_DEF_ALPHA'),
                      PRESENT_PRESENT('C_ALPHA','TEMP_DEF_ALPHA'),
                    ),
             E               =SIMP(statut='o',typ=(fonction_sdaster,nappe_sdaster,formule)),
             NU              =SIMP(statut='o',typ=(fonction_sdaster,nappe_sdaster,formule)),
             F_ALPHA         =SIMP(statut='o',typ=(fonction_sdaster,nappe_sdaster,formule)),
             C_ALPHA         =SIMP(statut='o',typ=(fonction_sdaster,nappe_sdaster,formule)),
             PHASE_REFE      =SIMP(statut='o',typ='TXM',into=("CHAUD","FROID")),
             EPSF_EPSC_TREF  =SIMP(statut='o',typ='R'),
             TEMP_DEF_ALPHA  =SIMP(statut='f',typ='R'),
             PRECISION       =SIMP(statut='f',typ='R',defaut= 1.0E+0),
             F1_SY           =SIMP(statut='f',typ=(fonction_sdaster,nappe_sdaster,formule)),
             F2_SY           =SIMP(statut='f',typ=(fonction_sdaster,nappe_sdaster,formule)),
             F3_SY           =SIMP(statut='f',typ=(fonction_sdaster,nappe_sdaster,formule)),
             F4_SY           =SIMP(statut='f',typ=(fonction_sdaster,nappe_sdaster,formule)),
             C_SY            =SIMP(statut='f',typ=(fonction_sdaster,nappe_sdaster,formule)),
             SY_MELANGE      =SIMP(statut='f',typ=(fonction_sdaster,nappe_sdaster,formule)),
             F1_S_VP         =SIMP(statut='f',typ=(fonction_sdaster,nappe_sdaster,formule)),
             F2_S_VP         =SIMP(statut='f',typ=(fonction_sdaster,nappe_sdaster,formule)),
             F3_S_VP         =SIMP(statut='f',typ=(fonction_sdaster,nappe_sdaster,formule)),
             F4_S_VP         =SIMP(statut='f',typ=(fonction_sdaster,nappe_sdaster,formule)),
             C_S_VP          =SIMP(statut='f',typ=(fonction_sdaster,nappe_sdaster,formule)),
             S_VP_MELANGE    =SIMP(statut='f',typ=(fonction_sdaster,nappe_sdaster,formule)),
             VERI_P          =SIMP(statut='c',typ='TXM',max='**',defaut=("TEMP","META",)),
           ),
           META_ECRO_LINE  =FACT(statut='f',
             F1_D_SIGM_EPSI  =SIMP(statut='f',typ=(fonction_sdaster,nappe_sdaster,formule)),
             F2_D_SIGM_EPSI  =SIMP(statut='f',typ=(fonction_sdaster,nappe_sdaster,formule)),
             F3_D_SIGM_EPSI  =SIMP(statut='f',typ=(fonction_sdaster,nappe_sdaster,formule)),
             F4_D_SIGM_EPSI  =SIMP(statut='f',typ=(fonction_sdaster,nappe_sdaster,formule)),
             C_D_SIGM_EPSI   =SIMP(statut='f',typ=(fonction_sdaster,nappe_sdaster,formule)),
             VERI_P          =SIMP(statut='c',typ='TXM',max='**',defaut=("TEMP",)),
           ),
           META_TRACTION   =FACT(statut='f',
             SIGM_F1         =SIMP(statut='f',typ=(fonction_sdaster,nappe_sdaster,formule)),
             SIGM_F2         =SIMP(statut='f',typ=(fonction_sdaster,nappe_sdaster,formule)),
             SIGM_F3         =SIMP(statut='f',typ=(fonction_sdaster,nappe_sdaster,formule)),
             SIGM_F4         =SIMP(statut='f',typ=(fonction_sdaster,nappe_sdaster,formule)),
             SIGM_C          =SIMP(statut='f',typ=(fonction_sdaster,nappe_sdaster,formule)),
             VERI_P          =SIMP(statut='c',typ='TXM',max='**',defaut=("EPSI","TEMP",)),
           ),
           META_VISC_FO    =FACT(statut='f',
             F1_ETA          =SIMP(statut='f',typ=(fonction_sdaster,nappe_sdaster,formule)),
             F1_N            =SIMP(statut='f',typ=(fonction_sdaster,nappe_sdaster,formule)),
             F1_C            =SIMP(statut='f',typ=(fonction_sdaster,nappe_sdaster,formule)),
             F1_M            =SIMP(statut='f',typ=(fonction_sdaster,nappe_sdaster,formule)),
             F2_ETA          =SIMP(statut='f',typ=(fonction_sdaster,nappe_sdaster,formule)),
             F2_N            =SIMP(statut='f',typ=(fonction_sdaster,nappe_sdaster,formule)),
             F2_C            =SIMP(statut='f',typ=(fonction_sdaster,nappe_sdaster,formule)),
             F2_M            =SIMP(statut='f',typ=(fonction_sdaster,nappe_sdaster,formule)),
             F3_ETA          =SIMP(statut='f',typ=(fonction_sdaster,nappe_sdaster,formule)),
             F3_N            =SIMP(statut='f',typ=(fonction_sdaster,nappe_sdaster,formule)),
             F3_C            =SIMP(statut='f',typ=(fonction_sdaster,nappe_sdaster,formule)),
             F3_M            =SIMP(statut='f',typ=(fonction_sdaster,nappe_sdaster,formule)),
             F4_ETA          =SIMP(statut='f',typ=(fonction_sdaster,nappe_sdaster,formule)),
             F4_N            =SIMP(statut='f',typ=(fonction_sdaster,nappe_sdaster,formule)),
             F4_C            =SIMP(statut='f',typ=(fonction_sdaster,nappe_sdaster,formule)),
             F4_M            =SIMP(statut='f',typ=(fonction_sdaster,nappe_sdaster,formule)),
             C_ETA           =SIMP(statut='f',typ=(fonction_sdaster,nappe_sdaster,formule)),
             C_N             =SIMP(statut='f',typ=(fonction_sdaster,nappe_sdaster,formule)),
             C_C             =SIMP(statut='f',typ=(fonction_sdaster,nappe_sdaster,formule)),
             C_M             =SIMP(statut='f',typ=(fonction_sdaster,nappe_sdaster,formule)),
             VERI_P          =SIMP(statut='c',typ='TXM',max='**',defaut=("TEMP",) ),
           ),
           META_PT         =FACT(statut='f',
             F1_K            =SIMP(statut='f',typ='R'),
             F2_K            =SIMP(statut='f',typ='R'),
             F3_K            =SIMP(statut='f',typ='R'),
             F4_K            =SIMP(statut='f',typ='R'),
             F1_D_F_META     =SIMP(statut='f',typ=(fonction_sdaster,nappe_sdaster,formule)),
             F2_D_F_META     =SIMP(statut='f',typ=(fonction_sdaster,nappe_sdaster,formule)),
             F3_D_F_META     =SIMP(statut='f',typ=(fonction_sdaster,nappe_sdaster,formule)),
             F4_D_F_META     =SIMP(statut='f',typ=(fonction_sdaster,nappe_sdaster,formule)),
             VERI_P          =SIMP(statut='c',typ='TXM',max='**',defaut=("TEMP","META",) ),
           ),
           META_RE         =FACT(statut='f',
             C_F1_THETA      =SIMP(statut='f',typ='R'),
             C_F2_THETA      =SIMP(statut='f',typ='R'),
             C_F3_THETA      =SIMP(statut='f',typ='R'),
             C_F4_THETA      =SIMP(statut='f',typ='R'),
             F1_C_THETA      =SIMP(statut='f',typ='R'),
             F2_C_THETA      =SIMP(statut='f',typ='R'),
             F3_C_THETA      =SIMP(statut='f',typ='R'),
             F4_C_THETA      =SIMP(statut='f',typ='R'),
           ),
#
# comportement fluide
#
           FLUIDE          =FACT(statut='f',
             regles=(EXCLUS('CELE_C','CELE_R'),),
             RHO             =SIMP(statut='o',typ='R'),
             CELE_C          =SIMP(statut='f',typ='C'),
             CELE_R          =SIMP(statut='f',typ='R'),
           ),
           PORO_JOINT      =FACT(statut='f',
             RHO_FLUI        =SIMP(statut='o',typ='R'),
             ENTRO_FLUI      =SIMP(statut='o',typ='R'),
             BIOT_M          =SIMP(statut='o',typ='R'),
             C_0             =SIMP(statut='o',typ='R'),
             T_R             =SIMP(statut='o',typ='R'),
             ALPHA_M         =SIMP(statut='o',typ='R'),
             LAMBDA_T        =SIMP(statut='o',typ='R'),
             LAMBDA_H        =SIMP(statut='o',typ='R'),
             SOURCE_INIT     =SIMP(statut='o',typ='R'),
             OMEGA_0         =SIMP(statut='o',typ='R'),
           ),
# =================================================================================
# COMPORTEMENT THERMO_HYDRO_MECANIQUE
# LES DONNEES NECESSAIRES A LA DEFINITION DU MATERIAU SONT DEPENDANTES
# DE LA LOI DE COUPLAGE THM DE LA RELATION
# LE COMPORTEMENT DE COUPLAGE COMP_THM N EST VALABLE QUE POUR LES LOIS
# DE COUPLAGE : LIQU_SATU,LIQU_GAZ,GAZ,LIQU_GAZ_ATM,LIQU_VAPE_GAZ,LIQU_VAPE
# ET LIQU_AD_GAZ_VAPE
# LA CORRESPONDANCE AVEC LES VARIABLES CACHEES EST LA SUIVANTE :
# 1 -->  LIQU_SATU
# 2 -->  GAZ
# 3 -->  LIQU_VAPE
# 4 -->  LIQU_VAPE_GAZ
# 5 -->  LIQU_GAZ
# 6 -->  LIQU_GAZ_ATM
# 9 -->  LIQU_AD_GAZ_VAPE
# =================================================================================
           COMP_THM        = SIMP(statut='f', typ='TXM',
                                  into = ( "LIQU_SATU"     ,
                                           "LIQU_GAZ"      ,
                                           "GAZ"           ,
                                           "LIQU_GAZ_ATM"  ,
                                           "LIQU_VAPE_GAZ" ,
                                           "LIQU_VAPE"     ,
                                           "LIQU_AD_GAZ_VAPE" ,
                                          ) ),
# =================================================================================
# --- LOI DE COUPLAGE DE TYPE LIQU_SATU -------------------------------------------
# =================================================================================
# --- PRESENCE OBLIGATOIRE DES MOT-CLES SUIVANT : ---------------------------------
# --- THM_INIT, THM_DIFFU, THM_LIQU -----------------------------------------------
# =================================================================================
           b_liqusatu      = BLOC(condition = "COMP_THM == 'LIQU_SATU' ",
                                 fr="Paramètres nécessaires pour une loi de couplage de type LIQU_SATU",
# =================================================================================
# --- MOT-CLE OBLIGATOIRE ---------------------------------------------------------
# =================================================================================
                             THM_INIT   = FACT(statut='o',
# ---------------------------------------------------------------------------------
# -------------------   DONNEES OBLIGATOIRE   -------------------------------------
# ---------------------------------------------------------------------------------
                                           PRE1          = SIMP(statut='o',typ='R'),
                                           PORO          = SIMP(statut='o',typ='R'),
# ---------------------------------------------------------------------------------
# -------------------   DONNEES NECESSAIRE SI THERMIQUE   -------------------------
# ---------------------------------------------------------------------------------
                                           TEMP          = SIMP(statut='f',typ='R'),
# ---------------------------------------------------------------------------------
# -------------------   DONNEES INUTILES   ----------------------------------------
# ---------------------------------------------------------------------------------
                                           PRE2          = SIMP(statut='f',typ='R'),
                                           PRES_VAPE     = SIMP(statut='f',typ='R'),
                                           DEGR_SATU     = SIMP(statut='f',typ='R'),
                                           PRES_ATMO     = SIMP(statut='f',typ='R'),
# ---------------------------------------------------------------------------------
# -------------------   DONNEE CACHEE ---------------------------------------------
# ---------------------------------------------------------------------------------
                                           COMP_THM         = SIMP(statut='c',typ='R',defaut= 1.0,),
                                             ),
# =================================================================================
# --- MOT-CLE OBLIGATOIRE ---------------------------------------------------------
# =================================================================================
                             THM_DIFFU  = FACT(statut='o',
# ---------------------------------------------------------------------------------
# -------------------   DONNEES OBLIGATOIRE   -------------------------------------
# ---------------------------------------------------------------------------------
                                           RHO           = SIMP(statut='o',typ='R'),
                                           BIOT_COEF     = SIMP(statut='o',typ='R'),
                                           PESA_X        = SIMP(statut='o',typ='R'),
                                           PESA_Y        = SIMP(statut='o',typ='R'),
                                           PESA_Z        = SIMP(statut='o',typ='R'),
# ---------------------------------------------------------------------------------
# -------------------   DONNEES NECESSAIRE SI THERMIQUE   -------------------------
# ---------------------------------------------------------------------------------
                                           CP            = SIMP(statut='f',typ='R'),
                                           PERM_IN       = SIMP(statut='f',typ=(fonction_sdaster,nappe_sdaster,formule)),
                                           PERM_END      = SIMP(statut='f',typ=(fonction_sdaster,nappe_sdaster,formule)),
                                                           regles = (EXCLUS('PERM_IN','PERM_END','PERMIN_X',),
                                                            PRESENT_PRESENT('PERMIN_X','PERMIN_Y','PERMIN_Z',), ),
                                           PERMIN_X      =SIMP(statut='f',typ=(fonction_sdaster,nappe_sdaster,formule)),
                                           PERMIN_Y      =SIMP(statut='f',typ=(fonction_sdaster,nappe_sdaster,formule)),
                                           PERMIN_Z      =SIMP(statut='f',typ=(fonction_sdaster,nappe_sdaster,formule)),
                                           LAMB_PHI    = SIMP(statut='f',typ=(fonction_sdaster,nappe_sdaster,formule)),
                                           D_LB_PHI    = SIMP(statut='f',typ=(fonction_sdaster,nappe_sdaster,formule)),
                                           LAMB_T      = SIMP(statut='f',typ=(fonction_sdaster,nappe_sdaster,formule)),
                                           D_LB_T      = SIMP(statut='f',typ=(fonction_sdaster,nappe_sdaster,formule)),
                                           LAMB_S      = SIMP(statut='f',typ=(fonction_sdaster,nappe_sdaster,formule)),
                                           D_LB_S      = SIMP(statut='f',typ=(fonction_sdaster,nappe_sdaster,formule)),
                                           LAMB_CT   = SIMP(statut='f',typ='R'),
# ---------------------------------------------------------------------------------
# -------------------   DONNEES INUTILES   ----------------------------------------
# ---------------------------------------------------------------------------------
                                           R_GAZ         = SIMP(statut='f',typ='R'),
                                           EMMAG           = SIMP(statut='f',typ='R'),
                                           SATU_PRES       =SIMP(statut='f',typ=(fonction_sdaster,nappe_sdaster,formule)),
                                           D_SATU_PRES     =SIMP(statut='f',typ=(fonction_sdaster,nappe_sdaster,formule)),
                                           PERM_LIQU       =SIMP(statut='f',typ=(fonction_sdaster,nappe_sdaster,formule)),
                                           D_PERM_LIQU_SATU=SIMP(statut='f',typ=(fonction_sdaster,nappe_sdaster,formule)),
                                           PERM_GAZ        =SIMP(statut='f',typ=(fonction_sdaster,nappe_sdaster,formule)),
                                           D_PERM_SATU_GAZ =SIMP(statut='f',typ=(fonction_sdaster,nappe_sdaster,formule)),
                                           D_PERM_PRES_GAZ =SIMP(statut='f',typ=(fonction_sdaster,nappe_sdaster,formule)),
                                           SIGMA_T         =SIMP(statut='f',typ=(fonction_sdaster,nappe_sdaster,formule)),
                                           D_SIGMA_T       =SIMP(statut='f',typ=(fonction_sdaster,nappe_sdaster,formule)),
                                           PERM_G_INTR     =SIMP(statut='f',typ=(fonction_sdaster,nappe_sdaster,formule)),
                                           CHAL_VAPO       =SIMP(statut='f',typ=(fonction_sdaster,nappe_sdaster,formule)),
                                           FICKV_T          = SIMP(statut='f',typ=(fonction_sdaster,nappe_sdaster,formule)),
                                           FICKV_PV         = SIMP(statut='f',typ=(fonction_sdaster,nappe_sdaster,formule)),
                                           FICKV_PG         = SIMP(statut='f',typ=(fonction_sdaster,nappe_sdaster,formule)),
                                           FICKV_S          = SIMP(statut='f',typ=(fonction_sdaster,nappe_sdaster,formule)),
                                           D_FV_T           = SIMP(statut='f',typ=(fonction_sdaster,nappe_sdaster,formule)),
                                           D_FV_PG          = SIMP(statut='f',typ=(fonction_sdaster,nappe_sdaster,formule)),
                                           FICKA_T          = SIMP(statut='f',typ=(fonction_sdaster,nappe_sdaster,formule)),
                                           FICKA_PA         = SIMP(statut='f',typ=(fonction_sdaster,nappe_sdaster,formule)),
                                           FICKA_PL         = SIMP(statut='f',typ=(fonction_sdaster,nappe_sdaster,formule)),
                                           FICKA_S          = SIMP(statut='f',typ=(fonction_sdaster,nappe_sdaster,formule)),
                                           D_FA_T           = SIMP(statut='f',typ=(fonction_sdaster,nappe_sdaster,formule)),
# ---------------------------------------------------------------------------------
# -------------------   DONNEES CACHEES -------------------------------------------
# ---------------------------------------------------------------------------------
         VERI_P          =SIMP(statut='c',typ='TXM',defaut=("TEMP","SAT","PORO","PGAZ","PCAP","ENDO",) ),
                                             ),
# =================================================================================
# --- MOT-CLE OBLIGATOIRE ---------------------------------------------------------
# =================================================================================
                             THM_LIQU   = FACT(statut='o',
# ---------------------------------------------------------------------------------
# -------------------   DONNEES OBLIGATOIRE   -------------------------------------
# ---------------------------------------------------------------------------------
                                           RHO           = SIMP(statut='o',typ='R'),
                                           UN_SUR_K      = SIMP(statut='o',typ='R'),
                                           VISC          = SIMP(statut='o',typ=(fonction_sdaster,nappe_sdaster,formule)),
                                           D_VISC_TEMP   = SIMP(statut='o',typ=(fonction_sdaster,nappe_sdaster,formule)),
# ---------------------------------------------------------------------------------
# -------------------   DONNEES NECESSAIRE SI THERMIQUE   -------------------------
# ---------------------------------------------------------------------------------
                                           ALPHA         = SIMP(statut='f',typ='R'),
                                           CP            = SIMP(statut='f',typ='R'),
# ---------------------------------------------------------------------------------
# -------------------   DONNEES CACHEES -------------------------------------------
# ---------------------------------------------------------------------------------
                                           VERI_P        = SIMP(statut='c',typ='TXM',defaut=("TEMP",)),
                                         ),
# =================================================================================
# --- MOT-CLE INUTILE -------------------------------------------------------------
# =================================================================================
           THM_GAZ         =FACT(statut='f',
             MASS_MOL        =SIMP(statut='f',typ='R'),
             CP              =SIMP(statut='f',typ='R'),
             VISC            =SIMP(statut='f',typ=(fonction_sdaster,nappe_sdaster,formule)),
             D_VISC_TEMP     =SIMP(statut='f',typ=(fonction_sdaster,nappe_sdaster,formule)),
             VERI_P          =SIMP(statut='c',typ='TXM',defaut=("TEMP",)),
           ),
# =================================================================================
# --- MOT-CLE INUTILE -------------------------------------------------------------
# =================================================================================
           THM_VAPE_GAZ    =FACT(statut='f',
             MASS_MOL        =SIMP(statut='f',typ='R'),
             CP              =SIMP(statut='f',typ='R'),
             VISC            =SIMP(statut='f',typ=(fonction_sdaster,nappe_sdaster,formule)),
             D_VISC_TEMP     =SIMP(statut='f',typ=(fonction_sdaster,nappe_sdaster,formule)),
             VERI_P          =SIMP(statut='c',typ='TXM',defaut=("TEMP",)),
           ),
                                 ),
# =================================================================================
# --- LOI DE COUPLAGE DE TYPE LIQU_GAZ --------------------------------------------
# =================================================================================
# --- PRESENCE OBLIGATOIRE DES MOT-CLES SUIVANT : ---------------------------------
# --- THM_INIT, THM_DIFFU, THM_LIQU, THM_GAZ --------------------------------------
# =================================================================================
           b_liqugaz      = BLOC(condition = "COMP_THM == 'LIQU_GAZ' ",
                                 fr="Paramètres nécessaires pour une loi de couplage de type LIQU_GAZ",
# =================================================================================
# --- MOT-CLE OBLIGATOIRE ---------------------------------------------------------
# =================================================================================
                             THM_INIT   = FACT(statut='o',
# ---------------------------------------------------------------------------------
# -------------------   DONNEES OBLIGATOIRE   -------------------------------------
# ---------------------------------------------------------------------------------
                                           PRE1             = SIMP(statut='o',typ='R'),
                                           PRE2             = SIMP(statut='o',typ='R'),
                                           PORO             = SIMP(statut='o',typ='R'),
# ---------------------------------------------------------------------------------
# -------------------   DONNEES NECESSAIRE SI THERMIQUE   -------------------------
# ---------------------------------------------------------------------------------
                                           TEMP             = SIMP(statut='f',typ='R'),
# ---------------------------------------------------------------------------------
# -------------------   DONNEES INUTILES   ----------------------------------------
# ---------------------------------------------------------------------------------
                                           PRES_VAPE        = SIMP(statut='f',typ='R'),
                                           DEGR_SATU        = SIMP(statut='f',typ='R'),
                                           PRES_ATMO        = SIMP(statut='f',typ='R'),
# ---------------------------------------------------------------------------------
# -------------------   DONNEE CACHEE ---------------------------------------------
# ---------------------------------------------------------------------------------
                                           COMP_THM         = SIMP(statut='c',typ='R',defaut= 5.0,),
                                             ),
# =================================================================================
# --- MOT-CLE OBLIGATOIRE ---------------------------------------------------------
# =================================================================================
                             THM_DIFFU  = FACT(statut='o',
# ---------------------------------------------------------------------------------
# -------------------   DONNEES OBLIGATOIRE   -------------------------------------
# ---------------------------------------------------------------------------------
                                           R_GAZ            = SIMP(statut='o',typ='R'),
                                           RHO              = SIMP(statut='o',typ='R'),
                                           BIOT_COEF        = SIMP(statut='o',typ='R'),
                                           PESA_X           = SIMP(statut='o',typ='R'),
                                           PESA_Y           = SIMP(statut='o',typ='R'),
                                           PESA_Z           = SIMP(statut='o',typ='R'),
                                           SATU_PRES        = SIMP(statut='o',typ=(fonction_sdaster,nappe_sdaster,formule)),
                                           D_SATU_PRES      = SIMP(statut='o',typ=(fonction_sdaster,nappe_sdaster,formule)),
                                           PERM_LIQU        = SIMP(statut='o',typ=(fonction_sdaster,nappe_sdaster,formule)),
                                           D_PERM_LIQU_SATU = SIMP(statut='o',typ=(fonction_sdaster,nappe_sdaster,formule)),
                                           PERM_GAZ         = SIMP(statut='o',typ=(fonction_sdaster,nappe_sdaster,formule)),
                                           D_PERM_SATU_GAZ  = SIMP(statut='o',typ=(fonction_sdaster,nappe_sdaster,formule)),
                                           D_PERM_PRES_GAZ  = SIMP(statut='o',typ=(fonction_sdaster,nappe_sdaster,formule)),
# ---------------------------------------------------------------------------------
# -------------------   DONNEES NECESSAIRE SI THERMIQUE   -------------------------
# ---------------------------------------------------------------------------------
                                           CP               = SIMP(statut='f',typ='R'),
                                           PERM_IN          = SIMP(statut='f',typ=(fonction_sdaster,nappe_sdaster,formule)),
                                           PERM_END         = SIMP(statut='f',typ=(fonction_sdaster,nappe_sdaster,formule)),
                                                           regles = (EXCLUS('PERM_IN','PERM_END','PERMIN_X',),
                                                            PRESENT_PRESENT('PERMIN_X','PERMIN_Y','PERMIN_Z',), ),
                                           PERMIN_X      =SIMP(statut='f',typ=(fonction_sdaster,nappe_sdaster,formule)),
                                           PERMIN_Y      =SIMP(statut='f',typ=(fonction_sdaster,nappe_sdaster,formule)),
                                           PERMIN_Z      =SIMP(statut='f',typ=(fonction_sdaster,nappe_sdaster,formule)),
                                           LAMB_PHI    = SIMP(statut='f',typ=(fonction_sdaster,nappe_sdaster,formule)),
                                           D_LB_PHI    = SIMP(statut='f',typ=(fonction_sdaster,nappe_sdaster,formule)),
                                           LAMB_T      = SIMP(statut='f',typ=(fonction_sdaster,nappe_sdaster,formule)),
                                           D_LB_T      = SIMP(statut='f',typ=(fonction_sdaster,nappe_sdaster,formule)),
                                           LAMB_S      = SIMP(statut='f',typ=(fonction_sdaster,nappe_sdaster,formule)),
                                           D_LB_S      = SIMP(statut='f',typ=(fonction_sdaster,nappe_sdaster,formule)),
                                           LAMB_CT   = SIMP(statut='f',typ='R'),
# ---------------------------------------------------------------------------------
# -------------------   DONNEES INUTILES   ----------------------------------------
# ---------------------------------------------------------------------------------
                                           EMMAG           = SIMP(statut='f',typ='R'),
                                           SIGMA_T          = SIMP(statut='f',typ=(fonction_sdaster,nappe_sdaster,formule)),
                                           D_SIGMA_T        = SIMP(statut='f',typ=(fonction_sdaster,nappe_sdaster,formule)),
                                           PERM_G_INTR      = SIMP(statut='f',typ=(fonction_sdaster,nappe_sdaster,formule)),
                                           CHAL_VAPO        = SIMP(statut='f',typ=(fonction_sdaster,nappe_sdaster,formule)),
                                           FICKV_T          = SIMP(statut='f',typ=(fonction_sdaster,nappe_sdaster,formule)),
                                           FICKV_PV         = SIMP(statut='f',typ=(fonction_sdaster,nappe_sdaster,formule)),
                                           FICKV_PG         = SIMP(statut='f',typ=(fonction_sdaster,nappe_sdaster,formule)),
                                           FICKV_S          = SIMP(statut='f',typ=(fonction_sdaster,nappe_sdaster,formule)),
                                           D_FV_T           = SIMP(statut='f',typ=(fonction_sdaster,nappe_sdaster,formule)),
                                           D_FV_PG          = SIMP(statut='f',typ=(fonction_sdaster,nappe_sdaster,formule)),
                                           FICKA_T          = SIMP(statut='f',typ=(fonction_sdaster,nappe_sdaster,formule)),
                                           FICKA_PA         = SIMP(statut='f',typ=(fonction_sdaster,nappe_sdaster,formule)),
                                           FICKA_PL         = SIMP(statut='f',typ=(fonction_sdaster,nappe_sdaster,formule)),
                                           FICKA_S          = SIMP(statut='f',typ=(fonction_sdaster,nappe_sdaster,formule)),
                                           D_FA_T           = SIMP(statut='f',typ=(fonction_sdaster,nappe_sdaster,formule)),
# ---------------------------------------------------------------------------------
# -------------------   DONNEES CACHEES -------------------------------------------
# ---------------------------------------------------------------------------------
          VERI_P           = SIMP(statut='c',typ='TXM',defaut=("TEMP","SAT","PORO","PGAZ","PCAP","ENDO",) ),
                                             ) ,
# =================================================================================
# --- MOT-CLE OBLIGATOIRE ---------------------------------------------------------
# =================================================================================
                             THM_LIQU   = FACT(statut='o',
# ---------------------------------------------------------------------------------
# -------------------   DONNEES OBLIGATOIRE   -------------------------------------
# ---------------------------------------------------------------------------------
                                           RHO              = SIMP(statut='o',typ='R'),
                                           UN_SUR_K         = SIMP(statut='o',typ='R'),
                                           VISC             = SIMP(statut='o',typ=(fonction_sdaster,nappe_sdaster,formule)),
                                           D_VISC_TEMP      = SIMP(statut='o',typ=(fonction_sdaster,nappe_sdaster,formule)),
# ---------------------------------------------------------------------------------
# -------------------   DONNEES NECESSAIRE SI THERMIQUE   -------------------------
# ---------------------------------------------------------------------------------
                                           ALPHA            = SIMP(statut='f',typ='R'),
                                           CP               = SIMP(statut='f',typ='R'),
# ---------------------------------------------------------------------------------
# -------------------   DONNEES CACHEES -------------------------------------------
# ---------------------------------------------------------------------------------
                                           VERI_P           = SIMP(statut='c',typ='TXM',defaut=("TEMP",)),
                                             ),
# =================================================================================
# --- MOT-CLE OBLIGATOIRE ---------------------------------------------------------
# =================================================================================
                             THM_GAZ    = FACT(statut='o',
# ---------------------------------------------------------------------------------
# -------------------   DONNEES OBLIGATOIRE   -------------------------------------
# ---------------------------------------------------------------------------------
                                           MASS_MOL        = SIMP(statut='o',typ='R'),
                                           VISC            = SIMP(statut='o',typ=(fonction_sdaster,nappe_sdaster,formule)),
                                           D_VISC_TEMP     = SIMP(statut='o',typ=(fonction_sdaster,nappe_sdaster,formule)),
# ---------------------------------------------------------------------------------
# -------------------   DONNEES NECESSAIRE SI THERMIQUE   -------------------------
# ---------------------------------------------------------------------------------
                                           CP              = SIMP(statut='f',typ='R'),
# ---------------------------------------------------------------------------------
# -------------------   DONNEES CACHEES -------------------------------------------
# ---------------------------------------------------------------------------------
                                           VERI_P          = SIMP(statut='c',typ='TXM',defaut=("TEMP",)),
                                             ),
# =================================================================================
# --- MOT-CLE INUTILE -------------------------------------------------------------
# =================================================================================
           THM_VAPE_GAZ    =FACT(statut='f',
             MASS_MOL        =SIMP(statut='f',typ='R'),
             CP              =SIMP(statut='f',typ='R'),
             VISC            =SIMP(statut='f',typ=(fonction_sdaster,nappe_sdaster,formule)),
             D_VISC_TEMP     =SIMP(statut='f',typ=(fonction_sdaster,nappe_sdaster,formule)),
             VERI_P          =SIMP(statut='c',typ='TXM',defaut=("TEMP",)),
           ),
                                 ),
# =================================================================================
# --- LOI DE COUPLAGE DE TYPE GAZ -------------------------------------------------
# =================================================================================
# --- PRESENCE OBLIGATOIRE DES MOT-CLES SUIVANT : ---------------------------------
# --- THM_INIT, THM_DIFFU, THM_GAZ ------------------------------------------------
# =================================================================================
           b_gaz          = BLOC(condition = "COMP_THM == 'GAZ' ",
                                 fr="Paramètres nécessaires pour une loi de couplage de type GAZ",
# =================================================================================
# --- MOT-CLE OBLIGATOIRE ---------------------------------------------------------
# =================================================================================
                             THM_INIT   = FACT(statut='o',
# ---------------------------------------------------------------------------------
# -------------------   DONNEES OBLIGATOIRE   -------------------------------------
# ---------------------------------------------------------------------------------
                                           TEMP             = SIMP(statut='o',typ='R'),
                                           PRE1             = SIMP(statut='o',typ='R'),
                                           PORO             = SIMP(statut='o',typ='R'),
# ---------------------------------------------------------------------------------
# -------------------   DONNEES INUTILES   ----------------------------------------
# ---------------------------------------------------------------------------------
                                           PRE2             = SIMP(statut='f',typ='R'),
                                           PRES_VAPE        = SIMP(statut='f',typ='R'),
                                           DEGR_SATU        = SIMP(statut='f',typ='R'),
                                           PRES_ATMO        = SIMP(statut='f',typ='R'),
# ---------------------------------------------------------------------------------
# -------------------   DONNEE CACHEE ---------------------------------------------
# ---------------------------------------------------------------------------------
                                           COMP_THM         = SIMP(statut='c',typ='R',defaut= 2.0,),
                                             ),
# =================================================================================
# --- MOT-CLE OBLIGATOIRE ---------------------------------------------------------
# =================================================================================
                             THM_DIFFU  = FACT(statut='o',
# ---------------------------------------------------------------------------------
# -------------------   DONNEES OBLIGATOIRE   -------------------------------------
# ---------------------------------------------------------------------------------
                                           R_GAZ            = SIMP(statut='o',typ='R'),
                                           RHO              = SIMP(statut='o',typ='R'),
                                           BIOT_COEF        = SIMP(statut='o',typ='R'),
                                           PESA_X           = SIMP(statut='o',typ='R'),
                                           PESA_Y           = SIMP(statut='o',typ='R'),
                                           PESA_Z           = SIMP(statut='o',typ='R'),
# ---------------------------------------------------------------------------------
# -------------------   DONNEES NECESSAIRE SI THERMIQUE   -------------------------
# ---------------------------------------------------------------------------------
                                           CP               = SIMP(statut='f',typ='R'),
                                           PERM_IN          = SIMP(statut='f',typ=(fonction_sdaster,nappe_sdaster,formule)),
                                           PERM_END         = SIMP(statut='f',typ=(fonction_sdaster,nappe_sdaster,formule)),
                                                           regles = (EXCLUS('PERM_IN','PERM_END','PERMIN_X',),
                                                            PRESENT_PRESENT('PERMIN_X','PERMIN_Y','PERMIN_Z',), ),
                                           PERMIN_X      =SIMP(statut='f',typ=(fonction_sdaster,nappe_sdaster,formule)),
                                           PERMIN_Y      =SIMP(statut='f',typ=(fonction_sdaster,nappe_sdaster,formule)),
                                           PERMIN_Z      =SIMP(statut='f',typ=(fonction_sdaster,nappe_sdaster,formule)),
                                           LAMB_PHI    = SIMP(statut='f',typ=(fonction_sdaster,nappe_sdaster,formule)),
                                           D_LB_PHI    = SIMP(statut='f',typ=(fonction_sdaster,nappe_sdaster,formule)),
                                           LAMB_T      = SIMP(statut='f',typ=(fonction_sdaster,nappe_sdaster,formule)),
                                           D_LB_T      = SIMP(statut='f',typ=(fonction_sdaster,nappe_sdaster,formule)),
                                           LAMB_S      = SIMP(statut='f',typ=(fonction_sdaster,nappe_sdaster,formule)),
                                           D_LB_S      = SIMP(statut='f',typ=(fonction_sdaster,nappe_sdaster,formule)),
                                           LAMB_CT   = SIMP(statut='f',typ='R'),
# ---------------------------------------------------------------------------------
# -------------------   DONNEES INUTILES   ----------------------------------------
# ---------------------------------------------------------------------------------
                                           EMMAG           = SIMP(statut='f',typ='R'),
                                           SATU_PRES       =SIMP(statut='f',typ=(fonction_sdaster,nappe_sdaster,formule)),
                                           D_SATU_PRES     =SIMP(statut='f',typ=(fonction_sdaster,nappe_sdaster,formule)),
                                           PERM_LIQU       =SIMP(statut='f',typ=(fonction_sdaster,nappe_sdaster,formule)),
                                           D_PERM_LIQU_SATU=SIMP(statut='f',typ=(fonction_sdaster,nappe_sdaster,formule)),
                                           PERM_GAZ        =SIMP(statut='f',typ=(fonction_sdaster,nappe_sdaster,formule)),
                                           D_PERM_SATU_GAZ =SIMP(statut='f',typ=(fonction_sdaster,nappe_sdaster,formule)),
                                           D_PERM_PRES_GAZ =SIMP(statut='f',typ=(fonction_sdaster,nappe_sdaster,formule)),
                                           SIGMA_T         =SIMP(statut='f',typ=(fonction_sdaster,nappe_sdaster,formule)),
                                           D_SIGMA_T       =SIMP(statut='f',typ=(fonction_sdaster,nappe_sdaster,formule)),
                                           PERM_G_INTR     =SIMP(statut='f',typ=(fonction_sdaster,nappe_sdaster,formule)),
                                           CHAL_VAPO       =SIMP(statut='f',typ=(fonction_sdaster,nappe_sdaster,formule)),
                                           FICKV_T          = SIMP(statut='f',typ=(fonction_sdaster,nappe_sdaster,formule)),
                                           FICKV_PV         = SIMP(statut='f',typ=(fonction_sdaster,nappe_sdaster,formule)),
                                           FICKV_PG         = SIMP(statut='f',typ=(fonction_sdaster,nappe_sdaster,formule)),
                                           FICKV_S          = SIMP(statut='f',typ=(fonction_sdaster,nappe_sdaster,formule)),
                                           D_FV_T           = SIMP(statut='f',typ=(fonction_sdaster,nappe_sdaster,formule)),
                                           D_FV_PG          = SIMP(statut='f',typ=(fonction_sdaster,nappe_sdaster,formule)),
                                           FICKA_T          = SIMP(statut='f',typ=(fonction_sdaster,nappe_sdaster,formule)),
                                           FICKA_PA         = SIMP(statut='f',typ=(fonction_sdaster,nappe_sdaster,formule)),
                                           FICKA_PL         = SIMP(statut='f',typ=(fonction_sdaster,nappe_sdaster,formule)),
                                           FICKA_S          = SIMP(statut='f',typ=(fonction_sdaster,nappe_sdaster,formule)),
                                           D_FA_T           = SIMP(statut='f',typ=(fonction_sdaster,nappe_sdaster,formule)),
# ---------------------------------------------------------------------------------
# -------------------   DONNEES CACHEES -------------------------------------------
# ---------------------------------------------------------------------------------
            VERI_P          =SIMP(statut='c',typ='TXM',defaut=("TEMP","SAT","PORO","PGAZ","PCAP","ENDO",) ),
                                             ) ,
# =================================================================================
# --- MOT-CLE OBLIGATOIRE ---------------------------------------------------------
# =================================================================================
                             THM_GAZ    = FACT(statut='o',
# ---------------------------------------------------------------------------------
# -------------------   DONNEES OBLIGATOIRE   -------------------------------------
# ---------------------------------------------------------------------------------
                                           MASS_MOL         = SIMP(statut='o',typ='R'),
                                           VISC             = SIMP(statut='o',typ=(fonction_sdaster,nappe_sdaster,formule)),
                                           D_VISC_TEMP      = SIMP(statut='o',typ=(fonction_sdaster,nappe_sdaster,formule)),
# ---------------------------------------------------------------------------------
# -------------------   DONNEES NECESSAIRE SI THERMIQUE   -------------------------
# ---------------------------------------------------------------------------------
                                           CP               = SIMP(statut='f',typ='R'),
# ---------------------------------------------------------------------------------
# -------------------   DONNEES CACHEES -------------------------------------------
# ---------------------------------------------------------------------------------
                                           VERI_P           = SIMP(statut='c',typ='TXM',defaut=("TEMP",)),
                                             ),
# =================================================================================
# --- MOT-CLE INUTILE -------------------------------------------------------------
# =================================================================================
           THM_LIQU        =FACT(statut='f',
             RHO             =SIMP(statut='f',typ='R'),
             UN_SUR_K        =SIMP(statut='f',typ='R'),
             ALPHA           =SIMP(statut='f',typ='R'),
             CP              =SIMP(statut='f',typ='R'),
             VISC            =SIMP(statut='f',typ=(fonction_sdaster,nappe_sdaster,formule)),
             D_VISC_TEMP     =SIMP(statut='f',typ=(fonction_sdaster,nappe_sdaster,formule)),
             COEF_HENRY      =SIMP(statut='f',typ='R'),
             VERI_P          =SIMP(statut='c',typ='TXM',defaut=("TEMP",)),
           ),
# =================================================================================
# --- MOT-CLE INUTILE -------------------------------------------------------------
# =================================================================================
           THM_VAPE_GAZ    =FACT(statut='f',
             MASS_MOL        =SIMP(statut='f',typ='R'),
             CP              =SIMP(statut='f',typ='R'),
             VISC            =SIMP(statut='f',typ=(fonction_sdaster,nappe_sdaster,formule)),
             D_VISC_TEMP     =SIMP(statut='f',typ=(fonction_sdaster,nappe_sdaster,formule)),
             VERI_P          =SIMP(statut='c',typ='TXM',defaut=("TEMP",)),
           ),
                                 ),
# =================================================================================
# --- LOI DE COUPLAGE DE TYPE LIQU_GAZ_ATM ----------------------------------------
# =================================================================================
# --- PRESENCE OBLIGATOIRE DES MOT-CLES SUIVANT : ---------------------------------
# --- THM_INIT, THM_DIFFU, THM_LIQU, THM_GAZ --------------------------------------
# =================================================================================
           b_liqugazatm   = BLOC(condition = "COMP_THM == 'LIQU_GAZ_ATM' ",
                                 fr="Paramètres nécessaires pour une loi de couplage de type LIQU_GAZ_ATM",
# =================================================================================
# --- MOT-CLE OBLIGATOIRE ---------------------------------------------------------
# =================================================================================
                             THM_INIT   = FACT(statut='o',
# ---------------------------------------------------------------------------------
# -------------------   DONNEES OBLIGATOIRE   -------------------------------------
# ---------------------------------------------------------------------------------
                                           PRE1             = SIMP(statut='o',typ='R'),
                                           PORO             = SIMP(statut='o',typ='R'),
# ---------------------------------------------------------------------------------
# -------------------   DONNEES NECESSAIRE SI THERMIQUE   -------------------------
# ---------------------------------------------------------------------------------
                                           TEMP             = SIMP(statut='f',typ='R'),
# ---------------------------------------------------------------------------------
# -------------------   DONNEES INUTILES   ----------------------------------------
# ---------------------------------------------------------------------------------
                                           PRE2             = SIMP(statut='f',typ='R'),
                                           PRES_VAPE        = SIMP(statut='f',typ='R'),
                                           DEGR_SATU        = SIMP(statut='f',typ='R'),
                                           PRES_ATMO        = SIMP(statut='f',typ='R'),
# ---------------------------------------------------------------------------------
# -------------------   DONNEE CACHEE ---------------------------------------------
# ---------------------------------------------------------------------------------
                                           COMP_THM         = SIMP(statut='c',typ='R',defaut= 6.0,),
                                             ),
# =================================================================================
# --- MOT-CLE OBLIGATOIRE ---------------------------------------------------------
# =================================================================================
                             THM_DIFFU  = FACT(statut='o',
# ---------------------------------------------------------------------------------
# -------------------   DONNEES OBLIGATOIRE   -------------------------------------
# ---------------------------------------------------------------------------------
                                           RHO              = SIMP(statut='o',typ='R'),
                                           BIOT_COEF        = SIMP(statut='o',typ='R'),
                                           PESA_X           = SIMP(statut='o',typ='R'),
                                           PESA_Y           = SIMP(statut='o',typ='R'),
                                           PESA_Z           = SIMP(statut='o',typ='R'),
                                           SATU_PRES        = SIMP(statut='o',typ=(fonction_sdaster,nappe_sdaster,formule)),
                                           D_SATU_PRES      = SIMP(statut='o',typ=(fonction_sdaster,nappe_sdaster,formule)),
                                           PERM_LIQU        = SIMP(statut='o',typ=(fonction_sdaster,nappe_sdaster,formule)),
                                           D_PERM_LIQU_SATU = SIMP(statut='o',typ=(fonction_sdaster,nappe_sdaster,formule)),
# ---------------------------------------------------------------------------------
# -------------------   DONNEES NECESSAIRE SI THERMIQUE   -------------------------
# ---------------------------------------------------------------------------------
                                           CP               = SIMP(statut='f',typ='R'),
                                           PERM_IN          = SIMP(statut='f',typ=(fonction_sdaster,nappe_sdaster,formule)),
                                           PERM_END         = SIMP(statut='f',typ=(fonction_sdaster,nappe_sdaster,formule)),
                                                           regles = (EXCLUS('PERM_IN','PERM_END','PERMIN_X',),
                                                            PRESENT_PRESENT('PERMIN_X','PERMIN_Y','PERMIN_Z',), ),
                                           PERMIN_X      =SIMP(statut='f',typ=(fonction_sdaster,nappe_sdaster,formule)),
                                           PERMIN_Y      =SIMP(statut='f',typ=(fonction_sdaster,nappe_sdaster,formule)),
                                           PERMIN_Z      =SIMP(statut='f',typ=(fonction_sdaster,nappe_sdaster,formule)),
                                           LAMB_PHI    = SIMP(statut='f',typ=(fonction_sdaster,nappe_sdaster,formule)),
                                           D_LB_PHI    = SIMP(statut='f',typ=(fonction_sdaster,nappe_sdaster,formule)),
                                           LAMB_T      = SIMP(statut='f',typ=(fonction_sdaster,nappe_sdaster,formule)),
                                           D_LB_T      = SIMP(statut='f',typ=(fonction_sdaster,nappe_sdaster,formule)),
                                           LAMB_S      = SIMP(statut='f',typ=(fonction_sdaster,nappe_sdaster,formule)),
                                           D_LB_S      = SIMP(statut='f',typ=(fonction_sdaster,nappe_sdaster,formule)),
                                           LAMB_CT   = SIMP(statut='f',typ='R'),
# ---------------------------------------------------------------------------------
# -------------------   DONNEES INUTILES   ----------------------------------------
# ---------------------------------------------------------------------------------
             EMMAG           = SIMP(statut='f',typ='R'),
             R_GAZ           =SIMP(statut='f',typ='R'),
             PERM_GAZ        =SIMP(statut='f',typ=(fonction_sdaster,nappe_sdaster,formule)),
             D_PERM_SATU_GAZ =SIMP(statut='f',typ=(fonction_sdaster,nappe_sdaster,formule)),
             D_PERM_PRES_GAZ =SIMP(statut='f',typ=(fonction_sdaster,nappe_sdaster,formule)),
             SIGMA_T         =SIMP(statut='f',typ=(fonction_sdaster,nappe_sdaster,formule)),
             D_SIGMA_T       =SIMP(statut='f',typ=(fonction_sdaster,nappe_sdaster,formule)),
             PERM_G_INTR     =SIMP(statut='f',typ=(fonction_sdaster,nappe_sdaster,formule)),
             CHAL_VAPO       =SIMP(statut='f',typ=(fonction_sdaster,nappe_sdaster,formule)),
             FICKV_T          = SIMP(statut='f',typ=(fonction_sdaster,nappe_sdaster,formule)),
             FICKV_PV         = SIMP(statut='f',typ=(fonction_sdaster,nappe_sdaster,formule)),
             FICKV_PG         = SIMP(statut='f',typ=(fonction_sdaster,nappe_sdaster,formule)),
             FICKV_S          = SIMP(statut='f',typ=(fonction_sdaster,nappe_sdaster,formule)),
             D_FV_T           = SIMP(statut='f',typ=(fonction_sdaster,nappe_sdaster,formule)),
             D_FV_PG          = SIMP(statut='f',typ=(fonction_sdaster,nappe_sdaster,formule)),
             FICKA_T          = SIMP(statut='f',typ=(fonction_sdaster,nappe_sdaster,formule)),
             FICKA_PA         = SIMP(statut='f',typ=(fonction_sdaster,nappe_sdaster,formule)),
             FICKA_PL         = SIMP(statut='f',typ=(fonction_sdaster,nappe_sdaster,formule)),
             FICKA_S          = SIMP(statut='f',typ=(fonction_sdaster,nappe_sdaster,formule)),
             D_FA_T           = SIMP(statut='f',typ=(fonction_sdaster,nappe_sdaster,formule)),
# ---------------------------------------------------------------------------------
# -------------------   DONNEES CACHEES -------------------------------------------
# ---------------------------------------------------------------------------------
             VERI_P          =SIMP(statut='c',typ='TXM',defaut=("TEMP","SAT","PORO","PGAZ","PCAP","ENDO",) ),
                                             ) ,
# =================================================================================
# --- MOT-CLE OBLIGATOIRE ---------------------------------------------------------
# =================================================================================
                             THM_LIQU   = FACT(statut='o',
# ---------------------------------------------------------------------------------
# -------------------   DONNEES OBLIGATOIRE   -------------------------------------
# ---------------------------------------------------------------------------------
                                           RHO              = SIMP(statut='o',typ='R'),
                                           UN_SUR_K         = SIMP(statut='o',typ='R'),
                                           VISC             = SIMP(statut='o',typ=(fonction_sdaster,nappe_sdaster,formule)),
                                           D_VISC_TEMP      = SIMP(statut='o',typ=(fonction_sdaster,nappe_sdaster,formule)),
# ---------------------------------------------------------------------------------
# -------------------   DONNEES NECESSAIRE SI THERMIQUE   -------------------------
# ---------------------------------------------------------------------------------
                                           ALPHA            = SIMP(statut='f',typ='R'),
                                           CP               = SIMP(statut='f',typ='R'),
# ---------------------------------------------------------------------------------
# -------------------   DONNEES CACHEES -------------------------------------------
# ---------------------------------------------------------------------------------
                                           VERI_P           = SIMP(statut='c',typ='TXM',defaut=("TEMP",)),
                                             ),
# =================================================================================
# --- MOT-CLE INUTILE -------------------------------------------------------------
# =================================================================================
                             THM_GAZ    = FACT(statut='f',
                                           MASS_MOL         = SIMP(statut='f',typ='R'),
                                           VISC             = SIMP(statut='f',typ=(fonction_sdaster,nappe_sdaster,formule)),
                                           D_VISC_TEMP      = SIMP(statut='f',typ=(fonction_sdaster,nappe_sdaster,formule)),
                                           CP               = SIMP(statut='f',typ='R'),
                                           VERI_P           = SIMP(statut='c',typ='TXM',defaut=("TEMP",)),
                                             ),
# =================================================================================
# --- MOT-CLE INUTILE -------------------------------------------------------------
# =================================================================================
           THM_VAPE_GAZ    =FACT(statut='f',
             MASS_MOL        =SIMP(statut='f',typ='R'),
             CP              =SIMP(statut='f',typ='R'),
             VISC            =SIMP(statut='f',typ=(fonction_sdaster,nappe_sdaster,formule)),
             D_VISC_TEMP     =SIMP(statut='f',typ=(fonction_sdaster,nappe_sdaster,formule)),
             VERI_P          =SIMP(statut='c',typ='TXM',defaut=("TEMP",)),
           ),
                                 ),
# =================================================================================
# --- LOI DE COUPLAGE DE TYPE LIQU_VAPE_GAZ ---------------------------------------
# =================================================================================
# --- PRESENCE OBLIGATOIRE DES MOT-CLES SUIVANT : ---------------------------------
# --- THM_INIT, THM_DIFFU, THM_LIQU, THM_GAZ, THM_VAPE_GAZ ------------------------
# =================================================================================
           b_liquvapegaz  = BLOC(condition = "COMP_THM == 'LIQU_VAPE_GAZ' ",
                                 fr="Paramètres nécessaires pour une loi de couplage de type LIQU_VAPE_GAZ",
# =================================================================================
# --- MOT-CLE OBLIGATOIRE ---------------------------------------------------------
# =================================================================================
                             THM_INIT   = FACT(statut='o',
# ---------------------------------------------------------------------------------
# -------------------   DONNEES OBLIGATOIRE   -------------------------------------
# ---------------------------------------------------------------------------------
                                           PRE1             = SIMP(statut='o',typ='R'),
                                           PRE2             = SIMP(statut='o',typ='R'),
                                           PORO             = SIMP(statut='o',typ='R'),
                                           PRES_VAPE        = SIMP(statut='o',typ='R'),
# ---------------------------------------------------------------------------------
# -------------------   DONNEES NECESSAIRE SI THERMIQUE   -------------------------
# ---------------------------------------------------------------------------------
                                           TEMP             = SIMP(statut='f',typ='R'),
# ---------------------------------------------------------------------------------
# -------------------   DONNEES INUTILES   ----------------------------------------
# ---------------------------------------------------------------------------------
                                           DEGR_SATU        = SIMP(statut='f',typ='R'),
                                           PRES_ATMO        = SIMP(statut='f',typ='R'),
# ---------------------------------------------------------------------------------
# -------------------   DONNEE CACHEE ---------------------------------------------
# ---------------------------------------------------------------------------------
                                           COMP_THM         = SIMP(statut='c',typ='R',defaut= 4.0,),
                                             ),
# =================================================================================
# --- MOT-CLE OBLIGATOIRE ---------------------------------------------------------
# =================================================================================
                             THM_DIFFU  = FACT(statut='o',
# ---------------------------------------------------------------------------------
# -------------------   DONNEES OBLIGATOIRE   -------------------------------------
# ---------------------------------------------------------------------------------
                                           R_GAZ            = SIMP(statut='o',typ='R'),
                                           RHO              = SIMP(statut='o',typ='R'),
                                           BIOT_COEF        = SIMP(statut='o',typ='R'),
                                           PESA_X           = SIMP(statut='o',typ='R'),
                                           PESA_Y           = SIMP(statut='o',typ='R'),
                                           PESA_Z           = SIMP(statut='o',typ='R'),
                                           SATU_PRES        = SIMP(statut='o',typ=(fonction_sdaster,nappe_sdaster,formule)),
                                           D_SATU_PRES      = SIMP(statut='o',typ=(fonction_sdaster,nappe_sdaster,formule)),
                                           PERM_LIQU        = SIMP(statut='o',typ=(fonction_sdaster,nappe_sdaster,formule)),
                                           D_PERM_LIQU_SATU = SIMP(statut='o',typ=(fonction_sdaster,nappe_sdaster,formule)),
                                           PERM_GAZ         = SIMP(statut='o',typ=(fonction_sdaster,nappe_sdaster,formule)),
                                           D_PERM_SATU_GAZ  = SIMP(statut='o',typ=(fonction_sdaster,nappe_sdaster,formule)),
                                           D_PERM_PRES_GAZ  = SIMP(statut='o',typ=(fonction_sdaster,nappe_sdaster,formule)),
                                           FICKV_T          = SIMP(statut='o',typ=(fonction_sdaster,nappe_sdaster,formule)),
# ---------------------------------------------------------------------------------
# -------------------   DONNEES NECESSAIRE SI THERMIQUE   -------------------------
# ---------------------------------------------------------------------------------
                                           CP               = SIMP(statut='f',typ='R'),
                                           PERM_IN          = SIMP(statut='f',typ=(fonction_sdaster,nappe_sdaster,formule)),
                                           PERM_END         = SIMP(statut='f',typ=(fonction_sdaster,nappe_sdaster,formule)),
                                                           regles = (EXCLUS('PERM_IN','PERM_END','PERMIN_X',),
                                                            PRESENT_PRESENT('PERMIN_X','PERMIN_Y','PERMIN_Z',), ),
                                           PERMIN_X      =SIMP(statut='f',typ=(fonction_sdaster,nappe_sdaster,formule)),
                                           PERMIN_Y      =SIMP(statut='f',typ=(fonction_sdaster,nappe_sdaster,formule)),
                                           PERMIN_Z      =SIMP(statut='f',typ=(fonction_sdaster,nappe_sdaster,formule)),
                                           LAMB_PHI    = SIMP(statut='f',typ=(fonction_sdaster,nappe_sdaster,formule)),
                                           D_LB_PHI    = SIMP(statut='f',typ=(fonction_sdaster,nappe_sdaster,formule)),
                                           LAMB_T      = SIMP(statut='f',typ=(fonction_sdaster,nappe_sdaster,formule)),
                                           D_LB_T      = SIMP(statut='f',typ=(fonction_sdaster,nappe_sdaster,formule)),
                                           LAMB_S      = SIMP(statut='f',typ=(fonction_sdaster,nappe_sdaster,formule)),
                                           D_LB_S      = SIMP(statut='f',typ=(fonction_sdaster,nappe_sdaster,formule)),
                                           LAMB_CT   = SIMP(statut='f',typ='R'),
# ---------------------------------------------------------------------------------
# -------------------   DONNEES FACULTATIVE   ----------------------------------
# ---------------------------------------------------------------------------------
                                           EMMAG            = SIMP(statut='f',typ='R'),
                                           SIGMA_T          = SIMP(statut='f',typ=(fonction_sdaster,nappe_sdaster,formule)),
                                           D_SIGMA_T        = SIMP(statut='f',typ=(fonction_sdaster,nappe_sdaster,formule)),
                                           PERM_G_INTR      = SIMP(statut='f',typ=(fonction_sdaster,nappe_sdaster,formule)),
                                           CHAL_VAPO        = SIMP(statut='f',typ=(fonction_sdaster,nappe_sdaster,formule)),
                                           FICKV_PV         = SIMP(statut='f',typ=(fonction_sdaster,nappe_sdaster,formule)),
                                           FICKV_PG         = SIMP(statut='f',typ=(fonction_sdaster,nappe_sdaster,formule)),
                                           FICKV_S          = SIMP(statut='f',typ=(fonction_sdaster,nappe_sdaster,formule)),
                                           D_FV_T           = SIMP(statut='f',typ=(fonction_sdaster,nappe_sdaster,formule)),
                                           D_FV_PG          = SIMP(statut='f',typ=(fonction_sdaster,nappe_sdaster,formule)),
# ---------------------------------------------------------------------------------
# -------------------   DONNEES INUTILES   ----------------------------------------
# ---------------------------------------------------------------------------------
                                           FICKA_T          = SIMP(statut='f',typ=(fonction_sdaster,nappe_sdaster,formule)),
                                           FICKA_PA         = SIMP(statut='f',typ=(fonction_sdaster,nappe_sdaster,formule)),
                                           FICKA_PL         = SIMP(statut='f',typ=(fonction_sdaster,nappe_sdaster,formule)),
                                           FICKA_S          = SIMP(statut='f',typ=(fonction_sdaster,nappe_sdaster,formule)),
                                           D_FA_T           = SIMP(statut='f',typ=(fonction_sdaster,nappe_sdaster,formule)),
# ---------------------------------------------------------------------------------
# -------------------   DONNEES CACHEES -------------------------------------------
# ---------------------------------------------------------------------------------
         VERI_P           = SIMP(statut='c',typ='TXM',defaut=("TEMP","SAT" ,"PORO","PGAZ","PCAP","ENDO","PVAP","PLIQ","PAD",) ),
                                             ) ,
# =================================================================================
# --- MOT-CLE OBLIGATOIRE ---------------------------------------------------------
# =================================================================================
                             THM_LIQU   = FACT(statut='o',
# ---------------------------------------------------------------------------------
# -------------------   DONNEES OBLIGATOIRE   -------------------------------------
# ---------------------------------------------------------------------------------
                                           RHO              = SIMP(statut='o',typ='R'),
                                           UN_SUR_K         = SIMP(statut='o',typ='R'),
                                           VISC             = SIMP(statut='o',typ=(fonction_sdaster,nappe_sdaster,formule)),
                                           D_VISC_TEMP      = SIMP(statut='o',typ=(fonction_sdaster,nappe_sdaster,formule)),
# ---------------------------------------------------------------------------------
# -------------------   DONNEES NECESSAIRE SI THERMIQUE   -------------------------
# ---------------------------------------------------------------------------------
                                           ALPHA            = SIMP(statut='f',typ='R'),
                                           CP               = SIMP(statut='f',typ='R'),
# ---------------------------------------------------------------------------------
# -------------------   DONNEES CACHEES -------------------------------------------
# ---------------------------------------------------------------------------------
                                           VERI_P           = SIMP(statut='c',typ='TXM',defaut=("TEMP",)),
                                             ),
# =================================================================================
# --- MOT-CLE OBLIGATOIRE ---------------------------------------------------------
# =================================================================================
                             THM_GAZ    = FACT(statut='o',
# ---------------------------------------------------------------------------------
# -------------------   DONNEES OBLIGATOIRE   -------------------------------------
# ---------------------------------------------------------------------------------
                                           MASS_MOL         = SIMP(statut='o',typ='R'),
                                           VISC             = SIMP(statut='o',typ=(fonction_sdaster,nappe_sdaster,formule)),
                                           D_VISC_TEMP      = SIMP(statut='o',typ=(fonction_sdaster,nappe_sdaster,formule)),
# ---------------------------------------------------------------------------------
# -------------------   DONNEES NECESSAIRE SI THERMIQUE   -------------------------
# ---------------------------------------------------------------------------------
                                           CP               = SIMP(statut='f',typ='R'),
# ---------------------------------------------------------------------------------
# -------------------   DONNEES CACHEES -------------------------------------------
# ---------------------------------------------------------------------------------
                                           VERI_P           = SIMP(statut='c',typ='TXM',defaut=("TEMP",)),
                                             ),
# =================================================================================
# --- MOT-CLE OBLIGATOIRE ---------------------------------------------------------
# =================================================================================
                             THM_VAPE_GAZ = FACT(statut='o',
# ---------------------------------------------------------------------------------
# -------------------   DONNEES OBLIGATOIRE   -------------------------------------
# ---------------------------------------------------------------------------------
                                           MASS_MOL         = SIMP(statut='o',typ='R'),
                                           CP               = SIMP(statut='o',typ='R'),
                                           VISC             = SIMP(statut='o',typ=(fonction_sdaster,nappe_sdaster,formule)),
                                           D_VISC_TEMP      = SIMP(statut='o',typ=(fonction_sdaster,nappe_sdaster,formule)),
# ---------------------------------------------------------------------------------
# -------------------   DONNEES CACHEES -------------------------------------------
# ---------------------------------------------------------------------------------
                                           VERI_P           = SIMP(statut='c',typ='TXM',defaut=("TEMP",)),
                                             ),
                                 ),
# =================================================================================
# --- LOI DE COUPLAGE DE TYPE LIQU_AD_GAZ_VAPE -------------------------------------
# =================================================================================
# --- PRESENCE OBLIGATOIRE DES MOT-CLES SUIVANT : ---------------------------------
# --- THM_INIT, THM_DIFFU, THM_LIQU, THM_GAZ, THM_VAPE_GAZ THM_AIR_DISSOUS---------
# =================================================================================
           b_liquadvape  = BLOC(condition = "COMP_THM == 'LIQU_AD_GAZ_VAPE' ",
                                 fr="Paramètres nécessaires pour une loi de couplage de type LIQU_AD_GAZ_VAPE",
# =================================================================================
# --- MOT-CLE OBLIGATOIRE ---------------------------------------------------------
# =================================================================================
                             THM_INIT   = FACT(statut='o',
# ---------------------------------------------------------------------------------
# -------------------   DONNEES OBLIGATOIRE   -------------------------------------
# ---------------------------------------------------------------------------------
                                           PRE1             = SIMP(statut='o',typ='R'),
                                           PRE2             = SIMP(statut='o',typ='R'),
                                           PORO             = SIMP(statut='o',typ='R'),
                                           PRES_VAPE        = SIMP(statut='o',typ='R'),
# ---------------------------------------------------------------------------------
# -------------------   DONNEES NECESSAIRE SI THERMIQUE   -------------------------
# ---------------------------------------------------------------------------------
                                           TEMP             = SIMP(statut='f',typ='R'),
# ---------------------------------------------------------------------------------
# -------------------   DONNEES INUTILES   ----------------------------------------
# ---------------------------------------------------------------------------------
                                           DEGR_SATU        = SIMP(statut='f',typ='R'),
                                           PRES_ATMO        = SIMP(statut='f',typ='R'),
# ---------------------------------------------------------------------------------
# -------------------   DONNEE CACHEE ---------------------------------------------
# ---------------------------------------------------------------------------------
                                           COMP_THM         = SIMP(statut='c',typ='R',defaut= 9.0,),
                                             ),
# =================================================================================
# --- MOT-CLE OBLIGATOIRE ---------------------------------------------------------
# =================================================================================
                             THM_DIFFU  = FACT(statut='o',
# ---------------------------------------------------------------------------------
# -------------------   DONNEES OBLIGATOIRE   -------------------------------------
# ---------------------------------------------------------------------------------
                                           R_GAZ            = SIMP(statut='o',typ='R'),
                                           RHO              = SIMP(statut='o',typ='R'),
                                           BIOT_COEF        = SIMP(statut='o',typ='R'),
                                           PESA_X           = SIMP(statut='o',typ='R'),
                                           PESA_Y           = SIMP(statut='o',typ='R'),
                                           PESA_Z           = SIMP(statut='o',typ='R'),
                                           SATU_PRES        = SIMP(statut='o',typ=(fonction_sdaster,nappe_sdaster,formule)),
                                           D_SATU_PRES      = SIMP(statut='o',typ=(fonction_sdaster,nappe_sdaster,formule)),
                                           PERM_LIQU        = SIMP(statut='o',typ=(fonction_sdaster,nappe_sdaster,formule)),
                                           D_PERM_LIQU_SATU = SIMP(statut='o',typ=(fonction_sdaster,nappe_sdaster,formule)),
                                           PERM_GAZ         = SIMP(statut='o',typ=(fonction_sdaster,nappe_sdaster,formule)),
                                           D_PERM_SATU_GAZ  = SIMP(statut='o',typ=(fonction_sdaster,nappe_sdaster,formule)),
                                           D_PERM_PRES_GAZ  = SIMP(statut='o',typ=(fonction_sdaster,nappe_sdaster,formule)),
                                           FICKV_T          = SIMP(statut='o',typ=(fonction_sdaster,nappe_sdaster,formule)),
                                           FICKA_T          = SIMP(statut='o',typ=(fonction_sdaster,nappe_sdaster,formule)),
# ---------------------------------------------------------------------------------
# -------------------   DONNEES NECESSAIRE SI THERMIQUE   -------------------------
# ---------------------------------------------------------------------------------
                                           CP               = SIMP(statut='f',typ='R'),
                                           PERM_IN          = SIMP(statut='f',typ=(fonction_sdaster,nappe_sdaster,formule)),
                                           PERM_END         = SIMP(statut='f',typ=(fonction_sdaster,nappe_sdaster,formule)),
                                                           regles = (EXCLUS('PERM_IN','PERM_END','PERMIN_X',),
                                                            PRESENT_PRESENT('PERMIN_X','PERMIN_Y','PERMIN_Z',), ),
                                           PERMIN_X      =SIMP(statut='f',typ=(fonction_sdaster,nappe_sdaster,formule)),
                                           PERMIN_Y      =SIMP(statut='f',typ=(fonction_sdaster,nappe_sdaster,formule)),
                                           PERMIN_Z      =SIMP(statut='f',typ=(fonction_sdaster,nappe_sdaster,formule)),
                                           LAMB_PHI    = SIMP(statut='f',typ=(fonction_sdaster,nappe_sdaster,formule)),
                                           D_LB_PHI    = SIMP(statut='f',typ=(fonction_sdaster,nappe_sdaster,formule)),
                                           LAMB_T      = SIMP(statut='f',typ=(fonction_sdaster,nappe_sdaster,formule)),
                                           D_LB_T      = SIMP(statut='f',typ=(fonction_sdaster,nappe_sdaster,formule)),
                                           LAMB_S      = SIMP(statut='f',typ=(fonction_sdaster,nappe_sdaster,formule)),
                                           D_LB_S      = SIMP(statut='f',typ=(fonction_sdaster,nappe_sdaster,formule)),
                                           LAMB_CT   = SIMP(statut='f',typ='R'),
# ---------------------------------------------------------------------------------
# -------------------   DONNEES FACULTATIVES   ------------------------------------
# ---------------------------------------------------------------------------------
                                           EMMAG            = SIMP(statut='f',typ='R'),
                                           SIGMA_T          = SIMP(statut='f',typ=(fonction_sdaster,nappe_sdaster,formule)),
                                           D_SIGMA_T        = SIMP(statut='f',typ=(fonction_sdaster,nappe_sdaster,formule)),
                                           PERM_G_INTR      = SIMP(statut='f',typ=(fonction_sdaster,nappe_sdaster,formule)),
                                           CHAL_VAPO        = SIMP(statut='f',typ=(fonction_sdaster,nappe_sdaster,formule)),
                                           FICKV_PV         = SIMP(statut='f',typ=(fonction_sdaster,nappe_sdaster,formule)),
                                           FICKV_PG         = SIMP(statut='f',typ=(fonction_sdaster,nappe_sdaster,formule)),
                                           FICKV_S          = SIMP(statut='f',typ=(fonction_sdaster,nappe_sdaster,formule)),
                                           D_FV_T          = SIMP(statut='f',typ=(fonction_sdaster,nappe_sdaster,formule)),
                                           D_FV_PG          = SIMP(statut='f',typ=(fonction_sdaster,nappe_sdaster,formule)),
#
                                           FICKA_PA         = SIMP(statut='f',typ=(fonction_sdaster,nappe_sdaster,formule)),
                                           FICKA_PL         = SIMP(statut='f',typ=(fonction_sdaster,nappe_sdaster,formule)),
                                           FICKA_S          = SIMP(statut='f',typ=(fonction_sdaster,nappe_sdaster,formule)),
                                           D_FA_T          = SIMP(statut='f',typ=(fonction_sdaster,nappe_sdaster,formule)),
# ---------------------------------------------------------------------------------
# -------------------   DONNEES CACHEES -------------------------------------------
# ---------------------------------------------------------------------------------
         VERI_P           = SIMP(statut='c',typ='TXM',defaut=("TEMP","SAT","PORO","PGAZ","PCAP","ENDO","PVAP","PLIQ","PAD",) ),
                                             ) ,
# =================================================================================
# --- MOT-CLE OBLIGATOIRE ---------------------------------------------------------
# =================================================================================
                             THM_LIQU   = FACT(statut='o',
# ---------------------------------------------------------------------------------
# -------------------   DONNEES OBLIGATOIRE   -------------------------------------
# ---------------------------------------------------------------------------------
                                           RHO              = SIMP(statut='o',typ='R'),
                                           UN_SUR_K         = SIMP(statut='o',typ='R'),
                                           VISC             = SIMP(statut='o',typ=(fonction_sdaster,nappe_sdaster,formule)),
                                           D_VISC_TEMP      = SIMP(statut='o',typ=(fonction_sdaster,nappe_sdaster,formule)),
# ---------------------------------------------------------------------------------
# -------------------   DONNEES NECESSAIRE SI THERMIQUE   -------------------------
# ---------------------------------------------------------------------------------
                                           ALPHA            = SIMP(statut='f',typ='R'),
                                           CP               = SIMP(statut='f',typ='R'),
                                           LAMB_PHI    = SIMP(statut='f',typ=(fonction_sdaster,nappe_sdaster,formule)),
                                           D_LB_PHI = SIMP(statut='f',typ=(fonction_sdaster,nappe_sdaster,formule)),
                                           LAMB_T    = SIMP(statut='f',typ=(fonction_sdaster,nappe_sdaster,formule)),
                                           D_LB_T = SIMP(statut='f',typ=(fonction_sdaster,nappe_sdaster,formule)),
                                           LAMB_CT        = SIMP(statut='f',typ='R'),
# ---------------------------------------------------------------------------------
# -------------------   DONNEES CACHEES -------------------------------------------
# ---------------------------------------------------------------------------------
                                           VERI_P           = SIMP(statut='c',typ='TXM',defaut=("TEMP",)),
                                             ),
# =================================================================================
# --- MOT-CLE OBLIGATOIRE ---------------------------------------------------------
# =================================================================================
                             THM_GAZ    = FACT(statut='o',
# ---------------------------------------------------------------------------------
# -------------------   DONNEES OBLIGATOIRE   -------------------------------------
# ---------------------------------------------------------------------------------
                                           MASS_MOL         = SIMP(statut='o',typ='R'),
                                           VISC             = SIMP(statut='o',typ=(fonction_sdaster,nappe_sdaster,formule)),
                                           D_VISC_TEMP      = SIMP(statut='o',typ=(fonction_sdaster,nappe_sdaster,formule)),
# ---------------------------------------------------------------------------------
# -------------------   DONNEES NECESSAIRE SI THERMIQUE   -------------------------
# ---------------------------------------------------------------------------------
                                           CP               = SIMP(statut='f',typ='R'),
# ---------------------------------------------------------------------------------
# -------------------   DONNEES CACHEES -------------------------------------------
# ---------------------------------------------------------------------------------
                                           VERI_P           = SIMP(statut='c',typ='TXM',defaut=("TEMP",)),
                                             ),
# =================================================================================
# --- MOT-CLE OBLIGATOIRE ---------------------------------------------------------
# =================================================================================
                             THM_VAPE_GAZ = FACT(statut='o',
# ---------------------------------------------------------------------------------
# -------------------   DONNEES OBLIGATOIRE   -------------------------------------
# ---------------------------------------------------------------------------------
                                           MASS_MOL         = SIMP(statut='o',typ='R'),
                                           CP               = SIMP(statut='o',typ='R'),
                                           VISC             = SIMP(statut='o',typ=(fonction_sdaster,nappe_sdaster,formule)),
                                           D_VISC_TEMP      = SIMP(statut='o',typ=(fonction_sdaster,nappe_sdaster,formule)),
# ---------------------------------------------------------------------------------
# -------------------   DONNEES CACHEES -------------------------------------------
# ---------------------------------------------------------------------------------
                                           VERI_P           = SIMP(statut='c',typ='TXM',defaut=("TEMP",)),
                                             ),
# =================================================================================
# --- MOT-CLE OBLIGATOIRE ---------------------------------------------------------
# =================================================================================
                             THM_AIR_DISS = FACT(statut='o',
# ---------------------------------------------------------------------------------
# -------------------   DONNEES OBLIGATOIRE   -------------------------------------
# ---------------------------------------------------------------------------------
                                           CP               = SIMP(statut='o',typ='R'),
                                           COEF_HENRY       = SIMP(statut='o',typ=(fonction_sdaster,nappe_sdaster,formule)),
                                           VERI_P      = SIMP(statut='c',typ='TXM',defaut=("TEMP",),),
                                             ),
                                 ),
# =================================================================================
# --- LOI DE COUPLAGE DE TYPE LIQU_VAPE -------------------------------------------
# =================================================================================
# --- PRESENCE OBLIGATOIRE DES MOT-CLES SUIVANT : ---------------------------------
# --- THM_INIT, THM_DIFFU, THM_LIQU, THM_VAPE_GAZ ---------------------------------
# =================================================================================
           b_liquvape  = BLOC(condition = "COMP_THM == 'LIQU_VAPE' ",
                                 fr="Paramètres nécessaires pour une loi de couplage de type LIQU_VAPE",
# =================================================================================
# --- MOT-CLE OBLIGATOIRE ---------------------------------------------------------
# =================================================================================
                             THM_INIT   = FACT(statut='o',
# ---------------------------------------------------------------------------------
# -------------------   DONNEES OBLIGATOIRE   -------------------------------------
# ---------------------------------------------------------------------------------
                                           PRE1             = SIMP(statut='o',typ='R'),
                                           PORO             = SIMP(statut='o',typ='R'),
                                           PRES_VAPE        = SIMP(statut='o',typ='R'),
# ---------------------------------------------------------------------------------
# -------------------   DONNEES NECESSAIRE SI THERMIQUE   -------------------------
# ---------------------------------------------------------------------------------
                                           TEMP             = SIMP(statut='f',typ='R'),
# ---------------------------------------------------------------------------------
# -------------------   DONNEES INUTILES   ----------------------------------------
# ---------------------------------------------------------------------------------
                                           PRE2             = SIMP(statut='f',typ='R'),
                                           DEGR_SATU        = SIMP(statut='f',typ='R'),
                                           PRES_ATMO        = SIMP(statut='f',typ='R'),
# ---------------------------------------------------------------------------------
# -------------------   DONNEE CACHEE ---------------------------------------------
# ---------------------------------------------------------------------------------
                                           COMP_THM         = SIMP(statut='c',typ='R',defaut= 3.0,),
                                             ),
# =================================================================================
# --- MOT-CLE OBLIGATOIRE ---------------------------------------------------------
# =================================================================================
                             THM_DIFFU  = FACT(statut='o',
# ---------------------------------------------------------------------------------
# -------------------   DONNEES OBLIGATOIRE   -------------------------------------
# ---------------------------------------------------------------------------------
                                           R_GAZ            = SIMP(statut='o',typ='R'),
                                           RHO              = SIMP(statut='o',typ='R'),
                                           BIOT_COEF        = SIMP(statut='o',typ='R'),
                                           PESA_X           = SIMP(statut='o',typ='R'),
                                           PESA_Y           = SIMP(statut='o',typ='R'),
                                           PESA_Z           = SIMP(statut='o',typ='R'),
                                           SATU_PRES        = SIMP(statut='o',typ=(fonction_sdaster,nappe_sdaster,formule)),
                                           D_SATU_PRES      = SIMP(statut='o',typ=(fonction_sdaster,nappe_sdaster,formule)),
                                           PERM_LIQU        = SIMP(statut='o',typ=(fonction_sdaster,nappe_sdaster,formule)),
                                           D_PERM_LIQU_SATU = SIMP(statut='o',typ=(fonction_sdaster,nappe_sdaster,formule)),
                                           PERM_GAZ         = SIMP(statut='o',typ=(fonction_sdaster,nappe_sdaster,formule)),
                                           D_PERM_SATU_GAZ  = SIMP(statut='o',typ=(fonction_sdaster,nappe_sdaster,formule)),
                                           D_PERM_PRES_GAZ  = SIMP(statut='o',typ=(fonction_sdaster,nappe_sdaster,formule)),
# ---------------------------------------------------------------------------------
# -------------------   DONNEES NECESSAIRE SI THERMIQUE   -------------------------
# ---------------------------------------------------------------------------------
                                           CP               = SIMP(statut='f',typ='R'),
                                           PERM_IN          = SIMP(statut='f',typ=(fonction_sdaster,nappe_sdaster,formule)),
                                           PERM_END         = SIMP(statut='f',typ=(fonction_sdaster,nappe_sdaster,formule)),
                                                           regles = (EXCLUS('PERM_IN','PERM_END','PERMIN_X',),
                                                            PRESENT_PRESENT('PERMIN_X','PERMIN_Y','PERMIN_Z',), ),
                                           PERMIN_X      =SIMP(statut='f',typ=(fonction_sdaster,nappe_sdaster,formule)),
                                           PERMIN_Y      =SIMP(statut='f',typ=(fonction_sdaster,nappe_sdaster,formule)),
                                           PERMIN_Z      =SIMP(statut='f',typ=(fonction_sdaster,nappe_sdaster,formule)),
                                           LAMB_PHI    = SIMP(statut='f',typ=(fonction_sdaster,nappe_sdaster,formule)),
                                           D_LB_PHI    = SIMP(statut='f',typ=(fonction_sdaster,nappe_sdaster,formule)),
                                           LAMB_T      = SIMP(statut='f',typ=(fonction_sdaster,nappe_sdaster,formule)),
                                           D_LB_T      = SIMP(statut='f',typ=(fonction_sdaster,nappe_sdaster,formule)),
                                           LAMB_S      = SIMP(statut='f',typ=(fonction_sdaster,nappe_sdaster,formule)),
                                           D_LB_S      = SIMP(statut='f',typ=(fonction_sdaster,nappe_sdaster,formule)),
                                           LAMB_CT   = SIMP(statut='f',typ='R'),
# ---------------------------------------------------------------------------------
# -------------------   DONNEES INUTILES   ----------------------------------------
# ---------------------------------------------------------------------------------
                                           EMMAG            = SIMP(statut='f',typ='R'),
                                           SIGMA_T          = SIMP(statut='f',typ=(fonction_sdaster,nappe_sdaster,formule)),
                                           D_SIGMA_T        = SIMP(statut='f',typ=(fonction_sdaster,nappe_sdaster,formule)),
                                           PERM_G_INTR      = SIMP(statut='f',typ=(fonction_sdaster,nappe_sdaster,formule)),
                                           CHAL_VAPO        = SIMP(statut='f',typ=(fonction_sdaster,nappe_sdaster,formule)),
                                           FICKV_T          = SIMP(statut='f',typ=(fonction_sdaster,nappe_sdaster,formule)),
                                           FICKV_PV         = SIMP(statut='f',typ=(fonction_sdaster,nappe_sdaster,formule)),
                                           FICKV_PG         = SIMP(statut='f',typ=(fonction_sdaster,nappe_sdaster,formule)),
                                           FICKV_S          = SIMP(statut='f',typ=(fonction_sdaster,nappe_sdaster,formule)),
                                           D_FV_T           = SIMP(statut='f',typ=(fonction_sdaster,nappe_sdaster,formule)),
                                           D_FV_PG          = SIMP(statut='f',typ=(fonction_sdaster,nappe_sdaster,formule)),
                                           FICKA_T          = SIMP(statut='f',typ=(fonction_sdaster,nappe_sdaster,formule)),
                                           FICKA_PA         = SIMP(statut='f',typ=(fonction_sdaster,nappe_sdaster,formule)),
                                           FICKA_PL         = SIMP(statut='f',typ=(fonction_sdaster,nappe_sdaster,formule)),
                                           FICKA_S          = SIMP(statut='f',typ=(fonction_sdaster,nappe_sdaster,formule)),
                                           D_FA_T           = SIMP(statut='f',typ=(fonction_sdaster,nappe_sdaster,formule)),
# ---------------------------------------------------------------------------------
# -------------------   DONNEES CACHEES -------------------------------------------
# ---------------------------------------------------------------------------------
            VERI_P           = SIMP(statut='c',typ='TXM',defaut=("TEMP","SAT","PORO","PGAZ","PCAP","ENDO",) ),
                                             ) ,
# =================================================================================
# --- MOT-CLE OBLIGATOIRE ---------------------------------------------------------
# =================================================================================
                             THM_LIQU   = FACT(statut='o',
# ---------------------------------------------------------------------------------
# -------------------   DONNEES OBLIGATOIRE   -------------------------------------
# ---------------------------------------------------------------------------------
                                           RHO              = SIMP(statut='o',typ='R'),
                                           UN_SUR_K         = SIMP(statut='o',typ='R'),
                                           VISC             = SIMP(statut='o',typ=(fonction_sdaster,nappe_sdaster,formule)),
                                           D_VISC_TEMP      = SIMP(statut='o',typ=(fonction_sdaster,nappe_sdaster,formule)),
# ---------------------------------------------------------------------------------
# -------------------   DONNEES NECESSAIRE SI THERMIQUE   -------------------------
# ---------------------------------------------------------------------------------
                                           ALPHA            = SIMP(statut='f',typ='R'),
                                           CP               = SIMP(statut='f',typ='R'),
# ---------------------------------------------------------------------------------
# -------------------   DONNEES CACHEES ---------------------------------------------
# ---------------------------------------------------------------------------------
                                           VERI_P           = SIMP(statut='c',typ='TXM',defaut=("TEMP",)),
                                             ),
# =================================================================================
# --- MOT-CLE OBLIGATOIRE ---------------------------------------------------------
# =================================================================================
                             THM_VAPE_GAZ = FACT(statut='o',
# ---------------------------------------------------------------------------------
# -------------------   DONNEES OBLIGATOIRE   -------------------------------------
# ---------------------------------------------------------------------------------
                                           MASS_MOL         = SIMP(statut='o',typ='R'),
                                           CP               = SIMP(statut='o',typ='R'),
                                           VISC             = SIMP(statut='o',typ=(fonction_sdaster,nappe_sdaster,formule)),
                                           D_VISC_TEMP      = SIMP(statut='o',typ=(fonction_sdaster,nappe_sdaster,formule)),
# ---------------------------------------------------------------------------------
# -------------------   DONNEES CACHEES -------------------------------------------
# ---------------------------------------------------------------------------------
                                           VERI_P           = SIMP(statut='c',typ='TXM',defaut=("TEMP",)),
                                             ),
# =================================================================================
# --- MOT-CLE INUTILE -------------------------------------------------------------
# =================================================================================
           THM_GAZ         =FACT(statut='f',
             MASS_MOL        =SIMP(statut='f',typ='R'),
             CP              =SIMP(statut='f',typ='R'),
             VISC            =SIMP(statut='f',typ=(fonction_sdaster,nappe_sdaster,formule)),
             D_VISC_TEMP     =SIMP(statut='f',typ=(fonction_sdaster,nappe_sdaster,formule)),
             VERI_P          =SIMP(statut='c',typ='TXM',defaut=("TEMP",)),
           ),
                                 ),
# courbes et coefficients associés à la fatigue et au dommage
#
           FATIGUE         =FACT(statut='f',
             regles=(PRESENT_ABSENT('WOHLER','A_BASQUIN','BETA_BASQUIN'),
                     PRESENT_ABSENT('WOHLER','A0','A1','A2','A3','SL'),
                     PRESENT_ABSENT('A_BASQUIN','A0','A1','A2','A3','SL'),
                     ENSEMBLE('A_BASQUIN','BETA_BASQUIN'),
                     ENSEMBLE('A0','A1','A2','A3','SL'),
                     PRESENT_PRESENT('A0','E_REFE'),
                     ENSEMBLE('D0','TAU0'),),
             WOHLER          =SIMP(statut='f',typ=(fonction_sdaster,nappe_sdaster,formule)),
             A_BASQUIN       =SIMP(statut='f',typ='R'),
             BETA_BASQUIN    =SIMP(statut='f',typ='R'),
             A0              =SIMP(statut='f',typ='R'),
             A1              =SIMP(statut='f',typ='R'),
             A2              =SIMP(statut='f',typ='R'),
             A3              =SIMP(statut='f',typ='R'),
             SL              =SIMP(statut='f',typ='R'),
             MANSON_COFFIN   =SIMP(statut='f',typ=(fonction_sdaster,nappe_sdaster,formule)),
             E_REFE          =SIMP(statut='f',typ='R'),
             D0              =SIMP(statut='f',typ='R'),
             TAU0            =SIMP(statut='f',typ='R'),
             VERI_P          =SIMP(statut='c',typ='TXM',max='**',defaut=("SIGM","EPSI",) ),
           ),
           DOMMA_LEMAITRE  =FACT(statut='f',
             S               =SIMP(statut='o',typ=(fonction_sdaster,nappe_sdaster,formule)),
             EPSP_SEUIL      =SIMP(statut='o',typ=(fonction_sdaster,nappe_sdaster,formule)),
             EXP_S           =SIMP(statut='f',typ='R',val_min=0.0E0,defaut=1.0),
             VERI_P          =SIMP(statut='c',typ='TXM',max='**',defaut=("TEMP",) ),
           ),
           CISA_PLAN_CRIT  =FACT(statut='f',
             CRITERE       =SIMP(statut='o',typ='TXM',into=("MATAKE_MODI_AC",
                                                            "DANG_VAN_MODI_AC",
                                                            "DANG_VAN_MODI_AV",
                                                            "MATAKE_MODI_AV",
                                                            "FATESOCI_MODI_AV",
                                                            ) ),

             b_critere_matake =BLOC(condition="CRITERE=='MATAKE_MODI_AC' or CRITERE=='MATAKE_MODI_AV'",
                         fr="Cisaillement plan critique critère de matake pour les cas amplitude constante et amplitude variable",
               MATAKE_A         =SIMP(statut='o',typ='R'),
               MATAKE_B         =SIMP(statut='o',typ='R'),
               COEF_FLEX_TORS   =SIMP(statut='o',typ='R',val_min=1.0E0,val_max=1.7321E0),
             ),

             b_critere_dang_van =BLOC(condition="(CRITERE=='DANG_VAN_MODI_AC' or CRITERE=='DANG_VAN_MODI_AV')",
                                 fr="Critère de Dang Van modifié pour les cas amplitude constante et amplitude variable",
               D_VAN_A            =SIMP(statut='o',typ='R'),
               D_VAN_B            =SIMP(statut='o',typ='R'),
               COEF_CISA_TRAC     =SIMP(statut='o',typ='R',val_min=1.0E0,val_max=1.7321E0),
             ),

             b_critere_fate_soci =BLOC(condition="CRITERE=='FATESOCI_MODI_AV'",
                               fr="Critère de Fatemi et Socie, en élasticité ou élastoplasticité, pour le cas amplitude variable",
               FATSOC_A           =SIMP(statut='o',typ='R'),
               COEF_CISA_TRAC     =SIMP(statut='o',typ='R',val_min=1.0E0,val_max=1.7321E0),
             ),
           ),
#
# autres comportements ...
#
           WEIBULL         =FACT(statut='f',
             M               =SIMP(statut='o',typ='R'),
             VOLU_REFE       =SIMP(statut='o',typ='R'),
             SIGM_REFE       =SIMP(statut='o',typ='R'),
             SEUIL_EPSP_CUMU =SIMP(statut='f',typ='R',defaut= 1.0E-6),
           ),
           WEIBULL_FO      =FACT(statut='f',
             M               =SIMP(statut='o',typ='R'),
             VOLU_REFE       =SIMP(statut='o',typ='R'),
             SIGM_CNV        =SIMP(statut='o',typ='R'),
             SIGM_REFE       =SIMP(statut='o',typ=(fonction_sdaster,nappe_sdaster,formule)),
             SEUIL_EPSP_CUMU =SIMP(statut='f',typ='R',defaut= 1.0E-6),
             VERI_P          =SIMP(statut='c',typ='TXM',max='**',defaut=("TEMP",) ),
           ),
           NON_LOCAL       =FACT(statut='f',
             LONG_CARA       =SIMP(statut='o',typ='R'),
             COEF_RIGI_MINI  =SIMP(statut='f',typ='R'),
           ),
           RUPT_FRAG       =FACT(statut='f',
             GC              =SIMP(statut='o',typ='R'),
             SIGM_C          =SIMP(statut='f',typ='R'),
             PENA_ADHERENCE  =SIMP(statut='f',typ='R'),
             PENA_CONTACT    =SIMP(statut='f',typ='R',defaut=1.),
           ),
           RUPT_FRAG_FO   =FACT(statut='f',
             GC              =SIMP(statut='o',typ=(fonction_sdaster,nappe_sdaster,formule)),
             SIGM_C          =SIMP(statut='f',typ=(fonction_sdaster,nappe_sdaster,formule)),
             PENA_ADHERENCE  =SIMP(statut='f',typ=(fonction_sdaster,nappe_sdaster,formule)),
             PENA_CONTACT    =SIMP(statut='f',typ='R',defaut=1.),
             VERI_P          =SIMP(statut='c',typ='TXM',max='**',defaut=("TEMP",) ),
           ),
           RCCM            =FACT(statut='f',
             SY_02           =SIMP(statut='f',typ='R'),
             SM              =SIMP(statut='f',typ='R'),
             SU              =SIMP(statut='f',typ='R'),
             SC              =SIMP(statut='f',typ='R'),
             SH              =SIMP(statut='f',typ='R'),
             N_KE            =SIMP(statut='f',typ='R'),
             M_KE            =SIMP(statut='f',typ='R'),
           ),
           RCCM_FO         =FACT(statut='f',
             SY_02           =SIMP(statut='f',typ=(fonction_sdaster,nappe_sdaster,formule)),
             SM              =SIMP(statut='f',typ=(fonction_sdaster,nappe_sdaster,formule)),
             SU              =SIMP(statut='f',typ=(fonction_sdaster,nappe_sdaster,formule)),
             S               =SIMP(statut='f',typ=(fonction_sdaster,nappe_sdaster,formule)),
             N_KE            =SIMP(statut='f',typ=(fonction_sdaster,nappe_sdaster,formule)),
             M_KE            =SIMP(statut='f',typ=(fonction_sdaster,nappe_sdaster,formule)),
             VERI_P          =SIMP(statut='c',typ='TXM',max='**',defaut=("TEMP",) ),
           ),
           LAIGLE          =FACT(statut='f',
             GAMMA_ULT       =SIMP(statut='o',typ='R'),
             GAMMA_E         =SIMP(statut='o',typ='R'),
             M_ULT           =SIMP(statut='o',typ='R'),
             M_E             =SIMP(statut='o',typ='R'),
             A_E             =SIMP(statut='o',typ='R'),
             M_PIC           =SIMP(statut='o',typ='R'),
             A_PIC           =SIMP(statut='o',typ='R'),
             ETA             =SIMP(statut='o',typ='R'),
             SIGMA_C         =SIMP(statut='o',typ='R'),
             GAMMA           =SIMP(statut='o',typ='R'),
             KSI             =SIMP(statut='o',typ='R'),
             GAMMA_CJS       =SIMP(statut='o',typ='R'),
             SIGMA_P1        =SIMP(statut='o',typ='R'),
             PA              =SIMP(statut='o',typ='R'),
           ),
           DRUCK_PRAGER  =FACT(statut='f',
             ALPHA           =SIMP(statut='o',typ='R'),
             SY              =SIMP(statut='o',typ='R'),
             P_ULTM          =SIMP(statut='o',typ='R'),
             ECROUISSAGE = SIMP(statut='o',typ='TXM',into=("LINEAIRE","PARABOLIQUE")),
             b_lineaire =BLOC(condition="ECROUISSAGE=='LINEAIRE'",
                                    fr="Loi de comportement de type Drucker Prager avec un ecrouissage lineaire",
                    H               =SIMP(statut='o',typ='R'),
                    TYPE_DP         =SIMP(statut='c',typ='R',defaut= 1.0,),
             ),
             b_parabolique =BLOC(condition="ECROUISSAGE=='PARABOLIQUE'",
                                    fr="Loi de comportement de type Drucker Prager avec un ecrouissage parabolique",
                    SY_ULTM         =SIMP(statut='o',typ='R'),
                    TYPE_DP         =SIMP(statut='c',typ='R',defaut= 2.0,),
             ),
           ),
           HOEK_BROWN          =FACT(statut='f',
             GAMMA_RUP       =SIMP(statut='o',typ='R'),
             GAMMA_RES       =SIMP(statut='o',typ='R'),
             S_END           =SIMP(statut='o',typ='R'),
             S_RUP           =SIMP(statut='o',typ='R'),
             M_END           =SIMP(statut='o',typ='R'),
             M_RUP           =SIMP(statut='o',typ='R'),
             BETA            =SIMP(statut='o',typ='R'),
             ALPHAHB         =SIMP(statut='o',typ='R'),
             PHI_RUP         =SIMP(statut='o',typ='R'),
             PHI_RES         =SIMP(statut='o',typ='R'),
             PHI_END         =SIMP(statut='f',typ='R'),
           ),
####  MONOCRISTAL

           ECOU_VISC1      =FACT(statut='f',
             TYPE_PARA       =SIMP(statut='f',typ='TXM',into=("ECOU_VISC",),),
             N               =SIMP(statut='o',typ='R'),
             K               =SIMP(statut='o',typ='R'),
             C               =SIMP(statut='o',typ='R'),
           ),
           ECOU_VISC2      =FACT(statut='f',
             TYPE_PARA       =SIMP(statut='f',typ='TXM',into=("ECOU_VISC",),),
             N               =SIMP(statut='o',typ='R'),
             K               =SIMP(statut='o',typ='R'),
             C               =SIMP(statut='o',typ='R'),
             D               =SIMP(statut='o',typ='R'),
             A               =SIMP(statut='o',typ='R'),
           ),
           ECOU_VISC3      =FACT(statut='f',
             TYPE_PARA       =SIMP(statut='f',typ='TXM',into=("ECOU_VISC",),),
             K               =SIMP(statut='o',typ='R',fr="Constante de Boltzmann, en eV/K"),
             TAUMU           =SIMP(statut='o',typ='R',fr="Seuil d ecoulement, en unite de contraintes"),
             GAMMA0          =SIMP(statut='o',typ='R',fr="Vitesse d ecoulement initiale"),
             DELTAV          =SIMP(statut='o',typ='R',fr="Volume d activation"),
             DELTAG0         =SIMP(statut='o',typ='R',fr="Gain d energie lie au franchissement d obstacle"),
           ),
           ECRO_ISOT1      =FACT(statut='f',
              regles=(UN_PARMI('H','H1'),
                      PRESENT_PRESENT('H1','H2','H3','H4'),
                      PRESENT_ABSENT('H','H1','H2','H3','H4','H5','H6'),
                      ),
             TYPE_PARA       =SIMP(statut='f',typ='TXM',into=("ECRO_ISOT",),),
             R_0             =SIMP(statut='o',typ='R'),
             Q               =SIMP(statut='o',typ='R'),
             B               =SIMP(statut='o',typ='R'),
             H               =SIMP(statut='f',typ='R'),
             H1              =SIMP(statut='f',typ='R'),
             H2              =SIMP(statut='f',typ='R'),
             H3              =SIMP(statut='f',typ='R'),
             H4              =SIMP(statut='f',typ='R'),
             H5              =SIMP(statut='f',typ='R'),
             H6              =SIMP(statut='f',typ='R'),
           ),
           ECRO_ISOT2      =FACT(statut='f',
              regles=(UN_PARMI('H','H1'),
                      PRESENT_PRESENT('H1','H2','H3','H4'),
                      PRESENT_ABSENT('H','H1','H2','H3','H4','H5','H6'),
                      ),
             TYPE_PARA       =SIMP(statut='f',typ='TXM',into=("ECRO_ISOT",),),
             R_0             =SIMP(statut='o',typ='R'),
             Q1              =SIMP(statut='o',typ='R'),
             B1              =SIMP(statut='o',typ='R'),
             H               =SIMP(statut='f',typ='R'),
             H1              =SIMP(statut='f',typ='R'),
             H2              =SIMP(statut='f',typ='R'),
             H3              =SIMP(statut='f',typ='R'),
             H4              =SIMP(statut='f',typ='R'),
             H5              =SIMP(statut='f',typ='R'),
             H6              =SIMP(statut='f',typ='R'),
             Q2              =SIMP(statut='o',typ='R'),
             B2              =SIMP(statut='o',typ='R'),
           ),
           ECRO_CINE1      =FACT(statut='f',
             TYPE_PARA       =SIMP(statut='f',typ='TXM',into=("ECRO_CINE",),),
             D               =SIMP(statut='o',typ='R'),
           ),
           ECRO_CINE2      =FACT(statut='f',
             TYPE_PARA       =SIMP(statut='f',typ='TXM',into=("ECRO_CINE",),),
             D               =SIMP(statut='o',typ='R'),
             GM              =SIMP(statut='o',typ='R'),
             PM              =SIMP(statut='o',typ='R'),
             C               =SIMP(statut='o',typ='R'),
           ),

####  MONOCRISTAL

           DRUCK_PRAGER_FO  =FACT(statut='f',
             ALPHA           =SIMP(statut='o',typ=(fonction_sdaster,formule)),
             SY              =SIMP(statut='o',typ=(fonction_sdaster,formule)),
             P_ULTM          =SIMP(statut='o',typ=(fonction_sdaster,formule)),
             ECROUISSAGE = SIMP(statut='o',typ='TXM',into=("LINEAIRE","PARABOLIQUE")),
             b_lineaire =BLOC(condition="ECROUISSAGE=='LINEAIRE'",
                                    fr="Loi de comportement de type Drucker Prager avec un ecrouissage lineaire",
                    H               =SIMP(statut='o',typ=(fonction_sdaster,formule)),
                    TYPE_DP         =SIMP(statut='c',typ='R',defaut= 1.0,),
             ),
             b_parabolique =BLOC(condition="ECROUISSAGE=='PARABOLIQUE'",
                                    fr="Loi de comportement de type Drucker Prager avec un ecrouissage parabolique",
                    SY_ULTM         =SIMP(statut='o',typ=(fonction_sdaster,formule)),
                    TYPE_DP         =SIMP(statut='c',typ='R',defaut= 2.0,),
             ),
           ),


           INFO            =SIMP(statut='f',typ='I',defaut=1,into=(1,2) ),
)  ;
#& MODIF COMMANDE  DATE 22/06/2005   AUTEUR REZETTE C.REZETTE 
#            CONFIGURATION MANAGEMENT OF EDF VERSION
# ======================================================================
# COPYRIGHT (C) 1991 - 2001  EDF R&D                  WWW.CODE-ASTER.ORG
# THIS PROGRAM IS FREE SOFTWARE; YOU CAN REDISTRIBUTE IT AND/OR MODIFY
# IT UNDER THE TERMS OF THE GNU GENERAL PUBLIC LICENSE AS PUBLISHED BY
# THE FREE SOFTWARE FOUNDATION; EITHER VERSION 2 OF THE LICENSE, OR   
# (AT YOUR OPTION) ANY LATER VERSION.                                 
#
# THIS PROGRAM IS DISTRIBUTED IN THE HOPE THAT IT WILL BE USEFUL, BUT 
# WITHOUT ANY WARRANTY; WITHOUT EVEN THE IMPLIED WARRANTY OF          
# MERCHANTABILITY OR FITNESS FOR A PARTICULAR PURPOSE. SEE THE GNU    
# GENERAL PUBLIC LICENSE FOR MORE DETAILS.                            
#
# YOU SHOULD HAVE RECEIVED A COPY OF THE GNU GENERAL PUBLIC LICENSE   
# ALONG WITH THIS PROGRAM; IF NOT, WRITE TO EDF R&D CODE_ASTER,       
#    1 AVENUE DU GENERAL DE GAULLE, 92141 CLAMART CEDEX, FRANCE.      
# ======================================================================
DEFI_MODELE_GENE=OPER(nom="DEFI_MODELE_GENE",op= 126,sd_prod=modele_gene,
                      reentrant='n',
            fr="Créer la structure globale à partir des sous-structures en sous-structuration dynamique", 
            UIinfo={"groupes":("Matrices/vecteurs",)},
         SOUS_STRUC      =FACT(statut='o',max='**',
           NOM             =SIMP(statut='o',typ='TXM' ),
           MACR_ELEM_DYNA  =SIMP(statut='o',typ=macr_elem_dyna ),
           ANGL_NAUT       =SIMP(statut='f',typ='R',max=3),
           TRANS           =SIMP(statut='f',typ='R',max=3),
         ),
         LIAISON         =FACT(statut='o',max='**',
           SOUS_STRUC_1    =SIMP(statut='o',typ='TXM' ),
           INTERFACE_1     =SIMP(statut='o',typ='TXM' ),
           SOUS_STRUC_2    =SIMP(statut='o',typ='TXM' ),
           INTERFACE_2     =SIMP(statut='o',typ='TXM' ),
           regles=(EXCLUS('GROUP_MA_MAIT_1','GROUP_MA_MAIT_2','MAILLE_MAIT_2'),
                   EXCLUS('MAILLE_MAIT_1','GROUP_MA_MAIT_2','MAILLE_MAIT_2'),),
           GROUP_MA_MAIT_1   =SIMP(statut='f',typ=grma,validators=NoRepeat(),max='**'),
           MAILLE_MAIT_1     =SIMP(statut='f',typ=ma  ,validators=NoRepeat(),max='**'),
           GROUP_MA_MAIT_2   =SIMP(statut='f',typ=grma,validators=NoRepeat(),max='**'),
           MAILLE_MAIT_2     =SIMP(statut='f',typ=ma  ,validators=NoRepeat(),max='**'),
           OPTION            =SIMP(statut='f',typ='TXM',defaut="CLASSIQUE",into=("REDUIT","CLASSIQUE") ),
         ),
         VERIF           =FACT(statut='f',max='**',
#  dans la doc U stop_erreur est obligatoire         
           STOP_ERREUR     =SIMP(statut='f',typ='TXM',defaut="OUI",into=("OUI","NON") ),
           PRECISION       =SIMP(statut='f',typ='R',defaut= 1.E-3 ),
           CRITERE         =SIMP(statut='f',typ='TXM',defaut="RELATIF",into=("RELATIF","ABSOLU") ),
         ),
         INFO            =SIMP(statut='f',typ='I',defaut= 1,into=( 1 , 2) ),
)  ;
#& MODIF COMMANDE  DATE 22/06/2005   AUTEUR REZETTE C.REZETTE 
#            CONFIGURATION MANAGEMENT OF EDF VERSION
# ======================================================================
# COPYRIGHT (C) 1991 - 2001  EDF R&D                  WWW.CODE-ASTER.ORG
# THIS PROGRAM IS FREE SOFTWARE; YOU CAN REDISTRIBUTE IT AND/OR MODIFY
# IT UNDER THE TERMS OF THE GNU GENERAL PUBLIC LICENSE AS PUBLISHED BY
# THE FREE SOFTWARE FOUNDATION; EITHER VERSION 2 OF THE LICENSE, OR   
# (AT YOUR OPTION) ANY LATER VERSION.                                 
#
# THIS PROGRAM IS DISTRIBUTED IN THE HOPE THAT IT WILL BE USEFUL, BUT 
# WITHOUT ANY WARRANTY; WITHOUT EVEN THE IMPLIED WARRANTY OF          
# MERCHANTABILITY OR FITNESS FOR A PARTICULAR PURPOSE. SEE THE GNU    
# GENERAL PUBLIC LICENSE FOR MORE DETAILS.                            
#
# YOU SHOULD HAVE RECEIVED A COPY OF THE GNU GENERAL PUBLIC LICENSE   
# ALONG WITH THIS PROGRAM; IF NOT, WRITE TO EDF R&D CODE_ASTER,       
#    1 AVENUE DU GENERAL DE GAULLE, 92141 CLAMART CEDEX, FRANCE.      
# ======================================================================
DEFI_NAPPE=OPER(nom="DEFI_NAPPE",op=   4,sd_prod=nappe_sdaster,
                fr="Définir une fonction réelle de deux variables réelles",
                reentrant='n',
            UIinfo={"groupes":("Fonction",)},
         regles=(UN_PARMI('FONCTION','DEFI_FONCTION'),
                 EXCLUS('FONCTION','NOM_PARA_FONC',),
                 ENSEMBLE('NOM_PARA_FONC','DEFI_FONCTION'),),
         NOM_PARA        =SIMP(statut='o',typ='TXM',into=C_PARA_FONCTION() ),
         NOM_RESU        =SIMP(statut='f',typ='TXM',defaut="TOUTRESU"),       
         PARA            =SIMP(statut='o',typ='R',max='**'),
         FONCTION        =SIMP(statut='f',typ=(fonction_sdaster,nappe_sdaster,formule),max='**' ),
         NOM_PARA_FONC   =SIMP(statut='f',typ='TXM',into=("TEMP","INST","X","Y","Z","EPSI","FREQ",
                                                          "PULS","AMOR","EPAIS","SAT", "PGAZ","PCAP") ),
         DEFI_FONCTION   =FACT(statut='f',max='**',
           VALE            =SIMP(statut='o',typ='R',max='**'),
           INTERPOL        =SIMP(statut='f',typ='TXM',max=2,defaut="LIN",into=("NON","LIN","LOG") ),
           PROL_DROITE     =SIMP(statut='f',typ='TXM',defaut="EXCLU",into=("CONSTANT","LINEAIRE","EXCLU") ),
           PROL_GAUCHE     =SIMP(statut='f',typ='TXM',defaut="EXCLU",into=("CONSTANT","LINEAIRE","EXCLU") ),
         ),
         INTERPOL        =SIMP(statut='f',typ='TXM',max=2,defaut="LIN",into=("NON","LIN","LOG") ),
         PROL_DROITE     =SIMP(statut='f',typ='TXM',defaut="EXCLU",into=("CONSTANT","LINEAIRE","EXCLU") ),
         PROL_GAUCHE     =SIMP(statut='f',typ='TXM',defaut="EXCLU",into=("CONSTANT","LINEAIRE","EXCLU") ),
         INFO            =SIMP(statut='f',typ='I',defaut= 1,into=( 1 , 2) ),
         VERIF           =SIMP(statut='f',typ='TXM',into=("CROISSANT",) ),
         TITRE           =SIMP(statut='f',typ='TXM',max='**'),
)  ;
#& MODIF COMMANDE  DATE 10/10/2006   AUTEUR MCOURTOI M.COURTOIS 
#            CONFIGURATION MANAGEMENT OF EDF VERSION
# ======================================================================
# COPYRIGHT (C) 1991 - 2001  EDF R&D                  WWW.CODE-ASTER.ORG
# THIS PROGRAM IS FREE SOFTWARE; YOU CAN REDISTRIBUTE IT AND/OR MODIFY
# IT UNDER THE TERMS OF THE GNU GENERAL PUBLIC LICENSE AS PUBLISHED BY
# THE FREE SOFTWARE FOUNDATION; EITHER VERSION 2 OF THE LICENSE, OR   
# (AT YOUR OPTION) ANY LATER VERSION.                                 
#
# THIS PROGRAM IS DISTRIBUTED IN THE HOPE THAT IT WILL BE USEFUL, BUT 
# WITHOUT ANY WARRANTY; WITHOUT EVEN THE IMPLIED WARRANTY OF          
# MERCHANTABILITY OR FITNESS FOR A PARTICULAR PURPOSE. SEE THE GNU    
# GENERAL PUBLIC LICENSE FOR MORE DETAILS.                            
#
# YOU SHOULD HAVE RECEIVED A COPY OF THE GNU GENERAL PUBLIC LICENSE   
# ALONG WITH THIS PROGRAM; IF NOT, WRITE TO EDF R&D CODE_ASTER,       
#    1 AVENUE DU GENERAL DE GAULLE, 92141 CLAMART CEDEX, FRANCE.      
# ======================================================================
DEFI_OBSTACLE=OPER(nom="DEFI_OBSTACLE",op=  73,sd_prod=table_fonction,
                   fr="Définition d'un obstacle plan perpendiculaire à une structure filaire",
                   reentrant='n',
         UIinfo={"groupes":("Modélisation",)},
         TYPE            =SIMP(statut='o',typ='TXM',defaut="CERCLE",
                             into=("CERCLE","PLAN_Y","PLAN_Z","DISCRET",
                             "BI_CERCLE","BI_PLAN_Y","BI_PLAN_Z","BI_CERC_INT",
                             "CRAYON_900","CRAYON_1300","GUID_A_CARTE_900",
                             "GUID_B_CARTE_900","GUID_C_CARTE_900",
                             "GUID_D_CARTE_900","GUID_E_CARTE_900",
                             "GUID_F_CARTE_900","GUID_A_CARTE_1300",
                             "GUID_B_CARTE_1300","GUID_C_CARTE_1300",
                             "GUID_D_CARTE_1300","GUID_E_CARTE_1300",
                             "GUID_F_CARTE_1300","GUID_A_CARSP_900",
                             "GUID_B_CARSP_900","GUID_C_CARSP_900",
                             "GUID_D_CARSP_900","GUID_E_CARSP_900",
                             "GUID_F_CARSP_900","GUID_A_CARSP_1300",
                             "GUID_B_CARSP_1300","GUID_C_CARSP_1300",
                             "GUID_D_CARSP_1300","GUID_E_CARSP_1300",
                             "GUID_F_CARSP_1300","GUID_A_GCONT_900",
                             "GUID_B_GCONT_900","GUID_C_GCONT_900",
                             "GUID_D_GCONT_900","GUID_E_GCONT_900",
                             "GUID_F_GCONT_900","GUID_A_GCONT_1300",
                             "GUID_B_GCONT_1300","GUID_C_GCONT_1300",
                             "GUID_D_GCONT_1300","GUID_E_GCONT_1300",
                             "GUID_F_GCONT_1300","GUID_A_GCOMB_900",
                             "GUID_B_GCOMB_900","GUID_C_GCOMB_900",
                             "GUID_D_GCOMB_900","GUID_E_GCOMB_900",
                             "GUID_F_GCOMB_900","GUID_A_GCOMB_1300",
                             "GUID_B_GCOMB_1300","GUID_C_GCOMB_1300",
                             "GUID_D_GCOMB_1300","GUID_E_GCOMB_1300",
                             "GUID_F_GCOMB_1300",) ),
         VALE            =SIMP(statut='f',typ='R',max='**'),
         VERIF           =SIMP(statut='f',typ='TXM',defaut="FERME"),
)  ;
#& MODIF COMMANDE  DATE 10/06/2004   AUTEUR REZETTE C.REZETTE 
#            CONFIGURATION MANAGEMENT OF EDF VERSION
# ======================================================================
# COPYRIGHT (C) 1991 - 2001  EDF R&D                  WWW.CODE-ASTER.ORG
# THIS PROGRAM IS FREE SOFTWARE; YOU CAN REDISTRIBUTE IT AND/OR MODIFY
# IT UNDER THE TERMS OF THE GNU GENERAL PUBLIC LICENSE AS PUBLISHED BY
# THE FREE SOFTWARE FOUNDATION; EITHER VERSION 2 OF THE LICENSE, OR   
# (AT YOUR OPTION) ANY LATER VERSION.                                 
#
# THIS PROGRAM IS DISTRIBUTED IN THE HOPE THAT IT WILL BE USEFUL, BUT 
# WITHOUT ANY WARRANTY; WITHOUT EVEN THE IMPLIED WARRANTY OF          
# MERCHANTABILITY OR FITNESS FOR A PARTICULAR PURPOSE. SEE THE GNU    
# GENERAL PUBLIC LICENSE FOR MORE DETAILS.                            
#
# YOU SHOULD HAVE RECEIVED A COPY OF THE GNU GENERAL PUBLIC LICENSE   
# ALONG WITH THIS PROGRAM; IF NOT, WRITE TO EDF R&D CODE_ASTER,       
#    1 AVENUE DU GENERAL DE GAULLE, 92141 CLAMART CEDEX, FRANCE.      
# ======================================================================
# RESPONSABLE GNICOLAS G.NICOLAS
DEFI_PARA_SENSI=OPER(nom="DEFI_PARA_SENSI",op=   2,sd_prod=para_sensi,
                    fr="Définition d'un paramètre de sensibilité",
                    ang="Definition of a sensitive parameter",
                    reentrant='n',
            UIinfo={"groupes":("Fonction",)},
         NOM_RESU        =SIMP(statut='c',typ='TXM',into=("TOUTRESU",),defaut="TOUTRESU",
                               fr="Nom du concept créé",
                               ang="Name of the concept"),
         VALE            =SIMP(statut='o',typ='R',
                               fr="Valeur du parametre",
                               ang="Value of the parameter"),
         TITRE           =SIMP(statut='f',typ='TXM',max='**'),
)  ;
#& MODIF COMMANDE  DATE 30/08/2005   AUTEUR ASSIRE A.ASSIRE 
#            CONFIGURATION MANAGEMENT OF EDF VERSION
# ======================================================================
# COPYRIGHT (C) 1991 - 2004  EDF R&D                  WWW.CODE-ASTER.ORG
# THIS PROGRAM IS FREE SOFTWARE; YOU CAN REDISTRIBUTE IT AND/OR MODIFY  
# IT UNDER THE TERMS OF THE GNU GENERAL PUBLIC LICENSE AS PUBLISHED BY  
# THE FREE SOFTWARE FOUNDATION; EITHER VERSION 2 OF THE LICENSE, OR     
# (AT YOUR OPTION) ANY LATER VERSION.                                                  
#                                                                       
# THIS PROGRAM IS DISTRIBUTED IN THE HOPE THAT IT WILL BE USEFUL, BUT   
# WITHOUT ANY WARRANTY; WITHOUT EVEN THE IMPLIED WARRANTY OF            
# MERCHANTABILITY OR FITNESS FOR A PARTICULAR PURPOSE. SEE THE GNU      
# GENERAL PUBLIC LICENSE FOR MORE DETAILS.                              
#                                                                       
# YOU SHOULD HAVE RECEIVED A COPY OF THE GNU GENERAL PUBLIC LICENSE     
# ALONG WITH THIS PROGRAM; IF NOT, WRITE TO EDF R&D CODE_ASTER,         
#    1 AVENUE DU GENERAL DE GAULLE, 92141 CLAMART CEDEX, FRANCE.        
# ======================================================================
# RESPONSABLE ASSIRE A.ASSIRE

from Macro.defi_part_feti_ops import defi_part_feti_ops

DEFI_PART_FETI=MACRO(nom="DEFI_PART_FETI",op=defi_part_feti_ops,sd_prod=sd_feti_sdaster,
                     reentrant='n',UIinfo={"groupe":("Maillage",)},
                     fr="Creation partitionnement en sous-domaines pour FETI",
         regles=(UN_PARMI('MAILLAGE','MODELE'),),
         MAILLAGE        =SIMP(statut='f',typ=maillage_sdaster),
         MODELE          =SIMP(statut='f',typ=modele_sdaster),
         NB_PART         =SIMP(statut='o',typ='I',val_min=2),
         EXCIT           =FACT(statut='f',max='**',
           CHARGE          =SIMP(statut='f',typ=(char_meca,char_cine_meca)),),

         # Methode de partitionnement
         METHODE         =SIMP(statut='f',typ='TXM',into=("PMETIS","SCOTCH","KMETIS",), defaut="SCOTCH" ),
         
         LOGICIEL      =SIMP(statut='f',typ='TXM'),

         # Corrige les problemes possibles de non-connexite des sous-domaines
         CORRECTION_CONNEX    =SIMP(statut='f',typ='TXM',defaut='NON',into=('OUI','NON')),

         # Permet de grouper des mailles dans un meme sous-doamine
         GROUPAGE        =FACT(statut='f',max='**',
           GROUP_MA       =SIMP(statut='o',typ=grma,),
                          ),
         # Permet d'appliquer des poids sur certaines mailles
         POIDS_MAILLES   =FACT(statut='f',max='**',
           GROUP_MA       =SIMP(statut='o',typ=grma,),
           POIDS          =SIMP(statut='f',typ='I',val_min=2),
                          ),
         # Prefixe pour le nom des group_ma definissant les sous-domaines 
         NOM_GROUP_MA    =SIMP(statut='f',typ='TXM',defaut='SD' ),

         # Traiter les mailles de bords (elles sont enlevees du graphe puis reinjectees)
         TRAITER_BORDS   =SIMP(statut='f',typ='TXM',defaut='OUI',into=('OUI','NON') ),
         
         # Si le mot-clé suivant est renseigné, crée de nouveau group_ma a partir des bords
         # Note : le calcul FETI sera impossible
         b_traiter_bords =BLOC(condition="TRAITER_BORDS == 'OUI'", fr="Crée t on des nouveaux group_ma",
           NOM_GROUP_MA_BORD  =SIMP(statut='f',typ='TXM'),
             ),

         INFO            =SIMP(statut='f',typ='I',into=(1, 2), defaut=1),
);
#& MODIF COMMANDE  DATE 22/02/2005   AUTEUR DURAND C.DURAND 
#            CONFIGURATION MANAGEMENT OF EDF VERSION
# ======================================================================
# COPYRIGHT (C) 1991 - 2004  EDF R&D                  WWW.CODE-ASTER.ORG
# THIS PROGRAM IS FREE SOFTWARE; YOU CAN REDISTRIBUTE IT AND/OR MODIFY  
# IT UNDER THE TERMS OF THE GNU GENERAL PUBLIC LICENSE AS PUBLISHED BY  
# THE FREE SOFTWARE FOUNDATION; EITHER VERSION 2 OF THE LICENSE, OR     
# (AT YOUR OPTION) ANY LATER VERSION.                                                  
#                                                                       
# THIS PROGRAM IS DISTRIBUTED IN THE HOPE THAT IT WILL BE USEFUL, BUT   
# WITHOUT ANY WARRANTY; WITHOUT EVEN THE IMPLIED WARRANTY OF            
# MERCHANTABILITY OR FITNESS FOR A PARTICULAR PURPOSE. SEE THE GNU      
# GENERAL PUBLIC LICENSE FOR MORE DETAILS.                              
#                                                                       
# YOU SHOULD HAVE RECEIVED A COPY OF THE GNU GENERAL PUBLIC LICENSE     
# ALONG WITH THIS PROGRAM; IF NOT, WRITE TO EDF R&D CODE_ASTER,         
#    1 AVENUE DU GENERAL DE GAULLE, 92141 CLAMART CEDEX, FRANCE.        
# ======================================================================
# RESPONSABLE ASSIRE A.ASSIRE

DEFI_PART_OPS=OPER(nom="DEFI_PART_OPS",op=21,sd_prod=sd_feti_sdaster,
                    fr="Creation partitionnement en sous-domaines pour FETI",
                    docu="U4.23.05",reentrant='n',
                    UIinfo={"groupes":("Résolution",)},
         MODELE          =SIMP(statut='o',typ=(modele_sdaster) ),
         MAILLAGE        =SIMP(statut='f',typ=(maillage_sdaster) ),
         NOM             =SIMP(statut='f',typ='TXM',defaut='SD'),
         INFO            =SIMP(statut='f',typ='I',defaut=1,into=(1,2,3,4) ),
         DEFI          =FACT(statut='f',max='**',
           GROUP_MA        =SIMP(statut='o',typ=grma),
           GROUP_MA_BORD   =SIMP(statut='f',typ=grma),
         ),
         EXCIT           =FACT(statut='f',max='**',
           CHARGE          =SIMP(statut='f',typ=(char_meca,char_cine_meca)),
         ),
);
#& MODIF COMMANDE  DATE 30/08/2005   AUTEUR ASSIRE A.ASSIRE 
#            CONFIGURATION MANAGEMENT OF EDF VERSION
# ======================================================================
# COPYRIGHT (C) 1991 - 2005  EDF R&D                  WWW.CODE-ASTER.ORG
# THIS PROGRAM IS FREE SOFTWARE; YOU CAN REDISTRIBUTE IT AND/OR MODIFY  
# IT UNDER THE TERMS OF THE GNU GENERAL PUBLIC LICENSE AS PUBLISHED BY  
# THE FREE SOFTWARE FOUNDATION; EITHER VERSION 2 OF THE LICENSE, OR     
# (AT YOUR OPTION) ANY LATER VERSION.                                                  
#                                                                       
# THIS PROGRAM IS DISTRIBUTED IN THE HOPE THAT IT WILL BE USEFUL, BUT   
# WITHOUT ANY WARRANTY; WITHOUT EVEN THE IMPLIED WARRANTY OF            
# MERCHANTABILITY OR FITNESS FOR A PARTICULAR PURPOSE. SEE THE GNU      
# GENERAL PUBLIC LICENSE FOR MORE DETAILS.                              
#                                                                       
# YOU SHOULD HAVE RECEIVED A COPY OF THE GNU GENERAL PUBLIC LICENSE     
# ALONG WITH THIS PROGRAM; IF NOT, WRITE TO EDF R&D CODE_ASTER,         
#    1 AVENUE DU GENERAL DE GAULLE, 92141 CLAMART CEDEX, FRANCE.        
# ======================================================================
# RESPONSABLE ASSIRE A.ASSIRE

DEFI_PART_PA_OPS=OPER(nom="DEFI_PART_PA_OPS",op=29,sd_prod=sd_feti_sdaster,
                    fr="Creation partitionnement en sous-domaines pour FETI",
                    docu="U4.00.00",reentrant='n',
                    UIinfo={"groupes":("Résolution",)},
         MAILLAGE        =SIMP(statut='o',typ=(maillage_sdaster,squelette) ),
         MODELE          =SIMP(statut='f',typ=(modele_sdaster)),
         NB_PART         =SIMP(statut='o',typ='I',),

         # Methode de partitionnement
         METHODE         =SIMP(statut='f',typ='TXM',into=("PMETIS","SCOTCH","KMETIS",), defaut="SCOTCH" ),
         
         LOGICIEL      =SIMP(statut='f',typ='TXM'),

         # Corrige les problemes possibles de non-connexite des sous-domaines
         CORRECTION_CONNEX    =SIMP(statut='f',typ='TXM',defaut='NON',into=('OUI','NON')),

         # Permet de grouper des mailles dans un meme sous-doamine
         GROUPAGE        =FACT(statut='f',max='**',
           GROUP_MA       =SIMP(statut='o',typ=grma,),
                          ),
         # Permet d'appliquer des poids sur certaines mailles
         POIDS_MAILLES   =FACT(statut='f',max='**',
           GROUP_MA       =SIMP(statut='o',typ=grma,),
           POIDS          =SIMP(statut='f',typ='I'),
                          ),
         # Prefixe pour le nom des group_ma definissant les sous-domaines 
         NOM_GROUP_MA    =SIMP(statut='f',typ='TXM',defaut='SD' ),

         # Traiter les mailles de bords (elles sont enlevees du graphe puis reinjectees)
         TRAITER_BORDS   =SIMP(statut='f',typ='TXM',defaut='OUI',into=('OUI','NON') ),

         # Si le mot-clé suivant est renseigné, crée de nouveau group_ma a partir des bords
         # Note : le calcul FETI sera impossible
         b_traiter_bords =BLOC(condition="TRAITER_BORDS == 'OUI'", fr="Crée t on des nouveaux group_ma",
           NOM_GROUP_MA_BORD  =SIMP(statut='f',typ='TXM'),
             ),

         INFO            =SIMP(statut='f',typ='I',into=(1, 2), defaut=1),

);
#& MODIF COMMANDE  DATE 10/10/2006   AUTEUR MCOURTOI M.COURTOIS 
#            CONFIGURATION MANAGEMENT OF EDF VERSION
# ======================================================================
# COPYRIGHT (C) 1991 - 2001  EDF R&D                  WWW.CODE-ASTER.ORG
# THIS PROGRAM IS FREE SOFTWARE; YOU CAN REDISTRIBUTE IT AND/OR MODIFY
# IT UNDER THE TERMS OF THE GNU GENERAL PUBLIC LICENSE AS PUBLISHED BY
# THE FREE SOFTWARE FOUNDATION; EITHER VERSION 2 OF THE LICENSE, OR   
# (AT YOUR OPTION) ANY LATER VERSION.                                 
#
# THIS PROGRAM IS DISTRIBUTED IN THE HOPE THAT IT WILL BE USEFUL, BUT 
# WITHOUT ANY WARRANTY; WITHOUT EVEN THE IMPLIED WARRANTY OF          
# MERCHANTABILITY OR FITNESS FOR A PARTICULAR PURPOSE. SEE THE GNU    
# GENERAL PUBLIC LICENSE FOR MORE DETAILS.                            
#
# YOU SHOULD HAVE RECEIVED A COPY OF THE GNU GENERAL PUBLIC LICENSE   
# ALONG WITH THIS PROGRAM; IF NOT, WRITE TO EDF R&D CODE_ASTER,       
#    1 AVENUE DU GENERAL DE GAULLE, 92141 CLAMART CEDEX, FRANCE.      
# ======================================================================
DEFI_SPEC_TURB=OPER(nom="DEFI_SPEC_TURB",op= 145,sd_prod=spectre_sdaster,
                    fr="Définition d'un spectre d'excitation turbulente",
                    reentrant='n',
            UIinfo={"groupes":("Modélisation",)},
         regles=(UN_PARMI('SPEC_LONG_COR_1','SPEC_LONG_COR_2','SPEC_LONG_COR_3',
                          'SPEC_LONG_COR_4','SPEC_CORR_CONV_1','SPEC_CORR_CONV_2',
                          'SPEC_FONC_FORME','SPEC_EXCI_POINT'),),
         SPEC_LONG_COR_1 =FACT(statut='f',
           LONG_COR        =SIMP(statut='o',typ='R' ),
           PROF_VITE_FLUI  =SIMP(statut='o',typ=(fonction_sdaster,nappe_sdaster,formule) ),
           VISC_CINE       =SIMP(statut='o',typ='R' ),
         ),
         SPEC_LONG_COR_2 =FACT(statut='f',
           regles=(ENSEMBLE('FREQ_COUP','PHI0','BETA' ),),
           LONG_COR        =SIMP(statut='o',typ='R' ),
           PROF_VITE_FLUI  =SIMP(statut='o',typ=(fonction_sdaster,nappe_sdaster,formule) ),
           FREQ_COUP       =SIMP(statut='f',typ='R',defaut= 0.1 ),
           PHI0            =SIMP(statut='f',typ='R',defaut= 1.5E-3 ),
           BETA            =SIMP(statut='f',typ='R',defaut= 2.7 ),
         ),
         SPEC_LONG_COR_3 =FACT(statut='f',
           regles=(ENSEMBLE('PHI0_1','BETA_1','PHI0_2','BETA_2','FREQ_COUP'),),
           LONG_COR        =SIMP(statut='o',typ='R' ),
           PROF_VITE_FLUI  =SIMP(statut='o',typ=(fonction_sdaster,nappe_sdaster,formule) ),
           FREQ_COUP       =SIMP(statut='f',typ='R',defaut= 0.2 ),
           PHI0_1          =SIMP(statut='f',typ='R',defaut= 5.E-3 ),
           BETA_1          =SIMP(statut='f',typ='R',defaut= 0.5 ),
           PHI0_2          =SIMP(statut='f',typ='R',defaut= 4.E-5 ),
           BETA_2          =SIMP(statut='f',typ='R',defaut= 3.5 ),
         ),
         SPEC_LONG_COR_4 =FACT(statut='f',
           regles=(ENSEMBLE('BETA','GAMMA'),),
           LONG_COR        =SIMP(statut='o',typ='R' ),
           PROF_VITE_FLUI  =SIMP(statut='o',typ=(fonction_sdaster,nappe_sdaster,formule) ),
           TAUX_VIDE       =SIMP(statut='o',typ='R' ),
           BETA            =SIMP(statut='f',typ='R',defaut= 2. ),
           GAMMA           =SIMP(statut='f',typ='R',defaut= 4. ),
         ),
         SPEC_CORR_CONV_1=FACT(statut='f',
           LONG_COR_1      =SIMP(statut='o',typ='R' ),
           LONG_COR_2      =SIMP(statut='f',typ='R' ),
           VITE_FLUI       =SIMP(statut='o',typ='R' ),
           RHO_FLUI        =SIMP(statut='o',typ='R' ),
           FREQ_COUP       =SIMP(statut='f',typ='R' ),
           K               =SIMP(statut='f',typ='R',defaut= 5.8E-3 ),
           D_FLUI          =SIMP(statut='o',typ='R' ),
           COEF_VITE_FLUI_A=SIMP(statut='f',typ='R' ),
           COEF_VITE_FLUI_O=SIMP(statut='f',typ='R' ),
           METHODE         =SIMP(statut='f',typ='TXM',defaut="GENERALE",
                                 into=("AU_YANG","GENERALE","CORCOS") ),
         ),
         SPEC_CORR_CONV_2=FACT(statut='f',
           FONCTION        =SIMP(statut='o',typ=(fonction_sdaster,nappe_sdaster,formule) ),
           VITE_FLUI       =SIMP(statut='o',typ='R' ),
           FREQ_COUP       =SIMP(statut='f',typ='R' ),
           METHODE         =SIMP(statut='f',typ='TXM',defaut="GENERALE",
                                 into=("AU_YANG","GENERALE","CORCOS",) ),
           COEF_VITE_FLUI_A=SIMP(statut='f',typ='R' ),
           COEF_VITE_FLUI_O=SIMP(statut='f',typ='R' ),
         ),
         SPEC_FONC_FORME =FACT(statut='f',
           regles=(UN_PARMI('INTE_SPEC','GRAPPE_1'),
                   ENSEMBLE('INTE_SPEC','FONCTION'),),
           INTE_SPEC       =SIMP(statut='f',typ=table_fonction),
           FONCTION        =SIMP(statut='f',typ=(fonction_sdaster,nappe_sdaster,formule),max='**'),
           GRAPPE_1        =SIMP(statut='f',typ='TXM',into=("DEBIT_180","DEBIT_300",) ),
           NOEUD           =SIMP(statut='o',typ=no),
           CARA_ELEM       =SIMP(statut='o',typ=cara_elem ),
           MODELE          =SIMP(statut='o',typ=modele_sdaster ),
         ),
         SPEC_EXCI_POINT =FACT(statut='f',
           regles=(UN_PARMI('INTE_SPEC','GRAPPE_2'),),
           INTE_SPEC       =SIMP(statut='f',typ=table_fonction),
           GRAPPE_2        =SIMP(statut='f',typ='TXM',
                                 into=("ASC_CEN","ASC_EXC","DES_CEN","DES_EXC",) ),
#  Quels sont les statuts des mots cles à l interieur des deux blocs qui suivent
           b_inte_spec =BLOC(condition = "INTE_SPEC != None",
             NATURE          =SIMP(statut='o',typ='TXM',max='**',into=("FORCE","MOMENT",) ),
             ANGL            =SIMP(statut='o',typ='R',max='**'),
             NOEUD           =SIMP(statut='o',typ=no,max='**'),
           ),
           b_grappe_2      =BLOC(condition = "GRAPPE_2 != None",
             RHO_FLUI        =SIMP(statut='o',typ='R' ),
             NOEUD           =SIMP(statut='o',typ=no),
           ),
           CARA_ELEM       =SIMP(statut='o',typ=cara_elem ),
           MODELE          =SIMP(statut='o',typ=modele_sdaster ),
         ),
         TITRE           =SIMP(statut='f',typ='TXM',max='**'),
)  ;
#& MODIF COMMANDE  DATE 22/06/2005   AUTEUR REZETTE C.REZETTE 
#            CONFIGURATION MANAGEMENT OF EDF VERSION
# ======================================================================
# COPYRIGHT (C) 1991 - 2001  EDF R&D                  WWW.CODE-ASTER.ORG
# THIS PROGRAM IS FREE SOFTWARE; YOU CAN REDISTRIBUTE IT AND/OR MODIFY
# IT UNDER THE TERMS OF THE GNU GENERAL PUBLIC LICENSE AS PUBLISHED BY
# THE FREE SOFTWARE FOUNDATION; EITHER VERSION 2 OF THE LICENSE, OR   
# (AT YOUR OPTION) ANY LATER VERSION.                                 
#
# THIS PROGRAM IS DISTRIBUTED IN THE HOPE THAT IT WILL BE USEFUL, BUT 
# WITHOUT ANY WARRANTY; WITHOUT EVEN THE IMPLIED WARRANTY OF          
# MERCHANTABILITY OR FITNESS FOR A PARTICULAR PURPOSE. SEE THE GNU    
# GENERAL PUBLIC LICENSE FOR MORE DETAILS.                            
#
# YOU SHOULD HAVE RECEIVED A COPY OF THE GNU GENERAL PUBLIC LICENSE   
# ALONG WITH THIS PROGRAM; IF NOT, WRITE TO EDF R&D CODE_ASTER,       
#    1 AVENUE DU GENERAL DE GAULLE, 92141 CLAMART CEDEX, FRANCE.      
# ======================================================================
DEFI_SQUELETTE=OPER(nom="DEFI_SQUELETTE",op= 110,sd_prod=squelette,
                    fr="Définit un maillage pour visualiser les résultats d'une sous-structuration dynamique",
                    reentrant='n',
            UIinfo={"groupes":("Maillage",)},
         regles=(UN_PARMI('CYCLIQUE','MODELE_GENE','MAILLAGE'),
                 PRESENT_PRESENT('CYCLIQUE','SECTEUR'),
                 EXCLUS('SOUS_STRUC','SECTEUR'),
                 PRESENT_PRESENT('NOM_GROUP_MA','MODELE_GENE'),
                 PRESENT_PRESENT('NOM_GROUP_MA','SOUS_STRUC'),),
         CYCLIQUE    =FACT(statut='f',max='**',
           regles=(UN_PARMI('MODE_CYCL','MAILLAGE'),
                   PRESENT_PRESENT('NB_SECTEUR','MAILLAGE'),),
           MODE_CYCL       =SIMP(statut='f',typ=mode_cycl ),
           NB_SECTEUR      =SIMP(statut='f',typ='I',validators=NoRepeat(),max=1 ),
           MAILLAGE        =SIMP(statut='f',typ=maillage_sdaster ),
         ),
         MODELE_GENE     =SIMP(statut='f',typ=modele_gene ),
         SQUELETTE       =SIMP(statut='f',typ=squelette ),
         RECO_GLOBAL     =FACT(statut='f',max='**',
           regles=(EXCLUS('TOUT','GROUP_NO_1'),
                   PRESENT_PRESENT('GROUP_NO_1','GROUP_NO_2'),
                   PRESENT_PRESENT('GROUP_NO_1','SOUS_STRUC_1'),
                   PRESENT_PRESENT('GROUP_NO_2','SOUS_STRUC_2'),
                   PRESENT_PRESENT('SOUS_STRUC_1','SOUS_STRUC_2'),),
           TOUT            =SIMP(statut='f',typ='TXM',defaut="OUI",into=("OUI",) ),
           GROUP_NO_1      =SIMP(statut='f',typ=grno),
           SOUS_STRUC_1    =SIMP(statut='f',typ='TXM' ),
           GROUP_NO_2      =SIMP(statut='f',typ=grno),
           SOUS_STRUC_2    =SIMP(statut='f',typ='TXM' ),
           PRECISION       =SIMP(statut='f',typ='R',defaut= 1.E-3 ),
           CRITERE         =SIMP(statut='f',typ='TXM',defaut="RELATIF",into=("RELATIF","ABSOLU") ),
           DIST_REFE       =SIMP(statut='f',typ='R' ),
         ),
         NOM_GROUP_MA    =FACT(statut='f',max='**',
           NOM             =SIMP(statut='o',typ='TXM' ),
           SOUS_STRUC      =SIMP(statut='o',typ='TXM' ),
           GROUP_MA        =SIMP(statut='o',typ=grma),
         ),
         EXCLUSIF        =SIMP(statut='f',typ='TXM',defaut="NON",into=("OUI","NON") ),
         MAILLAGE        =SIMP(statut='f',typ=maillage_sdaster ),
         MAILLE          =SIMP(statut='f',typ=ma  ,validators=NoRepeat(),max='**'),
         GROUP_MA        =SIMP(statut='f',typ=grma,validators=NoRepeat(),max='**'),
         TOUT            =SIMP(statut='f',typ='TXM',into=("OUI",) ),
         TRANS           =SIMP(statut='f',typ='R',min=3,max=3),
         ANGL_NAUT       =SIMP(statut='f',typ='R',min=3,max=3),
         SOUS_STRUC      =FACT(statut='f',max='**',
           NOM             =SIMP(statut='f',typ='TXM' ),
           MAILLE          =SIMP(statut='f',typ=ma  ,validators=NoRepeat(),max='**'),
           GROUP_MA        =SIMP(statut='f',typ=grma,validators=NoRepeat(),max='**'),
           TOUT            =SIMP(statut='f',typ='TXM',into=("OUI",) ),
         ),
         SECTEUR         =FACT(statut='f',max='**',
           MAILLE          =SIMP(statut='f',typ=ma  ,validators=NoRepeat(),max='**'),
           GROUP_MA        =SIMP(statut='f',typ=grma,validators=NoRepeat(),max='**'),
           TOUT            =SIMP(statut='f',typ='TXM',into=("OUI",) ),
         ),
         TITRE           =SIMP(statut='f',typ='TXM',max='**'),
)  ;
#& MODIF COMMANDE  DATE 03/01/2006   AUTEUR REZETTE C.REZETTE 
#            CONFIGURATION MANAGEMENT OF EDF VERSION
# ======================================================================
# COPYRIGHT (C) 1991 - 2001  EDF R&D                  WWW.CODE-ASTER.ORG
# THIS PROGRAM IS FREE SOFTWARE; YOU CAN REDISTRIBUTE IT AND/OR MODIFY
# IT UNDER THE TERMS OF THE GNU GENERAL PUBLIC LICENSE AS PUBLISHED BY
# THE FREE SOFTWARE FOUNDATION; EITHER VERSION 2 OF THE LICENSE, OR   
# (AT YOUR OPTION) ANY LATER VERSION.                                 
#
# THIS PROGRAM IS DISTRIBUTED IN THE HOPE THAT IT WILL BE USEFUL, BUT 
# WITHOUT ANY WARRANTY; WITHOUT EVEN THE IMPLIED WARRANTY OF          
# MERCHANTABILITY OR FITNESS FOR A PARTICULAR PURPOSE. SEE THE GNU    
# GENERAL PUBLIC LICENSE FOR MORE DETAILS.                            
#
# YOU SHOULD HAVE RECEIVED A COPY OF THE GNU GENERAL PUBLIC LICENSE   
# ALONG WITH THIS PROGRAM; IF NOT, WRITE TO EDF R&D CODE_ASTER,       
#    1 AVENUE DU GENERAL DE GAULLE, 92141 CLAMART CEDEX, FRANCE.      
# ======================================================================
DEFI_TRC=OPER(nom="DEFI_TRC",op=94,sd_prod=table_sdaster,reentrant='n',
            UIinfo={"groupes":("Modélisation",)},
              fr="Définir d'un diagramme de transformations en refroidissement continu (TRC) de référence d'un acier"
                +" pour les calculs métallurgiques.",
         HIST_EXP        =FACT(statut='o',max='**',
           VALE            =SIMP(statut='o',typ='R',max='**'),
         ),
         TEMP_MS         =FACT(statut='o',max='**',
           SEUIL           =SIMP(statut='o',typ='R'),
           AKM             =SIMP(statut='o',typ='R'),
           BKM             =SIMP(statut='o',typ='R'),
           TPLM            =SIMP(statut='o',typ='R'),
         ),
         GRAIN_AUST      =FACT(statut='f',max='**',
           DREF           =SIMP(statut='f',typ='R'),
           A              =SIMP(statut='f',typ='R'),
         ),
)  ;
#& MODIF COMMANDE  DATE 31/10/2006   AUTEUR A3BHHAE H.ANDRIAMBOLOLONA 
#            CONFIGURATION MANAGEMENT OF EDF VERSION
# ======================================================================
# COPYRIGHT (C) 1991 - 2001  EDF R&D                  WWW.CODE-ASTER.ORG
# THIS PROGRAM IS FREE SOFTWARE; YOU CAN REDISTRIBUTE IT AND/OR MODIFY
# IT UNDER THE TERMS OF THE GNU GENERAL PUBLIC LICENSE AS PUBLISHED BY
# THE FREE SOFTWARE FOUNDATION; EITHER VERSION 2 OF THE LICENSE, OR   
# (AT YOUR OPTION) ANY LATER VERSION.                                 
#
# THIS PROGRAM IS DISTRIBUTED IN THE HOPE THAT IT WILL BE USEFUL, BUT 
# WITHOUT ANY WARRANTY; WITHOUT EVEN THE IMPLIED WARRANTY OF          
# MERCHANTABILITY OR FITNESS FOR A PARTICULAR PURPOSE. SEE THE GNU    
# GENERAL PUBLIC LICENSE FOR MORE DETAILS.                            
#
# YOU SHOULD HAVE RECEIVED A COPY OF THE GNU GENERAL PUBLIC LICENSE   
# ALONG WITH THIS PROGRAM; IF NOT, WRITE TO EDF R&D CODE_ASTER,       
#    1 AVENUE DU GENERAL DE GAULLE, 92141 CLAMART CEDEX, FRANCE.      
# ======================================================================
def depl_interne_prod(DEPL_GLOBAL,**args ):
    if AsType(DEPL_GLOBAL)     == cham_no_sdaster: return cham_no_sdaster
    if AsType(DEPL_GLOBAL)     == evol_elas      : return evol_elas
    if AsType(DEPL_GLOBAL)     == dyna_trans     : return dyna_trans
    if AsType(DEPL_GLOBAL)     == dyna_harmo     : return dyna_harmo
    if AsType(DEPL_GLOBAL)     == mode_meca      : return mode_meca
    if AsType(DEPL_GLOBAL)     == base_modale    : return base_modale
    raise AsException("type de concept resultat non prevu")

DEPL_INTERNE=OPER(nom="DEPL_INTERNE",op=89,sd_prod=depl_interne_prod,reentrant='n',
            UIinfo={"groupes":("Matrices/vecteurs",)},
                  fr="Calculer le champ de déplacement à l'intérieur d'une sous-structure statique",
         DEPL_GLOBAL     =SIMP(statut='o',typ=(cham_no_sdaster,mode_meca,base_modale,evol_elas,dyna_trans,dyna_harmo),),
         SUPER_MAILLE    =SIMP(statut='o',typ=ma,),
         NOM_CAS         =SIMP(statut='f',typ='TXM',defaut=" "),
)  ;
#& MODIF COMMANDE  DATE 10/05/2006   AUTEUR MCOURTOI M.COURTOIS 
#            CONFIGURATION MANAGEMENT OF EDF VERSION
# ======================================================================
# COPYRIGHT (C) 1991 - 2001  EDF R&D                  WWW.CODE-ASTER.ORG
# THIS PROGRAM IS FREE SOFTWARE; YOU CAN REDISTRIBUTE IT AND/OR MODIFY
# IT UNDER THE TERMS OF THE GNU GENERAL PUBLIC LICENSE AS PUBLISHED BY
# THE FREE SOFTWARE FOUNDATION; EITHER VERSION 2 OF THE LICENSE, OR   
# (AT YOUR OPTION) ANY LATER VERSION.                                 
#
# THIS PROGRAM IS DISTRIBUTED IN THE HOPE THAT IT WILL BE USEFUL, BUT 
# WITHOUT ANY WARRANTY; WITHOUT EVEN THE IMPLIED WARRANTY OF          
# MERCHANTABILITY OR FITNESS FOR A PARTICULAR PURPOSE. SEE THE GNU    
# GENERAL PUBLIC LICENSE FOR MORE DETAILS.                            
#
# YOU SHOULD HAVE RECEIVED A COPY OF THE GNU GENERAL PUBLIC LICENSE   
# ALONG WITH THIS PROGRAM; IF NOT, WRITE TO EDF R&D CODE_ASTER,       
#    1 AVENUE DU GENERAL DE GAULLE, 92141 CLAMART CEDEX, FRANCE.      
# ======================================================================
DETRUIRE=MACRO(nom="DETRUIRE",op=-7,
            UIinfo={"groupes":("Gestion du travail",)},
              fr="Détruit des concepts utilisateurs dans la base GLOBALE ou des objets JEVEUX",
             op_init=ops.detruire,
             regles=(UN_PARMI('CONCEPT','OBJET',),),
            CONCEPT     =FACT(statut='f',max='**',
                regles=(DERIVABLE('NOM'),),
                NOM         =SIMP(statut='o',typ=assd,validators=NoRepeat(),max='**'),
                SENSIBILITE =SIMP(statut='f',typ=(para_sensi,theta_geom),validators=NoRepeat(),
                                 fr="Paramètre de sensibilité.",
                                 ang="Sensitivity parameter",max='**'),
            ),
            OBJET  =FACT(statut='f',max='**',
               CLASSE      =SIMP(statut='f',typ='TXM',into=('G','V','L'),defaut='G'),  
               CHAINE      =SIMP(statut='o',typ='TXM',validators=NoRepeat(),max='**'),
               POSITION    =SIMP(statut='f',typ='I'  ,max='**'),
            ),
            ALARME        =SIMP(statut='f',typ='TXM',into=('OUI','NON'),defaut='OUI',),
            INFO          =SIMP(statut='f',typ='I',into=(1,2),defaut=2, ),           
);
#& MODIF COMMANDE  DATE 10/10/2006   AUTEUR MCOURTOI M.COURTOIS 
#            CONFIGURATION MANAGEMENT OF EDF VERSION
# ======================================================================
# COPYRIGHT (C) 1991 - 2001  EDF R&D                  WWW.CODE-ASTER.ORG
# THIS PROGRAM IS FREE SOFTWARE; YOU CAN REDISTRIBUTE IT AND/OR MODIFY
# IT UNDER THE TERMS OF THE GNU GENERAL PUBLIC LICENSE AS PUBLISHED BY
# THE FREE SOFTWARE FOUNDATION; EITHER VERSION 2 OF THE LICENSE, OR   
# (AT YOUR OPTION) ANY LATER VERSION.                                 
#
# THIS PROGRAM IS DISTRIBUTED IN THE HOPE THAT IT WILL BE USEFUL, BUT 
# WITHOUT ANY WARRANTY; WITHOUT EVEN THE IMPLIED WARRANTY OF          
# MERCHANTABILITY OR FITNESS FOR A PARTICULAR PURPOSE. SEE THE GNU    
# GENERAL PUBLIC LICENSE FOR MORE DETAILS.                            
#
# YOU SHOULD HAVE RECEIVED A COPY OF THE GNU GENERAL PUBLIC LICENSE   
# ALONG WITH THIS PROGRAM; IF NOT, WRITE TO EDF R&D CODE_ASTER,       
#    1 AVENUE DU GENERAL DE GAULLE, 92141 CLAMART CEDEX, FRANCE.      
# ======================================================================
DYNA_ALEA_MODAL=OPER(nom="DYNA_ALEA_MODAL",op= 131,sd_prod=table_fonction,
                     fr="Calcul de la réponse spectrale d'une structure linéaire sous une excitation connue par sa DSP",
                     reentrant='n',
            UIinfo={"groupes":("Résolution",)},
         BASE_MODALE     =FACT(statut='o',
           regles=(UN_PARMI('NUME_ORDRE','BANDE'),),
           MODE_MECA       =SIMP(statut='o',typ=mode_meca ),
           BANDE           =SIMP(statut='f',typ='R',validators=NoRepeat(),max=2),
           NUME_ORDRE      =SIMP(statut='f',typ='I',validators=NoRepeat(),max='**'),
           b_bande =BLOC(condition = "BANDE != None",
             AMOR_UNIF       =SIMP(statut='o',typ='R' ),
           ),
           b_nume_ordre =BLOC(condition = "NUME_ORDRE != None",
             AMOR_REDUIT     =SIMP(statut='o',typ='R',max='**'),
           ),
         ),
         MODE_STAT       =SIMP(statut='f',typ=(mode_stat_depl,mode_stat_acce,mode_stat_forc,)),
# MODE_STAT devrait etre dans EXCIT car est utile et obligatoire que si NOM_CMP=depl_r, on pourrait
# ainsi rajouter un bloc du genre  b_mod_stat= BLOC(condition = "(GRANDEUR == None) or (GRANDEUR == 'DEPL_R')",        
         EXCIT           =FACT(statut='o',
           INTE_SPEC       =SIMP(statut='o',typ=table_fonction),
           NUME_VITE_FLUI  =SIMP(statut='f',typ='I' ),
           OPTION          =SIMP(statut='f',typ='TXM',defaut="TOUT",into=("TOUT","DIAG",) ),
           MODAL           =SIMP(statut='f',typ='TXM',defaut="NON",into=("OUI","NON") ),
           b_modal_non = BLOC(condition = "(MODAL == None) or (MODAL == 'NON')",           
             regles=(UN_PARMI('NOEUD_I','NUME_ORDRE_I'),),
             NUME_ORDRE_I    =SIMP(statut='f',typ='I',max='**'),
             NOEUD_I         =SIMP(statut='f',typ=no,max='**'),
             b_nume_ordre_i  =BLOC(condition = "NUME_ORDRE_I != None",
               regles=(EXCLUS('CHAM_NO','NOEUD'),),
# on devrait rajouter EXCLUS('GRANDEUR','CHAM_NO') pour eviter ambiguite car CHAM_NO => GRANDEUR='EFFO'
# cela impliquerait d'enlever la valeur par defaut a GRANDEUR            
               NUME_ORDRE_J    =SIMP(statut='o',typ='I',max='**'),
               CHAM_NO         =SIMP(statut='f',typ=cham_no_sdaster),
               NOEUD           =SIMP(statut='f',typ=no,max='**'),
               b_noeud         =BLOC(condition = "NOEUD != None",
                  NOM_CMP         =SIMP(statut='o',typ='TXM',max='**'),
                ),  
               GRANDEUR        =SIMP(statut='f',typ='TXM',defaut="DEPL_R",
                           into=("DEPL_R","EFFO","SOUR_DEBI_VOLU","SOUR_DEBI_MASS","SOUR_PRESS","SOUR_FORCE")),
# que se passe-t-il en cas d'incompatibilite entre GRANDEUR et NOM_CMP  
               DERIVATION      =SIMP(statut='f',typ='I',defaut= 0,into=( 0 , 1 , 2 ) ),
             ),           
             b_noeud_i       =BLOC(condition = "NOEUD_I != None",
               NOEUD_J         =SIMP(statut='o',typ=no,max='**'),
               NOM_CMP_I       =SIMP(statut='o',typ='TXM',max='**'),
               NOM_CMP_J       =SIMP(statut='o',typ='TXM',max='**'),
               NOEUD           =SIMP(statut='o',typ=no,max='**'),
               NOM_CMP         =SIMP(statut='o',typ='TXM',max='**'),
# ne serait-il pas bien que NOEUD et NOM_CMP soient facultatifs, car l'information peut etre contenue dans
# NOEUD_I, NOM_CMP_I ...  => modif. du Fortran
               GRANDEUR        =SIMP(statut='f',typ='TXM',defaut="DEPL_R",
                           into=("DEPL_R","EFFO","SOUR_DEBI_VOLU","SOUR_DEBI_MASS","SOUR_PRESS","SOUR_FORCE")),
# que se passe-t-il en cas d'incompatibilite entre GRANDEUR et NOM_CMP_I  
               DERIVATION      =SIMP(statut='f',typ='I',defaut= 0,into=( 0 , 1 , 2 ) ),
             ),
           ),  
           b_modal_oui = BLOC(condition = "(MODAL == 'OUI')",
# dans ce cas, y-a-t-il vraiment la possibilite d'une matrice interspectrale avec plusieurs termes
             NUME_ORDRE_I    =SIMP(statut='o',typ='I',max='**'),
             NUME_ORDRE_J    =SIMP(statut='o',typ='I',max='**'),
             GRANDEUR        =SIMP(statut='f',typ='TXM',defaut="DEPL_R",
                           into=("DEPL_R","EFFO","SOUR_DEBI_VOLU","SOUR_DEBI_MASS","SOUR_PRESS","SOUR_FORCE")),
             DERIVATION      =SIMP(statut='f',typ='I',defaut= 0,into=( 0 , 1 , 2 ) ),
# dans le cas MODAL=OUI, GRANDEUR peut-il etre different de EFFO et doit il etre impose a EFFO   On devrait
# pouvoir supprimer GRANDEUR et DERIVATION ici   
           ),  
                    
         ),
         REPONSE         =FACT(statut='f',
           regles=( ENSEMBLE('FREQ_MIN','FREQ_MAX'),),
           DERIVATION      =SIMP(statut='f',typ='I',defaut= 0,into=( 0 , 1 , 2 ,) ),
           OPTION          =SIMP(statut='f',typ='TXM',defaut="TOUT",into=("TOUT","DIAG") ),
           FREQ_MIN        =SIMP(statut='f',typ='R' ),
           FREQ_MAX        =SIMP(statut='f',typ='R' ),
           PAS             =SIMP(statut='f',typ='R' ),
           b_defaut_freq   =BLOC(condition = "FREQ_MIN == NONE",
              FREQ_EXCIT      =SIMP(statut='f',typ='TXM',defaut="AVEC",into=("AVEC","SANS") ),
              NB_POIN_MODE    =SIMP(statut='f',typ='I',defaut= 50 ),
           ),
         ),
         TITRE           =SIMP(statut='f',typ='TXM',max='**'),
         INFO            =SIMP(statut='f',typ='I',defaut= 1,into=( 1 , 2) ),
)  ;
#& MODIF COMMANDE  DATE 10/05/2006   AUTEUR MCOURTOI M.COURTOIS 
#            CONFIGURATION MANAGEMENT OF EDF VERSION
# ======================================================================
# COPYRIGHT (C) 1991 - 2001  EDF R&D                  WWW.CODE-ASTER.ORG
# THIS PROGRAM IS FREE SOFTWARE; YOU CAN REDISTRIBUTE IT AND/OR MODIFY
# IT UNDER THE TERMS OF THE GNU GENERAL PUBLIC LICENSE AS PUBLISHED BY
# THE FREE SOFTWARE FOUNDATION; EITHER VERSION 2 OF THE LICENSE, OR   
# (AT YOUR OPTION) ANY LATER VERSION.                                 
#
# THIS PROGRAM IS DISTRIBUTED IN THE HOPE THAT IT WILL BE USEFUL, BUT 
# WITHOUT ANY WARRANTY; WITHOUT EVEN THE IMPLIED WARRANTY OF          
# MERCHANTABILITY OR FITNESS FOR A PARTICULAR PURPOSE. SEE THE GNU    
# GENERAL PUBLIC LICENSE FOR MORE DETAILS.                            
#
# YOU SHOULD HAVE RECEIVED A COPY OF THE GNU GENERAL PUBLIC LICENSE   
# ALONG WITH THIS PROGRAM; IF NOT, WRITE TO EDF R&D CODE_ASTER,       
#    1 AVENUE DU GENERAL DE GAULLE, 92141 CLAMART CEDEX, FRANCE.      
# ======================================================================
def dyna_line_harm_prod(MATR_RIGI,**args):
   if (AsType(MATR_RIGI) == matr_asse_depl_r) : return dyna_harmo
   elif (AsType(MATR_RIGI) == matr_asse_depl_c) : return dyna_harmo
   elif (AsType(MATR_RIGI) == matr_asse_pres_c) : return acou_harmo
   elif (AsType(MATR_RIGI) == matr_asse_gene_r) : return harm_gene
   elif (AsType(MATR_RIGI) == matr_asse_gene_c) : return harm_gene
   raise AsException("type de concept resultat non prevu")

DYNA_LINE_HARM=OPER(nom="DYNA_LINE_HARM",op=  60,sd_prod=dyna_line_harm_prod,
                    fr="Calcul de la réponse dynamique complexe d'un système à une excitation harmonique",
                    reentrant='f',
            UIinfo={"groupes":("Résolution",)},
         regles=(PRESENT_ABSENT('AMOR_REDUIT','MATR_AMOR'),
                 PRESENT_ABSENT('AMOR_REDUIT','LIST_AMOR'),
                 PRESENT_ABSENT('MATR_AMOR','LIST_AMOR'),
                 UN_PARMI('FREQ','LIST_FREQ'),
                 CONCEPT_SENSIBLE('ENSEMBLE'),),
         MODELE          =SIMP(statut='f',typ=modele_sdaster ),
         CHAM_MATER      =SIMP(statut='f',typ=cham_mater ),
         CARA_ELEM       =SIMP(statut='f',typ=cara_elem ),
         MATR_MASS       =SIMP(statut='o',typ=(matr_asse_depl_r,matr_asse_pres_c,matr_asse_gene_r ) ),
         MATR_RIGI       =SIMP(statut='o',typ=(matr_asse_depl_r,matr_asse_depl_c,matr_asse_pres_c
                                              ,matr_asse_gene_r,matr_asse_gene_c ) ),
         MATR_AMOR       =SIMP(statut='f',typ=(matr_asse_depl_r,matr_asse_pres_c,matr_asse_gene_r ) ),
         AMOR_REDUIT     =SIMP(statut='f',typ='R',max='**'),
         LIST_AMOR       =SIMP(statut='f',typ=listr8_sdaster ),
         MATR_IMPE_PHI   =SIMP(statut='f',typ=(matr_asse_depl_r,matr_asse_gene_r) ),
         FREQ            =SIMP(statut='f',typ='R',validators=NoRepeat(),max='**'),
         LIST_FREQ       =SIMP(statut='f',typ=listr8_sdaster ),
         TOUT_CHAM       =SIMP(statut='f',typ='TXM',into=("OUI",)),
         NOM_CHAM        =SIMP(statut='f',typ='TXM',validators=NoRepeat(),max=3,into=("DEPL","VITE","ACCE") ),
         b_reuse =BLOC(condition = "reuse",fr="en mode concept reentrant : RESULTAT obligatoire",
             RESULTAT      =SIMP(statut='o',typ=(dyna_harmo,harm_gene)),
         ),         
         EXCIT           =FACT(statut='o',max='**',
           regles=(UN_PARMI('VECT_ASSE','CHARGE'),
                   UN_PARMI('FONC_MULT','FONC_MULT_C','COEF_MULT','COEF_MULT_C'),
                  ),
           VECT_ASSE       =SIMP(statut='f',typ=(cham_no_sdaster,vect_asse_gene) ),
           CHARGE          =SIMP(statut='f',typ=char_meca ),
           TYPE_CHARGE     =SIMP(statut='f',typ='TXM',defaut="FIXE",into=("FIXE",) ),
           FONC_MULT_C     =SIMP(statut='f',typ=fonction_c ),
           COEF_MULT_C     =SIMP(statut='f',typ='C' ),
           FONC_MULT       =SIMP(statut='f',typ=(fonction_sdaster,nappe_sdaster,formule) ),
           COEF_MULT       =SIMP(statut='f',typ='R' ),
           PHAS_DEG        =SIMP(statut='f',typ='R',defaut= 0.E+0 ),
           PUIS_PULS       =SIMP(statut='f',typ='I',defaut= 0 ),
         ),
         TITRE           =SIMP(statut='f',typ='TXM',max='**'),
         SENSIBILITE     =SIMP(statut='f',typ=(para_sensi,theta_geom),validators=NoRepeat(),max='**',
                               fr="Liste des paramètres de sensibilité.",
                               ang="List of sensitivity parameters"),
)  ;
# Rajouter test icompatibilite vect_asse et sensibilite
# Peut-on aussi rajouter ici le test d incompatibilite charge complexe - derivation 
#  presents dans le Fortran          
#& MODIF COMMANDE  DATE 12/06/2006   AUTEUR BOITEAU O.BOITEAU 
#            CONFIGURATION MANAGEMENT OF EDF VERSION
# ======================================================================
# COPYRIGHT (C) 1991 - 2001  EDF R&D                  WWW.CODE-ASTER.ORG
# THIS PROGRAM IS FREE SOFTWARE; YOU CAN REDISTRIBUTE IT AND/OR MODIFY
# IT UNDER THE TERMS OF THE GNU GENERAL PUBLIC LICENSE AS PUBLISHED BY
# THE FREE SOFTWARE FOUNDATION; EITHER VERSION 2 OF THE LICENSE, OR
# (AT YOUR OPTION) ANY LATER VERSION.
#
# THIS PROGRAM IS DISTRIBUTED IN THE HOPE THAT IT WILL BE USEFUL, BUT
# WITHOUT ANY WARRANTY; WITHOUT EVEN THE IMPLIED WARRANTY OF
# MERCHANTABILITY OR FITNESS FOR A PARTICULAR PURPOSE. SEE THE GNU
# GENERAL PUBLIC LICENSE FOR MORE DETAILS.
#
# YOU SHOULD HAVE RECEIVED A COPY OF THE GNU GENERAL PUBLIC LICENSE
# ALONG WITH THIS PROGRAM; IF NOT, WRITE TO EDF R&D CODE_ASTER,
#    1 AVENUE DU GENERAL DE GAULLE, 92141 CLAMART CEDEX, FRANCE.
# ======================================================================
DYNA_LINE_TRAN=OPER(nom="DYNA_LINE_TRAN",op=  48,sd_prod=dyna_trans,
                    fr="Calcul de la réponse dynamique transitoire à une excitation temporelle quelconque",
                    reentrant='f',
            UIinfo={"groupes":("Résolution",)},
#         regles=(UN_PARMI('WILSON','DIFF_CENTRE','ADAPT'),),
         regles=(UN_PARMI('NEWMARK','WILSON','DIFF_CENTRE','ADAPT'),
                 CONCEPT_SENSIBLE('ENSEMBLE'),),
         MODELE          =SIMP(statut='f',typ=modele_sdaster ),
         CHAM_MATER      =SIMP(statut='f',typ=cham_mater ),
         CARA_ELEM       =SIMP(statut='f',typ=cara_elem ),
         MATR_MASS       =SIMP(statut='o',typ=matr_asse_depl_r ),
         MATR_RIGI       =SIMP(statut='o',typ=matr_asse_depl_r ),
         MATR_AMOR       =SIMP(statut='f',typ=matr_asse_depl_r ),
         MODE_STAT       =SIMP(statut='f',typ=(mode_stat_depl,mode_stat_acce,mode_stat_forc,) ),
         NEWMARK         =FACT(statut='f',
           ALPHA           =SIMP(statut='f',typ='R',defaut= 0.25 ),
           DELTA           =SIMP(statut='f',typ='R',defaut= 0.5 ),
         ),
         WILSON          =FACT(statut='f',
           THETA           =SIMP(statut='f',typ='R',defaut= 1.4 ),
         ),
         DIFF_CENTRE     =FACT(statut='f',
         ),
         ADAPT           =FACT(statut='f',
         ),
         ETAT_INIT       =FACT(statut='f',
           regles=(AU_MOINS_UN('DYNA_TRANS', 'DEPL_INIT', 'VITE_INIT', 'ACCE_INIT'),
                   PRESENT_ABSENT('DYNA_TRANS', 'DEPL_INIT', 'VITE_INIT', 'ACCE_INIT'),),
           DYNA_TRANS      =SIMP(statut='f',typ=dyna_trans ),
           b_dyna_trans    =BLOC(condition = "DYNA_TRANS != None",
             regles=(EXCLUS('NUME_INIT','INST_INIT' ),),
             NUME_INIT       =SIMP(statut='f',typ='I' ),
             INST_INIT       =SIMP(statut='f',typ='R' ),
             b_inst_init     =BLOC(condition = "INST_INIT != None",
               PRECISION       =SIMP(statut='f',typ='R',defaut= 1.E-3 ),
               CRITERE         =SIMP(statut='f',typ='TXM',defaut="RELATIF",into=("RELATIF","ABSOLU") ),
             ),
           ),
           DEPL_INIT       =SIMP(statut='f',typ=cham_no_sdaster),
           VITE_INIT       =SIMP(statut='f',typ=cham_no_sdaster),
           ACCE_INIT       =SIMP(statut='f',typ=cham_no_sdaster),
         ),
         EXCIT           =FACT(statut='f',max='**',
           regles=(UN_PARMI('CHARGE','VECT_ASSE'),
                   EXCLUS('CHARGE','COEF_MULT'),
                   EXCLUS('FONC_MULT','COEF_MULT'),
                   EXCLUS('ACCE','COEF_MULT'),
                   PRESENT_ABSENT('ACCE','FONC_MULT'),
                   PRESENT_PRESENT('ACCE','VITE','DEPL'),
                   # PRESENT_ABSENT('MULT_APPUI','FONC_MULT'),
                   ),
           VECT_ASSE       =SIMP(statut='f',typ=cham_no_sdaster),
           CHARGE          =SIMP(statut='f',typ=char_meca ),
           FONC_MULT       =SIMP(statut='f',typ=(fonction_sdaster,nappe_sdaster,formule) ),
           COEF_MULT       =SIMP(statut='f',typ='R' ),
           TYPE_CHARGE     =SIMP(statut='f',typ='TXM',defaut="FIXE",into=("FIXE",) ),
           ACCE            =SIMP(statut='f',typ=(fonction_sdaster,nappe_sdaster,formule) ),
           VITE            =SIMP(statut='f',typ=(fonction_sdaster,nappe_sdaster,formule) ),
           DEPL            =SIMP(statut='f',typ=(fonction_sdaster,nappe_sdaster,formule) ),
           MULT_APPUI      =SIMP(statut='f',typ='TXM',defaut="NON",into=("OUI","NON") ),
           DIRECTION       =SIMP(statut='f',typ='R',max='**'),
           NOEUD           =SIMP(statut='f',typ=no  ,validators=NoRepeat(),max='**'),
           GROUP_NO        =SIMP(statut='f',typ=grno,validators=NoRepeat(),max='**'),
         ),
         AMOR_MODAL      =FACT(statut='f',
           MODE_MECA       =SIMP(statut='f',typ=mode_meca ),
           AMOR_REDUIT     =SIMP(statut='f',typ='R',max='**'),
           NB_MODE         =SIMP(statut='f',typ='I',defaut= 9999 ),
           REAC_VITE       =SIMP(statut='f',typ='TXM',defaut="NON",into=("OUI","NON") ),
         ),

         SOLVEUR         =FACT(statut='d',
         METHODE         =SIMP(statut='f',typ='TXM',defaut="MULT_FRONT",into=("MULT_FRONT","LDLT","GCPC","MUMPS") ),

           b_mult_front    =BLOC(condition = "METHODE == 'MULT_FRONT' ",fr="Paramètres de la méthode multi frontale",
             RENUM           =SIMP(statut='f',typ='TXM',defaut="METIS",into=("MD","MDA","METIS") ),
           ),

           b_ldlt          =BLOC(condition = "METHODE == 'LDLT' ",fr="Paramètres de la méthode LDLT",
             RENUM           =SIMP(statut='f',typ='TXM',defaut="RCMK",into=("RCMK","SANS") ),
           ),

           b_ldlt_mult     =BLOC(condition = "METHODE == 'LDLT' or METHODE == 'MULT_FRONT'",
                                   fr="Paramètres relatifs à la non inversibilité de la matrice à factorise",
             NPREC           =SIMP(statut='f',typ='I',defaut=8),
             STOP_SINGULIER  =SIMP(statut='f',typ='TXM',defaut="OUI",into=("OUI","NON") ),
           ),

           b_gcpc         =BLOC(condition = "METHODE == 'GCPC' ", fr="Paramètres de la méthode du gradient conjugué",
             PRE_COND        =SIMP(statut='f',typ='TXM',into=("LDLT_INC",),defaut="LDLT_INC" ),
             NIVE_REMPLISSAGE=SIMP(statut='f',typ='I',defaut= 0 ),
             RENUM           =SIMP(statut='f',typ='TXM',defaut="RCMK",into=("SANS","RCMK") ),
             RESI_RELA       =SIMP(statut='f',typ='R',defaut=1.E-6),
             NMAX_ITER       =SIMP(statut='f',typ='I',defaut= 0 ),
           ),
           b_mumps        =BLOC(condition = "METHODE == 'MUMPS' ",fr="Paramètres de la méthode MUMPS",
             TYPE_RESOL      =SIMP(statut='f',typ='TXM',defaut="AUTO",into=("NONSYM","SYMGEN","SYMDEF","AUTO")),
             SCALING         =SIMP(statut='f',typ='TXM',defaut="AUTO",into=("SANS","AUTO")),
             RENUM           =SIMP(statut='f',typ='TXM',defaut="AUTO",into=("AMD","AMF","PORD","METIS","QAMD","AUTO")),
             PCENT_PIVOT     =SIMP(statut='f',typ='I',defaut=80,),
             RESI_RELA       =SIMP(statut='f',typ='R',defaut=1.E-6,),
             ),
         ),

         INCREMENT       =FACT(statut='o',max='**',
           regles=(UN_PARMI('LIST_INST','FONC_INST','PAS'),),
           LIST_INST       =SIMP(statut='f',typ=listr8_sdaster ),
           FONC_INST       =SIMP(statut='f',typ=(fonction_sdaster,nappe_sdaster,formule) ),
           PAS             =SIMP(statut='f',typ='R' ),
           b_pas           =BLOC(condition = "PAS != None",
               INST_INIT       =SIMP(statut='f',typ='R' ),
               INST_FIN        =SIMP(statut='f',typ='R' ),
           ),
           b_list_fonc     =BLOC(condition = "LIST_INST != None or FONC_INST != None",
               regles=(EXCLUS('INST_FIN','NUME_FIN'),),
               NUME_FIN        =SIMP(statut='f',typ='I' ),
               INST_FIN        =SIMP(statut='f',typ='R' ),
           ),
           VITE_MIN        =SIMP(statut='f',typ='TXM',defaut="NORM",into=("MAXI","NORM") ),
           COEF_MULT_PAS   =SIMP(statut='f',typ='R',defaut= 1.1 ),
           COEF_DIVI_PAS   =SIMP(statut='f',typ='R',defaut= 1.33334 ),
           PAS_LIMI_RELA   =SIMP(statut='f',typ='R',defaut= 1.E-6 ),
           NB_POIN_PERIODE =SIMP(statut='f',typ='I',defaut= 50 ),
           NMAX_ITER_PAS   =SIMP(statut='f',typ='I',defaut= 16 ),
           PAS_CALCUL      =SIMP(statut='f',typ='I',defaut= 1 ),
         ),
         ARCHIVAGE       =FACT(statut='f',
           regles=(UN_PARMI('LIST_ARCH','PAS_ARCH', ),),
           LIST_ARCH       =SIMP(statut='f',typ=listis_sdaster ),
           PAS_ARCH        =SIMP(statut='f',typ='I' ),
           CHAM_EXCLU      =SIMP(statut='f',typ='TXM',validators=NoRepeat(),max='**',into=("DEPL","VITE","ACCE") ),
         ),
         SENSIBILITE     =SIMP(statut='f',typ=(para_sensi,theta_geom),validators=NoRepeat(),max='**',
                               fr="Liste des paramétres de sensibilité.",
                               ang="List of sensitivity parameters",
         ),
         TITRE           =SIMP(statut='f',typ='TXM',max='**'),
         INFO            =SIMP(statut='f',typ='I',into=(1,2) ),
)  ;
#& MODIF COMMANDE  DATE 10/10/2006   AUTEUR REZETTE C.REZETTE 
#            CONFIGURATION MANAGEMENT OF EDF VERSION
# ======================================================================
# COPYRIGHT (C) 1991 - 2001  EDF R&D                  WWW.CODE-ASTER.ORG
# THIS PROGRAM IS FREE SOFTWARE; YOU CAN REDISTRIBUTE IT AND/OR MODIFY
# IT UNDER THE TERMS OF THE GNU GENERAL PUBLIC LICENSE AS PUBLISHED BY
# THE FREE SOFTWARE FOUNDATION; EITHER VERSION 2 OF THE LICENSE, OR
# (AT YOUR OPTION) ANY LATER VERSION.
#
# THIS PROGRAM IS DISTRIBUTED IN THE HOPE THAT IT WILL BE USEFUL, BUT
# WITHOUT ANY WARRANTY; WITHOUT EVEN THE IMPLIED WARRANTY OF
# MERCHANTABILITY OR FITNESS FOR A PARTICULAR PURPOSE. SEE THE GNU
# GENERAL PUBLIC LICENSE FOR MORE DETAILS.
#
# YOU SHOULD HAVE RECEIVED A COPY OF THE GNU GENERAL PUBLIC LICENSE
# ALONG WITH THIS PROGRAM; IF NOT, WRITE TO EDF R&D CODE_ASTER,
#    1 AVENUE DU GENERAL DE GAULLE, 92141 CLAMART CEDEX, FRANCE.
# ======================================================================
DYNA_NON_LINE=OPER(nom="DYNA_NON_LINE",op= 70,sd_prod=evol_noli,reentrant='f',
            fr="Calcul de l'évolution dynamique d'une structure dont le matériau ou la géométrie ont un comportement non linéaire",
            UIinfo={"groupes":("Résolution",)},
         regles=(AU_MOINS_UN('COMP_INCR','COMP_ELAS',),
                 UN_PARMI('NEWMARK','HHT','TETA_METHODE',),
                 CONCEPT_SENSIBLE('ENSEMBLE'),),
         MODELE          =SIMP(statut='o',typ=modele_sdaster),
         CHAM_MATER      =SIMP(statut='o',typ=cham_mater),
         MODE_STAT       =SIMP(statut='f',typ=(mode_stat_depl,mode_stat_acce,mode_stat_forc,)),
         CARA_ELEM       =SIMP(statut='f',typ=cara_elem),
         EXCIT           =FACT(statut='o',max='**',
           regles=(PRESENT_ABSENT('FONC_MULT','ACCE'),
                   PRESENT_PRESENT('ACCE','VITE','DEPL'),
                   # PRESENT_ABSENT('MULT_APPUI','FONC_MULT'),
                   ),
           TYPE_CHARGE     =SIMP(statut='f',typ='TXM',defaut="FIXE_CSTE",
                                 into=("FIXE_CSTE","FIXE_PILO","SUIV","DIDI")),
           CHARGE          =SIMP(statut='o',typ=(char_meca,char_cine_meca)),
           FONC_MULT       =SIMP(statut='f',typ=(fonction_sdaster,nappe_sdaster,formule)),
           DEPL            =SIMP(statut='f',typ=(fonction_sdaster,nappe_sdaster,formule)),
           ACCE            =SIMP(statut='f',typ=(fonction_sdaster,nappe_sdaster,formule)),
           VITE            =SIMP(statut='f',typ=(fonction_sdaster,nappe_sdaster,formule)),
           MULT_APPUI      =SIMP(statut='f',typ='TXM',defaut="NON",into=("OUI","NON") ),
           DIRECTION       =SIMP(statut='f',typ='R',max='**'),
           NOEUD           =SIMP(statut='f',typ=no  ,validators=NoRepeat(),max='**'),
           GROUP_NO        =SIMP(statut='f',typ=grno,validators=NoRepeat(),max='**'),
         ),
         SOUS_STRUC      =FACT(statut='f',min=01,max='**',
                regles=(UN_PARMI('TOUT','MAILLE'),),
                CAS_CHARGE  =SIMP(statut='o',typ='TXM' ),
                TOUT        =SIMP(statut='f',typ='TXM',into=("OUI",) ),
                MAILLE      =SIMP(statut='f',typ=ma,validators=NoRepeat(),max='**',),
              ),
         AMOR_MODAL      =FACT(statut='f',
           regles=(EXCLUS('AMOR_REDUIT','LIST_AMOR'),),
           MODE_MECA       =SIMP(statut='f',typ=mode_meca),
           AMOR_REDUIT     =SIMP(statut='f',typ='R',max='**' ),
           LIST_AMOR       =SIMP(statut='f',typ=listr8_sdaster ),
           NB_MODE         =SIMP(statut='f',typ='I',defaut= 9999 ),
           REAC_VITE       =SIMP(statut='f',typ='TXM',defaut="OUI",into=("OUI","NON") ),
         ),
         COMP_INCR       =C_COMP_INCR(),
         COMP_ELAS       =FACT(statut='f',max='**',
           RELATION        =SIMP(statut='o',typ='TXM',defaut="ELAS",
                                 into=("ELAS","ELAS_VMIS_LINE","ELAS_VMIS_TRAC",
                                      "ELAS_POUTRE_GR","CABLE","ELAS_HYPER")),
           ELAS            =SIMP(statut='c',typ='I',defaut=1,into=(1,)),
           ELAS_VMIS_TRAC  =SIMP(statut='c',typ='I',defaut=1,into=(1,)),
           ELAS_VMIS_LINE  =SIMP(statut='c',typ='I',defaut=1,into=(1,)),
           ELAS_HYPER      =SIMP(statut='c',typ='I',defaut=1,into=(1,)),           
           ELAS_POUTRE_GR  =SIMP(statut='c',typ='I',defaut=3,into=(3,)),
           CABLE           =SIMP(statut='c',typ='I',defaut=1,into=(1,)),
           DEFORMATION     =SIMP(statut='f',typ='TXM',defaut="PETIT" ,into=("PETIT","GREEN","GREEN_GR",) ),
      regles=(PRESENT_ABSENT('TOUT','GROUP_MA','MAILLE'),),
           TOUT            =SIMP(statut='f',typ='TXM',into=("OUI",) ),
           GROUP_MA        =SIMP(statut='f',typ=grma,validators=NoRepeat(),max='**'),
           MAILLE          =SIMP(statut='f',typ=ma  ,validators=NoRepeat(),max='**'),
           RESI_INTE_RELA  =SIMP(statut='f',typ='R',defaut= 1.0E-6),
           ITER_INTE_MAXI  =SIMP(statut='f',typ='I',defaut= 10 ),
           ITER_INTE_PAS   =SIMP(statut='f',typ='I',defaut= 0 ),
           RESO_INTE       =SIMP(statut='f',typ='TXM',defaut="IMPLICITE",
                                 into=("RUNGE_KUTTA_2","RUNGE_KUTTA_4","IMPLICITE")),
         ),
#-------------------------------------------------------------------
         b_reuse =BLOC(condition = "reuse",fr="en mode concept reentrant : ETAT_INIT obligatoire",
         ETAT_INIT       =FACT(statut='o',
           regles=(AU_MOINS_UN('EVOL_NOLI','DEPL','VITE','ACCE','SIGM','VARI','VARI_NON_LOCAL',),
                   EXCLUS('EVOL_NOLI','DEPL',),
                   EXCLUS('EVOL_NOLI','VITE'),
                   EXCLUS('EVOL_NOLI','ACCE'),
                   EXCLUS('EVOL_NOLI','SIGM',),
                   EXCLUS('EVOL_NOLI','VARI',),
                   EXCLUS('EVOL_NOLI','VARI_NON_LOCAL',),
                   EXCLUS('NUME_ORDRE','INST'), ),
           DEPL            =SIMP(statut='f',typ=cham_no_sdaster),
           VITE            =SIMP(statut='f',typ=cham_no_sdaster),
           ACCE            =SIMP(statut='f',typ=cham_no_sdaster),
           SIGM            =SIMP(statut='f',typ=(cham_elem,carte_sdaster)),
           VARI            =SIMP(statut='f',typ=cham_elem),
           VARI_NON_LOCAL  =SIMP(statut='f',typ=cham_no_sdaster),
           EVOL_NOLI       =SIMP(statut='f',typ=evol_noli),
           NUME_ORDRE      =SIMP(statut='f',typ='I'),
           INST            =SIMP(statut='f',typ='R'),
           PRECISION       =SIMP(statut='f',typ='R',defaut= 1.0E-3 ),
           CRITERE         =SIMP(statut='f',typ='TXM',defaut="RELATIF",into=("RELATIF","ABSOLU") ),
           NUME_DIDI       =SIMP(statut='f',typ='I'),
           INST_ETAT_INIT  =SIMP(statut='f',typ='R'),
         ),),
         b_not_reuse =BLOC(condition = "not reuse",fr="en mode concept non reentrant : ETAT_INIT facultatif",
         ETAT_INIT       =FACT(statut='f',
           regles=(AU_MOINS_UN('EVOL_NOLI','DEPL','VITE','ACCE','SIGM','VARI','VARI_NON_LOCAL',),
                   EXCLUS('EVOL_NOLI','DEPL',),
                   EXCLUS('EVOL_NOLI','VITE'),
                   EXCLUS('EVOL_NOLI','ACCE'),
                   EXCLUS('EVOL_NOLI','SIGM',),
                   EXCLUS('EVOL_NOLI','VARI',),
                   EXCLUS('EVOL_NOLI','VARI_NON_LOCAL',),
                   EXCLUS('NUME_ORDRE','INST'), ),
           DEPL            =SIMP(statut='f',typ=cham_no_sdaster),
           VITE            =SIMP(statut='f',typ=cham_no_sdaster),
           ACCE            =SIMP(statut='f',typ=cham_no_sdaster),
           SIGM            =SIMP(statut='f',typ=(cham_elem,carte_sdaster)),
           VARI            =SIMP(statut='f',typ=cham_elem),
           VARI_NON_LOCAL  =SIMP(statut='f',typ=cham_no_sdaster),
           EVOL_NOLI       =SIMP(statut='f',typ=evol_noli),
           NUME_ORDRE      =SIMP(statut='f',typ='I'),
           INST            =SIMP(statut='f',typ='R'),
           PRECISION       =SIMP(statut='f',typ='R',defaut= 1.0E-3 ),
           CRITERE         =SIMP(statut='f',typ='TXM',defaut="RELATIF",into=("RELATIF","ABSOLU") ),
           NUME_DIDI       =SIMP(statut='f',typ='I'),
           INST_ETAT_INIT  =SIMP(statut='f',typ='R'),
         ),),
#-------------------------------------------------------------------
         INCREMENT       =FACT(statut='o',
           regles=(EXCLUS('NUME_INST_INIT','INST_INIT'),
                   EXCLUS('NUME_INST_FIN','INST_FIN'),),
           LIST_INST       =SIMP(statut='o',typ=listr8_sdaster),
           EVOLUTION       =SIMP(statut='f',typ='TXM',defaut="CHRONOLOGIQUE",
                                 into=("CHRONOLOGIQUE","RETROGRADE","SANS",) ),
           NUME_INST_INIT  =SIMP(statut='f',typ='I'),
           INST_INIT       =SIMP(statut='f',typ='R'),
           NUME_INST_FIN   =SIMP(statut='f',typ='I'),
           INST_FIN        =SIMP(statut='f',typ='R'),
           PRECISION       =SIMP(statut='f',typ='R',defaut=1.0E-3 ),
           # DEBUT DE BLOC POUR LA SUBDIVISION DES PAS DE TEMPS
           SUBD_METHODE    =SIMP( statut='f',typ='TXM',
              into =("AUCUNE","UNIFORME","EXTRAPOLE"),
              defaut="AUCUNE",
              fr="Méthode de subdivision des pas de temps en cas de non-convergence"
           ),
           b_subd_unif=BLOC(condition = "SUBD_METHODE == 'UNIFORME'",
             regles=(AU_MOINS_UN('SUBD_NIVEAU','SUBD_PAS_MINI'),),
             SUBD_COEF_PAS_1=SIMP(statut='f',typ='R',defaut=1.0,val_min=0.0,
                fr="Coefficient multiplicateur de la 1ère subdivision"),
             SUBD_PAS       =SIMP(statut='f',typ='I',defaut=4,val_min=2,
                fr="Nombre de subdivision d'un pas de temps"),
             SUBD_NIVEAU=SIMP(statut='f',typ='I',val_min=2,
                fr="Nombre maximum de niveau de subdivision d'un pas de temps"),
             SUBD_PAS_MINI=SIMP(statut='f',typ='R',val_min=0.0,
                fr="Pas de temps en dessous duquel on ne subdivise plus"),
           ),
           b_subd_extr=BLOC(condition = "SUBD_METHODE == 'EXTRAPOLE'",
             regles=(AU_MOINS_UN('SUBD_NIVEAU','SUBD_PAS_MINI'),),
             SUBD_OPTION    =SIMP(statut='f',typ='TXM',
                into =("IGNORE_PREMIERES","GARDE_DERNIERES",), 
                defaut="IGNORE_PREMIERES",
                fr="Technique d'extrapolation : les 1ere itérations sont ignorées ou les dernières sont gardées"),
             SUBD_ITER_IGNO =SIMP(statut='c',typ='I',defaut=3,val_min=0,
                fr="Les n premières itérations sont ignorées pour l'extrapolation"),
             SUBD_ITER_FIN  =SIMP(statut='c',typ='I',defaut=8,val_min=3,
                fr="Seules les n dernières itérations sont prises pour l'extrapolation"),
             SUBD_PAS       =SIMP(statut='c',typ='I',defaut=4,val_min=2,
                fr="Nombre de subdivision d'un pas de temps en cas divergence"),
             SUBD_NIVEAU=SIMP(statut='f',typ='I',val_min=2,
                fr="Nombre maximum de niveau de subdivision d'un pas de temps"),
             SUBD_PAS_MINI=SIMP(statut='f',typ='R',val_min=0.0,
                fr="Pas de temps en dessous duquel on ne subdivise plus"),
             SUBD_ITER_PLUS =SIMP(statut='c',typ='I',defaut=50,val_min=20,
                fr="% itération autorisée en plus"),
           ),
           # FIN DE BLOC POUR LA SUBDIVISION DES PAS DE TEMPS 
           OPTI_LIST_INST  =SIMP(statut='f',typ='TXM',into=("INCR_MAXI",),),
           NOM_CHAM        =SIMP(statut='f',typ='TXM',),
           NOM_CMP         =SIMP(statut='f',typ='TXM',),
           VALE            =SIMP(statut='f',typ='R'),
         ),
#-------------------------------------------------------------------
         NEWMARK         =FACT(statut='f',
           ALPHA           =SIMP(statut='f',typ='R',defaut= 0.25),
           DELTA           =SIMP(statut='f',typ='R',defaut= 0.5),
         ),
         HHT             =FACT(statut='f',
           ALPHA           =SIMP(statut='f',typ='R',defaut= -0.3 ),
           MODI_EQUI       =SIMP(statut='f',typ='TXM',defaut="NON",into=("OUI","NON") ),
         ),
         TETA_METHODE      =FACT(statut='f',
           TETA            =SIMP(statut='f',typ='R'
                                ,defaut= 1.,val_min=0.5,val_max=1. ),
         ),
         NEWTON          =FACT(statut='d',
           REAC_INCR       =SIMP(statut='f',typ='I',defaut= 1 ),
           PREDICTION      =SIMP(statut='f',typ='TXM',into=("TANGENTE","ELASTIQUE") ),
           MATRICE         =SIMP(statut='f',typ='TXM',defaut="TANGENTE",into=("TANGENTE","ELASTIQUE") ),
           REAC_ITER       =SIMP(statut='f',typ='I',defaut= 0),
           REAC_ITER_ELAS  =SIMP(statut='f',typ='I',defaut=0),
           PAS_MINI_ELAS   =SIMP(statut='f',typ='R',defaut=0.0E+0),
         ),
         SOLVEUR         =FACT(statut='d',
           METHODE         =SIMP(statut='f',typ='TXM',defaut="MULT_FRONT",into=("MULT_FRONT","LDLT","GCPC","MUMPS") ),
           b_mult_front    =BLOC(condition= "METHODE == 'MULT_FRONT' ",fr="Paramètres de la méthode multi frontale",
             RENUM           =SIMP(statut='f',typ='TXM',defaut="METIS",into=("MD","MDA","METIS") ),
           ),
           b_ldlt          =BLOC(condition= "METHODE == 'LDLT'",fr="Paramètres de la méthode LDLT",
             RENUM           =SIMP(statut='f',typ='TXM',defaut="RCMK",into=("RCMK","SANS") ),
           ),
           b_ldlt_mult     =BLOC(condition="METHODE == 'LDLT' or METHODE == 'MULT_FRONT'",
                                   fr="Paramètres relatifs à la non inversibilité de la matrice à factorise",
             NPREC           =SIMP(statut='f',typ='I',defaut= 8 ),
             STOP_SINGULIER  =SIMP(statut='f',typ='TXM',defaut="OUI",into=("OUI","NON","DECOUPE") ),
           ),
           b_mumps        =BLOC(condition = "METHODE == 'MUMPS' ",fr="Paramètres de la méthode MUMPS",
             TYPE_RESOL      =SIMP(statut='f',typ='TXM',defaut="AUTO",into=("NONSYM","SYMGEN","SYMDEF","AUTO")),
             SCALING         =SIMP(statut='f',typ='TXM',defaut="AUTO",into=("SANS","AUTO")),
             RENUM           =SIMP(statut='f',typ='TXM',defaut="AUTO",into=("AMD","AMF","PORD","METIS","QAMD","AUTO")),
             PCENT_PIVOT     =SIMP(statut='f',typ='I',defaut=80,),
             RESI_RELA       =SIMP(statut='f',typ='R',defaut=-1.0,),
             ),
           b_gcpc          =BLOC(condition="METHODE == 'GCPC'",fr="Paramètres de la méthode du gradient conjugué",
             PRE_COND        =SIMP(statut='f',typ='TXM',into=("LDLT_INC",),defaut="LDLT_INC" ),
             NIVE_REMPLISSAGE=SIMP(statut='f',typ='I',defaut=0),
             RENUM           =SIMP(statut='f',typ='TXM',defaut="RCMK",into=("SANS","RCMK") ),
             RESI_RELA       =SIMP(statut='f',typ='R',defaut= 1.E-6 ),
             NMAX_ITER       =SIMP(statut='f',typ='I',defaut= 0 ),
           ),
           SYME            =SIMP(statut='f',typ='TXM',defaut="NON",into=("OUI","NON") ),
         ),
#-------------------------------------------------------------------
         RECH_LINEAIRE   =FACT(statut='f',
           RESI_LINE_RELA  =SIMP(statut='f',typ='R',defaut= 1.0E-1 ),
           ITER_LINE_MAXI  =SIMP(statut='f',typ='I',defaut= 3),
           ITER_LINE_CRIT  =SIMP(statut='f',typ='I',defaut= 20),
           PAS_MINI_CRIT   =SIMP(statut='f',typ='R',defaut=0.0E+0),
           RHO_MIN         =SIMP(statut='f',typ='R',defaut=1.0E-2),
           RHO_MAX         =SIMP(statut='f',typ='R',defaut=1.0E+1),
           RHO_EXCL        =SIMP(statut='f',typ='R',defaut=0.9E-2,val_min=0.),
         ),
         PILOTAGE        =FACT(statut='f',
           regles=(EXCLUS('NOEUD','GROUP_NO'),PRESENT_ABSENT('TOUT','GROUP_MA','MAILLE'),),
           TYPE    =SIMP(statut='o',typ='TXM',into=("DDL_IMPO","LONG_ARC","PRED_ELAS","PRED_ELAS_INCR","DEFORMATION","ANA_LIM") ),
           COEF_MULT       =SIMP(statut='f',typ='R',defaut= 1.0E+0),
           ETA_PILO_MAX    =SIMP(statut='f',typ='R'),
           ETA_PILO_MIN    =SIMP(statut='f',typ='R'),
           ETA_PILO_R_MAX  =SIMP(statut='f',typ='R'),
           ETA_PILO_R_MIN  =SIMP(statut='f',typ='R'),
           PROJ_BORNES     =SIMP(statut='f',typ='TXM',defaut="OUI",into=("OUI","NON")),
           SELECTION       =SIMP(statut='f',typ='TXM',defaut="NORM_INCR_DEPL", into=("RESIDU","ANGL_INCR_DEPL","NORM_INCR_DEPL") ),
           TOUT            =SIMP(statut='f',typ='TXM',into=("OUI",) ),
           GROUP_MA        =SIMP(statut='f',typ=grma ,validators=NoRepeat(),max='**'),
           MAILLE          =SIMP(statut='f',typ=ma   ,validators=NoRepeat(),max='**'),
           NOEUD           =SIMP(statut='f',typ=no   ,validators=NoRepeat(),max='**'),
           GROUP_NO        =SIMP(statut='f',typ=grno ,validators=NoRepeat(),max='**'),
           NOM_CMP         =SIMP(statut='f',typ='TXM',max='**' ),
                         ),
         CONVERGENCE     =FACT(statut='d',
           regles=(PRESENT_ABSENT('RESI_REFE_RELA','RESI_GLOB_MAXI','RESI_GLOB_RELA'),),
           SIGM_REFE       =SIMP(statut='f',typ='R'),
           EPSI_REFE       =SIMP(statut='f',typ='R'),
           FLUX_THER_REFE  =SIMP(statut='f',typ='R'),
           FLUX_HYD1_REFE  =SIMP(statut='f',typ='R'),
           FLUX_HYD2_REFE  =SIMP(statut='f',typ='R'),
           RESI_REFE_RELA  =SIMP(statut='f',typ='R'),
           RESI_GLOB_MAXI  =SIMP(statut='f',typ='R'),
           RESI_GLOB_RELA  =SIMP(statut='f',typ='R'),
           ITER_GLOB_MAXI  =SIMP(statut='f',typ='I',defaut=10),
           ITER_GLOB_ELAS  =SIMP(statut='f',typ='I',defaut=25),
           ARRET           =SIMP(statut='f',typ='TXM',defaut="OUI"),
         ),
#-------------------------------------------------------------------
         SUIVI_DDL      = FACT(statut='f',max=4,
                               regles=(UN_PARMI('NOEUD','MAILLE','GROUP_NO','GROUP_MA','VALE_MIN','VALE_MAX'),
                                       PRESENT_PRESENT('MAILLE','POINT'),),
             NUME_SUIVI      =SIMP(statut='o',typ='I' ,min=1,max=4),
             NOM_CHAM        =SIMP(statut='o',typ='TXM',validators=NoRepeat(),max=1,
                                   into=("DEPL","VITE","ACCE","SIEF_ELGA",
                                         "VARI_ELGA","FORC_NODA","DEPL_ABSOLU","VITE_ABSOLU","ACCE_ABSOLU",)),
             NOM_CMP         =SIMP(statut='o',typ='TXM',max=1 ),
             NOEUD           =SIMP(statut='f',typ=no  ,validators=NoRepeat(),max='**'),
             GROUP_NO        =SIMP(statut='f',typ=grno,validators=NoRepeat(),max='**'),
             MAILLE          =SIMP(statut='f',typ=ma  ,validators=NoRepeat(),max='**'),
             GROUP_MA        =SIMP(statut='f',typ=grma,validators=NoRepeat(),max='**'),
             POINT           =SIMP(statut='f',typ='I' ,validators=NoRepeat(),max='**'),
             VALE_MAX        =SIMP(statut='f',typ='TXM',validators=NoRepeat(),max=1,into=("OUI",) ),
             VALE_MIN        =SIMP(statut='f',typ='TXM',validators=NoRepeat(),max=1,into=("OUI",) ),
         ),

         AFFICHAGE      = FACT(statut='f',max=16,

            UNITE       = SIMP(statut='f',typ='I',val_min=1),

            LONG_R      = SIMP(statut='f',typ='I',defaut=12,val_min=1,val_max=12),
            PREC_R      = SIMP(statut='f',typ='I',defaut=5, val_min=1,val_max=8),
            LONG_I      = SIMP(statut='f',typ='I',defaut=6, val_min=1,val_max=12),
            
            NOM_COLONNE = SIMP(statut='o',typ='TXM',defaut="STANDARD",
                                into=("STANDARD","MINIMUM",
                                      "ITER_NEWT",
                                      "INCR_TPS",
                                      "RESI_RELA","RELA_NOEU",
                                      "RESI_MAXI","MAXI_NOEU",
                                      "RESI_REFE","REFE_NOEU",
                                      "RELI_ITER","RELI_COEF",
                                      "PILO_PARA",
                                      "LAGR_ECAR","LAGR_INCR","LAGR_ITER",
                                      "MATR_ASSE",
                                      "ITER_DEBO",
                                      "CTCD_ITER","CTCD_INFO","CTCD_GEOM","CTCD_NOEU",
                                      "CTCC_GEOM","CTCC_FROT","CTCC_CONT",
                                      "SUIV_1","SUIV_2","SUIV_3","SUIV_4",
                                     ),
                               ),
            b_residu    = BLOC(condition = " NOM_COLONNE == 'RESI_RELA' or \
                    NOM_COLONNE == 'RESI_MAXI' or\
                    NOM_COLONNE == 'RESI_REFE' or\
                    NOM_COLONNE == 'CTCD_GEOM' or\
                    NOM_COLONNE == 'STANDARD' ",
                            INFO_RESIDU = SIMP(statut='f',typ='TXM',defaut="NON",into=("OUI","NON")),   
                          ),
         ),
#-------------------------------------------------------------------
         ARCHIVAGE       =FACT(statut='f',
           regles=(EXCLUS('PAS_ARCH','LIST_INST','INST'),
                   EXCLUS('ARCH_ETAT_INIT','NUME_INIT'), ),
           LIST_INST       =SIMP(statut='f',typ=(listr8_sdaster) ),
           INST            =SIMP(statut='f',typ='R',validators=NoRepeat(),max='**' ),
           PAS_ARCH        =SIMP(statut='f',typ='I' ),
           PRECISION       =SIMP(statut='f',typ='R',defaut= 1.0E-3),
           ARCH_ETAT_INIT  =SIMP(statut='f',typ='TXM',into=("OUI",)),
           NUME_INIT       =SIMP(statut='f',typ='I'),
           DETR_NUME_SUIV  =SIMP(statut='f',typ='TXM',into=("OUI",)),
           CHAM_EXCLU      =SIMP(statut='f',typ='TXM',validators=NoRepeat(),max='**',
           into=("DEPL","SIEF_ELGA","VARI_ELGA","ACCE","VITE","VARI_NON_LOCAL","LANL_ELGA")),
         ),
         OBSERVATION     =FACT(statut='f',max='**',
           regles=(UN_PARMI('NOEUD','GROUP_NO','MAILLE'),
                   PRESENT_PRESENT('MAILLE','POINT'),),
           NOM_CHAM        =SIMP(statut='o',typ='TXM',validators=NoRepeat(),max='**',

into=("DEPL","VITE","ACCE","SIEF_ELGA","VARI_ELGA","DEPL_ABSOLU","VITE_ABSOLU","ACCE_ABSOLU") ),
           NOM_CMP         =SIMP(statut='o',typ='TXM',max='**' ),
           LIST_ARCH       =SIMP(statut='f',typ=listis_sdaster),
           LIST_INST       =SIMP(statut='f',typ=listr8_sdaster),
           INST            =SIMP(statut='f',typ='R',validators=NoRepeat(),max='**' ),
           PRECISION       =SIMP(statut='f',typ='R',defaut= 1.0E-3 ),
           CRITERE         =SIMP(statut='f',typ='TXM',defaut="RELATIF",into=("RELATIF","ABSOLU") ),
           PAS_OBSE        =SIMP(statut='f',typ='I'),
           NOEUD           =SIMP(statut='f',typ=no  ,validators=NoRepeat(),max='**'),
           GROUP_NO        =SIMP(statut='f',typ=grno,validators=NoRepeat(),max='**'),
           MAILLE          =SIMP(statut='f',typ=ma  ,validators=NoRepeat(),max='**'),
           POINT           =SIMP(statut='f',typ='I' ,max='**'),
         ),
#-------------------------------------------------------------------
         CRIT_FLAMB     =FACT(statut='f',min=1,max=1,
           NB_FREQ         =SIMP(statut='f',typ='I',max=1,defaut=3),
           CHAR_CRIT       =SIMP(statut='f',typ='R',min=2,max=2,defaut=(-10.0,10.),
                            fr="Valeur des deux charges critiques délimitant la bande de recherche en HPP"),
         ),
         MODE_VIBR     =FACT(statut='f',min=1,max=1,
           MATR_RIGI        =SIMP(statut='f',typ='TXM',defaut="ELASTIQUE",into=("ELASTIQUE","TANGENTE") ),
           NB_FREQ         =SIMP(statut='f',typ='I',max=1,defaut=3),
         ),
#-------------------------------------------------------------------
           SENSIBILITE     =SIMP(statut='f',typ=(para_sensi,theta_geom),validators=NoRepeat(),max='**',
                               fr="Liste des paramètres de sensibilité",
                               ang="List of sensitivity parameters"),
#-------------------------------------------------------------------
           SOLV_NON_LOCAL  =FACT(statut='f',
             METHODE         =SIMP(statut='f',typ='TXM',defaut="MULT_FRONT",into=("MULT_FRONT","LDLT","GCPC","MUMPS") ),
             b_mult_front    =BLOC(condition = "METHODE == 'MULT_FRONT' ",fr="Paramètres de la méthode multi frontale",
               RENUM           =SIMP(statut='f',typ='TXM',defaut="METIS",into=("MD","MDA","METIS") ),
             ),
             b_ldlt         =BLOC(condition = "METHODE == 'LDLT' ",fr="Paramètres de la méthode LDLT",
               RENUM           =SIMP(statut='f',typ='TXM',defaut="RCMK",into=("RCMK","SANS") ),
             ),
             b_ldlt_mult    =BLOC(condition = "METHODE == 'LDLT' or METHODE == 'MULT_FRONT' ",
                                    fr="Paramètres relatifs à la non inversibilité de la matrice à factorise",
               NPREC           =SIMP(statut='f',typ='I',defaut= 8 ),
               STOP_SINGULIER  =SIMP(statut='f',typ='TXM',defaut="OUI",into=("OUI","NON") ),
             ),
             b_mumps        =BLOC(condition = "METHODE == 'MUMPS' ",fr="Paramètres de la méthode MUMPS",
               TYPE_RESOL      =SIMP(statut='f',typ='TXM',defaut="AUTO",into=("NONSYM","SYMGEN","SYMDEF","AUTO")),
               SCALING         =SIMP(statut='f',typ='TXM',defaut="AUTO",into=("SANS","AUTO")),
               RENUM           =SIMP(statut='f',typ='TXM',defaut="AUTO",into=("AMD","AMF","PORD","METIS","QAMD","AUTO")),
               PCENT_PIVOT     =SIMP(statut='f',typ='I',defaut=80,),
               RESI_RELA       =SIMP(statut='f',typ='R',defaut=-1.0,),
             ),
             b_gcpc         =BLOC(condition = "METHODE == 'GCPC' ", fr="Paramètres de la méthode du gradient conjugué",
               PRE_COND        =SIMP(statut='f',typ='TXM',into=("LDLT_INC",),defaut="LDLT_INC" ),
               NIVE_REMPLISSAGE=SIMP(statut='f',typ='I',defaut= 0 ),
               RESI_RELA       =SIMP(statut='f',typ='R',defaut= 1.E-6 ),
               NMAX_ITER       =SIMP(statut='f',typ='I',defaut= 0 ),
             ),
             EPS             =SIMP(statut='f',typ='R',defaut= 0.E+0 ),
           ),
           LAGR_NON_LOCAL  =FACT(statut='f',
             ITER_DUAL_MAXI  =SIMP(statut='f',typ='I',defaut= 50),
             RESI_DUAL_ABSO  =SIMP(statut='o',typ='R'),
             RESI_PRIM_ABSO  =SIMP(statut='o',typ='R'),
             R               =SIMP(statut='f',typ='R',defaut= 1000.),
             ITER_PRIM_MAXI  =SIMP(statut='f',typ='I',defaut= 10),
           ),
#-------------------------------------------------------------------
         INFO            =SIMP(statut='f',typ='I',defaut=1,into=(1,2) ),
         TITRE           =SIMP(statut='f',typ='TXM',max='**'),
)  ;
#& MODIF COMMANDE  DATE 10/10/2006   AUTEUR MCOURTOI M.COURTOIS 
#            CONFIGURATION MANAGEMENT OF EDF VERSION
# ======================================================================
# COPYRIGHT (C) 1991 - 2001  EDF R&D                  WWW.CODE-ASTER.ORG
# THIS PROGRAM IS FREE SOFTWARE; YOU CAN REDISTRIBUTE IT AND/OR MODIFY
# IT UNDER THE TERMS OF THE GNU GENERAL PUBLIC LICENSE AS PUBLISHED BY
# THE FREE SOFTWARE FOUNDATION; EITHER VERSION 2 OF THE LICENSE, OR   
# (AT YOUR OPTION) ANY LATER VERSION.                                 
#
# THIS PROGRAM IS DISTRIBUTED IN THE HOPE THAT IT WILL BE USEFUL, BUT 
# WITHOUT ANY WARRANTY; WITHOUT EVEN THE IMPLIED WARRANTY OF          
# MERCHANTABILITY OR FITNESS FOR A PARTICULAR PURPOSE. SEE THE GNU    
# GENERAL PUBLIC LICENSE FOR MORE DETAILS.                            
#
# YOU SHOULD HAVE RECEIVED A COPY OF THE GNU GENERAL PUBLIC LICENSE   
# ALONG WITH THIS PROGRAM; IF NOT, WRITE TO EDF R&D CODE_ASTER,       
#    1 AVENUE DU GENERAL DE GAULLE, 92141 CLAMART CEDEX, FRANCE.      
# ======================================================================
DYNA_SPEC_MODAL=OPER(nom="DYNA_SPEC_MODAL",op= 147,sd_prod=table_fonction,
                     fr="Calcul de la réponse par recombinaison modale d'une structure linéaire pour une excitation aléatoire",
                     reentrant='n',
            UIinfo={"groupes":("Résolution",)},
         BASE_ELAS_FLUI  =SIMP(statut='o',typ=melasflu_sdaster ),
         EXCIT           =FACT(statut='o',
           INTE_SPEC_GENE  =SIMP(statut='o',typ=table_fonction),
         ),
         OPTION          =SIMP(statut='f',typ='TXM',defaut="TOUT",into=("TOUT","DIAG") ),
         TITRE           =SIMP(statut='f',typ='TXM',max='**'),
)  ;
#& MODIF COMMANDE  DATE 27/11/2006   AUTEUR PELLET J.PELLET 
#            CONFIGURATION MANAGEMENT OF EDF VERSION
# ======================================================================
# COPYRIGHT (C) 1991 - 2003  EDF R&D                  WWW.CODE-ASTER.ORG
# THIS PROGRAM IS FREE SOFTWARE; YOU CAN REDISTRIBUTE IT AND/OR MODIFY
# IT UNDER THE TERMS OF THE GNU GENERAL PUBLIC LICENSE AS PUBLISHED BY
# THE FREE SOFTWARE FOUNDATION; EITHER VERSION 2 OF THE LICENSE, OR
# (AT YOUR OPTION) ANY LATER VERSION.
#
# THIS PROGRAM IS DISTRIBUTED IN THE HOPE THAT IT WILL BE USEFUL, BUT
# WITHOUT ANY WARRANTY; WITHOUT EVEN THE IMPLIED WARRANTY OF
# MERCHANTABILITY OR FITNESS FOR A PARTICULAR PURPOSE. SEE THE GNU
# GENERAL PUBLIC LICENSE FOR MORE DETAILS.
#
# YOU SHOULD HAVE RECEIVED A COPY OF THE GNU GENERAL PUBLIC LICENSE
# ALONG WITH THIS PROGRAM; IF NOT, WRITE TO EDF R&D CODE_ASTER,
#    1 AVENUE DU GENERAL DE GAULLE, 92141 CLAMART CEDEX, FRANCE.
# ======================================================================
#& RESPONSABLE
DYNA_TRAN_EXPLI=OPER(nom="DYNA_TRAN_EXPLI",op= 70,sd_prod=evol_noli,reentrant='f',UIinfo={"groupe":("Résolution",)},
                   fr="Calcul de l'évolution dynamique d'une structure dont la géométrie ou le matériau ont un comportement"
                       +" non linéaire, par une méthode explicite sur les accélérations ",
         regles=(AU_MOINS_UN('COMP_INCR','COMP_ELAS',),UN_PARMI('DIFF_CENT','TCHAMWA'),),
         MODELE          =SIMP(statut='o',typ=modele_sdaster),
         CHAM_MATER      =SIMP(statut='o',typ=cham_mater),
         MODE_STAT       =SIMP(statut='f',typ=(mode_stat_depl,mode_stat_acce,mode_stat_forc,)),
         CARA_ELEM       =SIMP(statut='f',typ=cara_elem),
         MASS_DIAG       =SIMP(statut='f',typ='TXM',into=("OUI","NON",) ),
         EXCIT           =FACT(statut='o',max='**',
           regles=(PRESENT_ABSENT('FONC_MULT','ACCE'),
                   PRESENT_PRESENT('ACCE','VITE','DEPL'),
                   # PRESENT_ABSENT('MULT_APPUI','FONC_MULT'),
                   ),
           TYPE_CHARGE     =SIMP(statut='f',typ='TXM',defaut="FIXE_CSTE",
                                 into=("FIXE_CSTE","FIXE_PILO","SUIV","DIDI")),
           CHARGE          =SIMP(statut='o',typ=char_meca),
           FONC_MULT       =SIMP(statut='f',typ=(fonction_sdaster,nappe_sdaster,formule)),
           DEPL            =SIMP(statut='f',typ=(fonction_sdaster,nappe_sdaster,formule)),
           ACCE            =SIMP(statut='f',typ=(fonction_sdaster,nappe_sdaster,formule)),
           VITE            =SIMP(statut='f',typ=(fonction_sdaster,nappe_sdaster,formule)),
           MULT_APPUI      =SIMP(statut='f',typ='TXM',defaut="NON",into=("OUI","NON") ),
           DIRECTION       =SIMP(statut='f',typ='R',max=3),
           NOEUD           =SIMP(statut='f',typ=no  ,validators=NoRepeat(),max='**'),
           GROUP_NO        =SIMP(statut='f',typ=grno,validators=NoRepeat(),max='**'),
         ),
         AMOR_MODAL      =FACT(statut='f',
           MODE_MECA       =SIMP(statut='o',typ=mode_meca),
           AMOR_REDUIT     =SIMP(statut='f',typ='R',max='**' ),
           NB_MODE         =SIMP(statut='f',typ='I',defaut= 9999 ),
           REAC_VITE       =SIMP(statut='f',typ='TXM',defaut="OUI",into=("OUI","NON") ),
         ),
         PROJ_MODAL      =FACT(statut='f',max='**',
           MODE_MECA       =SIMP(statut='o',typ=mode_meca),
           NB_MODE         =SIMP(statut='f',typ='I',defaut= 9999 ),
           regles=(PRESENT_PRESENT('MASS_GENE','RIGI_GENE'),),
           MASS_GENE       =SIMP(statut='f',typ=matr_asse_gene_r),
           RIGI_GENE       =SIMP(statut='f',typ=matr_asse_gene_r),
           AMOR_GENE       =SIMP(statut='f',typ=matr_asse_gene_r),
         ),
         EXCIT_GENE      =FACT(statut='f',max='**',
           FONC_MULT       =SIMP(statut='f',typ=fonction_sdaster,max='**' ),
           VECT_GENE       =SIMP(statut='f',typ=vect_asse_gene,max='**' ),
         ),
         COMP_INCR       =C_COMP_INCR(),
         COMP_ELAS       =FACT(statut='f',max='**',
           RELATION        =SIMP(statut='o',typ='TXM',defaut="ELAS",
                                 into=("ELAS","ELAS_VMIS_LINE","ELAS_VMIS_TRAC",
                                      "ELAS_POUTRE_GR","CABLE","ELAS_HYPER")),
           ELAS            =SIMP(statut='c',typ='I',defaut=1,into=(1,)),
           ELAS_VMIS_TRAC  =SIMP(statut='c',typ='I',defaut=1,into=(1,)),
           ELAS_VMIS_LINE  =SIMP(statut='c',typ='I',defaut=1,into=(1,)),
           ELAS_HYPER      =SIMP(statut='c',typ='I',defaut=1,into=(1,)),
           ELAS_POUTRE_GR  =SIMP(statut='c',typ='I',defaut=3,into=(3,)),
           CABLE           =SIMP(statut='c',typ='I',defaut=1,into=(1,)),
           DEFORMATION     =SIMP(statut='f',typ='TXM',defaut="PETIT" ,into=("PETIT","GREEN","GREEN_GR",) ),
      regles=(PRESENT_ABSENT('TOUT','GROUP_MA','MAILLE'),),
           TOUT            =SIMP(statut='f',typ='TXM',into=("OUI",) ),
           GROUP_MA        =SIMP(statut='f',typ=grma,validators=NoRepeat(),max='**'),
           MAILLE          =SIMP(statut='f',typ=ma  ,validators=NoRepeat(),max='**'),
           RESI_INTE_RELA  =SIMP(statut='f',typ='R',defaut= 1.0E-6),
           ITER_INTE_MAXI  =SIMP(statut='f',typ='I',defaut= 10 ),
           ITER_INTE_PAS   =SIMP(statut='f',typ='I',defaut= 0 ),
           RESO_INTE       =SIMP(statut='f',typ='TXM',defaut="IMPLICITE",
                                 into=("RUNGE_KUTTA_2","RUNGE_KUTTA_4","IMPLICITE")),
         ),
#-------------------------------------------------------------------
         ETAT_INIT       =FACT(statut='f',
           regles=(AU_MOINS_UN('EVOL_NOLI','DEPL','VITE','ACCE','SIGM','VARI','VARI_NON_LOCAL',),
                   EXCLUS('EVOL_NOLI','DEPL',),
                   EXCLUS('EVOL_NOLI','VITE'),
                   EXCLUS('EVOL_NOLI','ACCE'),
                   EXCLUS('EVOL_NOLI','SIGM',),
                   EXCLUS('EVOL_NOLI','VARI',),
                   EXCLUS('EVOL_NOLI','VARI_NON_LOCAL',),
                   EXCLUS('NUME_ORDRE','INST'), ),
           DEPL            =SIMP(statut='f',typ=cham_no_sdaster),
           VITE            =SIMP(statut='f',typ=cham_no_sdaster),
           ACCE            =SIMP(statut='f',typ=cham_no_sdaster),
           SIGM            =SIMP(statut='f',typ=(cham_elem,carte_sdaster)),
           VARI            =SIMP(statut='f',typ=cham_elem),
           VARI_NON_LOCAL  =SIMP(statut='f',typ=cham_no_sdaster),
           EVOL_NOLI       =SIMP(statut='f',typ=evol_noli),
           NUME_ORDRE      =SIMP(statut='f',typ='I'),
           INST            =SIMP(statut='f',typ='R'),
           PRECISION       =SIMP(statut='f',typ='R',defaut= 1.0E-3 ),
           CRITERE         =SIMP(statut='f',typ='TXM',defaut="RELATIF",into=("RELATIF","ABSOLU") ),
           NUME_DIDI       =SIMP(statut='f',typ='I'),
           INST_ETAT_INIT  =SIMP(statut='f',typ='R'),
         ),
#-------------------------------------------------------------------
         INCREMENT       =FACT(statut='o',
           regles=(EXCLUS('NUME_INST_INIT','INST_INIT'),
                   EXCLUS('NUME_INST_FIN','INST_FIN'),),
           LIST_INST       =SIMP(statut='o',typ=listr8_sdaster),
           EVOLUTION       =SIMP(statut='f',typ='TXM',defaut="CHRONOLOGIQUE",
                                 into=("CHRONOLOGIQUE","RETROGRADE","SANS",) ),
           NUME_INST_INIT  =SIMP(statut='f',typ='I'),
           INST_INIT       =SIMP(statut='f',typ='R'),
           NUME_INST_FIN   =SIMP(statut='f',typ='I'),
           INST_FIN        =SIMP(statut='f',typ='R'),
           PRECISION       =SIMP(statut='f',typ='R',defaut=1.0E-3 ),
           # DEBUT DE BLOC POUR LA SUBDIVISION DES PAS DE TEMPS
           SUBD_METHODE    =SIMP( statut='f',typ='TXM',
              into =("AUCUNE","UNIFORME","EXTRAPOLE"),
              defaut="AUCUNE",
              fr="Méthode de subdivision des pas de temps en cas de non-convergence"
           ),
           b_subd_unif=BLOC(condition = "SUBD_METHODE == 'UNIFORME'",
             regles=(AU_MOINS_UN('SUBD_NIVEAU','SUBD_PAS_MINI'),),
             SUBD_COEF_PAS_1=SIMP(statut='f',typ='R',defaut=1.0,val_min=0.0,
                fr="Coefficient multiplicateur de la 1ère subdivision"),
             SUBD_PAS       =SIMP(statut='f',typ='I',defaut=4,val_min=2,
                fr="Nombre de subdivision d'un pas de temps"),
             SUBD_NIVEAU=SIMP(statut='f',typ='I',val_min=2,
                fr="Nombre maximum de niveau de subdivision d'un pas de temps"),
             SUBD_PAS_MINI=SIMP(statut='f',typ='R',val_min=0.0,
                fr="Pas de temps en dessous duquel on ne subdivise plus"),
           ),
           b_subd_extr=BLOC(condition = "SUBD_METHODE == 'EXTRAPOLE'",
             regles=(AU_MOINS_UN('SUBD_NIVEAU','SUBD_PAS_MINI'),),
             SUBD_OPTION    =SIMP(statut='f',typ='TXM',
                into =("IGNORE_PREMIERES","GARDE_DERNIERES",),
                defaut="IGNORE_PREMIERES",
                fr="Technique d'extrapolation : les 1ere itérations sont ignorées ou les dernières sont gardées"),
             SUBD_ITER_IGNO =SIMP(statut='c',typ='I',defaut=3,val_min=0,
                fr="Les n premières itérations sont ignorées pour l'extrapolation"),
             SUBD_ITER_FIN  =SIMP(statut='c',typ='I',defaut=8,val_min=3,
                fr="Seules les n dernières itérations sont prises pour l'extrapolation"),
             SUBD_PAS       =SIMP(statut='c',typ='I',defaut=4,val_min=2,
                fr="Nombre de subdivision d'un pas de temps en cas divergence"),
             SUBD_NIVEAU=SIMP(statut='f',typ='I',val_min=2,
                fr="Nombre maximum de niveau de subdivision d'un pas de temps"),
             SUBD_PAS_MINI=SIMP(statut='f',typ='R',val_min=0.0,
                fr="Pas de temps en dessous duquel on ne subdivise plus"),
             SUBD_ITER_PLUS =SIMP(statut='c',typ='I',defaut=50,val_min=20,
                fr="% itération autorisée en plus"),
           ),
           # FIN DE BLOC POUR LA SUBDIVISION DES PAS DE TEMPS
           OPTI_LIST_INST  =SIMP(statut='f',typ='TXM',into=("INCR_MAXI",),),
           NOM_CHAM        =SIMP(statut='f',typ='TXM',),
           NOM_CMP         =SIMP(statut='f',typ='TXM',),
           VALE            =SIMP(statut='f',typ='R'),
         ),
#-------------------------------------------------------------------
         DIFF_CENT       =FACT(statut='f',
         ),
         TCHAMWA         =FACT(statut='f',
           PHI             =SIMP(statut='f',typ='R',defaut= 1.05),
         ),
         STOP_CFL        =SIMP(statut='f',typ='TXM',defaut="OUI",into=("OUI","NON")),
         NEWTON          =FACT(statut='c',
           REAC_INCR       =SIMP(statut='f',typ='I',defaut= 1 ),
           PREDICTION      =SIMP(statut='f',typ='TXM',into=("TANGENTE","ELASTIQUE") ),
           MATRICE         =SIMP(statut='f',typ='TXM',defaut="TANGENTE",into=("TANGENTE","ELASTIQUE") ),
           REAC_ITER       =SIMP(statut='f',typ='I',defaut= 0),
           REAC_ITER_ELAS  =SIMP(statut='f',typ='I',defaut=0),
           PAS_MINI_ELAS   =SIMP(statut='f',typ='R',defaut=0.0E+0),
         ),
         SOLVEUR         =FACT(statut='d',
           METHODE         =SIMP(statut='f',typ='TXM',defaut="MULT_FRONT",into=("MULT_FRONT","LDLT","GCPC") ),
           b_mult_front    =BLOC(condition= "METHODE == 'MULT_FRONT' ",fr="Paramètres de la méthode multi frontale",
             RENUM           =SIMP(statut='f',typ='TXM',defaut="METIS",into=("MD","MDA","METIS") ),
           ),
           b_ldlt          =BLOC(condition= "METHODE == 'LDLT'",fr="Paramètres de la méthode LDLT",
             RENUM           =SIMP(statut='f',typ='TXM',defaut="RCMK",into=("RCMK","SANS") ),
           ),
           b_ldlt_mult     =BLOC(condition="METHODE == 'LDLT' or METHODE == 'MULT_FRONT'",
                                   fr="Paramètres relatifs à la non inversibilité de la matrice à factorise",
             NPREC           =SIMP(statut='f',typ='I',defaut= 8 ),
             STOP_SINGULIER  =SIMP(statut='f',typ='TXM',defaut="OUI",into=("OUI","NON","DECOUPE") ),
           ),
           b_gcpc          =BLOC(condition="METHODE == 'GCPC'",fr="Paramètres de la méthode du gradient conjugué",
             PRE_COND        =SIMP(statut='f',typ='TXM',into=("LDLT_INC",),defaut="LDLT_INC" ),
             NIVE_REMPLISSAGE=SIMP(statut='f',typ='I',defaut=0),
             RENUM           =SIMP(statut='f',typ='TXM',defaut="RCMK",into=("SANS","RCMK") ),
             RESI_RELA       =SIMP(statut='f',typ='R',defaut= 1.E-6 ),
             NMAX_ITER       =SIMP(statut='f',typ='I',defaut= 0 ),
           ),
           SYME            =SIMP(statut='f',typ='TXM',defaut="NON",into=("OUI","NON") ),
         ),
#-------------------------------------------------------------------
         RECH_LINEAIRE   =FACT(statut='c',
           RESI_LINE_RELA  =SIMP(statut='f',typ='R',defaut= 1.0E-1 ),
           ITER_LINE_MAXI  =SIMP(statut='f',typ='I',defaut= 3),
           ITER_LINE_CRIT  =SIMP(statut='f',typ='I',defaut= 20),
           PAS_MINI_CRIT   =SIMP(statut='f',typ='R',defaut=0.0E+0),
           RHO_MIN         =SIMP(statut='f',typ='R',defaut=1.0E-2),
           RHO_MAX         =SIMP(statut='f',typ='R',defaut=1.0E+1),
           RHO_EXCL        =SIMP(statut='f',typ='R',defaut=0.9E-2),
         ),
         PILOTAGE        =FACT(statut='c',
           regles=(EXCLUS('NOEUD','GROUP_NO'),PRESENT_ABSENT('TOUT','GROUP_MA','MAILLE'),),
           TYPE    =SIMP(statut='o',typ='TXM',into=("DDL_IMPO","LONG_ARC","PRED_ELAS","PRED_ELAS_INCR","DEFORMATION","ANA_LIM") ),
           COEF_MULT       =SIMP(statut='f',typ='R',defaut= 1.0E+0),
           ETA_PILO_MAX    =SIMP(statut='f',typ='R'),
           ETA_PILO_MIN    =SIMP(statut='f',typ='R'),
           ETA_PILO_R_MAX  =SIMP(statut='f',typ='R'),
           ETA_PILO_R_MIN  =SIMP(statut='f',typ='R'),
           PROJ_BORNES     =SIMP(statut='f',typ='TXM',defaut="OUI",into=("OUI","NON")),
           SELECTION       =SIMP(statut='f',typ='TXM',defaut="NORM_INCR_DEPL", into=("RESIDU","ANGL_INCR_DEPL","NORM_INCR_DEPL") ),
           TOUT            =SIMP(statut='f',typ='TXM',into=("OUI",) ),
           GROUP_MA        =SIMP(statut='f',typ=grma ,validators=NoRepeat(),max='**'),
           MAILLE          =SIMP(statut='f',typ=ma   ,validators=NoRepeat(),max='**'),
           NOEUD           =SIMP(statut='f',typ=no   ,validators=NoRepeat(),max='**'),
           GROUP_NO        =SIMP(statut='f',typ=grno ,validators=NoRepeat(),max='**'),
           NOM_CMP         =SIMP(statut='f',typ='TXM',max='**' ),
                         ),
         CONVERGENCE     =FACT(statut='d',
           regles=(PRESENT_ABSENT('RESI_REFE_RELA','RESI_GLOB_MAXI','RESI_GLOB_RELA'),),
           SIGM_REFE       =SIMP(statut='f',typ='R'),
           EPSI_REFE       =SIMP(statut='f',typ='R'),
           FLUX_THER_REFE  =SIMP(statut='f',typ='R'),
           FLUX_HYD1_REFE  =SIMP(statut='f',typ='R'),
           FLUX_HYD2_REFE  =SIMP(statut='f',typ='R'),
           RESI_REFE_RELA  =SIMP(statut='f',typ='R'),
           RESI_GLOB_MAXI  =SIMP(statut='f',typ='R'),
           RESI_GLOB_RELA  =SIMP(statut='f',typ='R'),
           ITER_GLOB_MAXI  =SIMP(statut='f',typ='I',defaut=10),
           ITER_GLOB_ELAS  =SIMP(statut='f',typ='I',defaut=25),
           ARRET           =SIMP(statut='f',typ='TXM',defaut="OUI"),
           RESI_INTE_RELA  =SIMP(statut='f',typ='R'
                                ,defaut= 1.0E-6),
           ITER_INTE_MAXI  =SIMP(statut='f',typ='I',defaut= 10 ),
           ITER_INTE_PAS   =SIMP(statut='f',typ='I',defaut= 0 ),
           RESO_INTE       =SIMP(statut='f',typ='TXM',defaut="IMPLICITE",
                                 into=("RUNGE_KUTTA_2","RUNGE_KUTTA_4","IMPLICITE")),
         ),
#-------------------------------------------------------------------
        AFFICHAGE      = FACT(statut='f',max=16,

            UNITE       = SIMP(statut='f',typ='I',val_min=1),

            LONG_R      = SIMP(statut='f',typ='I',defaut=12,val_min=1,val_max=12),
            PREC_R      = SIMP(statut='f',typ='I',defaut=5, val_min=1,val_max=8),
            LONG_I      = SIMP(statut='f',typ='I',defaut=6, val_min=1,val_max=12),

            NOM_COLONNE = SIMP(statut='o',typ='TXM',defaut="STANDARD",
                                into=("STANDARD","MINIMUM",
                                      "ITER_NEWT",
                                      "INCR_TPS",
                                      "RESI_RELA","RELA_NOEU",
                                      "RESI_MAXI","MAXI_NOEU",
                                      "RESI_REFE","REFE_NOEU",
                                      "RELI_ITER","RELI_COEF",
                                      "PILO_PARA",
                                      "LAGR_ECAR","LAGR_INCR","LAGR_ITER",
                                      "MATR_ASSE",
                                      "ITER_DEBO",
                                      "CTCD_ITER","CTCD_INFO","CTCD_GEOM","CTCD_NOEU",
                                      "CTCC_GEOM","CTCC_FROT","CTCC_CONT",
                                      "SUIV_1","SUIV_2","SUIV_3","SUIV_4",
                                     ),
                               ),
            b_residu    = BLOC(condition = " NOM_COLONNE == 'RESI_RELA' or \
                    NOM_COLONNE == 'RESI_MAXI' or\
                    NOM_COLONNE == 'RESI_REFE' or\
                    NOM_COLONNE == 'CTCD_GEOM' or\
                    NOM_COLONNE == 'STANDARD' ",
                            INFO_RESIDU = SIMP(statut='f',typ='TXM',defaut="NON",into=("OUI","NON")),
                          ),
         ),
#-------------------------------------------------------------------
         ARCHIVAGE       =FACT(statut='f',
           regles=(EXCLUS('PAS_ARCH','LIST_INST','INST'),
                   EXCLUS('ARCH_ETAT_INIT','NUME_INIT'), ),
           LIST_INST       =SIMP(statut='f',typ=(listr8_sdaster) ),
           INST            =SIMP(statut='f',typ='R',validators=NoRepeat(),max='**' ),
           PAS_ARCH        =SIMP(statut='f',typ='I' ),
           PRECISION       =SIMP(statut='f',typ='R',defaut= 1.0E-3),
           ARCH_ETAT_INIT  =SIMP(statut='f',typ='TXM',into=("OUI",)),
           NUME_INIT       =SIMP(statut='f',typ='I'),
           DETR_NUME_SUIV  =SIMP(statut='f',typ='TXM',into=("OUI",)),
           CHAM_EXCLU      =SIMP(statut='f',typ='TXM',validators=NoRepeat(),max='**',
           into=("DEPL","SIEF_ELGA","VARI_ELGA","ACCE","VITE","VARI_NON_LOCAL","LANL_ELGA")),
         ),
         OBSERVATION     =FACT(statut='f',max='**',
           regles=(UN_PARMI('NOEUD','GROUP_NO','MAILLE'),
                   PRESENT_PRESENT('MAILLE','POINT'),),
           NOM_CHAM        =SIMP(statut='o',typ='TXM',validators=NoRepeat(),max='**',

into=("DEPL","VITE","ACCE","SIEF_ELGA","VARI_ELGA","DEPL_ABSOLU","VITE_ABSOLU","ACCE_ABSOLU") ),
           NOM_CMP         =SIMP(statut='o',typ='TXM',max='**' ),
           LIST_ARCH       =SIMP(statut='f',typ=listis_sdaster),
           LIST_INST       =SIMP(statut='f',typ=listr8_sdaster),
           INST            =SIMP(statut='f',typ='R',validators=NoRepeat(),max='**' ),
           PRECISION       =SIMP(statut='f',typ='R',defaut= 1.0E-3 ),
           CRITERE         =SIMP(statut='f',typ='TXM',defaut="RELATIF",into=("RELATIF","ABSOLU") ),
           PAS_OBSE        =SIMP(statut='f',typ='I'),
           NOEUD           =SIMP(statut='f',typ=no  ,validators=NoRepeat(),max='**'),
           GROUP_NO        =SIMP(statut='f',typ=grno,validators=NoRepeat(),max='**'),
           MAILLE          =SIMP(statut='f',typ=ma  ,validators=NoRepeat(),max='**'),
           POINT           =SIMP(statut='f',typ='I' ,max='**'),
         ),
#-------------------------------------------------------------------
           SOLV_NON_LOCAL  =FACT(statut='f',
             METHODE         =SIMP(statut='f',typ='TXM',defaut="MULT_FRONT",into=("MULT_FRONT","LDLT","GCPC") ),
             b_mult_front    =BLOC(condition = "METHODE == 'MULT_FRONT' ",fr="Paramètres de la méthode multi frontale",
               RENUM           =SIMP(statut='f',typ='TXM',defaut="METIS",into=("MD","MDA","METIS") ),
             ),
             b_ldlt         =BLOC(condition = "METHODE == 'LDLT' ",fr="Paramètres de la méthode LDLT",
               RENUM           =SIMP(statut='f',typ='TXM',defaut="RCMK",into=("RCMK","SANS") ),
             ),
             b_ldlt_mult    =BLOC(condition = "METHODE == 'LDLT' or METHODE == 'MULT_FRONT' ",
                                    fr="Paramètres relatifs à la non inversibilité de la matrice à factorise",
               NPREC           =SIMP(statut='f',typ='I',defaut= 8 ),
               STOP_SINGULIER  =SIMP(statut='f',typ='TXM',defaut="OUI",into=("OUI","NON") ),
             ),
             b_gcpc         =BLOC(condition = "METHODE == 'GCPC' ", fr="Paramètres de la méthode du gradient conjugué",
               PRE_COND        =SIMP(statut='f',typ='TXM',into=("LDLT_INC",),defaut="LDLT_INC" ),
               NIVE_REMPLISSAGE=SIMP(statut='f',typ='I',defaut= 0 ),
               RESI_RELA       =SIMP(statut='f',typ='R',defaut= 1.E-6 ),
               NMAX_ITER       =SIMP(statut='f',typ='I',defaut= 0 ),
             ),
           ),
           LAGR_NON_LOCAL  =FACT(statut='f',
             ITER_DUAL_MAXI  =SIMP(statut='f',typ='I',defaut= 50),
             RESI_DUAL_ABSO  =SIMP(statut='o',typ='R'),
             RESI_PRIM_ABSO  =SIMP(statut='o',typ='R'),
             R               =SIMP(statut='f',typ='R',defaut= 1000.),
             ITER_PRIM_MAXI  =SIMP(statut='f',typ='I',defaut= 10),
           ),
#-------------------------------------------------------------------
         INFO            =SIMP(statut='f',typ='I',defaut=1,into=(1,2) ),
         TITRE           =SIMP(statut='f',typ='TXM',max='**'),
)  ;
#& MODIF COMMANDE  DATE 10/10/2006   AUTEUR MCOURTOI M.COURTOIS 
#            CONFIGURATION MANAGEMENT OF EDF VERSION
# ======================================================================
# COPYRIGHT (C) 1991 - 2001  EDF R&D                  WWW.CODE-ASTER.ORG
# THIS PROGRAM IS FREE SOFTWARE; YOU CAN REDISTRIBUTE IT AND/OR MODIFY
# IT UNDER THE TERMS OF THE GNU GENERAL PUBLIC LICENSE AS PUBLISHED BY
# THE FREE SOFTWARE FOUNDATION; EITHER VERSION 2 OF THE LICENSE, OR   
# (AT YOUR OPTION) ANY LATER VERSION.                                 
#
# THIS PROGRAM IS DISTRIBUTED IN THE HOPE THAT IT WILL BE USEFUL, BUT 
# WITHOUT ANY WARRANTY; WITHOUT EVEN THE IMPLIED WARRANTY OF          
# MERCHANTABILITY OR FITNESS FOR A PARTICULAR PURPOSE. SEE THE GNU    
# GENERAL PUBLIC LICENSE FOR MORE DETAILS.                            
#
# YOU SHOULD HAVE RECEIVED A COPY OF THE GNU GENERAL PUBLIC LICENSE   
# ALONG WITH THIS PROGRAM; IF NOT, WRITE TO EDF R&D CODE_ASTER,       
#    1 AVENUE DU GENERAL DE GAULLE, 92141 CLAMART CEDEX, FRANCE.      
# ======================================================================
DYNA_TRAN_MODAL=OPER(nom="DYNA_TRAN_MODAL",op=  74,sd_prod=tran_gene,
                     fr="Calcul de la réponse dynamique transitoire d'un système amorti ou non en coordonées généralisées"
                        +" par superposition modale ou par sous structuration",
                     reentrant='f',
            UIinfo={"groupes":("Résolution",)},
      regles=(EXCLUS('AMOR_REDUIT','AMOR_GENE','LIST_AMOR'), 
              PRESENT_ABSENT('MODE_STAT','MODE_CORR'),),
         METHODE         =SIMP(statut='f',typ='TXM',defaut="EULER",
                               into=("EULER","NEWMARK","DEVOGE","ADAPT","ITMI") ),
         MASS_GENE       =SIMP(statut='o',typ=matr_asse_gene_r ),
         RIGI_GENE       =SIMP(statut='o',typ=matr_asse_gene_r ),
         AMOR_GENE       =SIMP(statut='f',typ=matr_asse_gene_r ),
         AMOR_REDUIT     =SIMP(statut='f',typ='R',max='**'),
         LIST_AMOR       =SIMP(statut='f',typ=listr8_sdaster ),
         MODE_STAT       =SIMP(statut='f',typ=(mode_stat_depl,mode_stat_acce,mode_stat_forc) ),
         MODE_CORR       =SIMP(statut='f',typ=(mult_elas,mode_stat_acce) ,),
         
         ETAT_INIT       =FACT(statut='f',
           regles=(EXCLUS('RESU_GENE','DEPL_INIT_GENE'),
                   EXCLUS('RESU_GENE','VITE_INIT_GENE'),),
           RESU_GENE       =SIMP(statut='f',typ=tran_gene ),
           b_resu_gene     =BLOC(condition = "RESU_GENE != None",
             INST_INIT       =SIMP(statut='f',typ='R' ),
             PRECISION       =SIMP(statut='f',typ='R',defaut= 1.E-3 ),
             CRITERE         =SIMP(statut='f',typ='TXM',defaut="RELATIF",into=("RELATIF","ABSOLU") ),
           ),
           DEPL_INIT_GENE  =SIMP(statut='f',typ=vect_asse_gene ),
           VITE_INIT_GENE  =SIMP(statut='f',typ=vect_asse_gene ),
         ),
         INCREMENT       =FACT(statut='o',max='**',
           INST_INIT       =SIMP(statut='f',typ='R' ),
           INST_FIN        =SIMP(statut='o',typ='R' ),
           PAS             =SIMP(statut='f',typ='R' ),
           VERI_PAS        =SIMP(statut='f',typ='TXM',defaut="OUI",into=("OUI","NON") ),
           VITE_MIN        =SIMP(statut='f',typ='TXM',defaut="NORM",into=("MAXI","NORM") ),
           COEF_MULT_PAS   =SIMP(statut='f',typ='R',defaut= 1.1 ),
           COEF_DIVI_PAS   =SIMP(statut='f',typ='R',defaut= 1.3333334 ),
           PAS_LIMI_RELA   =SIMP(statut='f',typ='R',defaut= 1.0E-6 ),
           NB_POIN_PERIODE =SIMP(statut='f',typ='I',defaut= 50 ),
           NMAX_ITER_PAS   =SIMP(statut='f',typ='I',defaut= 16 ),
         ),
         ARCHIVAGE       =FACT(statut='f',
           regles=(UN_PARMI('LIST_ARCH','PAS_ARCH'),),
           LIST_ARCH       =SIMP(statut='f',typ=listis_sdaster ),
           PAS_ARCH        =SIMP(statut='f',typ='I' ),
         ),
         
         NMAX_ITER       =SIMP(statut='f',typ='I',defaut= 20 ),
         RESI_RELA       =SIMP(statut='f',typ='R',defaut= 1.0E-3 ),
         LAMBDA          =SIMP(statut='f',typ='R',defaut= 10. ),
         
         EXCIT           =FACT(statut='f',max='**',
           regles=(UN_PARMI('FONC_MULT','COEF_MULT','ACCE'),
                   PRESENT_PRESENT('ACCE','VITE','DEPL'),
                   PRESENT_PRESENT('D_FONC_DT','D_FONC_DT2'),
                   PRESENT_ABSENT('NUME_ORDRE','VECT_GENE','COEF_MULT'),
                   EXCLUS('MULT_APPUI','CORR_STAT'),
                   PRESENT_ABSENT('MULT_APPUI','COEF_MULT'),
                   PRESENT_ABSENT('MULT_APPUI','FONC_MULT'),),
           VECT_GENE       =SIMP(statut='f',typ=vect_asse_gene ),
           NUME_ORDRE      =SIMP(statut='f',typ='I' ),
           FONC_MULT       =SIMP(statut='f',typ=(fonction_sdaster,nappe_sdaster,formule) ),
           COEF_MULT       =SIMP(statut='f',typ='R' ),
           ACCE            =SIMP(statut='f',typ=(fonction_sdaster,nappe_sdaster,formule) ),
           VITE            =SIMP(statut='f',typ=(fonction_sdaster,nappe_sdaster,formule) ),
           DEPL            =SIMP(statut='f',typ=(fonction_sdaster,nappe_sdaster,formule) ),
           MULT_APPUI      =SIMP(statut='f',typ='TXM',into=("OUI",) ),
           DIRECTION       =SIMP(statut='f',typ='R',max='**'),
           b_loca          =BLOC(condition= "DIRECTION != None",
             regles=(EXCLUS('NOEUD','GROUP_NO'),),
             NOEUD           =SIMP(statut='f',typ=no  ,validators=NoRepeat(),max='**'),
             GROUP_NO        =SIMP(statut='f',typ=grno,validators=NoRepeat(),max='**'),
           ),
           CORR_STAT       =SIMP(statut='f',typ='TXM',into=("OUI",) ),
           D_FONC_DT       =SIMP(statut='f',typ=(fonction_sdaster,nappe_sdaster,formule) ),
           D_FONC_DT2      =SIMP(statut='f',typ=(fonction_sdaster,nappe_sdaster,formule) ),
         ),
         CHOC            =FACT(statut='f',max='**',
           regles=(UN_PARMI('MAILLE','GROUP_MA','NOEUD_1','GROUP_NO_1' ),
                   EXCLUS('NOEUD_2','GROUP_NO_2'),
                   PRESENT_ABSENT('GROUP_MA','NOEUD_2','GROUP_NO_2'),
                   PRESENT_ABSENT('MAILLE','NOEUD_2','GROUP_NO_2'),),
           INTITULE        =SIMP(statut='f',typ='TXM' ),
           GROUP_MA        =SIMP(statut='f',typ=grma,max='**'),
           MAILLE          =SIMP(statut='f',typ=ma,max='**'),
           NOEUD_1         =SIMP(statut='f',typ=no),
           NOEUD_2         =SIMP(statut='f',typ=no),
           GROUP_NO_1      =SIMP(statut='f',typ=grno),
           GROUP_NO_2      =SIMP(statut='f',typ=grno),
           OBSTACLE        =SIMP(statut='o',typ=table_fonction),
           ORIG_OBST       =SIMP(statut='f',typ='R',min=3,max=3),
           NORM_OBST       =SIMP(statut='o',typ='R',min=3,max=3),
           ANGL_VRIL       =SIMP(statut='f',typ='R' ),
           JEU             =SIMP(statut='f',typ='R',defaut= 1. ),
           DIST_1          =SIMP(statut='f',typ='R',val_min=0.E+0 ),
           DIST_2          =SIMP(statut='f',typ='R',val_min=0.E+0 ),
           SOUS_STRUC_1    =SIMP(statut='f',typ='TXM' ),
           SOUS_STRUC_2    =SIMP(statut='f',typ='TXM' ),
           REPERE          =SIMP(statut='f',typ='TXM',defaut="GLOBAL"),
           RIGI_NOR        =SIMP(statut='f',typ='R' ),
           AMOR_NOR        =SIMP(statut='f',typ='R',defaut= 0.E+0 ),
           RIGI_TAN        =SIMP(statut='f',typ='R',defaut= 0.E+0 ),
           AMOR_TAN        =SIMP(statut='f',typ='R',defaut= 0.E+0 ),
           COULOMB         =SIMP(statut='f',typ='R',defaut= 0.E+0 ),

           LAME_FLUIDE     =SIMP(statut='f',typ='TXM',defaut="NON",into=("OUI","NON") ),
           b_lame          =BLOC(condition="LAME_FLUIDE=='OUI'",
               ALPHA           =SIMP(statut='f',typ='R',defaut= 0.E+0 ),
               BETA            =SIMP(statut='f',typ='R',defaut= 0.E+0 ),
               CHI             =SIMP(statut='f',typ='R',defaut= 0.E+0 ),
               DELTA           =SIMP(statut='f',typ='R',defaut= 0.E+0 ),
           ),
         ),
         VERI_CHOC       =FACT(statut='f',max='**',
           STOP_CRITERE    =SIMP(statut='f',typ='TXM',defaut="OUI",into=("OUI","NON") ),
           SEUIL           =SIMP(statut='f',typ='R',defaut= 0.5 ),
         ),
         FLAMBAGE        =FACT(statut='f',max='**',
           regles=(UN_PARMI('NOEUD_1','GROUP_NO_1'),
                   EXCLUS('NOEUD_2','GROUP_NO_2'),),
           NOEUD_1         =SIMP(statut='f',typ=no),
           NOEUD_2         =SIMP(statut='f',typ=no),
           GROUP_NO_1      =SIMP(statut='f',typ=grno),
           GROUP_NO_2      =SIMP(statut='f',typ=grno),
           OBSTACLE        =SIMP(statut='o',typ=table_fonction),
           ORIG_OBST       =SIMP(statut='f',typ='R',max='**'),
           NORM_OBST       =SIMP(statut='o',typ='R',max='**'),
           ANGL_VRIL       =SIMP(statut='f',typ='R' ),
           JEU             =SIMP(statut='f',typ='R',defaut= 1. ),
           DIST_1          =SIMP(statut='f',typ='R' ),
           DIST_2          =SIMP(statut='f',typ='R' ),
           REPERE          =SIMP(statut='f',typ='TXM',defaut="GLOBAL"),
           RIGI_NOR        =SIMP(statut='f',typ='R' ),
           FNOR_CRIT       =SIMP(statut='f',typ='R' ),
           FNOR_POST_FL    =SIMP(statut='f',typ='R' ),
           RIGI_NOR_POST_FL=SIMP(statut='f',typ='R' ),
         ),
         ANTI_SISM       =FACT(statut='f',max='**',
           regles=(UN_PARMI('NOEUD_1','GROUP_NO_1'),
                   UN_PARMI('NOEUD_2','GROUP_NO_2'),),
           NOEUD_1         =SIMP(statut='f',typ=no),
           NOEUD_2         =SIMP(statut='f',typ=no),
           GROUP_NO_1      =SIMP(statut='f',typ=grno),
           GROUP_NO_2      =SIMP(statut='f',typ=grno),
           RIGI_K1         =SIMP(statut='f',typ='R',defaut= 0.E+0 ),
           RIGI_K2         =SIMP(statut='f',typ='R',defaut= 0.E+0 ),
           SEUIL_FX        =SIMP(statut='f',typ='R',defaut= 0.E+0 ),
           C               =SIMP(statut='f',typ='R',defaut= 0.E+0 ),
           PUIS_ALPHA      =SIMP(statut='f',typ='R',defaut= 0.E+0 ),
           DX_MAX          =SIMP(statut='f',typ='R',defaut= 1. ),
         ),
         RELA_EFFO_DEPL  =FACT(statut='f',max='**',
           NOEUD           =SIMP(statut='o',typ=no),
           SOUS_STRUC      =SIMP(statut='f',typ='TXM' ),
           NOM_CMP         =SIMP(statut='f',typ='TXM' ),
           RELATION        =SIMP(statut='o',typ=(fonction_sdaster,nappe_sdaster,formule) ),
         ),
         RELA_TRANSIS    =FACT(statut='f',max='**',
           NOEUD           =SIMP(statut='o',typ=no),
           SOUS_STRUC      =SIMP(statut='f',typ='TXM' ),
           NOM_CMP         =SIMP(statut='f',typ='TXM' ),
           RELATION        =SIMP(statut='o',typ=(fonction_sdaster,nappe_sdaster,formule) ),
         ),
         RELA_EFFO_VITE  =FACT(statut='f',max='**',
           NOEUD           =SIMP(statut='o',typ=no),
           SOUS_STRUC      =SIMP(statut='f',typ='TXM' ),
           NOM_CMP         =SIMP(statut='f',typ='TXM' ),
           RELATION        =SIMP(statut='o',typ=(fonction_sdaster,nappe_sdaster,formule) ),
         ),
         b_itmi          =BLOC(condition = "METHODE=='ITMI'",
                regles=(ENSEMBLE('BASE_ELAS_FLUI','NUME_VITE_FLUI'),),
                BASE_ELAS_FLUI  =SIMP(statut='f',typ=melasflu_sdaster ),
                NUME_VITE_FLUI  =SIMP(statut='f',typ='I' ),
                ETAT_STAT       =SIMP(statut='f',typ='TXM',defaut="NON",into=("OUI","NON") ),
                PREC_DUREE      =SIMP(statut='f',typ='R',defaut= 1.E-2 ),
                CHOC_FLUI       =SIMP(statut='f',typ='TXM',defaut="NON",into=("OUI","NON") ),
                NB_MODE         =SIMP(statut='f',typ='I' ),
                NB_MODE_FLUI    =SIMP(statut='f',typ='I' ),
                NB_MODE_DIAG    =SIMP(statut='f',typ='I' ),
                TS_REG_ETAB     =SIMP(statut='f',typ='R' ),
         ),
         INFO            =SIMP(statut='f',typ='I',defaut= 1,into=( 1 , 2) ),
         IMPRESSION      =FACT(statut='f',max='**',
           regles=(EXCLUS('TOUT','NIVEAU'),),
           TOUT            =SIMP(statut='f',typ='TXM',into=("OUI",) ),
           NIVEAU          =SIMP(statut='f',typ='TXM',into=("DEPL_LOC","VITE_LOC","FORC_LOC","TAUX_CHOC") ),
           INST_INIT       =SIMP(statut='f',typ='R' ),
           INST_FIN        =SIMP(statut='f',typ='R' ),
         ),
         TITRE           =SIMP(statut='f',typ='TXM',max='**'),
 )  ;
#& MODIF COMMANDE  DATE 22/06/2005   AUTEUR REZETTE C.REZETTE 
#            CONFIGURATION MANAGEMENT OF EDF VERSION
# ======================================================================
# COPYRIGHT (C) 1991 - 2001  EDF R&D                  WWW.CODE-ASTER.ORG
# THIS PROGRAM IS FREE SOFTWARE; YOU CAN REDISTRIBUTE IT AND/OR MODIFY
# IT UNDER THE TERMS OF THE GNU GENERAL PUBLIC LICENSE AS PUBLISHED BY
# THE FREE SOFTWARE FOUNDATION; EITHER VERSION 2 OF THE LICENSE, OR   
# (AT YOUR OPTION) ANY LATER VERSION.                                 
#
# THIS PROGRAM IS DISTRIBUTED IN THE HOPE THAT IT WILL BE USEFUL, BUT 
# WITHOUT ANY WARRANTY; WITHOUT EVEN THE IMPLIED WARRANTY OF          
# MERCHANTABILITY OR FITNESS FOR A PARTICULAR PURPOSE. SEE THE GNU    
# GENERAL PUBLIC LICENSE FOR MORE DETAILS.                            
#
# YOU SHOULD HAVE RECEIVED A COPY OF THE GNU GENERAL PUBLIC LICENSE   
# ALONG WITH THIS PROGRAM; IF NOT, WRITE TO EDF R&D CODE_ASTER,       
#    1 AVENUE DU GENERAL DE GAULLE, 92141 CLAMART CEDEX, FRANCE.      
# ======================================================================
# RESPONSABLE VABHHTS J.PELLET
ENGENDRE_TEST=PROC(nom="ENGENDRE_TEST",op=178,
            UIinfo={"groupes":("Impression",)},
      fr="Engendre des tests pour la non régression du code (pour développeurs)",
      regles=(UN_PARMI('TOUT','CO'),),
         UNITE           =SIMP(statut='f',typ='I',defaut=8),  
         TOUT            =SIMP(statut='f',typ='TXM',into=("OUI",) ),
         CO              =SIMP(statut='f',typ=assd,validators=NoRepeat(),max='**'),
         TYPE_TEST       =SIMP(statut='f',typ='TXM',defaut="SOMME",into=("SOMME","RESUME") ),
         FORMAT_R        =SIMP(statut='f',typ='TXM',defaut="1PE12.5"),
         PREC_R          =SIMP(statut='f',typ='TXM',defaut="1.E-5"),
)  ;
#& MODIF COMMANDE  DATE 29/08/2006   AUTEUR MCOURTOI M.COURTOIS 
#            CONFIGURATION MANAGEMENT OF EDF VERSION
# ======================================================================
# COPYRIGHT (C) 1991 - 2001  EDF R&D                  WWW.CODE-ASTER.ORG
# THIS PROGRAM IS FREE SOFTWARE; YOU CAN REDISTRIBUTE IT AND/OR MODIFY
# IT UNDER THE TERMS OF THE GNU GENERAL PUBLIC LICENSE AS PUBLISHED BY
# THE FREE SOFTWARE FOUNDATION; EITHER VERSION 2 OF THE LICENSE, OR   
# (AT YOUR OPTION) ANY LATER VERSION.                                 
#
# THIS PROGRAM IS DISTRIBUTED IN THE HOPE THAT IT WILL BE USEFUL, BUT 
# WITHOUT ANY WARRANTY; WITHOUT EVEN THE IMPLIED WARRANTY OF          
# MERCHANTABILITY OR FITNESS FOR A PARTICULAR PURPOSE. SEE THE GNU    
# GENERAL PUBLIC LICENSE FOR MORE DETAILS.                            
#
# YOU SHOULD HAVE RECEIVED A COPY OF THE GNU GENERAL PUBLIC LICENSE   
# ALONG WITH THIS PROGRAM; IF NOT, WRITE TO EDF R&D CODE_ASTER,       
#    1 AVENUE DU GENERAL DE GAULLE, 92141 CLAMART CEDEX, FRANCE.      
# ======================================================================

from Macro.exec_logiciel_ops import exec_logiciel_ops
def exec_logiciel_prod(self, MAILLAGE, **args):
   if MAILLAGE != None:
      mcf = MAILLAGE[0]
      self.type_sdprod(mcf['MAILLAGE'], maillage_sdaster)
   return None

EXEC_LOGICIEL = MACRO(nom="EXEC_LOGICIEL",op=exec_logiciel_ops, sd_prod=exec_logiciel_prod,
                      fr="Exécute un logiciel ou une commande système depuis Aster",
                      UIinfo={"groupes":("Outils métier",)},
      
      regles = (AU_MOINS_UN('LOGICIEL', 'MAILLAGE'),),
      
      LOGICIEL = SIMP(statut='f', typ='TXM'),
      ARGUMENT = SIMP(statut='f', max='**', typ='TXM'),

      MAILLAGE = FACT(statut='f',
         FORMAT     = SIMP(statut='o', typ='TXM', into=("GMSH", "GIBI", "SALOME")),
         UNITE_GEOM = SIMP(statut='f', typ='I', val_min=10, val_max=90, defaut=16,
                           fr="Unité logique définissant le fichier (fort.N) contenant les données géométriques (datg)"),
         UNITE      = SIMP(statut='f', typ='I', val_min=10, val_max=90, defaut=19,
                           fr="Unité logique définissant le fichier (fort.N) produit par le mailleur"),
         MAILLAGE   = SIMP(statut='o', typ=CO),
      ),

      CODE_RETOUR_MAXI = SIMP(statut='f', typ='I', defaut=0, val_min=-1,
                              fr="Valeur maximale du code retour toléré (-1 pour l'ignorer)"),
      
      INFO     = SIMP(statut='f', typ='I', defaut=2, into=(1,2),),
)
#& MODIF COMMANDE  DATE 14/10/2005   AUTEUR CIBHHLV L.VIVAN 
#            CONFIGURATION MANAGEMENT OF EDF VERSION
# ======================================================================
# COPYRIGHT (C) 1991 - 2001  EDF R&D                  WWW.CODE-ASTER.ORG
# THIS PROGRAM IS FREE SOFTWARE; YOU CAN REDISTRIBUTE IT AND/OR MODIFY
# IT UNDER THE TERMS OF THE GNU GENERAL PUBLIC LICENSE AS PUBLISHED BY
# THE FREE SOFTWARE FOUNDATION; EITHER VERSION 2 OF THE LICENSE, OR   
# (AT YOUR OPTION) ANY LATER VERSION.                                 
#
# THIS PROGRAM IS DISTRIBUTED IN THE HOPE THAT IT WILL BE USEFUL, BUT 
# WITHOUT ANY WARRANTY; WITHOUT EVEN THE IMPLIED WARRANTY OF          
# MERCHANTABILITY OR FITNESS FOR A PARTICULAR PURPOSE. SEE THE GNU    
# GENERAL PUBLIC LICENSE FOR MORE DETAILS.                            
#
# YOU SHOULD HAVE RECEIVED A COPY OF THE GNU GENERAL PUBLIC LICENSE   
# ALONG WITH THIS PROGRAM; IF NOT, WRITE TO EDF R&D CODE_ASTER,       
#    1 AVENUE DU GENERAL DE GAULLE, 92141 CLAMART CEDEX, FRANCE.      
# ======================================================================
def extr_mode_prod(FILTRE_MODE,**args):
  vale=FILTRE_MODE[0]['MODE']
  if AsType(vale) == mode_meca   : return mode_meca
  if AsType(vale) == mode_meca_c : return mode_meca_c
  if AsType(vale) == mode_gene   : return mode_gene
  raise AsException("type de concept resultat non prevu")

EXTR_MODE=OPER(nom="EXTR_MODE",op= 168,sd_prod=extr_mode_prod,
               reentrant='n',fr="Extraire séléctivement des modes des structures de données modales",
            UIinfo={"groupes":("Résolution",)},
         FILTRE_MODE     =FACT(statut='o',max='**',
           regles=(UN_PARMI('TOUT_ORDRE','NUME_ORDRE','NUME_MODE','NUME_MODE_EXCLU','FREQ_MIN','CRIT_EXTR',),),
           MODE            =SIMP(statut='o',typ=(mode_meca,mode_meca_c,mode_gene ) ),
           TOUT_ORDRE      =SIMP(statut='f',typ='TXM',into=("OUI","NON") ),
           NUME_ORDRE      =SIMP(statut='f',typ='I',validators=NoRepeat(),max='**'),
           NUME_MODE       =SIMP(statut='f',typ='I',validators=NoRepeat(),max='**'),
           NUME_MODE_EXCLU =SIMP(statut='f',typ='I',validators=NoRepeat(),max='**'),
           FREQ_MIN        =SIMP(statut='f',typ='R' ),
           CRIT_EXTR       =SIMP(statut='f',typ='TXM',into=("MASS_EFFE_UN","MASS_GENE") ),
           b_freq_min      =BLOC(condition = "FREQ_MIN != None",  
             FREQ_MAX        =SIMP(statut='o',typ='R' ),
             PRECISION       =SIMP(statut='f',typ='R',defaut= 1.E-3 ),
           ),
           b_crit_extr     =BLOC(condition = "CRIT_EXTR != None",
             regles=(AU_MOINS_UN('SEUIL','SEUIL_X','SEUIL_Y','SEUIL_Z'),),
             SEUIL           =SIMP(statut='f',typ='R'),
             SEUIL_X         =SIMP(statut='f',typ='R'),
             SEUIL_Y         =SIMP(statut='f',typ='R'),
             SEUIL_Z         =SIMP(statut='f',typ='R'),
           ),    
         ),
         TITRE           =SIMP(statut='f',typ='TXM',max='**'),
         IMPRESSION      =FACT(statut='f',
           CUMUL           =SIMP(statut='f',typ='TXM',defaut="NON",into=("OUI","NON") ),
           CRIT_EXTR       =SIMP(statut='f',typ='TXM',defaut="MASS_EFFE_UN",into=("MASS_EFFE_UN","MASS_GENE") ),
         ),
)  ;
#& MODIF COMMANDE  DATE 10/10/2006   AUTEUR VABHHTS J.PELLET 
#            CONFIGURATION MANAGEMENT OF EDF VERSION
# ======================================================================
# COPYRIGHT (C) 1991 - 2001  EDF R&D                  WWW.CODE-ASTER.ORG
# THIS PROGRAM IS FREE SOFTWARE; YOU CAN REDISTRIBUTE IT AND/OR MODIFY
# IT UNDER THE TERMS OF THE GNU GENERAL PUBLIC LICENSE AS PUBLISHED BY
# THE FREE SOFTWARE FOUNDATION; EITHER VERSION 2 OF THE LICENSE, OR
# (AT YOUR OPTION) ANY LATER VERSION.
#
# THIS PROGRAM IS DISTRIBUTED IN THE HOPE THAT IT WILL BE USEFUL, BUT
# WITHOUT ANY WARRANTY; WITHOUT EVEN THE IMPLIED WARRANTY OF
# MERCHANTABILITY OR FITNESS FOR A PARTICULAR PURPOSE. SEE THE GNU
# GENERAL PUBLIC LICENSE FOR MORE DETAILS.
#
# YOU SHOULD HAVE RECEIVED A COPY OF THE GNU GENERAL PUBLIC LICENSE
# ALONG WITH THIS PROGRAM; IF NOT, WRITE TO EDF R&D CODE_ASTER,
#    1 AVENUE DU GENERAL DE GAULLE, 92141 CLAMART CEDEX, FRANCE.
# ======================================================================
def extr_resu_prod(RESULTAT,**args):
  if AsType(RESULTAT) == evol_elas    : return evol_elas
  if AsType(RESULTAT) == evol_noli    : return evol_noli
  if AsType(RESULTAT) == evol_ther    : return evol_ther
  if AsType(RESULTAT) == dyna_trans   : return dyna_trans
  if AsType(RESULTAT) == dyna_harmo   : return dyna_harmo
  if AsType(RESULTAT) == acou_harmo   : return acou_harmo
  if AsType(RESULTAT) == mode_meca    : return mode_meca
  if AsType(RESULTAT) == mode_acou    : return mode_acou
  if AsType(RESULTAT) == mode_stat_depl :    return mode_stat_depl
  if AsType(RESULTAT) == mode_stat_acce :    return mode_stat_acce
  if AsType(RESULTAT) == mode_stat_forc :    return mode_stat_forc
  if AsType(RESULTAT) == mult_elas    : return mult_elas
  if AsType(RESULTAT) == fourier_elas : return fourier_elas
  raise AsException("type de concept resultat non prevu")

EXTR_RESU=OPER(nom="EXTR_RESU",op=176,sd_prod=extr_resu_prod,reentrant='f',
            UIinfo={"groupes":("Résultats et champs",)},
            fr="Extraire des champs au sein d'une SD Résultat",
         regles=(CONCEPT_SENSIBLE('SEPARE'), REUSE_SENSIBLE(),
                 DERIVABLE('RESULTAT'),),
         RESULTAT        =SIMP(statut='o',typ=(evol_elas,dyna_trans,dyna_harmo,acou_harmo,mode_meca,
                                               mode_acou,mode_stat_depl,mode_stat_acce,mode_stat_forc,evol_ther,evol_noli,
                                               mult_elas,fourier_elas,fourier_ther ) ),

         SENSIBILITE     =SIMP(statut='f',typ=(para_sensi,theta_geom),validators=NoRepeat(),max='**',
                                   fr="Liste des paramètres de sensibilité.",
                                   ang="List of sensitivity parameters"),

         ARCHIVAGE       =FACT(statut='f',
           regles=(  UN_PARMI('NUME_ORDRE', 'INST', 'FREQ', 'NUME_MODE',
                        'NOEUD_CMP', 'LIST_INST', 'LIST_FREQ', 'LIST_ORDRE',
                        'NOM_CAS', 'LIST_ARCH', 'PAS_ARCH' ),
                     EXCLUS( 'CHAM_EXCLU','NOM_CHAM' ),   ),
           CHAM_EXCLU      =SIMP(statut='f',typ='TXM',validators=NoRepeat(),max='**'),
           NOM_CHAM        =SIMP(statut='f',typ='TXM',validators=NoRepeat(),max='**',into=C_NOM_CHAM_INTO()),
           PRECISION       =SIMP(statut='f',typ='R',defaut=1.E-3 ),
           CRITERE         =SIMP(statut='f',typ='TXM',into=("RELATIF","ABSOLU"),defaut="RELATIF"),
           LIST_ARCH       =SIMP(statut='f',typ=listis_sdaster),
           PAS_ARCH        =SIMP(statut='f',typ='I'),
           NUME_ORDRE      =SIMP(statut='f',typ='I',validators=NoRepeat(),max='**'),
           LIST_ORDRE      =SIMP(statut='f',typ=listis_sdaster),
           INST            =SIMP(statut='f',typ='R',validators=NoRepeat(),max='**'),
           LIST_INST       =SIMP(statut='f',typ=listr8_sdaster),
           FREQ            =SIMP(statut='f',typ='R',validators=NoRepeat(),max='**'),
           LIST_FREQ       =SIMP(statut='f',typ=listr8_sdaster),
           NUME_MODE       =SIMP(statut='f',typ='I',validators=NoRepeat(),max='**'),
           NOEUD_CMP       =SIMP(statut='f',typ='TXM',validators=NoRepeat(),max='**'),
           NOM_CAS         =SIMP(statut='f',typ='TXM'),
                               ),

         TITRE           =SIMP(statut='f',typ='TXM',max='**' ),
)  ;
#& MODIF COMMANDE  DATE 22/06/2005   AUTEUR REZETTE C.REZETTE 
#            CONFIGURATION MANAGEMENT OF EDF VERSION
# ======================================================================
# COPYRIGHT (C) 1991 - 2003  EDF R&D                  WWW.CODE-ASTER.ORG
# THIS PROGRAM IS FREE SOFTWARE; YOU CAN REDISTRIBUTE IT AND/OR MODIFY  
# IT UNDER THE TERMS OF THE GNU GENERAL PUBLIC LICENSE AS PUBLISHED BY  
# THE FREE SOFTWARE FOUNDATION; EITHER VERSION 2 OF THE LICENSE, OR     
# (AT YOUR OPTION) ANY LATER VERSION.                                                  
#                                                                       
# THIS PROGRAM IS DISTRIBUTED IN THE HOPE THAT IT WILL BE USEFUL, BUT   
# WITHOUT ANY WARRANTY; WITHOUT EVEN THE IMPLIED WARRANTY OF            
# MERCHANTABILITY OR FITNESS FOR A PARTICULAR PURPOSE. SEE THE GNU      
# GENERAL PUBLIC LICENSE FOR MORE DETAILS.                              
#                                                                       
# YOU SHOULD HAVE RECEIVED A COPY OF THE GNU GENERAL PUBLIC LICENSE     
# ALONG WITH THIS PROGRAM; IF NOT, WRITE TO EDF R&D CODE_ASTER,         
#    1 AVENUE DU GENERAL DE GAULLE, 92141 CLAMART CEDEX, FRANCE.        
# ======================================================================
def extr_table_prod(TYPE_RESU,**args):
  if TYPE_RESU == "MATR_ASSE_GENE_R" : return matr_asse_gene_r
  raise AsException("type de concept resultat non prevu")

EXTR_TABLE=OPER(nom="EXTR_TABLE",op=173,sd_prod=extr_table_prod,reentrant='n',
            UIinfo={"groupes":("Résultats et champs",)},
         fr="Extraire d'une table la matrice de masse généralisée assemblée",
         TYPE_RESU       =SIMP(statut='o',typ='TXM',into=("MATR_ASSE_GENE_R",) ),

         TABLE           =SIMP(statut='o',typ=table_sdaster),

         NOM_PARA        =SIMP(statut='o',typ='TXM'),

         FILTRE          =FACT(statut='f',min=1,max='**',
           NOM_PARA        =SIMP(statut='o',typ='TXM'),
           CRIT_COMP       =SIMP(statut='f',typ='TXM',defaut="EQ",
                                 into=("EQ","LT","GT","NE","LE","GE","VIDE",
                                       "NON_VIDE","MAXI","ABS_MAXI","MINI","ABS_MINI") ),
           b_vale          =BLOC(condition = "(CRIT_COMP in ('EQ','NE','GT','LT','GE','LE'))",
              regles=(UN_PARMI('VALE','VALE_I','VALE_K','VALE_C',),),
              VALE            =SIMP(statut='f',typ='R'),
              VALE_I          =SIMP(statut='f',typ='I'),
              VALE_C          =SIMP(statut='f',typ='C'),
              VALE_K          =SIMP(statut='f',typ='TXM'),),

           CRITERE         =SIMP(statut='f',typ='TXM',defaut="RELATIF",into=("RELATIF","ABSOLU") ),
           PRECISION       =SIMP(statut='f',typ='R',defaut= 1.0E-3 ),
         ),

         TITRE           =SIMP(statut='f',typ='TXM',max='**' ),  
)  ;
#& MODIF COMMANDE  DATE 22/06/2005   AUTEUR REZETTE C.REZETTE 
#            CONFIGURATION MANAGEMENT OF EDF VERSION
# ======================================================================
# COPYRIGHT (C) 1991 - 2001  EDF R&D                  WWW.CODE-ASTER.ORG
# THIS PROGRAM IS FREE SOFTWARE; YOU CAN REDISTRIBUTE IT AND/OR MODIFY
# IT UNDER THE TERMS OF THE GNU GENERAL PUBLIC LICENSE AS PUBLISHED BY
# THE FREE SOFTWARE FOUNDATION; EITHER VERSION 2 OF THE LICENSE, OR   
# (AT YOUR OPTION) ANY LATER VERSION.                                 
#
# THIS PROGRAM IS DISTRIBUTED IN THE HOPE THAT IT WILL BE USEFUL, BUT 
# WITHOUT ANY WARRANTY; WITHOUT EVEN THE IMPLIED WARRANTY OF          
# MERCHANTABILITY OR FITNESS FOR A PARTICULAR PURPOSE. SEE THE GNU    
# GENERAL PUBLIC LICENSE FOR MORE DETAILS.                            
#
# YOU SHOULD HAVE RECEIVED A COPY OF THE GNU GENERAL PUBLIC LICENSE   
# ALONG WITH THIS PROGRAM; IF NOT, WRITE TO EDF R&D CODE_ASTER,       
#    1 AVENUE DU GENERAL DE GAULLE, 92141 CLAMART CEDEX, FRANCE.      
# ======================================================================
def fact_grad_prod(MATR_ASSE,**args):
  if AsType(MATR_ASSE) == matr_asse_depl_r : return matr_asse_depl_r
  if AsType(MATR_ASSE) == matr_asse_temp_r : return matr_asse_temp_r
  if AsType(MATR_ASSE) == matr_asse_pres_r : return matr_asse_pres_r
  raise AsException("type de concept resultat non prevu")

FACT_GRAD=OPER(nom="FACT_GRAD",op=85,sd_prod=fact_grad_prod,
            UIinfo={"groupes":("Résolution",)},
               fr="Construire une matrice de préconditionnement pour une résolution par gradient conjugué",
               reentrant='n',
         MATR_ASSE       =SIMP(statut='o',
                               typ=(matr_asse_depl_r,matr_asse_temp_r,
                                    matr_asse_pres_r) ),
         PRE_COND        =SIMP(statut='f',typ='TXM',defaut="LDLT_INC",into=("LDLT_INC",) ),
         NIVE_REMPLISSAGE=SIMP(statut='f',typ='I',defaut= 0 ),  
         INFO            =SIMP(statut='f',typ='I',into=(1,2) ),
)  ;
#& MODIF COMMANDE  DATE 22/06/2005   AUTEUR REZETTE C.REZETTE 
#            CONFIGURATION MANAGEMENT OF EDF VERSION
# ======================================================================
# COPYRIGHT (C) 1991 - 2001  EDF R&D                  WWW.CODE-ASTER.ORG
# THIS PROGRAM IS FREE SOFTWARE; YOU CAN REDISTRIBUTE IT AND/OR MODIFY
# IT UNDER THE TERMS OF THE GNU GENERAL PUBLIC LICENSE AS PUBLISHED BY
# THE FREE SOFTWARE FOUNDATION; EITHER VERSION 2 OF THE LICENSE, OR
# (AT YOUR OPTION) ANY LATER VERSION.
#
# THIS PROGRAM IS DISTRIBUTED IN THE HOPE THAT IT WILL BE USEFUL, BUT
# WITHOUT ANY WARRANTY; WITHOUT EVEN THE IMPLIED WARRANTY OF
# MERCHANTABILITY OR FITNESS FOR A PARTICULAR PURPOSE. SEE THE GNU
# GENERAL PUBLIC LICENSE FOR MORE DETAILS.
#
# YOU SHOULD HAVE RECEIVED A COPY OF THE GNU GENERAL PUBLIC LICENSE
# ALONG WITH THIS PROGRAM; IF NOT, WRITE TO EDF R&D CODE_ASTER,
#    1 AVENUE DU GENERAL DE GAULLE, 92141 CLAMART CEDEX, FRANCE.
# ======================================================================
# RESPONSABLE VABHHTS J.PELLET
def fact_ldlt_prod(MATR_ASSE,**args):
  if AsType(MATR_ASSE) == matr_asse_depl_r : return matr_asse_depl_r
  if AsType(MATR_ASSE) == matr_asse_depl_c : return matr_asse_depl_c
  if AsType(MATR_ASSE) == matr_asse_temp_r : return matr_asse_temp_r
  if AsType(MATR_ASSE) == matr_asse_temp_c : return matr_asse_temp_c
  if AsType(MATR_ASSE) == matr_asse_pres_r : return matr_asse_pres_r
  if AsType(MATR_ASSE) == matr_asse_pres_c : return matr_asse_pres_c
  raise AsException("type de concept resultat non prevu")

FACT_LDLT=OPER(nom="FACT_LDLT",op=14,sd_prod=fact_ldlt_prod,
               fr="Factoriser une matrice assemblée en un produit de deux matrices triangulaires",
               reentrant='f',
            UIinfo={"groupes":("Résolution",)},
         regles=(EXCLUS('BLOC_DEBUT','DDL_DEBUT'),
                 EXCLUS('BLOC_FIN','DDL_FIN'),),
         MATR_ASSE       =SIMP(statut='o',typ=(matr_asse_depl_r,matr_asse_depl_c,matr_asse_temp_r,
                                               matr_asse_temp_c,matr_asse_pres_r,matr_asse_pres_c) ),
         STOP_SINGULIER  =SIMP(statut='f',typ='TXM',defaut="OUI",into=("OUI","NON") ),
         NPREC           =SIMP(statut='f',typ='I',defaut=8,val_min=0,),
         PRE_COND        =SIMP(statut='f',typ='TXM',defaut="SANS",into=("SANS","DIAG") ),
         BLOC_DEBUT      =SIMP(statut='f',typ='I',val_min=1,),
         DDL_DEBUT       =SIMP(statut='f',typ='I',val_min=1,),
         BLOC_FIN        =SIMP(statut='f',typ='I',val_min=1,),
         DDL_FIN         =SIMP(statut='f',typ='I',val_min=1,),
#
         EPS             =SIMP(statut='f',typ='R',defaut= 0.E+0 ),

#        mots clés pour solveur MUMPS :
         TYPE_RESOL      =SIMP(statut='f',typ='TXM',defaut='AUTO',into=('NONSYM','SYMGEN','SYMDEF','AUTO')),
         PCENT_PIVOT     =SIMP(statut='f',typ='I',defaut=20,),

         TITRE           =SIMP(statut='f',typ='TXM',max='**'),
         INFO            =SIMP(statut='f',typ='I',into=(1,2) ),
)  ;
#& MODIF COMMANDE  DATE 22/06/2005   AUTEUR REZETTE C.REZETTE 
#            CONFIGURATION MANAGEMENT OF EDF VERSION
# ======================================================================
# COPYRIGHT (C) 1991 - 2001  EDF R&D                  WWW.CODE-ASTER.ORG
# THIS PROGRAM IS FREE SOFTWARE; YOU CAN REDISTRIBUTE IT AND/OR MODIFY
# IT UNDER THE TERMS OF THE GNU GENERAL PUBLIC LICENSE AS PUBLISHED BY
# THE FREE SOFTWARE FOUNDATION; EITHER VERSION 2 OF THE LICENSE, OR   
# (AT YOUR OPTION) ANY LATER VERSION.                                 
#
# THIS PROGRAM IS DISTRIBUTED IN THE HOPE THAT IT WILL BE USEFUL, BUT 
# WITHOUT ANY WARRANTY; WITHOUT EVEN THE IMPLIED WARRANTY OF          
# MERCHANTABILITY OR FITNESS FOR A PARTICULAR PURPOSE. SEE THE GNU    
# GENERAL PUBLIC LICENSE FOR MORE DETAILS.                            
#
# YOU SHOULD HAVE RECEIVED A COPY OF THE GNU GENERAL PUBLIC LICENSE   
# ALONG WITH THIS PROGRAM; IF NOT, WRITE TO EDF R&D CODE_ASTER,       
#    1 AVENUE DU GENERAL DE GAULLE, 92141 CLAMART CEDEX, FRANCE.      
# ======================================================================
FIN=PROC(nom="FIN",op=9999,repetable='n',fr="Fin d'une étude, fin du travail engagé par une des commandes DEBUT ou POURSUITE",
            UIinfo={"groupes":("Gestion du travail",)},
         FORMAT_HDF      =SIMP(fr="sauvegarde de la base GLOBALE au format HDF",statut='f',
                               typ='TXM',defaut="NON",into=("OUI","NON",) ), 
         RETASSAGE       =SIMP(fr="provoque le retassage de la base GLOBALE",
                               statut='f',typ='TXM',defaut="NON",into=("OUI","NON",) ),
         PERFORMANCE     =SIMP(fr="provoque l'impression d'un résumé des mesures de temps ",
                               statut='f',typ='TXM',defaut="OUI",into=("OUI","NON",) ),
         INFO_RESU       =SIMP(fr="provoque l'impression des informations sur les structures de données",
                               statut='f',typ='TXM',defaut="OUI",into=("OUI","NON",) ),
         UNITE           =SIMP(statut='f',typ='I',defaut=6),  
)  ;
#& MODIF COMMANDE  DATE 22/06/2005   AUTEUR REZETTE C.REZETTE 
#            CONFIGURATION MANAGEMENT OF EDF VERSION
# ======================================================================
# COPYRIGHT (C) 1991 - 2001  EDF R&D                  WWW.CODE-ASTER.ORG
# THIS PROGRAM IS FREE SOFTWARE; YOU CAN REDISTRIBUTE IT AND/OR MODIFY
# IT UNDER THE TERMS OF THE GNU GENERAL PUBLIC LICENSE AS PUBLISHED BY
# THE FREE SOFTWARE FOUNDATION; EITHER VERSION 2 OF THE LICENSE, OR   
# (AT YOUR OPTION) ANY LATER VERSION.                                 
#
# THIS PROGRAM IS DISTRIBUTED IN THE HOPE THAT IT WILL BE USEFUL, BUT 
# WITHOUT ANY WARRANTY; WITHOUT EVEN THE IMPLIED WARRANTY OF          
# MERCHANTABILITY OR FITNESS FOR A PARTICULAR PURPOSE. SEE THE GNU    
# GENERAL PUBLIC LICENSE FOR MORE DETAILS.                            
#
# YOU SHOULD HAVE RECEIVED A COPY OF THE GNU GENERAL PUBLIC LICENSE   
# ALONG WITH THIS PROGRAM; IF NOT, WRITE TO EDF R&D CODE_ASTER,       
#    1 AVENUE DU GENERAL DE GAULLE, 92141 CLAMART CEDEX, FRANCE.      
# ======================================================================
FONC_FLUI_STRU=OPER(nom="FONC_FLUI_STRU",op= 169,sd_prod=fonction_sdaster,
                    reentrant='n',fr="Crée une fonction constante paramètrée par l'abscisse curviligne",
            UIinfo={"groupes":("Fonction",)},
         TYPE_FLUI_STRU  =SIMP(statut='o',typ=(type_flui_stru) ),
)  ;
#& MODIF COMMANDE  DATE 22/06/2005   AUTEUR REZETTE C.REZETTE 
#            CONFIGURATION MANAGEMENT OF EDF VERSION
# ======================================================================
# COPYRIGHT (C) 1991 - 2001  EDF R&D                  WWW.CODE-ASTER.ORG
# THIS PROGRAM IS FREE SOFTWARE; YOU CAN REDISTRIBUTE IT AND/OR MODIFY
# IT UNDER THE TERMS OF THE GNU GENERAL PUBLIC LICENSE AS PUBLISHED BY
# THE FREE SOFTWARE FOUNDATION; EITHER VERSION 2 OF THE LICENSE, OR   
# (AT YOUR OPTION) ANY LATER VERSION.                                 
#
# THIS PROGRAM IS DISTRIBUTED IN THE HOPE THAT IT WILL BE USEFUL, BUT 
# WITHOUT ANY WARRANTY; WITHOUT EVEN THE IMPLIED WARRANTY OF          
# MERCHANTABILITY OR FITNESS FOR A PARTICULAR PURPOSE. SEE THE GNU    
# GENERAL PUBLIC LICENSE FOR MORE DETAILS.                            
#
# YOU SHOULD HAVE RECEIVED A COPY OF THE GNU GENERAL PUBLIC LICENSE   
# ALONG WITH THIS PROGRAM; IF NOT, WRITE TO EDF R&D CODE_ASTER,       
#    1 AVENUE DU GENERAL DE GAULLE, 92141 CLAMART CEDEX, FRANCE.      
# ======================================================================
def form_pyth_ops(self,d):
  import types,string
  NOM_PARA=self.etape['NOM_PARA']
  VALE    =self.etape['VALE']
  if type(NOM_PARA) not in (types.ListType,types.TupleType) : NOM_PARA=[NOM_PARA,]
  if self.sd==None : return
  texte=string.join(VALE.splitlines())

  self.sd.setFormule(NOM_PARA,string.strip(texte))

FORMULE=FORM(nom="FORMULE",op_init=form_pyth_ops,op=-5,
             sd_prod=formule,UIinfo={"groupes":("Fonction",)},
             fr="Définit une formule réelle à partir de son expression mathématique",
         VALE     =SIMP(statut='f',typ='TXM'),
         NOM_PARA =SIMP(statut='o',typ='TXM',max='**'),
);
#& MODIF COMMANDE  DATE 10/10/2006   AUTEUR MCOURTOI M.COURTOIS 
#            CONFIGURATION MANAGEMENT OF EDF VERSION
# ======================================================================
# COPYRIGHT (C) 1991 - 2001  EDF R&D                  WWW.CODE-ASTER.ORG
# THIS PROGRAM IS FREE SOFTWARE; YOU CAN REDISTRIBUTE IT AND/OR MODIFY
# IT UNDER THE TERMS OF THE GNU GENERAL PUBLIC LICENSE AS PUBLISHED BY
# THE FREE SOFTWARE FOUNDATION; EITHER VERSION 2 OF THE LICENSE, OR   
# (AT YOUR OPTION) ANY LATER VERSION.                                 
#
# THIS PROGRAM IS DISTRIBUTED IN THE HOPE THAT IT WILL BE USEFUL, BUT 
# WITHOUT ANY WARRANTY; WITHOUT EVEN THE IMPLIED WARRANTY OF          
# MERCHANTABILITY OR FITNESS FOR A PARTICULAR PURPOSE. SEE THE GNU    
# GENERAL PUBLIC LICENSE FOR MORE DETAILS.                            
#
# YOU SHOULD HAVE RECEIVED A COPY OF THE GNU GENERAL PUBLIC LICENSE   
# ALONG WITH THIS PROGRAM; IF NOT, WRITE TO EDF R&D CODE_ASTER,       
#    1 AVENUE DU GENERAL DE GAULLE, 92141 CLAMART CEDEX, FRANCE.      
# ======================================================================
# RESPONSABLE CAMBIER S.CAMBIER
GENE_FONC_ALEA=OPER(nom="GENE_FONC_ALEA",op= 118,sd_prod=table_fonction,
                    fr="Génération de la fonction temporelle à partir d une matrice interspectrale",
                    reentrant='n',
            UIinfo={"groupes":("Fonction",)},
         INTE_SPEC       =SIMP(statut='o',typ=table_fonction),
         NUME_VITE_FLUI  =SIMP(statut='f',typ='I' ),
         INTERPOL        =SIMP(statut='f',typ='TXM',defaut="OUI",into=("NON","OUI") ),
         b_interpol_oui    =BLOC(condition = "INTERPOL == 'OUI' ",fr="Parametres cas interpolation autorisee",
           DUREE_TIRAGE    =SIMP(statut='f',typ='R' ),
           FREQ_INIT       =SIMP(statut='f',typ='R' ),
           FREQ_FIN        =SIMP(statut='f',typ='R' ),
             ),
         NB_POIN         =SIMP(statut='f',typ='I'),
         NB_TIRAGE       =SIMP(statut='f',typ='I',defaut= 1 ),
         INIT_ALEA       =SIMP(statut='f',typ='I'),
         INFO            =SIMP(statut='f',typ='I',defaut= 1,into=( 1 , 2) ),
         TITRE           =SIMP(statut='f',typ='TXM',max='**'),
)  ;
#& MODIF COMMANDE  DATE 11/07/2005   AUTEUR CAMBIER S.CAMBIER 
#            CONFIGURATION MANAGEMENT OF EDF VERSION
# ======================================================================
# COPYRIGHT (C) 1991 - 2002  EDF R&D                  WWW.CODE-ASTER.ORG
# THIS PROGRAM IS FREE SOFTWARE; YOU CAN REDISTRIBUTE IT AND/OR MODIFY  
# IT UNDER THE TERMS OF THE GNU GENERAL PUBLIC LICENSE AS PUBLISHED BY  
# THE FREE SOFTWARE FOUNDATION; EITHER VERSION 2 OF THE LICENSE, OR     
# (AT YOUR OPTION) ANY LATER VERSION.                                                  
#                                                                       
# THIS PROGRAM IS DISTRIBUTED IN THE HOPE THAT IT WILL BE USEFUL, BUT   
# WITHOUT ANY WARRANTY; WITHOUT EVEN THE IMPLIED WARRANTY OF            
# MERCHANTABILITY OR FITNESS FOR A PARTICULAR PURPOSE. SEE THE GNU      
# GENERAL PUBLIC LICENSE FOR MORE DETAILS.                              
#                                                                       
# YOU SHOULD HAVE RECEIVED A COPY OF THE GNU GENERAL PUBLIC LICENSE     
# ALONG WITH THIS PROGRAM; IF NOT, WRITE TO EDF R&D CODE_ASTER,         
#    1 AVENUE DU GENERAL DE GAULLE, 92141 CLAMART CEDEX, FRANCE.        
# ======================================================================
# RESPONSABLE CAMBIER S.CAMBIER
def gene_matr_alea_prod(MATR_MOYEN,**args ):
  if (AsType(MATR_MOYEN) == matr_asse_gene_r )  : return matr_asse_gene_r
  if (AsType(MATR_MOYEN) == macr_elem_dyna) : return macr_elem_dyna
  raise AsException("type de concept resultat non prevu")

GENE_MATR_ALEA=OPER(nom="GENE_MATR_ALEA",op=  27,
#sd_prod=matr_asse_gene_r,
sd_prod=gene_matr_alea_prod,
               fr="Générer une réalisation d'une matrice aléatoire réelle sym. déf. positive ou d'un macro élément dynamique",
               reentrant='n',
            UIinfo={"groupes":("Matrice",)},
   MATR_MOYEN   = SIMP(statut='o', typ=(matr_asse_gene_r,macr_elem_dyna)),

#    cas matrice generalisee 
   b_matr =BLOC( condition = "AsType(MATR_MOYEN) in (matr_asse_gene_r,)",
           COEF_VAR     = SIMP(statut='f', typ='R', defaut=0.1, val_min=0.E+0 ,
                                fr="coefficient de variation de la matrice a generer" ),
           ),
#    cas macr_elem_dyna 
   b_macr =BLOC( condition = "AsType(MATR_MOYEN) in (macr_elem_dyna,)",
           fr="cas macr_elem_dyna (sous-structuratio)",
           COEF_VAR_RIGI     = SIMP(statut='f', typ='R', defaut=0.1, val_min=0.E+0 ,
                                fr="coefficient de variation de la matrice de raideur" ),
           COEF_VAR_MASS     = SIMP(statut='f', typ='R', defaut=0., val_min=0.E+0 ,
                                fr="coefficient de variation de la matrice de masse" ),
           COEF_VAR_AMOR     = SIMP(statut='f', typ='R', defaut=0., val_min=0.E+0 ,
                                fr="coefficient de variation de la matrice d'amortissement" ),),

   INIT_ALEA    =SIMP(statut='f',typ='I'),
) ;
   
#& MODIF COMMANDE  DATE 28/02/2006   AUTEUR VABHHTS J.PELLET 
#            CONFIGURATION MANAGEMENT OF EDF VERSION
# ======================================================================
# COPYRIGHT (C) 1991 - 2002  EDF R&D                  WWW.CODE-ASTER.ORG
# THIS PROGRAM IS FREE SOFTWARE; YOU CAN REDISTRIBUTE IT AND/OR MODIFY  
# IT UNDER THE TERMS OF THE GNU GENERAL PUBLIC LICENSE AS PUBLISHED BY  
# THE FREE SOFTWARE FOUNDATION; EITHER VERSION 2 OF THE LICENSE, OR     
# (AT YOUR OPTION) ANY LATER VERSION.                                                  
#                                                                       
# THIS PROGRAM IS DISTRIBUTED IN THE HOPE THAT IT WILL BE USEFUL, BUT   
# WITHOUT ANY WARRANTY; WITHOUT EVEN THE IMPLIED WARRANTY OF            
# MERCHANTABILITY OR FITNESS FOR A PARTICULAR PURPOSE. SEE THE GNU      
# GENERAL PUBLIC LICENSE FOR MORE DETAILS.                              
#                                                                       
# YOU SHOULD HAVE RECEIVED A COPY OF THE GNU GENERAL PUBLIC LICENSE     
# ALONG WITH THIS PROGRAM; IF NOT, WRITE TO EDF R&D CODE_ASTER,         
#    1 AVENUE DU GENERAL DE GAULLE, 92141 CLAMART CEDEX, FRANCE.        
# ======================================================================
# RESPONSABLE CAMBIER S.CAMBIER
from Macro.gene_vari_alea_ops import gene_vari_alea_ops,gene_vari_alea_init
GENE_VARI_ALEA=MACRO(nom="GENE_VARI_ALEA",
               op_init=gene_vari_alea_init,op=gene_vari_alea_ops,
               sd_prod=reel,reentrant='n',
               fr="Générer une réalisation d'une variable aléatoire réelle de loi de probabilité donnée (Gamma ou Exponentielle)",
               UIinfo={"groupes":("Fonction",)},
   TYPE       = SIMP(statut='f', typ='TXM', into=("EXP_TRONQUEE", "EXPONENTIELLE", "GAMMA"), defaut="GAMMA"),
   b_gamma    =BLOC(condition = "TYPE == 'GAMMA' ",fr="Parametres loi gamma",
           VALE_MOY   = SIMP(statut='f', typ='R', defaut=1.),
           BORNE_INF  = SIMP(statut='f', typ='R', defaut=0.),
           COEF_VAR   = SIMP(statut='f', typ='R', defaut=0.1),
             ),
   b_expo    =BLOC(condition = "TYPE == 'EXPONENTIELLE' ",fr="Parametres loi exponentielle",
           VALE_MOY   = SIMP(statut='f', typ='R', defaut=0.),
           BORNE_INF  = SIMP(statut='f', typ='R', defaut=-1.),
             ),
   b_expo_tronq    =BLOC(condition = "TYPE == 'EXP_TRONQUEE' ",fr="Parametres loi exponentielle tronquee",
           VALE_MOY   = SIMP(statut='f', typ='R', defaut=0.),
           BORNE_INF  = SIMP(statut='f', typ='R', defaut=-1.),
           BORNE_SUP  = SIMP(statut='f', typ='R', defaut=1.),
           COEF_VAR   = SIMP(statut='f', typ='R', defaut=0.1,val_min=0.),
             ),
   INIT_ALEA       =SIMP(statut='f',typ='I'),
)
#& MODIF COMMANDE  DATE 23/08/2004   AUTEUR CIBHHLV L.VIVAN 
#            CONFIGURATION MANAGEMENT OF EDF VERSION
# ======================================================================
# COPYRIGHT (C) 1991 - 2001  EDF R&D                  WWW.CODE-ASTER.ORG
# THIS PROGRAM IS FREE SOFTWARE; YOU CAN REDISTRIBUTE IT AND/OR MODIFY
# IT UNDER THE TERMS OF THE GNU GENERAL PUBLIC LICENSE AS PUBLISHED BY
# THE FREE SOFTWARE FOUNDATION; EITHER VERSION 2 OF THE LICENSE, OR   
# (AT YOUR OPTION) ANY LATER VERSION.                                 
#
# THIS PROGRAM IS DISTRIBUTED IN THE HOPE THAT IT WILL BE USEFUL, BUT 
# WITHOUT ANY WARRANTY; WITHOUT EVEN THE IMPLIED WARRANTY OF          
# MERCHANTABILITY OR FITNESS FOR A PARTICULAR PURPOSE. SEE THE GNU    
# GENERAL PUBLIC LICENSE FOR MORE DETAILS.                            
#
# YOU SHOULD HAVE RECEIVED A COPY OF THE GNU GENERAL PUBLIC LICENSE   
# ALONG WITH THIS PROGRAM; IF NOT, WRITE TO EDF R&D CODE_ASTER,       
#    1 AVENUE DU GENERAL DE GAULLE, 92141 CLAMART CEDEX, FRANCE.      
# ======================================================================
IMPR_CHARGE=PROC(nom="IMPR_CHARGE",op= 158,
                 fr="Impression des charges mécaniques de type ddl imposés et relations linéaires entre les ddl",
                 UIinfo={"groupes":("Fonction",)},
         UNITE           =SIMP(statut='f',typ='I',defaut=30),  
         FORMAT          =SIMP(statut='f',typ='TXM',defaut="IDEAS",into=("IDEAS",) ),
         VERSION         =SIMP(statut='f',typ='I',defaut= 5,into=( 5 ,) ),
         CHARGE          =SIMP(statut='o',typ=char_meca,validators=NoRepeat(),max='**', ),
)  ;
#& MODIF COMMANDE  DATE 22/06/2005   AUTEUR REZETTE C.REZETTE 
#            CONFIGURATION MANAGEMENT OF EDF VERSION
# ======================================================================
# COPYRIGHT (C) 1991 - 2001  EDF R&D                  WWW.CODE-ASTER.ORG
# THIS PROGRAM IS FREE SOFTWARE; YOU CAN REDISTRIBUTE IT AND/OR MODIFY
# IT UNDER THE TERMS OF THE GNU GENERAL PUBLIC LICENSE AS PUBLISHED BY
# THE FREE SOFTWARE FOUNDATION; EITHER VERSION 2 OF THE LICENSE, OR   
# (AT YOUR OPTION) ANY LATER VERSION.                                 
#
# THIS PROGRAM IS DISTRIBUTED IN THE HOPE THAT IT WILL BE USEFUL, BUT 
# WITHOUT ANY WARRANTY; WITHOUT EVEN THE IMPLIED WARRANTY OF          
# MERCHANTABILITY OR FITNESS FOR A PARTICULAR PURPOSE. SEE THE GNU    
# GENERAL PUBLIC LICENSE FOR MORE DETAILS.                            
#
# YOU SHOULD HAVE RECEIVED A COPY OF THE GNU GENERAL PUBLIC LICENSE   
# ALONG WITH THIS PROGRAM; IF NOT, WRITE TO EDF R&D CODE_ASTER,       
#    1 AVENUE DU GENERAL DE GAULLE, 92141 CLAMART CEDEX, FRANCE.      
# ======================================================================
IMPR_CLASSI=PROC(nom="IMPR_CLASSI",op= 114,
            UIinfo={"groupes":("Fonction",)},fr="Ecrit le résultat d'une analyse modale au format du code CLASSI",
         regles=(EXCLUS('TOUT_ORDRE','NUME_ORDRE','FREQ','NUME_MODE','LIST_FREQ',
                        'LIST_ORDRE' ),),
         UNITE_CLASSI    =SIMP(statut='o',typ='I' ),
         MODE_MECA       =SIMP(statut='o',typ=mode_meca ),
         TOUT_ORDRE      =SIMP(statut='f',typ='TXM',into=("OUI",) ),
         NUME_ORDRE      =SIMP(statut='f',typ='I',validators=NoRepeat(),max='**'),
         LIST_ORDRE      =SIMP(statut='f',typ=listis_sdaster ),
         NUME_MODE       =SIMP(statut='f',typ='I',validators=NoRepeat(),max='**'),
         FREQ            =SIMP(statut='f',typ='R',validators=NoRepeat(),max='**'),
         LIST_FREQ       =SIMP(statut='f',typ=listr8_sdaster ),
         b_prec_crit     =BLOC(condition = "LIST_FREQ != None or FREQ != None",
             PRECISION       =SIMP(statut='f',typ='R',defaut= 1.E-3 ),
             CRITERE         =SIMP(statut='f',typ='TXM',defaut="RELATIF",
                                   into=("RELATIF","ABSOLU") ),
         ),
         IMPRESSION      =FACT(statut='f',max='**',
           regles=(UN_PARMI('NOEUD','GROUP_NO', ),),
           NOEUD           =SIMP(statut='f',typ=no   ,validators=NoRepeat(),max='**'),
           GROUP_NO        =SIMP(statut='f',typ=grno ,validators=NoRepeat(),max='**'),
           NOM_CMP         =SIMP(statut='f',typ='TXM',max='**'),
         ),
         AMOR            =SIMP(statut='o',typ='R',max='**'),
)  ;
#& MODIF COMMANDE  DATE 10/05/2006   AUTEUR MCOURTOI M.COURTOIS 
#            CONFIGURATION MANAGEMENT OF EDF VERSION
# ======================================================================
# COPYRIGHT (C) 1991 - 2001  EDF R&D                  WWW.CODE-ASTER.ORG
# THIS PROGRAM IS FREE SOFTWARE; YOU CAN REDISTRIBUTE IT AND/OR MODIFY
# IT UNDER THE TERMS OF THE GNU GENERAL PUBLIC LICENSE AS PUBLISHED BY
# THE FREE SOFTWARE FOUNDATION; EITHER VERSION 2 OF THE LICENSE, OR
# (AT YOUR OPTION) ANY LATER VERSION.
#
# THIS PROGRAM IS DISTRIBUTED IN THE HOPE THAT IT WILL BE USEFUL, BUT
# WITHOUT ANY WARRANTY; WITHOUT EVEN THE IMPLIED WARRANTY OF
# MERCHANTABILITY OR FITNESS FOR A PARTICULAR PURPOSE. SEE THE GNU
# GENERAL PUBLIC LICENSE FOR MORE DETAILS.
#
# YOU SHOULD HAVE RECEIVED A COPY OF THE GNU GENERAL PUBLIC LICENSE
# ALONG WITH THIS PROGRAM; IF NOT, WRITE TO EDF R&D CODE_ASTER,
#    1 AVENUE DU GENERAL DE GAULLE, 92141 CLAMART CEDEX, FRANCE.
# ======================================================================
# RESPONSABLE VABHHTS J.PELLET
IMPR_CO=PROC(nom="IMPR_CO",op=17,
            UIinfo={"groupes":("Impression",)},
             fr="Imprimer tous les objets JEVEUX qui constituent un concept utilisateur existant (pour les développeurs)",
         regles=(UN_PARMI('CONCEPT','CHAINE','TOUT' ),),

         UNITE           =SIMP(statut='f',typ='I',defaut=8),
         NIVEAU          =SIMP(statut='f',typ='I',defaut=2,into=(-1,0,1,2) ),
         ATTRIBUT        =SIMP(statut='f',typ='TXM',defaut="NON",into=("NON","OUI") ),
         CONTENU         =SIMP(statut='f',typ='TXM',defaut="OUI",into=("NON","OUI") ),
         BASE            =SIMP(statut='f',typ='TXM',defaut="G",into=(" ","G","V","L") ),
         CONCEPT    =FACT(statut='f',max='**',
             regles=(DERIVABLE('NOM'),),
             NOM         =SIMP(statut='o',typ=assd,validators=NoRepeat(),max='**'),
             SENSIBILITE =SIMP(statut='f',typ=(para_sensi,theta_geom),validators=NoRepeat(),
                                 fr="Paramètre de sensibilité.",
                                 ang="Sensitivity parameter",max='**'),),        
         CHAINE          =SIMP(statut='f',typ='TXM'),
         POSITION        =SIMP(statut='f',typ='I',defaut=1),
         TOUT            =SIMP(statut='f',typ='TXM',into=("OUI",) ),
)  ;
#& MODIF COMMANDE  DATE 22/06/2005   AUTEUR REZETTE C.REZETTE 
#            CONFIGURATION MANAGEMENT OF EDF VERSION
# ======================================================================
# COPYRIGHT (C) 1991 - 2004  EDF R&D                  WWW.CODE-ASTER.ORG
# THIS PROGRAM IS FREE SOFTWARE; YOU CAN REDISTRIBUTE IT AND/OR MODIFY  
# IT UNDER THE TERMS OF THE GNU GENERAL PUBLIC LICENSE AS PUBLISHED BY  
# THE FREE SOFTWARE FOUNDATION; EITHER VERSION 2 OF THE LICENSE, OR     
# (AT YOUR OPTION) ANY LATER VERSION.                                                  
#                                                                       
# THIS PROGRAM IS DISTRIBUTED IN THE HOPE THAT IT WILL BE USEFUL, BUT   
# WITHOUT ANY WARRANTY; WITHOUT EVEN THE IMPLIED WARRANTY OF            
# MERCHANTABILITY OR FITNESS FOR A PARTICULAR PURPOSE. SEE THE GNU      
# GENERAL PUBLIC LICENSE FOR MORE DETAILS.                              
#                                                                       
# YOU SHOULD HAVE RECEIVED A COPY OF THE GNU GENERAL PUBLIC LICENSE     
# ALONG WITH THIS PROGRAM; IF NOT, WRITE TO EDF R&D CODE_ASTER,         
#    1 AVENUE DU GENERAL DE GAULLE, 92141 CLAMART CEDEX, FRANCE.        
# ======================================================================
# RESPONSABLE MCOURTOI M.COURTOIS
from Macro.impr_fonction_ops import impr_fonction_ops

IMPR_FONCTION=MACRO(nom="IMPR_FONCTION",op=impr_fonction_ops,sd_prod=None,
                 fr="Imprime le contenu d'objets de type fonction ou liste de réels dans un fichier destiné à un traceur de courbe",
            UIinfo={"groupes":("Fonction",)},
         FORMAT          =SIMP(statut='o',typ='TXM',position='global',defaut='TABLEAU',
                               into=("TABLEAU","AGRAF","XMGRACE",),),
         b_pilote = BLOC(condition = "FORMAT == 'XMGRACE'",
                        fr="Mots-clés propres à XMGRACE",
           PILOTE          =SIMP(statut='f',typ='TXM',defaut='',
                                 into=('','POSTSCRIPT','EPS','MIF','SVG','PNM','PNG','JPEG','PDF','INTERACTIF'),
                            fr="Pilote de sortie, PNG/JPEG/PDF ne sont pas disponibles sur toutes les installations de xmgrace"),
           UNITE           =SIMP(statut='f',typ='I',val_min=10,val_max=90,defaut=29,
                                 fr="Unité logique définissant le fichier (fort.N) dans lequel on écrit"),
         ),
         b_agraf = BLOC(condition = "FORMAT == 'AGRAF'",
                        fr="Mots-clés propres à AGRAF",
           UNITE           =SIMP(statut='o',typ='I',defaut=25,
                                 fr="Unité logique définissant le fichier (fort.N) dans lequel on écrit"),
           UNITE_DIGR      =SIMP(statut='o',typ='I',defaut=26,
                                 fr="Unité logique définissant le fichier dans lequel on écrit les directives Agraf"),
         ),
         # unite pour TABLEAU dans le bloc de mise en forme spécifique

         COURBE          =FACT(statut='o',max='**',fr="Définition de la fonction à tracer",
           regles=(UN_PARMI('FONCTION','LIST_RESU','FONC_X','ABSCISSE'),),
           FONCTION        =SIMP(statut='f',typ=(fonction_sdaster, formule, fonction_c, nappe_sdaster),
                                 fr="Fonction réelle ou complexe", ),
           LIST_RESU       =SIMP(statut='f',typ=listr8_sdaster,
                                 fr="Liste des ordonnees d'une fonction réelle définie par deux listes", ),
           FONC_X          =SIMP(statut='f',typ=(fonction_sdaster,formule),
                                 fr="Fonction abscisses d'une fonction paramétrique",),
           ABSCISSE        =SIMP(statut='f',typ='R',max='**',
                                 fr="Valeurs des abscisses", ),
           b_fonction      =BLOC(condition = "FONCTION != None",
             LIST_PARA       =SIMP(statut='f',typ=listr8_sdaster ),
           ),
           b_fonction_c  =BLOC(condition = "AsType(FONCTION) == fonction_c",
                                 fr="Fonction complexe définie par le mot-clé fonction",
             PARTIE          =SIMP(statut='f',typ='TXM',into=("REEL","IMAG") ),
           ),
           b_list_resu     =BLOC(condition = "LIST_RESU != None",
             LIST_PARA       =SIMP(statut='o',typ=listr8_sdaster ),
           ),
           b_fonc_x        =BLOC(condition = "FONC_X != None",
             FONC_Y          =SIMP(statut='o',typ=(fonction_sdaster,formule),fr="Fonction ordonnées d une fonction paramétrique" ),
             LIST_PARA       =SIMP(statut='f',typ=listr8_sdaster ),
           ),
           b_vale_resu     =BLOC(condition = "ABSCISSE != None",
             ORDONNEE      =SIMP(statut='o',typ='R',max='**',
                                 fr="Valeurs des ordonnées"),
           ),

           # le bloc n'est pas activé (vide) car position n'est pas pris en compte
           b_forme         =BLOC(condition = "FORMAT != 'TABLEAU'",
                                 fr="Données de mise en forme de la fonction (cf. doc)",
           ),
              LEGENDE         =SIMP(statut='f',typ='TXM',
                                    fr="Légende associée à la fonction" ),
              STYLE           =SIMP(statut='f',typ='I',val_min=0,
                                    fr="Style de la ligne représentant la fonction",),
              COULEUR         =SIMP(statut='f',typ='I',val_min=0,
                                    fr="Couleur associée à la fonction",),
              MARQUEUR        =SIMP(statut='f',typ='I',val_min=0,
                                    fr="Type du marqueur associé à la fonction",),
              FREQ_MARQUEUR   =SIMP(statut='f',typ='I',defaut=0,
                                    fr="Fréquence d impression du marqueur associé à la fonction", ),
           # fin bloc b_forme
           TRI             =SIMP(statut='f',typ='TXM',defaut="N",
                                 fr="Choix du tri effectué sur les abscisses ou sur les ordonnées",
                                 into=("N","X","Y","XY","YX") ),
         ),
         # Mise en page du tableau ou du graphique
         b_tableau = BLOC(condition = "FORMAT == 'TABLEAU'",
                          fr="Mots-clés propres au format Tableau",
           UNITE           =SIMP(statut='o',typ='I',defaut=8,
                                 fr="Unité logique définissant le fichier (fort.N) dans lequel on écrit"),
           TITRE           =SIMP(statut='f',typ='TXM',
                                 fr="Titre associé au graphique" ),
           SOUS_TITRE      =SIMP(statut='f',typ='TXM',
                                 fr="Sous-titre du graphique" ),
           SEPARATEUR      =SIMP(statut='f',typ='TXM',defaut=' ',
                                 fr="Séparateur des colonnes du tableau (ex : ' ', ';'...)"),
           COMMENTAIRE     =SIMP(statut='f',typ='TXM',defaut='#',
                                 fr="Caractère indiquant au traceur de fonction que la ligne peut etre ignorée"),
           DEBUT_LIGNE     =SIMP(statut='f',typ='TXM',defaut='',
                                 fr="Caractère de debut de ligne"),
           FIN_LIGNE       =SIMP(statut='f',typ='TXM',defaut='\n',
                                 fr="Caractère de fin de ligne"),
         ),
         b_graphique = BLOC(condition = "FORMAT != 'TABLEAU'",
                        fr="Mise en page du graphique",
           TITRE           =SIMP(statut='f',typ='TXM',
                                 fr="Titre associé au graphique" ),
           SOUS_TITRE      =SIMP(statut='f',typ='TXM',
                                 fr="Sous-titre du graphique" ),
           BORNE_X         =SIMP(statut='f',typ='R',min=2,max=2,
                                 fr="Intervalles de variation des abscisses"),
           BORNE_Y         =SIMP(statut='f',typ='R',min=2,max=2,
                                 fr="Intervalles de variation des ordonnées"),
           ECHELLE_X       =SIMP(statut='f',typ='TXM',defaut="LIN",into=("LIN","LOG"),
                                 fr="Type d'échelle pour les abscisses" ),
           ECHELLE_Y       =SIMP(statut='f',typ='TXM',defaut="LIN",into=("LIN","LOG"),
                                 fr="Type d'échelle pour les ordonnées" ),
           GRILLE_X        =SIMP(statut='f',typ='R',max=1,val_min=0.,
                                 fr="Pas du quadrillage vertical" ),
           GRILLE_Y        =SIMP(statut='f',typ='R',max=1,val_min=0.,
                                 fr="Pas du quadrillage horizontal" ),
           LEGENDE_X       =SIMP(statut='f',typ='TXM',
                                 fr="Légende associée à l'axe des abscisses" ),
           LEGENDE_Y       =SIMP(statut='f',typ='TXM',
                                 fr="Légende associée à l'axe des ordonnées" ),
         ),
         INFO            =SIMP(statut='f',typ='I',defaut=1,into=(1,2) ),
)  ;
#& MODIF COMMANDE  DATE 21/02/2006   AUTEUR REZETTE C.REZETTE 
#            CONFIGURATION MANAGEMENT OF EDF VERSION
# ======================================================================
# COPYRIGHT (C) 1991 - 2001  EDF R&D                  WWW.CODE-ASTER.ORG
# THIS PROGRAM IS FREE SOFTWARE; YOU CAN REDISTRIBUTE IT AND/OR MODIFY
# IT UNDER THE TERMS OF THE GNU GENERAL PUBLIC LICENSE AS PUBLISHED BY
# THE FREE SOFTWARE FOUNDATION; EITHER VERSION 2 OF THE LICENSE, OR   
# (AT YOUR OPTION) ANY LATER VERSION.                                 
#
# THIS PROGRAM IS DISTRIBUTED IN THE HOPE THAT IT WILL BE USEFUL, BUT 
# WITHOUT ANY WARRANTY; WITHOUT EVEN THE IMPLIED WARRANTY OF          
# MERCHANTABILITY OR FITNESS FOR A PARTICULAR PURPOSE. SEE THE GNU    
# GENERAL PUBLIC LICENSE FOR MORE DETAILS.                            
#
# YOU SHOULD HAVE RECEIVED A COPY OF THE GNU GENERAL PUBLIC LICENSE   
# ALONG WITH THIS PROGRAM; IF NOT, WRITE TO EDF R&D CODE_ASTER,       
#    1 AVENUE DU GENERAL DE GAULLE, 92141 CLAMART CEDEX, FRANCE.      
# ======================================================================
IMPR_GENE=PROC(nom="IMPR_GENE",op= 157,
            fr="Imprimer le résultat d'un calcul dynamique en variables généralisées au format RESULTAT",
            UIinfo={"groupes":("Impression",)},
         FORMAT          =SIMP(statut='f',typ='TXM',defaut="RESULTAT",into=("RESULTAT",) ),
         UNITE           =SIMP(statut='f',typ='I',defaut=8),  
         GENE            =FACT(statut='o',max='**',
           regles=(EXCLUS('TOUT_ORDRE','NUME_ORDRE','INST','FREQ','NUME_MODE',
                          'LIST_INST','LIST_FREQ','TOUT_MODE','TOUT_INST','LIST_ORDRE'),
                   EXCLUS('TOUT_MODE','NUME_ORDRE','INST','FREQ','NUME_MODE',
                          'LIST_INST','LIST_FREQ','TOUT_ORDRE','TOUT_INST','LIST_ORDRE'),
                   EXCLUS('TOUT_INST','NUME_ORDRE','INST','FREQ','NUME_MODE',
                          'LIST_INST','LIST_FREQ','TOUT_ORDRE','LIST_ORDRE'),
                   EXCLUS('TOUT_CMP_GENE','NUME_CMP_GENE'),
                   EXCLUS('TOUT_CHAM','NOM_CHAM'),
                   EXCLUS('TOUT_PARA','NOM_PARA'),),
#  faut-il faire des blocs selon le type de RESU_GENE                   
           RESU_GENE       =SIMP(statut='o',typ=(vect_asse_gene, tran_gene, mode_gene, harm_gene)),
           TOUT_ORDRE      =SIMP(statut='f',typ='TXM',into=("OUI",) ),
           NUME_ORDRE      =SIMP(statut='f',typ='I',validators=NoRepeat(),max='**'),
           LIST_ORDRE      =SIMP(statut='f',typ=listis_sdaster ),
           INST            =SIMP(statut='f',typ='R',validators=NoRepeat(),max='**'),
           LIST_INST       =SIMP(statut='f',typ=listr8_sdaster ),
           TOUT_INST       =SIMP(statut='f',typ='TXM',into=("OUI",) ),
           FREQ            =SIMP(statut='f',typ='R',validators=NoRepeat(),max='**'),
           LIST_FREQ       =SIMP(statut='f',typ=listr8_sdaster ),
           TOUT_MODE       =SIMP(statut='f',typ='TXM',into=("OUI",) ),
           NUME_MODE       =SIMP(statut='f',typ='I',validators=NoRepeat(),max='**'),
           PRECISION       =SIMP(statut='f',typ='R',defaut= 1.E-3 ),
           CRITERE         =SIMP(statut='f',typ='TXM',defaut="RELATIF",
                                   into=("RELATIF","ABSOLU") ),
           TOUT_CMP_GENE   =SIMP(statut='f',typ='TXM',into=("OUI","NON") ),
           NUME_CMP_GENE   =SIMP(statut='f',typ='I',max='**'),
           TOUT_CHAM       =SIMP(statut='f',typ='TXM',into=("OUI","NON") ),
           NOM_CHAM        =SIMP(statut='f',typ='TXM',max='**'),
           TOUT_PARA       =SIMP(statut='f',typ='TXM',into=("OUI","NON") ),
           NOM_PARA        =SIMP(statut='f',typ='TXM',max='**'),
           SOUS_TITRE      =SIMP(statut='f',typ='TXM',max='**'),
           INFO_CMP_GENE   =SIMP(statut='f',typ='TXM',into=("OUI","NON") ),
           INFO_GENE       =SIMP(statut='f',typ='TXM',into=("OUI","NON") ),
         ),
)  ;
#& MODIF COMMANDE  DATE 22/06/2005   AUTEUR REZETTE C.REZETTE 
#            CONFIGURATION MANAGEMENT OF EDF VERSION
# ======================================================================
# COPYRIGHT (C) 1991 - 2001  EDF R&D                  WWW.CODE-ASTER.ORG
# THIS PROGRAM IS FREE SOFTWARE; YOU CAN REDISTRIBUTE IT AND/OR MODIFY
# IT UNDER THE TERMS OF THE GNU GENERAL PUBLIC LICENSE AS PUBLISHED BY
# THE FREE SOFTWARE FOUNDATION; EITHER VERSION 2 OF THE LICENSE, OR   
# (AT YOUR OPTION) ANY LATER VERSION.                                 
#
# THIS PROGRAM IS DISTRIBUTED IN THE HOPE THAT IT WILL BE USEFUL, BUT 
# WITHOUT ANY WARRANTY; WITHOUT EVEN THE IMPLIED WARRANTY OF          
# MERCHANTABILITY OR FITNESS FOR A PARTICULAR PURPOSE. SEE THE GNU    
# GENERAL PUBLIC LICENSE FOR MORE DETAILS.                            
#
# YOU SHOULD HAVE RECEIVED A COPY OF THE GNU GENERAL PUBLIC LICENSE   
# ALONG WITH THIS PROGRAM; IF NOT, WRITE TO EDF R&D CODE_ASTER,       
#    1 AVENUE DU GENERAL DE GAULLE, 92141 CLAMART CEDEX, FRANCE.      
# ======================================================================
IMPR_JEVEUX=PROC(nom="IMPR_JEVEUX",op=16,
            UIinfo={"groupes":("Impression",)},
                 fr="Imprimer le contenu des objets créés par JEVEUX (pour développeur)",
         ENTITE          =SIMP(fr="choix de l'observation",statut='o',typ='TXM',
                               into=("DISQUE","MEMOIRE","REPERTOIRE",    
                                     "OBJET","ATTRIBUT","SYSTEME") ),
         b_objet      =BLOC(condition = "(ENTITE=='OBJET')",
            NOMOBJ          =SIMP(fr="nom d'objet",statut='f',typ='TXM' ),  
            NUMOC           =SIMP(fr="numéro d objet de collection",statut='f',typ='I' ),  
            NOMOC           =SIMP(fr="nom d'objet de collection",statut='f',typ='TXM' ),  
         ),
         b_attribut   =BLOC(condition = "(ENTITE=='ATTRIBUT')",
            NOMOBJ          =SIMP(fr="nom de collection",statut='f',typ='TXM' ),  
            NOMATR          =SIMP(fr="nom d attribut de collection",statut='f',typ='TXM',
                                  into=('$$DESO','$$IADD','$$IADM','$$NOM','$$LONG',
                                      '$$LONO','$$LUTI','$$NUM') ),
         ),
         b_systeme    =BLOC(condition = "(ENTITE=='SYSTEME')",
            CLASSE          =SIMP(statut='o',typ='TXM',into=('G','V','L') ),  
            NOMATR          =SIMP(fr="nom d attribut systeme",statut='f',typ='TXM',   
                                  into=('$$CARA','$$IADD','$$GENR','$$TYPE','$$MARQ',
                                      '$$DOCU','$$ORIG','$$RNOM','$$LTYP','$$LONG',
                                      '$$LONO','$$DATE','$$LUTI','$$HCOD','$$INDX',
                                      '$$TLEC','$$TECR','$$IADM','$$ACCE','$$USADI') ),
         ),
         b_repertoire =BLOC(condition = "(ENTITE=='REPERTOIRE')",
            CLASSE          =SIMP(statut='f',typ='TXM',into=('G','V','L',' '),defaut=' '),  
         ),
         b_disque     =BLOC(condition = "(ENTITE=='DISQUE')",
            CLASSE          =SIMP(statut='f',typ='TXM' ,into=('G','V','L',' '),defaut=' '),  
         ),
         IMPRESSION      =FACT(statut='f',
           NOM             =SIMP(statut='f',typ='TXM' ),  
           UNITE           =SIMP(statut='f',typ='I'),  
         ),
         COMMENTAIRE     =SIMP(statut='f',typ='TXM' ),  
)  ;
#& MODIF COMMANDE  DATE 22/06/2005   AUTEUR REZETTE C.REZETTE 
#            CONFIGURATION MANAGEMENT OF EDF VERSION
# ======================================================================
# COPYRIGHT (C) 1991 - 2001  EDF R&D                  WWW.CODE-ASTER.ORG
# THIS PROGRAM IS FREE SOFTWARE; YOU CAN REDISTRIBUTE IT AND/OR MODIFY
# IT UNDER THE TERMS OF THE GNU GENERAL PUBLIC LICENSE AS PUBLISHED BY
# THE FREE SOFTWARE FOUNDATION; EITHER VERSION 2 OF THE LICENSE, OR   
# (AT YOUR OPTION) ANY LATER VERSION.                                 
#
# THIS PROGRAM IS DISTRIBUTED IN THE HOPE THAT IT WILL BE USEFUL, BUT 
# WITHOUT ANY WARRANTY; WITHOUT EVEN THE IMPLIED WARRANTY OF          
# MERCHANTABILITY OR FITNESS FOR A PARTICULAR PURPOSE. SEE THE GNU    
# GENERAL PUBLIC LICENSE FOR MORE DETAILS.                            
#
# YOU SHOULD HAVE RECEIVED A COPY OF THE GNU GENERAL PUBLIC LICENSE   
# ALONG WITH THIS PROGRAM; IF NOT, WRITE TO EDF R&D CODE_ASTER,       
#    1 AVENUE DU GENERAL DE GAULLE, 92141 CLAMART CEDEX, FRANCE.      
# ======================================================================
IMPR_MACR_ELEM=PROC(nom="IMPR_MACR_ELEM",op= 160,
                    UIinfo={"groupes":("Impression",)},
         fr="Impression d'une structure de données MACR_ELEM_DYNA au format IDEAS MISS3D PLEXUS ou CADYRO",
         MACR_ELEM_DYNA  =SIMP(statut='o',typ=macr_elem_dyna ),
         FORMAT          =SIMP(statut='f',typ='TXM',defaut="IDEAS",
                               into=("MISS_3D","IDEAS","CADYRO","PLEXUS") ),

         b_plexus         =BLOC(condition = "FORMAT == 'IDEAS'",
           UNITE           =SIMP(statut='f',typ='I',defaut=30),
           VERSION          =SIMP(statut='f',typ='I',defaut= 5,into=( 5 ,) ),
         ),             

         b_ideas         =BLOC(condition = "FORMAT == 'PLEXUS'",
           UNITE           =SIMP(statut='f',typ='I',defaut=30),
           VERSION         =SIMP(statut='f',typ='I',defaut= 5,into=( 5 ,) ),
         ),                      

         b_miss_3d       =BLOC(condition = "FORMAT == 'MISS_3D'",
           regles=(EXCLUS('AMOR_REDUIT','LIST_AMOR'),),
           UNITE           =SIMP(statut='f',typ='I',defaut= 26 ),
           SOUS_TITRE      =SIMP(statut='f',typ='TXM',max='**'),
           AMOR_REDUIT     =SIMP(statut='f',typ='R'  ,max='**'),
           LIST_AMOR       =SIMP(statut='f',typ=listr8_sdaster ),
           GROUP_MA_INTERF =SIMP(statut='o',typ=grma ,max='**'),
           GROUP_MA_FLU_STR=SIMP(statut='f',typ=grma,max='**'),
           GROUP_MA_FLU_SOL=SIMP(statut='f',typ=grma,max='**'),
           GROUP_MA_SOL_SOL=SIMP(statut='f',typ=grma,max='**'),
           IMPR_MODE_MECA  =SIMP(statut='f',typ='TXM',defaut="OUI",into=("OUI","NON") ),
           IMPR_MODE_STAT  =SIMP(statut='f',typ='TXM',defaut="OUI",into=("OUI","NON") ),
         ),

         b_cadyro        =BLOC(condition = "FORMAT == 'CADYRO'",
           SQUELETTE       =SIMP(statut='f',typ=squelette ),
           UNITE_MODE_MECA =SIMP(statut='f',typ='I',defaut= 26 ),
           UNITE_MODE_STAT =SIMP(statut='f',typ='I',defaut= 27 ),
           UNITE_MAILLAGE  =SIMP(statut='f',typ='I',defaut= 28 ),
           IMPR_MODE_MECA  =SIMP(statut='f',typ='TXM',defaut="OUI",into=("OUI","NON") ),
           IMPR_MODE_STAT  =SIMP(statut='f',typ='TXM',defaut="OUI",into=("OUI","NON") ),
         ),

)  ;
#& MODIF COMMANDE  DATE 22/06/2005   AUTEUR REZETTE C.REZETTE 
#            CONFIGURATION MANAGEMENT OF EDF VERSION
# ======================================================================
# COPYRIGHT (C) 1991 - 2001  EDF R&D                  WWW.CODE-ASTER.ORG
# THIS PROGRAM IS FREE SOFTWARE; YOU CAN REDISTRIBUTE IT AND/OR MODIFY
# IT UNDER THE TERMS OF THE GNU GENERAL PUBLIC LICENSE AS PUBLISHED BY
# THE FREE SOFTWARE FOUNDATION; EITHER VERSION 2 OF THE LICENSE, OR
# (AT YOUR OPTION) ANY LATER VERSION.
#
# THIS PROGRAM IS DISTRIBUTED IN THE HOPE THAT IT WILL BE USEFUL, BUT
# WITHOUT ANY WARRANTY; WITHOUT EVEN THE IMPLIED WARRANTY OF
# MERCHANTABILITY OR FITNESS FOR A PARTICULAR PURPOSE. SEE THE GNU
# GENERAL PUBLIC LICENSE FOR MORE DETAILS.
#
# YOU SHOULD HAVE RECEIVED A COPY OF THE GNU GENERAL PUBLIC LICENSE
# ALONG WITH THIS PROGRAM; IF NOT, WRITE TO EDF R&D CODE_ASTER,
#    1 AVENUE DU GENERAL DE GAULLE, 92141 CLAMART CEDEX, FRANCE.
# ======================================================================
IMPR_MATRICE=PROC(nom="IMPR_MATRICE",op= 159,
                  fr="Imprimer sur un fichier au format IDEAS ou RESULTAT des matrices élémentaires et assemblées",
                  UIinfo={"groupes":("Impression",)},
                  regles=(AU_MOINS_UN('MATR_ELEM','MATR_ASSE'),),
# ======================================================================
   MATR_ELEM       =FACT(statut='f',max='**',
#
           MATRICE     =SIMP(statut='o',typ=(matr_elem, vect_elem)),
           FORMAT      =SIMP(statut='f',typ='TXM',defaut="IDEAS",
                                 into=("IDEAS","RESULTAT") ),
#
         b_format_ideas  =BLOC(condition="FORMAT=='IDEAS'",fr="unité logique d'impression et version IDEAS",
           UNITE       =SIMP(statut='f',typ='I',defaut=30),  
           VERSION     =SIMP(statut='f',typ='I',defaut= 5,into=( 5 ,), ),  ),
#
         b_format_resultat  =BLOC(condition="FORMAT=='RESULTAT'",fr="unité logique d'impression au format RESULTAT",
                             regles=(PRESENT_ABSENT('TOUT','GROUP_MA','MAILLE','GROUP_NO','NOEUD'),),
           UNITE       =SIMP(statut='f',typ='I',defaut=8),
           TOUT        =SIMP(statut='f',typ='TXM',into=("OUI",) ),
           NOEUD       =SIMP(statut='f',typ=no   ,validators=NoRepeat(),max='**'),
           GROUP_NO    =SIMP(statut='f',typ=grno ,validators=NoRepeat(),max='**'),
           MAILLE      =SIMP(statut='f',typ=ma   ,validators=NoRepeat(),max='**'),
           GROUP_MA    =SIMP(statut='f',typ=grma ,validators=NoRepeat(),max='**'),
           NOM_CMP     =SIMP(statut='f',typ='TXM',max='**'),
           GRAIN       =SIMP(statut='f',typ='TXM',defaut="VALEUR",into=("VALEUR","NOEUD","MAILLE") ),
           NB_CHIFFRE  =SIMP(statut='f',typ='I',defaut= 4 ),  ),
         ),
# ======================================================================
   MATR_ASSE       =FACT(statut='f',max='**',
#
           MATRICE     =SIMP(statut='o',typ=matr_asse_gd),
           FORMAT      =SIMP(statut='f',typ='TXM',defaut="IDEAS",into=("IDEAS","RESULTAT") ),
# 
         b_format_ideas  =BLOC(condition="FORMAT=='IDEAS'",fr="unité logique d'impression et version IDEAS",
           UNITE       =SIMP(statut='f',typ='I',defaut=30),  
           VERSION     =SIMP(statut='f',typ='I',defaut= 5,into=( 5 ,), ),  ),
# 
         b_format_resultat  =BLOC(condition="FORMAT=='RESULTAT'",fr="unité logique d'impression au format RESULTAT",
                             regles=(PRESENT_ABSENT('TOUT','GROUP_MA','MAILLE','GROUP_NO','NOEUD'),),
           UNITE       =SIMP(statut='f',typ='I',defaut=8),
           TOUT        =SIMP(statut='f',typ='TXM',into=("OUI",) ),
           NOEUD       =SIMP(statut='f',typ=no   ,validators=NoRepeat(),max='**'),
           GROUP_NO    =SIMP(statut='f',typ=grno ,validators=NoRepeat(),max='**'),
           MAILLE      =SIMP(statut='f',typ=ma   ,validators=NoRepeat(),max='**'),
           GROUP_MA    =SIMP(statut='f',typ=grma ,validators=NoRepeat(),max='**'),
           OPTION      =SIMP(statut='f',typ='TXM',defaut="SOUS_MATRICE",into=("SOUS_MATRICE","LIGNE","COLONNE") ),
           NOM_CMP     =SIMP(statut='f',typ='TXM',max='**'),
           GRAIN       =SIMP(statut='f',typ='TXM',defaut="VALEUR",into=("VALEUR","NOEUD") ),
           NB_CHIFFRE  =SIMP(statut='f',typ='I',defaut= 4 ),
           VALE_ZERO   =SIMP(statut='f',typ='R',defaut= 0.E+0 ),  ),
         ),
# ======================================================================
)  ;
#& MODIF COMMANDE  DATE 21/02/2006   AUTEUR REZETTE C.REZETTE 
#            CONFIGURATION MANAGEMENT OF EDF VERSION
# ======================================================================
# COPYRIGHT (C) 1991 - 2001  EDF R&D                  WWW.CODE-ASTER.ORG
# THIS PROGRAM IS FREE SOFTWARE; YOU CAN REDISTRIBUTE IT AND/OR MODIFY
# IT UNDER THE TERMS OF THE GNU GENERAL PUBLIC LICENSE AS PUBLISHED BY
# THE FREE SOFTWARE FOUNDATION; EITHER VERSION 2 OF THE LICENSE, OR   
# (AT YOUR OPTION) ANY LATER VERSION.                                 
#
# THIS PROGRAM IS DISTRIBUTED IN THE HOPE THAT IT WILL BE USEFUL, BUT 
# WITHOUT ANY WARRANTY; WITHOUT EVEN THE IMPLIED WARRANTY OF          
# MERCHANTABILITY OR FITNESS FOR A PARTICULAR PURPOSE. SEE THE GNU    
# GENERAL PUBLIC LICENSE FOR MORE DETAILS.                            
#
# YOU SHOULD HAVE RECEIVED A COPY OF THE GNU GENERAL PUBLIC LICENSE   
# ALONG WITH THIS PROGRAM; IF NOT, WRITE TO EDF R&D CODE_ASTER,       
#    1 AVENUE DU GENERAL DE GAULLE, 92141 CLAMART CEDEX, FRANCE.      
# ======================================================================
IMPR_MISS_3D=PROC(nom="IMPR_MISS_3D",op= 162,
            UIinfo={"groupes":("Impression",)},
         fr="Impression des données d'entrée pour une étude sismique avec MISS3D",
         regles=(UN_PARMI('INST_INIT','FREQ_INIT'),
                 PRESENT_PRESENT('INST_INIT','INST_FIN'),
                 PRESENT_PRESENT('FREQ_INIT','FREQ_FIN'),),
         MACR_ELEM_DYNA  =SIMP(statut='o',typ=macr_elem_dyna ),
         EXCIT           =FACT(statut='f',max='**',
           regles=(UN_PARMI('FONC_MULT','COEF_MULT' ),),
           VECT_ASSE       =SIMP(statut='f',typ=cham_no_sdaster),
           FONC_MULT       =SIMP(statut='f',typ=(fonction_sdaster,nappe_sdaster,formule) ),
           COEF_MULT       =SIMP(statut='f',typ='R' ),
         ),
         EXCIT_SOL       =FACT(statut='f',max='**',
           DIRECTION       =SIMP(statut='o',typ='R',min=3,max=3),
           FONC_SIGNAL     =SIMP(statut='f',typ=(fonction_sdaster,nappe_sdaster,formule) ),
           NOM_CHAM        =SIMP(statut='f',typ='TXM',defaut="DEPL",
                                 into=("DEPL","VITE","ACCE","FORC",) ),
         ),
         INST_INIT       =SIMP(statut='f',typ='R' ),
         INST_FIN        =SIMP(statut='f',typ='R' ),
         FREQ_INIT       =SIMP(statut='f',typ='R' ),
         FREQ_FIN        =SIMP(statut='f',typ='R' ),
         PAS             =SIMP(statut='o',typ='R' ),
         UNITE           =SIMP(statut='f',typ='I',defaut= 26 ),
         INFO            =SIMP(statut='f',typ='I',defaut= 1,into=( 1 , 2 ) ),
         TITRE           =SIMP(statut='f',typ='TXM',max='**'),
)  ;
#& MODIF COMMANDE  DATE 07/11/2006   AUTEUR DURAND C.DURAND 
#            CONFIGURATION MANAGEMENT OF EDF VERSION
# ======================================================================
# COPYRIGHT (C) 1991 - 2004  EDF R&D                  WWW.CODE-ASTER.ORG
# THIS PROGRAM IS FREE SOFTWARE; YOU CAN REDISTRIBUTE IT AND/OR MODIFY  
# IT UNDER THE TERMS OF THE GNU GENERAL PUBLIC LICENSE AS PUBLISHED BY  
# THE FREE SOFTWARE FOUNDATION; EITHER VERSION 2 OF THE LICENSE, OR     
# (AT YOUR OPTION) ANY LATER VERSION.                                                  
#                                                                       
# THIS PROGRAM IS DISTRIBUTED IN THE HOPE THAT IT WILL BE USEFUL, BUT   
# WITHOUT ANY WARRANTY; WITHOUT EVEN THE IMPLIED WARRANTY OF            
# MERCHANTABILITY OR FITNESS FOR A PARTICULAR PURPOSE. SEE THE GNU      
# GENERAL PUBLIC LICENSE FOR MORE DETAILS.                              
#                                                                       
# YOU SHOULD HAVE RECEIVED A COPY OF THE GNU GENERAL PUBLIC LICENSE     
# ALONG WITH THIS PROGRAM; IF NOT, WRITE TO EDF R&D CODE_ASTER,         
#    1 AVENUE DU GENERAL DE GAULLE, 92141 CLAMART CEDEX, FRANCE.        
# ======================================================================
# RESPONSABLE thomasso D.THOMASSON
#
from Macro.impr_oar_ops import impr_oar_ops
IMPR_OAR =MACRO(nom="IMPR_OAR",op= impr_oar_ops, sd_prod=None,
               fr="Impression au format OAR",
               UIinfo={"groupes":("Impression",)},
   TYPE_CALC = SIMP(statut='o', typ='TXM',into=('COMPOSANT', 'MEF', 'TUYAUTERIE')),
   b_composant =BLOC(condition = "TYPE_CALC == 'COMPOSANT' ",
      regles = (AU_MOINS_UN('RESU_MECA','RESU_THER')),
      DIAMETRE = SIMP(statut='o', typ='R'),
      ORIGINE  = SIMP(statut='o', typ='TXM', defaut='INTERNE', into=('INTERNE', 'EXTERNE')),
      COEF_U   = SIMP(statut='f', typ='R',   defaut=1.0),
      ANGLE_C  = SIMP(statut='o', typ='R',   defaut=0.0),
      REVET    = SIMP(statut='f', typ='TXM', defaut='NON', into=('OUI', 'NON')),
      RESU_MECA = FACT(statut='f', max='**',
         NUM_CHAR  = SIMP(statut='o', typ='I'),
         TYPE      = SIMP(statut='o', typ='TXM', defaut='FX', into=('FX', 'FY', 'FZ', 'MX', 'MY', 'MZ', 'PRE')),
         TABLE     = SIMP(statut='o', typ=table_sdaster),
         TABLE_S   = SIMP(statut='f', typ=table_sdaster)),
      RESU_THER = FACT(statut='f', max='**',
         NUM_TRAN  = SIMP(statut='o', typ='I'),
         TABLE_T   = SIMP(statut='o', typ=table_sdaster),
         TABLE_TEMP= SIMP(statut='o', typ=table_sdaster),
         TABLE_S   = SIMP(statut='f', typ=table_sdaster),
         TABLE_ST  = SIMP(statut='f', typ=table_sdaster)),
         ),
   b_mef = BLOC(condition = "TYPE_CALC == 'MEF' ",
      regles = (AU_MOINS_UN('RESU_MECA','RESU_THER')),
      DIAMETRE = SIMP(statut='o', typ='R'),
      ORIGINE  = SIMP(statut='o', typ='TXM', defaut='INTERNE', into=('INTERNE', 'EXTERNE')),
      COEF_U   = SIMP(statut='f', typ='R',   defaut=1.0),
      RESU_MECA = FACT(statut='f', max='**',
         AZI       = SIMP(statut='o', typ='R'),
         TABLE_T   = SIMP(statut='o', typ=table_sdaster),
         TABLE_F   = SIMP(statut='o', typ=table_sdaster),
         TABLE_P   = SIMP(statut='o', typ=table_sdaster),
         TABLE_CA  = SIMP(statut='o', typ=table_sdaster)),
      RESU_THER=FACT(statut='f', max='**',
         AZI       = SIMP(statut='o', typ='R'),
         NUM_CHAR  = SIMP(statut='o', typ='I'),
         TABLE_T   = SIMP(statut='o', typ=table_sdaster),
         TABLE_TI  = SIMP(statut='o', typ=table_sdaster)),
      ),
   b_tuyauterie = BLOC(condition = "TYPE_CALC == 'TUYAUTERIE' ",
      RESU_MECA = FACT(statut='o', max='**',
         NUM_CHAR  = SIMP(statut='o', typ='I'),
         TABLE     = SIMP(statut='o', typ=table_sdaster),
         MAILLAGE  = SIMP(statut='o', typ=maillage_sdaster)),
         ),
   UNITE = SIMP(statut='f',typ='I',defaut=38),
   AJOUT = SIMP(statut='f', typ='TXM', defaut='NON', into=('OUI', 'NON')),
   );
#& MODIF COMMANDE  DATE 06/11/2006   AUTEUR MCOURTOI M.COURTOIS 
#            CONFIGURATION MANAGEMENT OF EDF VERSION
# ======================================================================
# COPYRIGHT (C) 1991 - 2001  EDF R&D                  WWW.CODE-ASTER.ORG
# THIS PROGRAM IS FREE SOFTWARE; YOU CAN REDISTRIBUTE IT AND/OR MODIFY
# IT UNDER THE TERMS OF THE GNU GENERAL PUBLIC LICENSE AS PUBLISHED BY
# THE FREE SOFTWARE FOUNDATION; EITHER VERSION 2 OF THE LICENSE, OR
# (AT YOUR OPTION) ANY LATER VERSION.
#
# THIS PROGRAM IS DISTRIBUTED IN THE HOPE THAT IT WILL BE USEFUL, BUT
# WITHOUT ANY WARRANTY; WITHOUT EVEN THE IMPLIED WARRANTY OF
# MERCHANTABILITY OR FITNESS FOR A PARTICULAR PURPOSE. SEE THE GNU
# GENERAL PUBLIC LICENSE FOR MORE DETAILS.
#
# YOU SHOULD HAVE RECEIVED A COPY OF THE GNU GENERAL PUBLIC LICENSE
# ALONG WITH THIS PROGRAM; IF NOT, WRITE TO EDF R&D CODE_ASTER,
#    1 AVENUE DU GENERAL DE GAULLE, 92141 CLAMART CEDEX, FRANCE.
# ======================================================================
IMPR_RESU=PROC(nom="IMPR_RESU",op=39,
            UIinfo={"groupes":("Impression",)},
               fr="Imprimer un maillage et/ou les résultats d'un calcul (différents formats)",
         MODELE          =SIMP(statut='f',typ=modele_sdaster),

         FORMAT          =SIMP(statut='f',typ='TXM',position='global',defaut="RESULTAT",
                                 into=("RESULTAT","IDEAS","ASTER","CASTEM","ENSIGHT","MED","GMSH") ),

         b_format_resultat  =BLOC(condition="FORMAT=='RESULTAT'",fr="unité logique d'impression au format RESULTAT",
           UNITE           =SIMP(statut='f',typ='I',defaut=8),  
         ),

         b_format_ideas  =BLOC(condition="FORMAT=='IDEAS'",fr="unité logique d'impression et version IDEAS",
           UNITE           =SIMP(statut='f',typ='I',defaut=30),  
           VERSION         =SIMP(statut='f',typ='I',defaut=5,into=(4,5)),
         ),

         b_format_aster  =BLOC(condition="FORMAT=='ASTER'",fr="unité logique d'impression au format ASTER",
           UNITE           =SIMP(statut='f',typ='I',defaut=26),  
         ),

         b_format_castem =BLOC(condition="FORMAT=='CASTEM'",fr="unité logique d'impression et version CASTEM",
           UNITE           =SIMP(statut='f',typ='I',defaut=37),  
           NIVE_GIBI       =SIMP(statut='f',typ='I',defaut=10,into=(3,10)),
         ),

         b_format_ensight  =BLOC(condition="FORMAT=='ENSIGHT'",fr="unité logique d'impression au format ENSIGHT",
           UNITE           =SIMP(statut='f',typ='I',defaut=31),  
         ),

         b_format_med  =BLOC(condition="FORMAT=='MED'",fr="unité logique d'impression au format MED",
           UNITE           =SIMP(statut='f',typ='I',defaut=80),  
         ),

         b_format_gmsh  =BLOC(condition="FORMAT=='GMSH'",fr="unité logique d'impression et version GMSH",
           UNITE           =SIMP(statut='f',typ='I',defaut=37),  
           VERSION         =SIMP(statut='f',typ='R',defaut=1.2,into=(1.0,1.2)),
         ),

         RESU            =FACT(statut='o',max='**',

           regles=(AU_MOINS_UN('CHAM_GD','RESULTAT','MAILLAGE'),
                   EXCLUS('CHAM_GD','RESULTAT'),),
           MAILLAGE        =SIMP(statut='f',typ=(maillage_sdaster,squelette)),
           INFO_MAILLAGE   =SIMP(statut='f',typ='TXM',defaut="NON",into=("OUI","NON") ),
           CHAM_GD         =SIMP(statut='f',typ=cham_gd_sdaster),
           RESULTAT        =SIMP(statut='f',typ=resultat_sdaster),# CO() sd a creer !!!

           b_sensibilite   =BLOC(condition="RESULTAT != None",
                                 fr="Définition des paramètres de sensibilité",
                                 ang="Definition of sensitivity parameters",
             regles=(DERIVABLE('RESULTAT'),),
             SENSIBILITE     =SIMP(statut='f',typ=(para_sensi,theta_geom),validators=NoRepeat(),max='**',
                                   fr="Liste des paramètres de sensibilité.",
                                   ang="List of sensitivity parameters"),),

#           b_partie        =BLOC(condition="""((AsType(RESULTAT)==dyna_harmo) or  
#                           (AsType(CHAM_GD)!=carte_sdaster))  and ((FORMAT=='CASTEM') or (FORMAT=='GMSH'))""",
             PARTIE          =SIMP(statut='f',typ='TXM',into=("REEL","IMAG") ),
#           ),
           b_extrac        =BLOC(condition="RESULTAT != None",
                                 fr="extraction d un champ de grandeur",
             regles=(EXCLUS('TOUT_CHAM','NOM_CHAM'),
                     EXCLUS('TOUT_ORDRE','NUME_ORDRE','INST','FREQ','NUME_MODE','NOEUD_CMP',
                            'LIST_INST','LIST_FREQ','LIST_ORDRE','NOM_CAS','ANGL'),),
             TOUT_CHAM       =SIMP(statut='f',typ='TXM',into=("OUI","NON") ),
             NOM_CHAM        =SIMP(statut='f',typ='TXM',validators=NoRepeat(),max='**',into=C_NOM_CHAM_INTO()),

             TOUT_ORDRE      =SIMP(statut='f',typ='TXM',into=("OUI",) ),
             NUME_ORDRE      =SIMP(statut='f',typ='I',validators=NoRepeat(),max='**'),
             NUME_MODE       =SIMP(statut='f',typ='I',validators=NoRepeat(),max='**'),
             LIST_ORDRE      =SIMP(statut='f',typ=listis_sdaster),
             NOEUD_CMP       =SIMP(statut='f',typ='TXM',validators=NoRepeat(),max='**'),
             NOM_CAS         =SIMP(statut='f',typ='TXM',validators=NoRepeat(),max='**'),
             ANGL            =SIMP(statut='f',typ='R',validators=NoRepeat(),max='**'),
             FREQ            =SIMP(statut='f',typ='R',validators=NoRepeat(),max='**'),
             LIST_FREQ       =SIMP(statut='f',typ=listr8_sdaster),
             INST            =SIMP(statut='f',typ='R',validators=NoRepeat(),max='**'),
             LIST_INST       =SIMP(statut='f',typ=listr8_sdaster),

             b_acce_reel     =BLOC(condition="(FREQ != None)or(LIST_FREQ != None)or(INST != None)or(LIST_INST != None)",
               PRECISION       =SIMP(statut='f',typ='R',defaut=1.0E-3),
               CRITERE         =SIMP(statut='f',typ='TXM',defaut="RELATIF",into=("RELATIF","ABSOLU") ),
             ),
           ),
###
           b_parametres    =BLOC(condition="""(RESULTAT != None)and(FORMAT == 'RESULTAT')""",
             regles=(EXCLUS('TOUT_PARA','NOM_PARA'),),
             INFO_RESU       =SIMP(statut='f',typ='TXM',defaut="NON",into=("OUI","NON") ),
             TOUT_PARA       =SIMP(statut='f',typ='TXM',into=("OUI","NON",) ),
             NOM_PARA        =SIMP(statut='f',typ='TXM',max='**'),
             FORM_TABL       =SIMP(statut='f',typ='TXM',defaut="NON",into=("OUI","NON","EXCEL") ),
           ),
###
           b_cmp=BLOC(condition="""((CHAM_GD != None)or(RESULTAT != None))and\
           ((FORMAT == 'CASTEM')or(FORMAT == 'RESULTAT')or(FORMAT == 'IDEAS')or(FORMAT == 'ENSIGHT')or(FORMAT == 'MED'))""",
                                fr="sélection des composantes",
             regles=(EXCLUS('TOUT_CMP','NOM_CMP'),),
             TOUT_CMP        =SIMP(statut='f',typ='TXM',into=("OUI",) ),
             NOM_CMP         =SIMP(statut='f',typ='TXM',max='**'),
           ),
###
           b_gmsh=BLOC(condition="""((CHAM_GD != None)or(RESULTAT != None))and((FORMAT == 'GMSH'))""",
                                fr="sélection des composantes et des entités toplogiques",
             NOM_CMP         =SIMP(statut='f',typ='TXM',max='**'),
             MAILLE          =SIMP(statut='f',typ=ma  ,validators=NoRepeat(),max='**'),
             GROUP_MA        =SIMP(statut='f',typ=grma,validators=NoRepeat(),max='**'),
           ),
###
           b_topologie=BLOC(condition="""((CHAM_GD != None)or(RESULTAT != None))and\
           ((FORMAT == 'RESULTAT')or(FORMAT == 'IDEAS')or(FORMAT == 'MED'))""",
                                fr="sélection des entités topologiques",
             TOUT            =SIMP(statut='f',typ='TXM',into=("OUI",) ),
             NOEUD           =SIMP(statut='f',typ=no  ,validators=NoRepeat(),max='**'),
             GROUP_NO        =SIMP(statut='f',typ=grno,validators=NoRepeat(),max='**'),
             MAILLE          =SIMP(statut='f',typ=ma  ,validators=NoRepeat(),max='**'),
             GROUP_MA        =SIMP(statut='f',typ=grma,validators=NoRepeat(),max='**'),
           ),
###
           b_valeurs=BLOC(condition="(FORMAT == 'RESULTAT')",
                               fr="sélection sur les valeurs",
             VALE_MAX        =SIMP(statut='f',typ='TXM',into=("OUI",) ),
             VALE_MIN        =SIMP(statut='f',typ='TXM',into=("OUI",) ),
             BORNE_SUP       =SIMP(statut='f',typ='R'),
             BORNE_INF       =SIMP(statut='f',typ='R'),
             IMPR_COOR       =SIMP(statut='f',typ='TXM',defaut="NON",into=("OUI","NON") ),
             FORMAT_R        =SIMP(statut='f',typ='TXM',defaut="1PE12.5"),
           ),

           SOUS_TITRE      =SIMP(statut='f',typ='TXM',max='**'),
         ),
         INFO            =SIMP(statut='f',typ='I',defaut=1,into=(1,2) ),
) ;
#& MODIF COMMANDE  DATE 23/08/2004   AUTEUR CIBHHLV L.VIVAN 
#            CONFIGURATION MANAGEMENT OF EDF VERSION
# ======================================================================
# COPYRIGHT (C) 1991 - 2001  EDF R&D                  WWW.CODE-ASTER.ORG
# THIS PROGRAM IS FREE SOFTWARE; YOU CAN REDISTRIBUTE IT AND/OR MODIFY
# IT UNDER THE TERMS OF THE GNU GENERAL PUBLIC LICENSE AS PUBLISHED BY
# THE FREE SOFTWARE FOUNDATION; EITHER VERSION 2 OF THE LICENSE, OR   
# (AT YOUR OPTION) ANY LATER VERSION.                                 
#
# THIS PROGRAM IS DISTRIBUTED IN THE HOPE THAT IT WILL BE USEFUL, BUT 
# WITHOUT ANY WARRANTY; WITHOUT EVEN THE IMPLIED WARRANTY OF          
# MERCHANTABILITY OR FITNESS FOR A PARTICULAR PURPOSE. SEE THE GNU    
# GENERAL PUBLIC LICENSE FOR MORE DETAILS.                            
#
# YOU SHOULD HAVE RECEIVED A COPY OF THE GNU GENERAL PUBLIC LICENSE   
# ALONG WITH THIS PROGRAM; IF NOT, WRITE TO EDF R&D CODE_ASTER,       
#    1 AVENUE DU GENERAL DE GAULLE, 92141 CLAMART CEDEX, FRANCE.      
# ======================================================================
IMPR_STURM=PROC(nom="IMPR_STURM",op=32,fr="Calculer et imprimer le nombre de valeurs propres dans un intervalle donné",
            UIinfo={"groupes":("Résolution",)},
         MATR_A          =SIMP(statut='o',typ=(matr_asse_depl_r,matr_asse_temp_r,matr_asse_pres_r ) ),
         MATR_B          =SIMP(statut='o',typ=(matr_asse_depl_r,matr_asse_temp_r,matr_asse_pres_r ) ),
         TYPE_RESU       =SIMP(statut='f',typ='TXM',defaut="DYNAMIQUE",into=("MODE_FLAMB","DYNAMIQUE"),
                               fr="Type d analyse" ),
         b_dynamique  =BLOC(condition = "TYPE_RESU == 'DYNAMIQUE'",
                            fr="Recheche du nombre de fréquences propres",
             FREQ_MIN        =SIMP(statut='f',typ='R',defaut= 0.E+0 ,fr="Borne inférieure de l intervalle" ),
             FREQ_MAX        =SIMP(statut='o',typ='R',fr="Borne supérieure de l intervalle" ),
         ),
         b_mode_flamb =BLOC(condition = "TYPE_RESU == 'MODE_FLAMB'",
                            fr="Recherche du nombre de charges critiques",
             CHAR_CRIT_MIN   =SIMP(statut='o',typ='R',fr="Borne inférieure de l intervalle" ),
             CHAR_CRIT_MAX   =SIMP(statut='o',typ='R',fr="Borne supérieure de l intervalle" ),
         ),
         NPREC_SOLVEUR   =SIMP(statut='f',typ='I',defaut= 8 ),
         NMAX_ITER_SHIFT =SIMP(statut='f',typ='I',defaut= 5 ),
         UNITE           =SIMP(statut='f',typ='I',defaut=8),  
         PREC_SHIFT      =SIMP(statut='f',typ='R',defaut= 1.E-2 ),
         SEUIL_FREQ      =SIMP(statut='f',typ='R',defaut= 1.E-2 ),
)  ;
#& MODIF COMMANDE  DATE 10/05/2006   AUTEUR MCOURTOI M.COURTOIS 
#            CONFIGURATION MANAGEMENT OF EDF VERSION
# ======================================================================
# COPYRIGHT (C) 1991 - 2001  EDF R&D                  WWW.CODE-ASTER.ORG
# THIS PROGRAM IS FREE SOFTWARE; YOU CAN REDISTRIBUTE IT AND/OR MODIFY
# IT UNDER THE TERMS OF THE GNU GENERAL PUBLIC LICENSE AS PUBLISHED BY
# THE FREE SOFTWARE FOUNDATION; EITHER VERSION 2 OF THE LICENSE, OR   
# (AT YOUR OPTION) ANY LATER VERSION.                                 
#
# THIS PROGRAM IS DISTRIBUTED IN THE HOPE THAT IT WILL BE USEFUL, BUT 
# WITHOUT ANY WARRANTY; WITHOUT EVEN THE IMPLIED WARRANTY OF          
# MERCHANTABILITY OR FITNESS FOR A PARTICULAR PURPOSE. SEE THE GNU    
# GENERAL PUBLIC LICENSE FOR MORE DETAILS.                            
#
# YOU SHOULD HAVE RECEIVED A COPY OF THE GNU GENERAL PUBLIC LICENSE   
# ALONG WITH THIS PROGRAM; IF NOT, WRITE TO EDF R&D CODE_ASTER,       
#    1 AVENUE DU GENERAL DE GAULLE, 92141 CLAMART CEDEX, FRANCE.      
# ======================================================================
# RESPONSABLE MCOURTOI M.COURTOIS
from Macro.impr_table_ops import impr_table_ops

IMPR_TABLE=MACRO(nom="IMPR_TABLE",op=impr_table_ops,sd_prod=None,
            UIinfo={"groupes":("Impression",)},
                fr="Impression du contenu d'une table dans un fichier",
           regles=(DERIVABLE("TABLE"),),
   TABLE          =SIMP(statut='o',typ=table_sdaster),
   SENSIBILITE    =SIMP(statut='f',typ=(para_sensi,theta_geom),validators=NoRepeat(),max='**',
                         fr="Liste des paramètres de sensibilité.",
                         ang="List of sensitivity parameters"),
   FORMAT         =SIMP(statut='f',typ='TXM',defaut="TABLEAU",
                         into=("TABLEAU","ASTER","TABLEAU_CROISE","AGRAF","XMGRACE",),),
   b_pilote       =BLOC(condition = "FORMAT == 'XMGRACE'",
                        fr="Mots-clés propres à XMGRACE",
      PILOTE         =SIMP(statut='f',typ='TXM',defaut='',
                           into=('','POSTSCRIPT','EPS','MIF','SVG','PNM','PNG','JPEG','PDF','INTERACTIF'),
                      fr="Pilote de sortie, PNG/JPEG/PDF ne sont pas disponibles sur toutes les installations de xmgrace"),
      UNITE          =SIMP(statut='f',typ='I',val_min=10,val_max=90,defaut=29,
                           fr="Unité logique définissant le fichier (fort.N) dans lequel on écrit"),
   ),
   b_unite        =BLOC(condition = "FORMAT != 'XMGRACE'",
      UNITE          =SIMP(statut='f',typ='I',defaut=8,
                           fr="Unité logique définissant le fichier (fort.N) dans lequel on écrit"),
   ),
   FILTRE         =FACT(statut='f',max='**',
      NOM_PARA       =SIMP(statut='o',typ='TXM'),
      CRIT_COMP      =SIMP(statut='f',typ='TXM',defaut="EQ",
                           into=("EQ","LT","GT","NE","LE","GE","VIDE",
                                 "NON_VIDE","MAXI","ABS_MAXI","MINI","ABS_MINI"),),
      b_vale         =BLOC(condition = "(CRIT_COMP in ('EQ','NE','GT','LT','GE','LE'))",
         regles=(UN_PARMI('VALE','VALE_I','VALE_K','VALE_C',),),
         VALE           =SIMP(statut='f',typ='R'),
         VALE_I         =SIMP(statut='f',typ='I'),
         VALE_C         =SIMP(statut='f',typ='C'),
         VALE_K         =SIMP(statut='f',typ='TXM'),
      ),
      b_crit         =BLOC(condition = "CRIT_COMP in ('EQ','NE')",
         CRITERE        =SIMP(statut='f',typ='TXM',defaut="RELATIF",into=("RELATIF","ABSOLU") ),
         PRECISION      =SIMP(statut='f',typ='R',defaut= 1.0E-3 ),
      ),
   ),
   TRI            =FACT(statut='f',
      NOM_PARA       =SIMP(statut='o',typ='TXM',validators=NoRepeat(),max='**'),
      ORDRE          =SIMP(statut='f',typ='TXM',defaut="CROISSANT", # max='**',
                           into=("CROISSANT","DECROISSANT") ),
   ),
   PAGINATION     =SIMP(statut='f',typ='TXM',max='**'),
   FORMAT_R       =SIMP(statut='f',typ='TXM',defaut="E12.5"),
   FORMAT_C       =SIMP(statut='f',typ='TXM',defaut="MODULE_PHASE",
                              into=("MODULE_PHASE","REEL_IMAG") ),
   NOM_PARA       =SIMP(statut='f',typ='TXM',validators=NoRepeat(),max='**'),
   IMPR_FONCTION  =SIMP(statut='f',typ='TXM',defaut="NON",into=("OUI","NON") ),

   # mise en forme pour les formats qui passent par Graph
   b_forme         =BLOC(condition = "FORMAT == 'XMGRACE'",
                         fr="Données de mise en forme du graphique",
      # pour la courbe
      LEGENDE         =SIMP(statut='f',typ='TXM',
                            fr="Légende associée à la fonction" ),
      STYLE           =SIMP(statut='f',typ='I',val_min=0,
                            fr="Style de la ligne représentant la fonction",),
      COULEUR         =SIMP(statut='f',typ='I',val_min=0,
                            fr="Couleur associée à la fonction",),
      MARQUEUR        =SIMP(statut='f',typ='I',val_min=0,
                            fr="Type du marqueur associé à la fonction",),
      FREQ_MARQUEUR   =SIMP(statut='f',typ='I',defaut=0,
                            fr="Fréquence d impression du marqueur associé à la fonction", ),
      # format du graphique
      BORNE_X         =SIMP(statut='f',typ='R',min=2,max=2,
                            fr="Intervalles de variation des abscisses"),
      BORNE_Y         =SIMP(statut='f',typ='R',min=2,max=2,
                            fr="Intervalles de variation des ordonnées"),
      ECHELLE_X       =SIMP(statut='f',typ='TXM',defaut="LIN",into=("LIN","LOG"),
                            fr="Type d'échelle pour les abscisses" ),
      ECHELLE_Y       =SIMP(statut='f',typ='TXM',defaut="LIN",into=("LIN","LOG"),
                            fr="Type d'échelle pour les ordonnées" ),
      GRILLE_X        =SIMP(statut='f',typ='R',max=1,val_min=0.,
                            fr="Pas du quadrillage vertical" ),
      GRILLE_Y        =SIMP(statut='f',typ='R',max=1,val_min=0.,
                            fr="Pas du quadrillage horizontal" ),
      LEGENDE_X       =SIMP(statut='f',typ='TXM',
                            fr="Légende associée à l'axe des abscisses" ),
      LEGENDE_Y       =SIMP(statut='f',typ='TXM',
                            fr="Légende associée à l'axe des ordonnées" ),
   ),

   TITRE          =SIMP(statut='f',typ='TXM',max='**'),
   INFO           =SIMP(statut='f',typ='I',defaut=1,into=(1,2) ),
)  
#& MODIF COMMANDE  DATE 10/06/2004   AUTEUR REZETTE C.REZETTE 
#            CONFIGURATION MANAGEMENT OF EDF VERSION
# ======================================================================
# COPYRIGHT (C) 1991 - 2001  EDF R&D                  WWW.CODE-ASTER.ORG
# THIS PROGRAM IS FREE SOFTWARE; YOU CAN REDISTRIBUTE IT AND/OR MODIFY
# IT UNDER THE TERMS OF THE GNU GENERAL PUBLIC LICENSE AS PUBLISHED BY
# THE FREE SOFTWARE FOUNDATION; EITHER VERSION 2 OF THE LICENSE, OR   
# (AT YOUR OPTION) ANY LATER VERSION.                                 
#
# THIS PROGRAM IS DISTRIBUTED IN THE HOPE THAT IT WILL BE USEFUL, BUT 
# WITHOUT ANY WARRANTY; WITHOUT EVEN THE IMPLIED WARRANTY OF          
# MERCHANTABILITY OR FITNESS FOR A PARTICULAR PURPOSE. SEE THE GNU    
# GENERAL PUBLIC LICENSE FOR MORE DETAILS.                            
#
# YOU SHOULD HAVE RECEIVED A COPY OF THE GNU GENERAL PUBLIC LICENSE   
# ALONG WITH THIS PROGRAM; IF NOT, WRITE TO EDF R&D CODE_ASTER,       
#    1 AVENUE DU GENERAL DE GAULLE, 92141 CLAMART CEDEX, FRANCE.      
# ======================================================================
INCLUDE=MACRO(nom="INCLUDE",op=ops.build_include,
            UIinfo={"groupes":("Gestion du travail",)},
             fr="Débranchement vers un fichier de commandes secondaires",
             sd_prod=ops.INCLUDE,op_init=ops.INCLUDE_context,fichier_ini=1,
         UNITE = SIMP(statut='o',typ='I'),
         INFO  = SIMP(statut='f',typ='I',defaut=1,into=(1,2)),
);
#& MODIF COMMANDE  DATE 22/06/2005   AUTEUR REZETTE C.REZETTE 
#            CONFIGURATION MANAGEMENT OF EDF VERSION
# ======================================================================
# COPYRIGHT (C) 1991 - 2001  EDF R&D                  WWW.CODE-ASTER.ORG
# THIS PROGRAM IS FREE SOFTWARE; YOU CAN REDISTRIBUTE IT AND/OR MODIFY
# IT UNDER THE TERMS OF THE GNU GENERAL PUBLIC LICENSE AS PUBLISHED BY
# THE FREE SOFTWARE FOUNDATION; EITHER VERSION 2 OF THE LICENSE, OR   
# (AT YOUR OPTION) ANY LATER VERSION.                                 
#
# THIS PROGRAM IS DISTRIBUTED IN THE HOPE THAT IT WILL BE USEFUL, BUT 
# WITHOUT ANY WARRANTY; WITHOUT EVEN THE IMPLIED WARRANTY OF          
# MERCHANTABILITY OR FITNESS FOR A PARTICULAR PURPOSE. SEE THE GNU    
# GENERAL PUBLIC LICENSE FOR MORE DETAILS.                            
#
# YOU SHOULD HAVE RECEIVED A COPY OF THE GNU GENERAL PUBLIC LICENSE   
# ALONG WITH THIS PROGRAM; IF NOT, WRITE TO EDF R&D CODE_ASTER,       
#    1 AVENUE DU GENERAL DE GAULLE, 92141 CLAMART CEDEX, FRANCE.      
# ======================================================================
INCLUDE_MATERIAU=MACRO(nom="INCLUDE_MATERIAU",op=-14,
            UIinfo={"groupes":("Modélisation",)},
         fr="Récupérer les caractéristiques d'un matériau dans le Catalogue Materiaux d'Aster ",
         sd_prod=ops.INCLUDE_MATERIAU,op_init=ops.INCLUDE_context,fichier_ini=0,
         NOM_AFNOR       =SIMP(statut='o',typ='TXM' ),  
         TYPE_MODELE     =SIMP(statut='o',typ='TXM',into=("REF","PAR") ),
         VARIANTE        =SIMP(statut='o',typ='TXM',     
                               into=("A","B","C","D","E","F","G","H","I","J",    
                                     "K","L","M","N","O","P","Q","R","S","T","U","V",   
                                     "W","X","Y","Z",) ),
         TYPE_VALE       =SIMP(statut='o',typ='TXM',into=("NOMI","MINI","MAXI") ),
         NOM_MATER       =SIMP(statut='o',typ='TXM' ),  
         UNITE           =SIMP(statut='f',typ='I',defaut= 32 ),  
         EXTRACTION      =FACT(statut='f',max=99,
           COMPOR          =SIMP(statut='o',typ='TXM' ),  
           TEMP_EVAL       =SIMP(statut='o',typ='R' ),  
         ),
         UNITE_LONGUEUR  =SIMP(statut='f',typ='TXM',into=("M","MM"),defaut="M" ),  
         INFO            =SIMP(statut='f',typ='I',defaut= 1,into=(1,2) ),
)  ;
#& MODIF COMMANDE  DATE 14/09/2004   AUTEUR MCOURTOI M.COURTOIS 
#            CONFIGURATION MANAGEMENT OF EDF VERSION
# ======================================================================
# COPYRIGHT (C) 1991 - 2002  EDF R&D                  WWW.CODE-ASTER.ORG
# THIS PROGRAM IS FREE SOFTWARE; YOU CAN REDISTRIBUTE IT AND/OR MODIFY  
# IT UNDER THE TERMS OF THE GNU GENERAL PUBLIC LICENSE AS PUBLISHED BY  
# THE FREE SOFTWARE FOUNDATION; EITHER VERSION 2 OF THE LICENSE, OR     
# (AT YOUR OPTION) ANY LATER VERSION.                                                  
#                                                                       
# THIS PROGRAM IS DISTRIBUTED IN THE HOPE THAT IT WILL BE USEFUL, BUT   
# WITHOUT ANY WARRANTY; WITHOUT EVEN THE IMPLIED WARRANTY OF            
# MERCHANTABILITY OR FITNESS FOR A PARTICULAR PURPOSE. SEE THE GNU      
# GENERAL PUBLIC LICENSE FOR MORE DETAILS.                              
#                                                                       
# YOU SHOULD HAVE RECEIVED A COPY OF THE GNU GENERAL PUBLIC LICENSE     
# ALONG WITH THIS PROGRAM; IF NOT, WRITE TO EDF R&D CODE_ASTER,         
#    1 AVENUE DU GENERAL DE GAULLE, 92141 CLAMART CEDEX, FRANCE.        
# ======================================================================
# RESPONSABLE D6BHHJP J.P.LEFEBVRE
INFO_EXEC_ASTER=OPER(nom="INFO_EXEC_ASTER",op=35,sd_prod=table_sdaster,
                    fr="Récupère différentes informations propres à l'exécution en cours",
                    reentrant='n',
                    UIinfo={"groupes":("Gestion du travail",)},

         regles=(),
         LISTE_INFO     =SIMP(statut='o',typ='TXM',validators=NoRepeat(),max=3,
                              into=("CPU_RESTANT","UNITE_LIBRE","ETAT_UNITE"),),
         b_etat_unite   =BLOC(condition = "'ETAT_UNITE' in LISTE_INFO", 
            regles=(UN_PARMI('UNITE','FICHIER'),),
            UNITE          =SIMP(statut='f',typ='I',val_min=1,val_max=99,max=1,
                                 fr="Unité logique dont on veut obtenir l'état",),
            FICHIER        =SIMP(statut='f',typ='TXM',validators=LongStr(1,255),
                                 fr="Nom du fichier dont on veut obtenir l'état",),
         ),
         TITRE          =SIMP(statut='f',typ='TXM',max='**'),
         INFO           =SIMP(statut='f',typ='I',defaut=1,into=(1,2) ),
)  ;
#& MODIF COMMANDE  DATE 24/10/2006   AUTEUR DURAND C.DURAND 
#            CONFIGURATION MANAGEMENT OF EDF VERSION
# ======================================================================
# COPYRIGHT (C) 1991 - 2005  EDF R&D                  WWW.CODE-ASTER.ORG
# THIS PROGRAM IS FREE SOFTWARE; YOU CAN REDISTRIBUTE IT AND/OR MODIFY  
# IT UNDER THE TERMS OF THE GNU GENERAL PUBLIC LICENSE AS PUBLISHED BY  
# THE FREE SOFTWARE FOUNDATION; EITHER VERSION 2 OF THE LICENSE, OR     
# (AT YOUR OPTION) ANY LATER VERSION.                                                  
#                                                                       
# THIS PROGRAM IS DISTRIBUTED IN THE HOPE THAT IT WILL BE USEFUL, BUT   
# WITHOUT ANY WARRANTY; WITHOUT EVEN THE IMPLIED WARRANTY OF            
# MERCHANTABILITY OR FITNESS FOR A PARTICULAR PURPOSE. SEE THE GNU      
# GENERAL PUBLIC LICENSE FOR MORE DETAILS.                              
#                                                                       
# YOU SHOULD HAVE RECEIVED A COPY OF THE GNU GENERAL PUBLIC LICENSE     
# ALONG WITH THIS PROGRAM; IF NOT, WRITE TO EDF R&D CODE_ASTER,         
#    1 AVENUE DU GENERAL DE GAULLE, 92141 CLAMART CEDEX, FRANCE.        
# ======================================================================
from Macro.info_fonction_ops import info_fonction_ops
def info_fonction_prod(self,ECART_TYPE,RMS,NOCI_SEISME,MAX,NORME, **args):
   if (RMS         != None): return table_sdaster
   if (MAX         != None): return table_sdaster
   if (NOCI_SEISME != None): return table_sdaster
   if (ECART_TYPE  != None): return table_sdaster
   if (NORME       != None): return table_sdaster
   raise AsException("type de concept resultat non prevu")

INFO_FONCTION=MACRO(nom="INFO_FONCTION",op=info_fonction_ops,sd_prod=info_fonction_prod
                    ,fr="Opérations mathématiques sur des concepts de type fonction, fonction_c ou nappe",
                     reentrant='n',
            UIinfo={"groupes":("Fonction",)},
         regles=(UN_PARMI('MAX','RMS','NOCI_SEISME','NORME','ECART_TYPE',),),
         RMS             =FACT(statut='f',fr="Valeur RMS d'une fonction",max='**',
           METHODE         =SIMP(statut='f',typ='TXM',defaut="TRAPEZE",into=("SIMPSON","TRAPEZE") ),
           FONCTION        =SIMP(statut='o',typ=fonction_sdaster ),
           INST_INIT       =SIMP(statut='f',typ='R',fr="Instant initial définissant le début du signal" ),
           INST_FIN        =SIMP(statut='f',typ='R',fr="Instant final définissant la fin du signal" ),
           CRITERE         =SIMP(statut='f',typ='TXM',defaut="RELATIF",into=("RELATIF","ABSOLU") ),
           PRECISION       =SIMP(statut='f',typ='R',defaut= 1.E-3,val_min=0.E+0 ),
         ),
         NOCI_SEISME     =FACT(statut='f',
           regles=(UN_PARMI('FONCTION','SPEC_OSCI',),),
           FONCTION        =SIMP(statut='f',typ=fonction_sdaster ),
           SPEC_OSCI       =SIMP(statut='f',typ=nappe_sdaster ),
           b_option_f      =BLOC(condition="""FONCTION !=None""",
             OPTION          =SIMP(statut='f',typ='TXM',defaut="TOUT",validators=NoRepeat(),max='**',
                                   into=("INTE_ARIAS","POUV_DEST","INTE_SPEC","VITE_ABSO_CUMU",
                                         "DUREE_PHAS_FORT","MAXI","ACCE_SUR_VITE","TOUT",), ),
             b_amor          =BLOC(condition="""OPTION=="TOUT" or OPTION=="INTE_SPEC" """,
               AMOR_REDUIT     =SIMP(statut='o',typ='R'), ),),
           b_option_n      =BLOC(condition="""SPEC_OSCI !=None""",
             OPTION          =SIMP(statut='f',typ='TXM',defaut="INTE_SPEC",into=("INTE_SPEC",), ),
             NATURE          =SIMP(statut='o',typ='TXM',into=("DEPL","VITE","ACCE") ),
             AMOR_REDUIT     =SIMP(statut='o',typ='R'), ),
           INST_INIT       =SIMP(statut='f',typ='R'),
           INST_FIN        =SIMP(statut='f',typ='R'),
           COEF            =SIMP(statut='f',typ='R',defaut= 0.E+0 ),
           PESANTEUR       =SIMP(statut='f',typ='R',defaut= 9.81E+0 ),
           FREQ_INIT       =SIMP(statut='f',typ='R',defaut= 4.E-1 ),
           FREQ_FIN        =SIMP(statut='f',typ='R',defaut= 10.E+0 ),
           LIST_FREQ       =SIMP(statut='f',typ=listr8_sdaster ),
           FREQ            =SIMP(statut='f',typ='R',max='**'),
           NORME           =SIMP(statut='f',typ='R',defaut= 1.E+0 ),
           BORNE_INF       =SIMP(statut='f',typ='R',defaut= 0.05E+0 ),
           BORNE_SUP       =SIMP(statut='f',typ='R',defaut= 0.95E+0 ),
           b_acce_reel     =BLOC(condition="(INST_INIT != None)or(INST_FIN != None)or(FREQ_INIT != None)or(FREQ_FIN != None)",
             PRECISION       =SIMP(statut='f',typ='R',defaut=1.0E-3,val_min=0.E+0),
             CRITERE         =SIMP(statut='f',typ='TXM',defaut="RELATIF",into=("RELATIF","ABSOLU") ),
           ),
         ),
         MAX             =FACT(statut='f',fr="Extrémas locaux d'une fonction",
           FONCTION        =SIMP(statut='o',typ=(fonction_sdaster,nappe_sdaster),max='**' ),
         ),
         NORME           =FACT(statut='f',fr="Norme L2 d'une fonction",
            FONCTION      =SIMP(statut='o', typ=nappe_sdaster),
         ),     
         ECART_TYPE      =FACT(statut='f',fr="Ecart-type d'une fonction",
            METHODE       =SIMP(statut='f',typ='TXM',defaut="TRAPEZE",into=("SIMPSON","TRAPEZE") ),
            FONCTION      =SIMP(statut='o',typ=fonction_sdaster),
            INST_INIT     =SIMP(statut='f',typ='R',fr="Instant initial définissant le début du signal" ),
            INST_FIN      =SIMP(statut='f',typ='R',fr="Instant final définissant la fin du signal" ),
            CRITERE       =SIMP(statut='f',typ='TXM',defaut="RELATIF",into=("RELATIF","ABSOLU") ),
            PRECISION     =SIMP(statut='f',typ='R',defaut= 1.E-3,val_min=0.E+0 ),
         ),     
         INFO            =SIMP(statut='f',typ='I',defaut=1,into=(1,2) ),
)
#& MODIF COMMANDE  DATE 22/06/2005   AUTEUR REZETTE C.REZETTE 
#            CONFIGURATION MANAGEMENT OF EDF VERSION
# ======================================================================
# COPYRIGHT (C) 1991 - 2001  EDF R&D                  WWW.CODE-ASTER.ORG
# THIS PROGRAM IS FREE SOFTWARE; YOU CAN REDISTRIBUTE IT AND/OR MODIFY
# IT UNDER THE TERMS OF THE GNU GENERAL PUBLIC LICENSE AS PUBLISHED BY
# THE FREE SOFTWARE FOUNDATION; EITHER VERSION 2 OF THE LICENSE, OR   
# (AT YOUR OPTION) ANY LATER VERSION.                                 
#
# THIS PROGRAM IS DISTRIBUTED IN THE HOPE THAT IT WILL BE USEFUL, BUT 
# WITHOUT ANY WARRANTY; WITHOUT EVEN THE IMPLIED WARRANTY OF          
# MERCHANTABILITY OR FITNESS FOR A PARTICULAR PURPOSE. SEE THE GNU    
# GENERAL PUBLIC LICENSE FOR MORE DETAILS.                            
#
# YOU SHOULD HAVE RECEIVED A COPY OF THE GNU GENERAL PUBLIC LICENSE   
# ALONG WITH THIS PROGRAM; IF NOT, WRITE TO EDF R&D CODE_ASTER,       
#    1 AVENUE DU GENERAL DE GAULLE, 92141 CLAMART CEDEX, FRANCE.      
# ======================================================================
# RESPONSABLE G8BHHXD X.DESROCHES
INTE_MAIL_2D=OPER(nom="INTE_MAIL_2D",op=50,sd_prod=courbe_sdaster,
            UIinfo={"groupes":("Post traitements",)},
                  fr="Définition d'une courbe dans un maillage 2D",reentrant='n',

         MAILLAGE        =SIMP(statut='o',typ=(maillage_sdaster) ),

         regles=(PRESENT_ABSENT('TOUT','GROUP_MA','MAILLE'),
                 AU_MOINS_UN('DEFI_SEGMENT','DEFI_ARC','DEFI_CHEMIN'),
                 PRESENT_ABSENT('DEFI_CHEMIN','DEFI_SEGMENT','DEFI_ARC'),
                 PRESENT_ABSENT('DEFI_SEGMENT','NOEUD_ORIG','GROUP_NO_ORIG'),
                 PRESENT_ABSENT('DEFI_ARC','NOEUD_ORIG','GROUP_NO_ORIG'),
                 EXCLUS('NOEUD_ORIG','GROUP_NO_ORIG'),
                 EXCLUS('DEFI_CHEMIN','DEFI_SEGMENT'),
                 EXCLUS('DEFI_CHEMIN','DEFI_ARC'),),

         TOUT            =SIMP(statut='f',typ='TXM',into=("OUI",) ),
         GROUP_MA        =SIMP(statut='f',typ=grma,validators=NoRepeat(),max='**'),
         MAILLE          =SIMP(statut='f',typ=ma  ,validators=NoRepeat(),max='**'),

         DEFI_SEGMENT    =FACT(statut='f',max='**',
           regles=(UN_PARMI('ORIGINE','NOEUD_ORIG','GROUP_NO_ORIG'),
                   UN_PARMI('EXTREMITE','NOEUD_EXTR','GROUP_NO_EXTR'),),
           ORIGINE         =SIMP(statut='f',typ='R',min=2,max=2),  
           NOEUD_ORIG      =SIMP(statut='f',typ=no,),
           GROUP_NO_ORIG   =SIMP(statut='f',typ=grno,),
           EXTREMITE       =SIMP(statut='f',typ='R',min=2,max=2),  
           NOEUD_EXTR      =SIMP(statut='f',typ=no,),
           GROUP_NO_EXTR   =SIMP(statut='f',typ=grno,),
         ),

         DEFI_ARC        =FACT(statut='f',max='**',
           regles=(UN_PARMI('CENTRE','NOEUD_CENTRE','GROUP_NO_CENTRE'),
                   UN_PARMI('RAYON','ORIGINE','NOEUD_ORIG','GROUP_NO_ORIG'),
                   UN_PARMI('RAYON','EXTREMITE','NOEUD_EXTR','GROUP_NO_EXTR'),               
                   PRESENT_PRESENT('RAYON','SECTEUR'),),
           CENTRE          =SIMP(statut='f',typ='R',min=2,max=2),  
           NOEUD_CENTRE    =SIMP(statut='f',typ=no,),
           GROUP_NO_CENTRE =SIMP(statut='f',typ=grno,),
           RAYON           =SIMP(statut='f',typ='R',val_min=0.E+0),  
           SECTEUR         =SIMP(statut='f',typ='R',min=2,max=2,
                                 val_min=-180.E+0,val_max=180E+0),  
           ORIGINE         =SIMP(statut='f',typ='R',min=2,max=2),  
           NOEUD_ORIG      =SIMP(statut='f',typ=no,),
           GROUP_NO_ORIG   =SIMP(statut='f',typ=grno,),
           EXTREMITE       =SIMP(statut='f',typ='R',min=2,max=2),  
           NOEUD_EXTR      =SIMP(statut='f',typ=no,),
           GROUP_NO_EXTR   =SIMP(statut='f',typ=grno,),
           PRECISION       =SIMP(statut='f',typ='R',defaut= 1.0E-3 ),  
           CRITERE         =SIMP(statut='f',typ='TXM',defaut="RELATIF",    
                                 into=("RELATIF","ABSOLU",) ),
         ),

         DEFI_CHEMIN     =FACT(statut='f',max='**',
           regles=(UN_PARMI('MAILLE','GROUP_MA'),),
           MAILLE          =SIMP(statut='f',typ=ma  ,validators=NoRepeat(),max='**'),
           GROUP_MA        =SIMP(statut='f',typ=grma,validators=NoRepeat(),max='**'),
         ),

         NOEUD_ORIG      =SIMP(statut='f',typ=no,),
         GROUP_NO_ORIG   =SIMP(statut='f',typ=grno,),
         PRECISION       =SIMP(statut='f',typ='R',defaut=1.0E-3),  
         INFO            =SIMP(statut='f',typ='I',defaut=1,into=(1,2)),
)  ;
#& MODIF COMMANDE  DATE 22/06/2005   AUTEUR REZETTE C.REZETTE 
#            CONFIGURATION MANAGEMENT OF EDF VERSION
# ======================================================================
# COPYRIGHT (C) 1991 - 2001  EDF R&D                  WWW.CODE-ASTER.ORG
# THIS PROGRAM IS FREE SOFTWARE; YOU CAN REDISTRIBUTE IT AND/OR MODIFY
# IT UNDER THE TERMS OF THE GNU GENERAL PUBLIC LICENSE AS PUBLISHED BY
# THE FREE SOFTWARE FOUNDATION; EITHER VERSION 2 OF THE LICENSE, OR   
# (AT YOUR OPTION) ANY LATER VERSION.                                 
#
# THIS PROGRAM IS DISTRIBUTED IN THE HOPE THAT IT WILL BE USEFUL, BUT 
# WITHOUT ANY WARRANTY; WITHOUT EVEN THE IMPLIED WARRANTY OF          
# MERCHANTABILITY OR FITNESS FOR A PARTICULAR PURPOSE. SEE THE GNU    
# GENERAL PUBLIC LICENSE FOR MORE DETAILS.                            
#
# YOU SHOULD HAVE RECEIVED A COPY OF THE GNU GENERAL PUBLIC LICENSE   
# ALONG WITH THIS PROGRAM; IF NOT, WRITE TO EDF R&D CODE_ASTER,       
#    1 AVENUE DU GENERAL DE GAULLE, 92141 CLAMART CEDEX, FRANCE.      
# ======================================================================
# RESPONSABLE G8BHHXD X.DESROCHES
INTE_MAIL_3D=OPER(nom="INTE_MAIL_3D",op=96,sd_prod=surface_sdaster,
            UIinfo={"groupes":("Post traitements",)},
                  fr="Définir un chemin de type segment de droite dans un maillage 3D",reentrant='n',
         MAILLAGE        =SIMP(statut='o',typ=maillage_sdaster),
         TOUT            =SIMP(statut='f',typ='TXM',into=("OUI",) ),
         GROUP_MA        =SIMP(statut='f',typ=grma,validators=NoRepeat(),max='**'),
         MAILLE          =SIMP(statut='f',typ=ma  ,validators=NoRepeat(),max='**'),
         DEFI_SEGMENT    =FACT(statut='o',max='**',
           regles=(UN_PARMI('ORIGINE','NOEUD_ORIG','GROUP_NO_ORIG'),
                   UN_PARMI('EXTREMITE','NOEUD_EXTR','GROUP_NO_EXTR'),),
           ORIGINE         =SIMP(statut='f',typ='R',min=3,max=3),  
           NOEUD_ORIG      =SIMP(statut='f',typ=no,),
           GROUP_NO_ORIG   =SIMP(statut='f',typ=grno,),
           EXTREMITE       =SIMP(statut='f',typ='R',min=3,max=3),  
           NOEUD_EXTR      =SIMP(statut='f',typ=no,),
           GROUP_NO_EXTR   =SIMP(statut='f',typ=grno,),
         ),
         PRECISION       =SIMP(statut='f',typ='R',defaut=1.0E-6),  
         INFO            =SIMP(statut='f',typ='I',defaut=1,into=(1,2)),
)  ;
#& MODIF COMMANDE  DATE 16/05/2006   AUTEUR REZETTE C.REZETTE 
#            CONFIGURATION MANAGEMENT OF EDF VERSION
# ======================================================================
# COPYRIGHT (C) 1991 - 2001  EDF R&D                  WWW.CODE-ASTER.ORG
# THIS PROGRAM IS FREE SOFTWARE; YOU CAN REDISTRIBUTE IT AND/OR MODIFY
# IT UNDER THE TERMS OF THE GNU GENERAL PUBLIC LICENSE AS PUBLISHED BY
# THE FREE SOFTWARE FOUNDATION; EITHER VERSION 2 OF THE LICENSE, OR   
# (AT YOUR OPTION) ANY LATER VERSION.                                 
#
# THIS PROGRAM IS DISTRIBUTED IN THE HOPE THAT IT WILL BE USEFUL, BUT 
# WITHOUT ANY WARRANTY; WITHOUT EVEN THE IMPLIED WARRANTY OF          
# MERCHANTABILITY OR FITNESS FOR A PARTICULAR PURPOSE. SEE THE GNU    
# GENERAL PUBLIC LICENSE FOR MORE DETAILS.                            
#
# YOU SHOULD HAVE RECEIVED A COPY OF THE GNU GENERAL PUBLIC LICENSE   
# ALONG WITH THIS PROGRAM; IF NOT, WRITE TO EDF R&D CODE_ASTER,       
#    1 AVENUE DU GENERAL DE GAULLE, 92141 CLAMART CEDEX, FRANCE.      
# ======================================================================
def lire_champ_prod(TYPE_CHAM=None,**args):
# Remarque : si cette liste évolue, il faut penser à mettre à jour son
#            homologue dans macr_adap_mail
  import string
#  
  if TYPE_CHAM[0:5] == "NOEU_" : return cham_no_sdaster
  if TYPE_CHAM[0:2] == "EL"    : return cham_elem
  raise AsException("type de concept resultat non prevu")

LIRE_CHAMP=OPER(nom="LIRE_CHAMP",op= 192,sd_prod=lire_champ_prod,
                fr="Lire un champ dans un fichier au format MED et le stocker dans un concept.",
                reentrant='n',UIinfo={"groupe":("Résultats et champs",)},
         MAILLAGE        =SIMP(statut='o',typ=maillage_sdaster,),
         FORMAT          =SIMP(statut='f',typ='TXM',defaut="MED",into=("MED",),),
         UNITE           =SIMP(statut='f',typ='I',defaut= 81,),  
         b_format =BLOC(condition = "FORMAT == 'MED'",
         regles=( UN_PARMI('NOM_CMP_IDEM','NOM_CMP'),
                  PRESENT_PRESENT('NOM_CMP','NOM_CMP_MED' ),
                  EXCLUS('NUME_ORDRE','INST'),
                  EXCLUS('NUME_PT','INST'),),
            NOM_MED      =SIMP(statut='o',typ='TXM', ),
            NOM_CMP_IDEM =SIMP(statut='f',typ='TXM',into=("OUI",), ),
            NOM_CMP      =SIMP(statut='f',typ='TXM',validators=NoRepeat(),max='**',),
            NOM_CMP_MED  =SIMP(statut='f',typ='TXM',validators=NoRepeat(),max='**',),
            NUME_PT      =SIMP(statut='f',typ='I'  ,validators=NoRepeat(),max='**',),
            NUME_ORDRE   =SIMP(statut='f',typ='I'  ,validators=NoRepeat(),max='**',
                           fr="Numero d ordre du champ à lire",ang="Rank of the field to be read" ),
            INST         =SIMP(statut='f',typ='R',fr="Instant associé",ang="Instant" ),
#
            b_precision     =BLOC(condition="(INST != None)",
              PRECISION       =SIMP(statut='f',typ='R',defaut=1.0E-3,
              fr="Précision sur le choix de l'instant associé",ang="Accuracy over instant choice" ),
              CRITERE         =SIMP(statut='f',typ='TXM',defaut="RELATIF",into=("RELATIF","ABSOLU"),
              fr="Critère de précision sur le choix de l'instant associé",
              ang="Accuracy criterium over instant choice" ),),
#
            NOM_MAIL_MED =SIMP(statut='f',typ='TXM',),
                  ),
#        Remarque : si cette liste évolue, il faut penser à mettre à jour son
#                   homologue dans macr_adap_mail
         TYPE_CHAM       =SIMP(statut='o',typ='TXM',into=C_TYPE_CHAM_INTO()),
         b_modele =BLOC(condition = "TYPE_CHAM!=None and TYPE_CHAM[0:2] == 'EL'",
            MODELE      =SIMP(statut='o',typ=modele_sdaster, ),
                  ),
         INFO            =SIMP(statut='f',typ='I',defaut= 1,into=(1,2) ),
)  ;
#& MODIF COMMANDE  DATE 22/06/2005   AUTEUR REZETTE C.REZETTE 
#            CONFIGURATION MANAGEMENT OF EDF VERSION
# ======================================================================
# COPYRIGHT (C) 1991 - 2001  EDF R&D                  WWW.CODE-ASTER.ORG
# THIS PROGRAM IS FREE SOFTWARE; YOU CAN REDISTRIBUTE IT AND/OR MODIFY
# IT UNDER THE TERMS OF THE GNU GENERAL PUBLIC LICENSE AS PUBLISHED BY
# THE FREE SOFTWARE FOUNDATION; EITHER VERSION 2 OF THE LICENSE, OR   
# (AT YOUR OPTION) ANY LATER VERSION.                                 
#
# THIS PROGRAM IS DISTRIBUTED IN THE HOPE THAT IT WILL BE USEFUL, BUT 
# WITHOUT ANY WARRANTY; WITHOUT EVEN THE IMPLIED WARRANTY OF          
# MERCHANTABILITY OR FITNESS FOR A PARTICULAR PURPOSE. SEE THE GNU    
# GENERAL PUBLIC LICENSE FOR MORE DETAILS.                            
#
# YOU SHOULD HAVE RECEIVED A COPY OF THE GNU GENERAL PUBLIC LICENSE   
# ALONG WITH THIS PROGRAM; IF NOT, WRITE TO EDF R&D CODE_ASTER,       
#    1 AVENUE DU GENERAL DE GAULLE, 92141 CLAMART CEDEX, FRANCE.      
# ======================================================================

from Macro.lire_fonction_ops import lire_fonction_ops

def lire_fonction_prod(self,TYPE,**args):
  if   (TYPE == 'FONCTION')  : return fonction_sdaster
  elif (TYPE == 'FONCTION_C'): return fonction_c
  elif (TYPE == 'NAPPE'   )  : return nappe_sdaster
  raise AsException("type de concept resultat non prevu")

LIRE_FONCTION=MACRO(nom="LIRE_FONCTION",op=lire_fonction_ops,sd_prod=lire_fonction_prod,
                   fr="Lit les valeurs réelles dans un fichier de données représentant une fonction et"
                     +" crée un concept de type fonction ou nappe",
                   reentrant='n',
            UIinfo={"groupes":("Fonction",)},
         FORMAT          =SIMP(statut='f',typ='TXM',into=("LIBRE",),defaut="LIBRE"  ),
         TYPE            =SIMP(statut='f',typ='TXM',into=("FONCTION","FONCTION_C","NAPPE"),defaut="FONCTION"  ),
         SEPAR           =SIMP(statut='f',typ='TXM',into=("None",",",";","/"),defaut="None" ),
         INDIC_PARA      =SIMP(statut='f',typ='I',min=2,max=2,defaut=[1,1]),
         b_fonction      =BLOC(condition = "TYPE=='FONCTION' ",
           INDIC_RESU      =SIMP(statut='f',typ='I',min=2,max=2,defaut=[1,2]), ),
         b_fonction_c    =BLOC(condition = "TYPE=='FONCTION_C' ",
           FORMAT_C        =SIMP(statut='f',typ='TXM',defaut="REEL_IMAG",into=("REEL_IMAG","MODULE_PHASE") ),
           b_reel_imag     =BLOC(condition = "FORMAT_C=='REEL_IMAG' ",
             INDIC_REEL      =SIMP(statut='o',typ='I',min=2,max=2,defaut=[1,2]),
             INDIC_IMAG      =SIMP(statut='o',typ='I',min=2,max=2,defaut=[1,3]), ) ,
           b_modu_phas     =BLOC(condition = "FORMAT_C=='MODULE_PHASE' ",
             INDIC_MODU      =SIMP(statut='o',typ='I',min=2,max=2,defaut=[1,2]),
             INDIC_PHAS      =SIMP(statut='o',typ='I',min=2,max=2,defaut=[1,3]), ), ),
         b_nappe         =BLOC(condition = "TYPE=='NAPPE' ",
           NOM_PARA_FONC   =SIMP(statut='o',typ='TXM',into=C_PARA_FONCTION() ),
           INDIC_ABSCISSE  =SIMP(statut='o',typ='I',min=2,max=2,),
           INTERPOL_FONC   =SIMP(statut='f',typ='TXM',max=2,defaut="LIN",into=("NON","LIN","LOG") ),
           PROL_DROITE_FONC=SIMP(statut='f',typ='TXM',defaut="EXCLU",into=("CONSTANT","LINEAIRE","EXCLU") ),
           PROL_GAUCHE_FONC=SIMP(statut='f',typ='TXM',defaut="EXCLU",into=("CONSTANT","LINEAIRE","EXCLU") ),
           DEFI_FONCTION   =FACT(statut='f',max='**',
             INDIC_RESU      =SIMP(statut='o',typ='I',min=2,max=2,),),  ),
         UNITE           =SIMP(statut='o',typ='I' ),
         NOM_PARA        =SIMP(statut='o',typ='TXM',into=C_PARA_FONCTION() ),
         NOM_RESU        =SIMP(statut='f',typ='TXM',defaut="TOUTRESU"),
         INTERPOL        =SIMP(statut='f',typ='TXM',max=2,defaut="LIN",into=("NON","LIN","LOG") ),
         PROL_DROITE     =SIMP(statut='f',typ='TXM',defaut="EXCLU",into=("CONSTANT","LINEAIRE","EXCLU") ),
         PROL_GAUCHE     =SIMP(statut='f',typ='TXM',defaut="EXCLU",into=("CONSTANT","LINEAIRE","EXCLU") ),
         VERIF           =SIMP(statut='f',typ='TXM',defaut="CROISSANT",into=("CROISSANT","NON") ),
         INFO            =SIMP(statut='f',typ='I',defaut= 1,into=( 1 , 2) ),
         TITRE           =SIMP(statut='f',typ='TXM',max='**'),
)  ;
#& MODIF COMMANDE  DATE 21/02/2006   AUTEUR REZETTE C.REZETTE 
#            CONFIGURATION MANAGEMENT OF EDF VERSION
# ======================================================================
# COPYRIGHT (C) 1991 - 2005  EDF R&D                  WWW.CODE-ASTER.ORG
# THIS PROGRAM IS FREE SOFTWARE; YOU CAN REDISTRIBUTE IT AND/OR MODIFY  
# IT UNDER THE TERMS OF THE GNU GENERAL PUBLIC LICENSE AS PUBLISHED BY  
# THE FREE SOFTWARE FOUNDATION; EITHER VERSION 2 OF THE LICENSE, OR     
# (AT YOUR OPTION) ANY LATER VERSION.                                                  
#                                                                       
# THIS PROGRAM IS DISTRIBUTED IN THE HOPE THAT IT WILL BE USEFUL, BUT   
# WITHOUT ANY WARRANTY; WITHOUT EVEN THE IMPLIED WARRANTY OF            
# MERCHANTABILITY OR FITNESS FOR A PARTICULAR PURPOSE. SEE THE GNU      
# GENERAL PUBLIC LICENSE FOR MORE DETAILS.                              
#                                                                       
# YOU SHOULD HAVE RECEIVED A COPY OF THE GNU GENERAL PUBLIC LICENSE     
# ALONG WITH THIS PROGRAM; IF NOT, WRITE TO EDF R&D CODE_ASTER,         
#    1 AVENUE DU GENERAL DE GAULLE, 92141 CLAMART CEDEX, FRANCE.        
# ======================================================================
LIRE_FORC_MISS=OPER(nom="LIRE_FORC_MISS",op= 179,sd_prod=vect_asse_gene,
                    fr="Création d un vecteur assemblé à partir de base modale",
                    reentrant='n',
            UIinfo={"groupes":("Matrices/vecteurs",)},           
         BASE            =SIMP(statut='o',typ=base_modale ),
         NUME_DDL_GENE   =SIMP(statut='o',typ=nume_ddl_gene ),
         FREQ_EXTR       =SIMP(statut='o',typ='R',max=1),
         NOM_CMP         =SIMP(statut='o',typ='TXM',into=("DX","DY","DZ") ),
         NOM_CHAM        =SIMP(statut='f',typ='TXM',into=("DEPL","VITE","ACCE"),defaut="DEPL"),
         UNITE_RESU_FORC =SIMP(statut='f',typ='I',defaut=30),
)  ;

#& MODIF COMMANDE  DATE 19/09/2006   AUTEUR ACBHHCD G.DEVESA 
#            CONFIGURATION MANAGEMENT OF EDF VERSION
# ======================================================================
# COPYRIGHT (C) 1991 - 2005  EDF R&D                  WWW.CODE-ASTER.ORG
# THIS PROGRAM IS FREE SOFTWARE; YOU CAN REDISTRIBUTE IT AND/OR MODIFY  
# IT UNDER THE TERMS OF THE GNU GENERAL PUBLIC LICENSE AS PUBLISHED BY  
# THE FREE SOFTWARE FOUNDATION; EITHER VERSION 2 OF THE LICENSE, OR     
# (AT YOUR OPTION) ANY LATER VERSION.                                                  
#                                                                       
# THIS PROGRAM IS DISTRIBUTED IN THE HOPE THAT IT WILL BE USEFUL, BUT   
# WITHOUT ANY WARRANTY; WITHOUT EVEN THE IMPLIED WARRANTY OF            
# MERCHANTABILITY OR FITNESS FOR A PARTICULAR PURPOSE. SEE THE GNU      
# GENERAL PUBLIC LICENSE FOR MORE DETAILS.                              
#                                                                       
# YOU SHOULD HAVE RECEIVED A COPY OF THE GNU GENERAL PUBLIC LICENSE     
# ALONG WITH THIS PROGRAM; IF NOT, WRITE TO EDF R&D CODE_ASTER,         
#    1 AVENUE DU GENERAL DE GAULLE, 92141 CLAMART CEDEX, FRANCE.        
# ======================================================================
LIRE_IMPE_MISS=OPER(nom="LIRE_IMPE_MISS",op= 164,sd_prod=matr_asse_gene_c,
                    fr="Création d une matrice assemblée à partir de base modale",
                    reentrant='n',
            UIinfo={"groupes":("Matrices/vecteurs",)},           
         BASE            =SIMP(statut='o',typ=base_modale ),
         NUME_DDL_GENE   =SIMP(statut='o',typ=nume_ddl_gene ),
         FREQ_EXTR       =SIMP(statut='o',typ='R',max=1),
         UNITE_RESU_IMPE =SIMP(statut='f',typ='I',defaut=30),
         TYPE            =SIMP(statut='f',typ='TXM',defaut="ASCII",into=("BINAIRE","ASCII") ),         
)  ;

#& MODIF COMMANDE  DATE 10/10/2006   AUTEUR MCOURTOI M.COURTOIS 
#            CONFIGURATION MANAGEMENT OF EDF VERSION
# ======================================================================
# COPYRIGHT (C) 1991 - 2001  EDF R&D                  WWW.CODE-ASTER.ORG
# THIS PROGRAM IS FREE SOFTWARE; YOU CAN REDISTRIBUTE IT AND/OR MODIFY
# IT UNDER THE TERMS OF THE GNU GENERAL PUBLIC LICENSE AS PUBLISHED BY
# THE FREE SOFTWARE FOUNDATION; EITHER VERSION 2 OF THE LICENSE, OR   
# (AT YOUR OPTION) ANY LATER VERSION.                                 
#
# THIS PROGRAM IS DISTRIBUTED IN THE HOPE THAT IT WILL BE USEFUL, BUT 
# WITHOUT ANY WARRANTY; WITHOUT EVEN THE IMPLIED WARRANTY OF          
# MERCHANTABILITY OR FITNESS FOR A PARTICULAR PURPOSE. SEE THE GNU    
# GENERAL PUBLIC LICENSE FOR MORE DETAILS.                            
#
# YOU SHOULD HAVE RECEIVED A COPY OF THE GNU GENERAL PUBLIC LICENSE   
# ALONG WITH THIS PROGRAM; IF NOT, WRITE TO EDF R&D CODE_ASTER,       
#    1 AVENUE DU GENERAL DE GAULLE, 92141 CLAMART CEDEX, FRANCE.      
# ======================================================================

from Macro.lire_inte_spec_ops import lire_inte_spec_ops

LIRE_INTE_SPEC=MACRO(nom="LIRE_INTE_SPEC",op=lire_inte_spec_ops,sd_prod=table_fonction,
                    fr="Lecture sur un fichier externe de fonctions complexes pour créer une matrice interspectrale",
                    reentrant='n',
            UIinfo={"groupes":("Fonction",)},
         UNITE           =SIMP(statut='o',typ='I' ),
         FORMAT          =SIMP(statut='f',typ='TXM',defaut="MODULE_PHASE",into=("REEL_IMAG","MODULE_PHASE") ),
         NOM_PARA        =SIMP(statut='f',typ='TXM',defaut="FREQ",
                               into=("DX","DY","DZ","DRX","DRY","DRZ","TEMP",
                                     "INST","X","Y","Z","EPSI","FREQ","PULS","AMOR","ABSC",) ),
         NOM_RESU        =SIMP(statut='f',typ='TXM',defaut="DSP" ),
         INTERPOL        =SIMP(statut='f',typ='TXM',max=2,into=("NON","LIN","LOG") ),
         PROL_DROITE     =SIMP(statut='f',typ='TXM',into=("CONSTANT","LINEAIRE","EXCLU") ),
         PROL_GAUCHE     =SIMP(statut='f',typ='TXM',into=("CONSTANT","LINEAIRE","EXCLU") ),
         TITRE           =SIMP(statut='f',typ='TXM',max='**'),
         INFO            =SIMP(statut='f',typ='I',defaut= 1,into=( 1 , 2) ),
)  ;
#& MODIF COMMANDE  DATE 21/11/2006   AUTEUR COURTOIS M.COURTOIS 
#            CONFIGURATION MANAGEMENT OF EDF VERSION
# ======================================================================
# COPYRIGHT (C) 1991 - 2001  EDF R&D                  WWW.CODE-ASTER.ORG
# THIS PROGRAM IS FREE SOFTWARE; YOU CAN REDISTRIBUTE IT AND/OR MODIFY
# IT UNDER THE TERMS OF THE GNU GENERAL PUBLIC LICENSE AS PUBLISHED BY
# THE FREE SOFTWARE FOUNDATION; EITHER VERSION 2 OF THE LICENSE, OR   
# (AT YOUR OPTION) ANY LATER VERSION.                                 
#
# THIS PROGRAM IS DISTRIBUTED IN THE HOPE THAT IT WILL BE USEFUL, BUT 
# WITHOUT ANY WARRANTY; WITHOUT EVEN THE IMPLIED WARRANTY OF          
# MERCHANTABILITY OR FITNESS FOR A PARTICULAR PURPOSE. SEE THE GNU    
# GENERAL PUBLIC LICENSE FOR MORE DETAILS.                            
#
# YOU SHOULD HAVE RECEIVED A COPY OF THE GNU GENERAL PUBLIC LICENSE   
# ALONG WITH THIS PROGRAM; IF NOT, WRITE TO EDF R&D CODE_ASTER,       
#    1 AVENUE DU GENERAL DE GAULLE, 92141 CLAMART CEDEX, FRANCE.      
# ======================================================================
# RESPONSABLE VABHHTS J.PELLET
LIRE_MAILLAGE=OPER(nom="LIRE_MAILLAGE",op=   1,sd_prod=maillage_sdaster,
                   fr="Crée un maillage par lecture d'un fichier au format Aster ou Med",
                   ang="Readings of a mesh file",
                   reentrant='n',
            UIinfo={"groupes":("Maillage",)},
#
         UNITE           =SIMP(statut='f',typ='I',defaut= 20 ),
#
         FORMAT          =SIMP(statut='f',typ='TXM',defaut="ASTER",into=("ASTER","MED"),
                            fr="Format du fichier : ASTER ou MED.",
                            ang="Format of the file : ASTER or MED.",),
#
         ABSC_CURV       =FACT(statut='f',min=0,
               TOUT          =SIMP(statut='f',typ='TXM',defaut="NON",into=("OUI","NON") ),
         ),
#
         VERI_MAIL       =FACT(statut='d',
               VERIF         =SIMP(statut='f',typ='TXM',defaut="OUI",into=("OUI","NON") ),  
               APLAT         =SIMP(statut='f',typ='R',defaut= 1.0E-3 ),  
         ),
#
         b_format_med =BLOC( condition = " ( FORMAT == 'MED' ) " ,
                             fr="Informations complémentaires pour la lecture MED.",
                             ang="Further information for MED readings.",
#
# Pour une lecture dans un fichier MED, on peut préciser le nom sous lequel
# le maillage y a été enregistré. Par défaut, on va le chercher sous le nom du concept à créer.
            NOM_MED    = SIMP(statut='f',typ='TXM',
                              fr="Nom du maillage dans le fichier MED.",
                              ang="Name of the mesh into the MED file.",),
            INFO_MED   = SIMP(statut='f',typ='I',defaut= 1,into=(1,2) ),
#
            RENOMME = FACT(statut='f', max='**',
                                 fr="Renommer un nom de groupe MED",
                 NOM_MED     = SIMP(statut='o', typ=grma,
                                    fr="Nom du groupe dans le fichier MED"),
                 NOM         = SIMP(statut='o', typ=grma, validators=LongStr(1,8),
                                    fr="Nom du groupe dans le maillage ASTER"),
            ),
         ),
#
         INFO            =SIMP(statut='f',typ='I',defaut= 1,into=(1,2) ),
#
)  ;
#& MODIF COMMANDE  DATE 22/06/2005   AUTEUR REZETTE C.REZETTE 
#            CONFIGURATION MANAGEMENT OF EDF VERSION
# ======================================================================
# COPYRIGHT (C) 1991 - 2001  EDF R&D                  WWW.CODE-ASTER.ORG
# THIS PROGRAM IS FREE SOFTWARE; YOU CAN REDISTRIBUTE IT AND/OR MODIFY
# IT UNDER THE TERMS OF THE GNU GENERAL PUBLIC LICENSE AS PUBLISHED BY
# THE FREE SOFTWARE FOUNDATION; EITHER VERSION 2 OF THE LICENSE, OR   
# (AT YOUR OPTION) ANY LATER VERSION.                                 
#
# THIS PROGRAM IS DISTRIBUTED IN THE HOPE THAT IT WILL BE USEFUL, BUT 
# WITHOUT ANY WARRANTY; WITHOUT EVEN THE IMPLIED WARRANTY OF          
# MERCHANTABILITY OR FITNESS FOR A PARTICULAR PURPOSE. SEE THE GNU    
# GENERAL PUBLIC LICENSE FOR MORE DETAILS.                            
#
# YOU SHOULD HAVE RECEIVED A COPY OF THE GNU GENERAL PUBLIC LICENSE   
# ALONG WITH THIS PROGRAM; IF NOT, WRITE TO EDF R&D CODE_ASTER,       
#    1 AVENUE DU GENERAL DE GAULLE, 92141 CLAMART CEDEX, FRANCE.      
# ======================================================================
def lire_miss_3d_prod(TYPE_RESU,**args):
  if TYPE_RESU == "TRANS" : return dyna_trans
  if TYPE_RESU == "HARMO" : return dyna_harmo
  raise AsException("type de concept resultat non prevu")

LIRE_MISS_3D=OPER(nom="LIRE_MISS_3D",op= 163,sd_prod=lire_miss_3d_prod,
                  fr="Restituer sur base physique une réponse harmonique ou transitoire issue de MISS3D",
                  reentrant='n',
            UIinfo={"groupes":("Maillage",)},
         MACR_ELEM_DYNA  =SIMP(statut='o',typ=macr_elem_dyna ),
         UNITE           =SIMP(statut='f',typ='I',defaut= 27 ),
         NOM             =SIMP(statut='f',typ='TXM' ),
         TYPE_RESU       =SIMP(statut='f',typ='TXM',defaut="TRANS",into=("TRANS","HARMO") ),
         TITRE           =SIMP(statut='f',typ='TXM',max='**'),
)  ;
#& MODIF COMMANDE  DATE 22/06/2005   AUTEUR REZETTE C.REZETTE 
#            CONFIGURATION MANAGEMENT OF EDF VERSION
# ======================================================================
# COPYRIGHT (C) 1991 - 2001  EDF R&D                  WWW.CODE-ASTER.ORG
# THIS PROGRAM IS FREE SOFTWARE; YOU CAN REDISTRIBUTE IT AND/OR MODIFY
# IT UNDER THE TERMS OF THE GNU GENERAL PUBLIC LICENSE AS PUBLISHED BY
# THE FREE SOFTWARE FOUNDATION; EITHER VERSION 2 OF THE LICENSE, OR   
# (AT YOUR OPTION) ANY LATER VERSION.                                 
#
# THIS PROGRAM IS DISTRIBUTED IN THE HOPE THAT IT WILL BE USEFUL, BUT 
# WITHOUT ANY WARRANTY; WITHOUT EVEN THE IMPLIED WARRANTY OF          
# MERCHANTABILITY OR FITNESS FOR A PARTICULAR PURPOSE. SEE THE GNU    
# GENERAL PUBLIC LICENSE FOR MORE DETAILS.                            
#
# YOU SHOULD HAVE RECEIVED A COPY OF THE GNU GENERAL PUBLIC LICENSE   
# ALONG WITH THIS PROGRAM; IF NOT, WRITE TO EDF R&D CODE_ASTER,       
#    1 AVENUE DU GENERAL DE GAULLE, 92141 CLAMART CEDEX, FRANCE.      
# ======================================================================
LIRE_PLEXUS=OPER(nom="LIRE_PLEXUS",op= 184,sd_prod=evol_char,
                 fr="Lire le fichier de résultats au format IDEAS produit par le logiciel EUROPLEXUS",
                 reentrant='n',
            UIinfo={"groupes":("Maillage",)},
         regles=(UN_PARMI('TOUT_ORDRE','NUME_ORDRE','INST','LIST_INST','LIST_ORDRE'),),
         UNITE           =SIMP(statut='f',typ='I',defaut= 19 ),
         FORMAT          =SIMP(statut='f',typ='TXM',defaut="IDEAS",into=("IDEAS",)),
         MAIL_PLEXUS     =SIMP(statut='o',typ=maillage_sdaster ),
         MAILLAGE        =SIMP(statut='o',typ=maillage_sdaster ),
         MODELE          =SIMP(statut='o',typ=modele_sdaster ),
         TOUT_ORDRE      =SIMP(statut='f',typ='TXM',into=("OUI",) ),
         NUME_ORDRE      =SIMP(statut='f',typ='I',validators=NoRepeat(),max='**'),
         LIST_ORDRE      =SIMP(statut='f',typ=listis_sdaster ),
         INST            =SIMP(statut='f',typ='R',validators=NoRepeat(),max='**'),
         LIST_INST       =SIMP(statut='f',typ=listr8_sdaster ),
         b_prec_crit     =BLOC(condition = "LIST_INST != None or INST != None",
             PRECISION       =SIMP(statut='f',typ='R',defaut= 1.E-3 ),
             CRITERE         =SIMP(statut='f',typ='TXM',defaut="RELATIF",
                                   into=("RELATIF","ABSOLU") ),
         ),
         TITRE           =SIMP(statut='f',typ='TXM',max='**'),
)  ;
#& MODIF COMMANDE  DATE 03/10/2005   AUTEUR NICOLAS O.NICOLAS 
#            CONFIGURATION MANAGEMENT OF EDF VERSION
# ======================================================================
# COPYRIGHT (C) 1991 - 2001  EDF R&D                  WWW.CODE-ASTER.ORG
# THIS PROGRAM IS FREE SOFTWARE; YOU CAN REDISTRIBUTE IT AND/OR MODIFY
# IT UNDER THE TERMS OF THE GNU GENERAL PUBLIC LICENSE AS PUBLISHED BY
# THE FREE SOFTWARE FOUNDATION; EITHER VERSION 2 OF THE LICENSE, OR
# (AT YOUR OPTION) ANY LATER VERSION.
#
# THIS PROGRAM IS DISTRIBUTED IN THE HOPE THAT IT WILL BE USEFUL, BUT
# WITHOUT ANY WARRANTY; WITHOUT EVEN THE IMPLIED WARRANTY OF
# MERCHANTABILITY OR FITNESS FOR A PARTICULAR PURPOSE. SEE THE GNU
# GENERAL PUBLIC LICENSE FOR MORE DETAILS.
#
# YOU SHOULD HAVE RECEIVED A COPY OF THE GNU GENERAL PUBLIC LICENSE
# ALONG WITH THIS PROGRAM; IF NOT, WRITE TO EDF R&D CODE_ASTER,
#    1 AVENUE DU GENERAL DE GAULLE, 92141 CLAMART CEDEX, FRANCE.
# ======================================================================
# RESPONSABLE VABHHTS J.PELLET

def lire_resu_prod(TYPE_RESU,**args):
  if TYPE_RESU == "EVOL_CHAR" :  return evol_char
  if TYPE_RESU == "EVOL_THER" :  return evol_ther
  if TYPE_RESU == "EVOL_ELAS" :  return evol_elas
  if TYPE_RESU == "EVOL_NOLI" :  return evol_noli
  if TYPE_RESU == "DYNA_TRANS" : return dyna_trans
  if TYPE_RESU == "DYNA_HARMO" : return dyna_harmo
  if TYPE_RESU == "HARM_GENE" :  return harm_gene
  if TYPE_RESU == "MODE_MECA" :  return mode_meca
  if TYPE_RESU == "MODE_MECA_C" : return mode_meca_c
  raise AsException("type de concept resultat non prevu")

# pour éviter d'écrire 3 fois cette liste :
def l_nom_cham_pas_elga(): return (
     "ACCE", "ACCE_ABSOLU", "CRIT_ELNO_RUPT", "DCHA_ELNO_SIGM",
     "DCHA_NOEU_SIGM", "DEDE_ELNO_DLDE", "DEDE_NOEU_DLDE", "DEGE_ELNO_DEPL", "DEGE_NOEU_DEPL",
     "DEPL", "DEPL_ABSOLU", "DESI_ELNO_DLSI", "DESI_NOEU_DLSI", "DETE_ELNO_DLTE", "DETE_NOEU_DLTE",
     "DURT_ELNO_META", "DURT_NOEU_META", "ECIN_ELEM_DEPL", "EFGE_ELNO_CART", "EFGE_ELNO_DEPL",
     "EFGE_NOEU_CART", "EFGE_NOEU_DEPL", "ENDO_ELNO_SIGA", "ENDO_ELNO_SINO", "ENDO_NOEU_SINO",
     "ENEL_ELNO_ELGA", "ENEL_NOEU_ELGA", "EPEQ_ELNO_TUYO", "EPGR_ELNO", "EPME_ELNO_DEPL",
     "EPMG_ELNO_DEPL", "EPMG_NOEU_DEPL", "EPOT_ELEM_DEPL", "EPSA_ELNO", "EPSA_NOEU",
     "EPSG_ELNO_DEPL", "EPSG_NOEU_DEPL", "EPSI_ELNO_DEPL", "EPSI_ELNO_TUYO", "EPSI_NOEU_DEPL",
     "EPSP_ELNO", "EPSP_ELNO_ZAC", "EPSP_NOEU", "EPSP_NOEU_ZAC", "EQUI_ELNO_EPME", "EQUI_ELNO_EPSI",
     "EQUI_ELNO_SIGM", "EQUI_NOEU_EPME", "EQUI_NOEU_EPSI", "EQUI_NOEU_SIGM", "ERRE_ELEM_NOZ1",
     "ERRE_ELEM_NOZ2", "ERRE_ELNO_ELGA", "ERRE_NOEU_ELGA", "ERTH_ELEM_TEMP", "ERTH_ELNO_ELEM",
     "ETOT_ELEM", "ETOT_ELNO_ELGA", "FLUX_ELNO_TEMP", "FLUX_NOEU_TEMP", "FORC_NODA", "FSUR_2D",
     "FSUR_3D", "FVOL_2D", "FVOL_3D", "GRAD_NOEU_THETA", "HYDR_ELNO_ELGA", "HYDR_NOEU_ELGA",
     "INTE_ELNO_ACTI", "INTE_ELNO_REAC", "INTE_NOEU_ACTI", "INTE_NOEU_REAC", "IRRA",
     "META_ELNO_TEMP", "META_NOEU_TEMP", "PMPB_ELNO_SIEF", "PMPB_NOEU_SIEF",
     "PRES", "PRES_DBEL_DEPL", "PRES_ELNO_DBEL", "PRES_ELNO_IMAG", "PRES_ELNO_REEL",
     "PRES_NOEU_DBEL", "PRES_NOEU_IMAG", "PRES_NOEU_REEL",
     "RADI_ELNO_SIGM", "RADI_NOEU_SIGM", "REAC_NODA",
     "SIEF_ELNO", "SIEF_ELNO_ELGA", "SIEF_NOEU", "SIEF_NOEU_ELGA", "SIEQ_ELNO_TUYO",
     "SIGM_ELNO_CART", "SIGM_ELNO_COQU", "SIGM_ELNO_DEPL", "SIGM_ELNO_SIEF",
     "SIGM_ELNO_TUYO", "SIGM_ELNO_ZAC", "SIGM_NOEU_CART", "SIGM_NOEU_COQU",
     "SIGM_NOEU_DEPL", "SIGM_NOEU_SIEF", "SIGM_NOEU_ZAC", "SIGM_NOZ1_ELGA",
     "SIGM_NOZ2_ELGA", "SIPO_ELNO_DEPL", "SIPO_ELNO_SIEF", "SIPO_NOEU_DEPL",
     "SIPO_NOEU_SIEF", "SIRE_ELNO_DEPL", "SIRE_NOEU_DEPL", "TEMP", "THETA",
     "VALE_CONT", "VALE_NCOU_MAXI", "VARI_ELNO", "VARI_ELNO_COQU",
     "VARI_ELNO_ELGA", "VARI_ELNO_TUYO", "VARI_NOEU", "VARI_NOEU_ELGA", "VARI_NON_LOCAL",
     "VITE", "VITE_ABSOLU", "VITE_VENT",
                           )

LIRE_RESU=OPER(nom="LIRE_RESU",op=150,sd_prod=lire_resu_prod,reentrant='n',
            UIinfo={"groupes":("Résultats et champs",)},
               fr="Lire dans un fichier, soit format IDEAS, soit au format ENSIGHT soit au format MED,"
                 +" des champs et les stocker dans une SD résultat",


# 0) mots clés généraux :
#----------------------
         TYPE_RESU       =SIMP(statut='o',typ='TXM',into=("EVOL_THER","EVOL_ELAS","EVOL_NOLI","MODE_MECA",
                                                          "MODE_MECA_C","DYNA_TRANS","DYNA_HARMO","HARM_GENE",
                                                          "EVOL_CHAR") ),

         FORMAT          =SIMP(statut='o',typ='TXM',into=("IDEAS","IDEAS_DS58","ENSIGHT","MED") ),

         INFO            =SIMP(statut='f',typ='I',into=(1,2) ),
         TITRE           =SIMP(statut='f',typ='TXM',max='**'),

         regles=(UN_PARMI('MAILLAGE','MODELE'),),
         MAILLAGE        =SIMP(statut='f',typ=maillage_sdaster),
         MODELE          =SIMP(statut='f',typ=modele_sdaster),

         NB_VARI         =SIMP(statut='f',typ='I' ),


# 1) blocs selon le format choisi :
#---------------------------------

# 1-1 ideas dataset-58 :
# ----------------------
         b_dataset_58 = BLOC(condition="FORMAT=='IDEAS_DS58'",
           UNITE           =SIMP(statut='f',typ='I',defaut= 19 ),
         ),
         b_dataset_58_b = BLOC(condition="(FORMAT=='IDEAS_DS58') and ((TYPE_RESU=='DYNA_TRANS') or\
                                        (TYPE_RESU=='DYNA_HARMO') or (TYPE_RESU=='HARM_GENE'))",
           UNITE           =SIMP(statut='f',typ='I',defaut= 19 ),
           NOM_CHAM=SIMP(statut='o',typ='TXM',into=("DEPL","VITE","ACCE","EPSI_NOEU_DEPL","SIEF_NOEU",) ),
           REDEFI_ORIENT=FACT(statut='f',max='**',
                              regles=(PRESENT_PRESENT('CODE_DIR','DIRECTION','NOEUD',),),
                              CODE_DIR =SIMP(statut='f',typ='I',into=(1,2,3,) ),
                              DIRECTION=SIMP(statut='f',typ='R',min=3,max=3,),
                              NOEUD    =SIMP(statut='f',typ=no,validators=NoRepeat(),max='**'),),
         ),

# 1-2 ideas  :
# ---------
         b_ideas         =BLOC(condition="FORMAT=='IDEAS'",
           UNITE           =SIMP(statut='f',typ='I',defaut= 19 ),
#           TEST            =SIMP(statut='f',typ='TXM',into=("OUI","NON"),defaut="NON" ),
           NOM_CHAM        =SIMP(statut='o',typ='TXM',validators=NoRepeat(),max='**',into=l_nom_cham_pas_elga()),
           FORMAT_IDEAS    =FACT(statut='f',max='**',
             regles=(UN_PARMI('POSI_INST','POSI_FREQ'),),
             NOM_CHAM        =SIMP(statut='o',typ='TXM',into=l_nom_cham_pas_elga()),
             NUME_DATASET    =SIMP(statut='f',typ='I',into=(55,57,2414) ),
             RECORD_3        =SIMP(statut='f',typ='I',max=10),
             RECORD_6        =SIMP(statut='f',typ='I',max=10),
             RECORD_9        =SIMP(statut='f',typ='I',max=10),
             POSI_ORDRE      =SIMP(statut='o',typ='I',min=2,max=2),
             POSI_NUME_MODE  =SIMP(statut='f',typ='I',min=2,max=2),
             POSI_MASS_GENE  =SIMP(statut='f',typ='I',min=2,max=2),
             POSI_AMOR_GENE  =SIMP(statut='f',typ='I',min=2,max=2),
             POSI_INST       =SIMP(statut='f',typ='I',min=2,max=2),
             POSI_FREQ       =SIMP(statut='f',typ='I',min=2,max=2),
             NOM_CMP         =SIMP(statut='o',typ='TXM',max='**'),),
         ),
# 1-3 ensight :
# -------------
         b_ensight       =BLOC(condition="FORMAT=='ENSIGHT'",
           NOM_FICHIER     =SIMP(statut='f',typ='TXM'),
           NOM_CHAM        =SIMP(statut='o',typ='TXM',validators=NoRepeat(),max='**',into=l_nom_cham_pas_elga()),
         ),

# 1-4 med :
# ---------
         b_med           =BLOC(condition = "FORMAT == 'MED'",fr="Nom du champ dans le fichier MED",
           UNITE           =SIMP(statut='f',typ='I',defaut= 81, fr="Le fichier est : fort.n.",),
           FORMAT_MED      =FACT(statut='f',max='**',
             regles=(ENSEMBLE('NOM_CMP','NOM_CMP_MED'),),
             NOM_CHAM        =SIMP(statut='o',typ='TXM',into=l_nom_cham_pas_elga()),
             NOM_CHAM_MED    =SIMP(statut='o',typ='TXM',               fr="Nom du champ dans le fichier MED.",  ),
             NOM_CMP         =SIMP(statut='f',typ='TXM',max='**',      fr="Nom des composantes dans ASTER.", ),
             NOM_CMP_MED     =SIMP(statut='f',typ='TXM',max='**',      fr="Nom des composantes dans MED.", ),
           ),
                  ),

# 2) blocs selon le type du résultat :
#---------------------------------
         b_mode_meca     =BLOC(condition="(TYPE_RESU=='MODE_MECA')or(TYPE_RESU=='MODE_MECA_C')",
           MATR_A         =SIMP(statut='f',typ=matr_asse_depl_r,),
           MATR_B         =SIMP(statut='f',typ=matr_asse_depl_r,),
         ),


# 3) autres blocs :
#---------------------------------
         b_extrac        =BLOC(condition="1",fr="accès à un champ dans la structure de données résultat",
           regles=(UN_PARMI('TOUT_ORDRE','NUME_ORDRE','LIST_ORDRE','INST','LIST_INST','FREQ','LIST_FREQ'),),
           TOUT_ORDRE      =SIMP(statut='f',typ='TXM',into=("OUI",) ),
           NUME_ORDRE      =SIMP(statut='f',typ='I',validators=NoRepeat(),max='**'),
           INST            =SIMP(statut='f',typ='R',validators=NoRepeat(),max='**'),
           LIST_INST       =SIMP(statut='f',typ=listr8_sdaster),
           LIST_ORDRE      =SIMP(statut='f',typ=listis_sdaster),
           FREQ            =SIMP(statut='f',typ='R',validators=NoRepeat(),max='**'),
           LIST_FREQ       =SIMP(statut='f',typ=listr8_sdaster),

           b_acce_reel     =BLOC(condition="(INST != None)or(LIST_INST != None)or(FREQ != None)or(LIST_FREQ != None)",
             PRECISION       =SIMP(statut='f',typ='R',defaut=1.0E-3),
             CRITERE         =SIMP(statut='f',typ='TXM',defaut="RELATIF",into=("RELATIF","ABSOLU") ),
           ),
         ),
)  ;
#& MODIF COMMANDE  DATE 03/04/2006   AUTEUR MCOURTOI M.COURTOIS 
#            CONFIGURATION MANAGEMENT OF EDF VERSION
# ======================================================================
# COPYRIGHT (C) 1991 - 2002  EDF R&D                  WWW.CODE-ASTER.ORG
# THIS PROGRAM IS FREE SOFTWARE; YOU CAN REDISTRIBUTE IT AND/OR MODIFY  
# IT UNDER THE TERMS OF THE GNU GENERAL PUBLIC LICENSE AS PUBLISHED BY  
# THE FREE SOFTWARE FOUNDATION; EITHER VERSION 2 OF THE LICENSE, OR     
# (AT YOUR OPTION) ANY LATER VERSION.                                                  
#                                                                       
# THIS PROGRAM IS DISTRIBUTED IN THE HOPE THAT IT WILL BE USEFUL, BUT   
# WITHOUT ANY WARRANTY; WITHOUT EVEN THE IMPLIED WARRANTY OF            
# MERCHANTABILITY OR FITNESS FOR A PARTICULAR PURPOSE. SEE THE GNU      
# GENERAL PUBLIC LICENSE FOR MORE DETAILS.                              
#                                                                       
# YOU SHOULD HAVE RECEIVED A COPY OF THE GNU GENERAL PUBLIC LICENSE     
# ALONG WITH THIS PROGRAM; IF NOT, WRITE TO EDF R&D CODE_ASTER,         
#    1 AVENUE DU GENERAL DE GAULLE, 92141 CLAMART CEDEX, FRANCE.        
# ======================================================================

from Macro.lire_table_ops import lire_table_ops

LIRE_TABLE=MACRO(nom="LIRE_TABLE",op=lire_table_ops,sd_prod=table_sdaster,
                 fr="Lecture d'un fichier contenant une table",
            UIinfo={"groupes":("Table",)},
         UNITE           =SIMP(statut='o',typ='I' ),
         FORMAT          =SIMP(statut='f',typ='TXM',into=("ASTER",),defaut="ASTER"),
         NUME_TABLE      =SIMP(statut='f',typ='I',defaut=1),
         SEPARATEUR      =SIMP(statut='f',typ='TXM',defaut=' '),
         PARA            =SIMP(statut='f',typ='TXM',max='**'),
         TITRE           =SIMP(statut='f',typ='TXM',max='**'),
         )  ;

#& MODIF COMMANDE  DATE 13/02/2006   AUTEUR DURAND C.DURAND 
#            CONFIGURATION MANAGEMENT OF EDF VERSION
# ======================================================================
# COPYRIGHT (C) 1991 - 2005  EDF R&D                  WWW.CODE-ASTER.ORG
# THIS PROGRAM IS FREE SOFTWARE; YOU CAN REDISTRIBUTE IT AND/OR MODIFY  
# IT UNDER THE TERMS OF THE GNU GENERAL PUBLIC LICENSE AS PUBLISHED BY  
# THE FREE SOFTWARE FOUNDATION; EITHER VERSION 2 OF THE LICENSE, OR     
# (AT YOUR OPTION) ANY LATER VERSION.                                                  
#                                                                       
# THIS PROGRAM IS DISTRIBUTED IN THE HOPE THAT IT WILL BE USEFUL, BUT   
# WITHOUT ANY WARRANTY; WITHOUT EVEN THE IMPLIED WARRANTY OF            
# MERCHANTABILITY OR FITNESS FOR A PARTICULAR PURPOSE. SEE THE GNU      
# GENERAL PUBLIC LICENSE FOR MORE DETAILS.                              
#                                                                       
# YOU SHOULD HAVE RECEIVED A COPY OF THE GNU GENERAL PUBLIC LICENSE     
# ALONG WITH THIS PROGRAM; IF NOT, WRITE TO EDF R&D CODE_ASTER,         
#    1 AVENUE DU GENERAL DE GAULLE, 92141 CLAMART CEDEX, FRANCE.        
# ======================================================================
# ======================================================================

MAC_MODES=OPER(nom="MAC_MODES",op=  141,sd_prod=table_sdaster,
               fr="Normalisation de modes propres",
               reentrant='n',
            UIinfo={"groupes":("Résolution",)},
         BASE_1       =SIMP(statut='o',typ=(mode_meca,mode_flamb,base_modale) ),
         BASE_2       =SIMP(statut='o',typ=(mode_meca,mode_flamb,base_modale) ),
         MATR_ASSE       =SIMP(statut='f',typ=(matr_asse_depl_r,matr_asse_depl_c) ),
         TITRE      =SIMP(statut='f',typ='TXM',max='**'),
         INFO       =SIMP(statut='f',typ='I',defaut= 1,into=( 1 , 2) ),
)  ;
#& MODIF COMMANDE  DATE 30/10/2006   AUTEUR DURAND C.DURAND 
#            CONFIGURATION MANAGEMENT OF EDF VERSION
# ======================================================================
# COPYRIGHT (C) 1991 - 2001  EDF R&D                  WWW.CODE-ASTER.ORG
# THIS PROGRAM IS FREE SOFTWARE; YOU CAN REDISTRIBUTE IT AND/OR MODIFY
# IT UNDER THE TERMS OF THE GNU GENERAL PUBLIC LICENSE AS PUBLISHED BY
# THE FREE SOFTWARE FOUNDATION; EITHER VERSION 2 OF THE LICENSE, OR   
# (AT YOUR OPTION) ANY LATER VERSION.                                 
#
# THIS PROGRAM IS DISTRIBUTED IN THE HOPE THAT IT WILL BE USEFUL, BUT 
# WITHOUT ANY WARRANTY; WITHOUT EVEN THE IMPLIED WARRANTY OF          
# MERCHANTABILITY OR FITNESS FOR A PARTICULAR PURPOSE. SEE THE GNU    
# GENERAL PUBLIC LICENSE FOR MORE DETAILS.                            
#
# YOU SHOULD HAVE RECEIVED A COPY OF THE GNU GENERAL PUBLIC LICENSE   
# ALONG WITH THIS PROGRAM; IF NOT, WRITE TO EDF R&D CODE_ASTER,       
#    1 AVENUE DU GENERAL DE GAULLE, 92141 CLAMART CEDEX, FRANCE.      
# ======================================================================
# RESPONSABLE GNICOLAS G.NICOLAS


from Macro.macr_adap_mail_ops import macr_adap_mail_ops

def macr_adap_mail_prod(self,MAJ_CHAM,ADAPTATION,**args):
#
# 0. Typage des structures produites
#
  maillage_np1=args['MAILLAGE_NP1']
  self.type_sdprod(maillage_np1,maillage_sdaster)
#
  if ( args['MAILLAGE_NP1_ANNEXE'] is not None ) :
    maillage_np1_annexe=args['MAILLAGE_NP1_ANNEXE']
    self.type_sdprod(maillage_np1_annexe,maillage_sdaster)
#
  if MAJ_CHAM == None:return None
# Remarque : la liste qui suit doit etre conforme à son homologue de LIRE_CHAMP
  for ch in MAJ_CHAM:
    t=ch['TYPE_CHAM']
    if t[0:5] == "NOEU_":self.type_sdprod(ch['CHAM_MAJ'],cham_no_sdaster)
    if t[0:2] == "EL":   self.type_sdprod(ch['CHAM_MAJ'],cham_elem)
  return None


MACR_ADAP_MAIL=MACRO(nom="MACR_ADAP_MAIL",op=macr_adap_mail_ops,sd_prod=macr_adap_mail_prod,
                     fr="Adapter un maillage avec le logiciel HOMARD.",
                     ang="Mesh adaptation with HOMARD software.",
                     docu="U7.03.01-b",UIinfo={"groupe":("Maillage",)},
#
# 1. Le niveau d'information
#
  INFO = SIMP(statut='f',typ='I',defaut=1,into=(1,2)),
#
# 2. Version de HOMARD
#
  VERSION_HOMARD = SIMP(statut='f',typ='TXM',defaut="V8_5",
                        into=("V8_5", "V8_N", "V8_N_PERSO"),
                        fr="Version de HOMARD",
                        ang="HOMARD release"),
#
# 3. Langue des messages produits par HOMARD
#
  LANGUE = SIMP(statut='f',typ='TXM',defaut="FRANCAIS",    
                into=("FRANCAIS","FRENCH","ANGLAIS","ENGLISH",),
                fr="Langue des messages produits par HOMARD.",
                ang="Language for HOMARD messages." ),
#
# 4. Les maillages
# 4.1. Quel que soit le type de traitement, il faut donner  :
#      A. Le concept du maillage initial (entree)
#      B. Le concept du maillage final (sortie)
#
  MAILLAGE_N   = SIMP(statut='o',typ=maillage_sdaster,
                      fr="Maillage avant adaptation",
                      ang="Mesh before adaptation" ),
#
  MAILLAGE_NP1 = SIMP(statut='o',typ=CO,
                      fr="Maillage apres adaptation",
                      ang="Mesh after adaptation" ),
#
# 4.2. Eventuellement, on peut produire un maillage annexe
#      Actuellement, c'est le maillage n+1, mais de degré différent.
#
  MAILLAGE_NP1_ANNEXE = SIMP(statut='f',typ=CO,
                             fr="Maillage annexe apres adaptation",
                             ang="Additional mesh after adaptation" ),
#
# 5. Le pilotage de l'adaptation, avec les variantes suivantes :
#  . Raffinement et deraffinement, selon un champ d'indicateurs d'erreur
#  . Raffinement seul, selon un champ d'indicateurs d'erreur
#  . Deraffinement seul, selon un champ d'indicateurs d'erreur
#  . Raffinement seul, selon des zones geometriques
#  . Raffinement uniforme : toutes les mailles sont divisées
#  . Deraffinement uniforme : toutes les mailles sont regroupées
#  . Rien : le maillage est le meme a la sortie et a l'entree
#
  ADAPTATION = SIMP(statut='o',typ='TXM',
                    into=("RAFF_DERA","RAFFINEMENT","DERAFFINEMENT","RAFFINEMENT_ZONE", \
                          "RAFFINEMENT_UNIFORME","DERAFFINEMENT_UNIFORME","RIEN"),    
                    fr="Pilotage de l'adaptation : selon un indicateur d'erreur ou uniforme.",
                    ang="Adaptation control : among an error indicator or uniform" ),
#
# 6. Pour de l'adaptation libre, il faut un indicateur d'erreur
#
  b_indicateur_d_erreur = BLOC( condition = " (ADAPTATION == 'RAFF_DERA') or \
                                              (ADAPTATION == 'RAFFINEMENT') or \
                                              (ADAPTATION == 'DERAFFINEMENT') " ,
                                fr="Pour une adaptation libre, choix de l'indicateur d'erreur ou d'une zone à raffiner",
                                ang="For free adaptation, selection of error indicator or zone",
#
    regles=(UN_PARMI('CHAM_GD','RESULTAT_N')),
#
# 6.1. Repérage de la zone à raffiner à l'aide d'un indicateur
#
# 6.1.1. Sous forme de champ de grandeur
#
    CHAM_GD    = SIMP(statut='f',typ=cham_gd_sdaster,
                      fr="Champ de grandeur Code_Aster contenant l'indicateur d'erreur",
                      ang="Code_Aster champ de grandeur with error indicator" ),
#
# 6.1.2. Sous forme de concept resultat_sdaster
#
    RESULTAT_N = SIMP(statut='f',typ=(evol_elas,evol_noli,evol_ther) ,
                      fr="Concept resultat Code_Aster contenant l'indicateur d'erreur",
                      ang="Code_Aster result with error indicator" ),
#
    b_champ_indicateur = BLOC(condition="(RESULTAT_N != None)",
      INDICATEUR = SIMP(statut='o',typ='TXM',     
                        fr="Champ de l'indicateur d'erreur dans le résultat",
                        ang="Error indicator field in the result structure" ),
    ),
#
# 6.1.3. Est-ce un champ dérivé
#
    b_sensibilite = BLOC(condition=" (RESULTAT_N != None) or (CHAM_GD != None) ",
                        fr="Est-ce un champ dérivé",
                        ang="Is the indicator a derivative field",
#
      SENSIBILITE = SIMP(statut='f',typ=(para_sensi,theta_geom),
                         fr="Paramètre de sensibilité.",
                         ang="Sensitivity parameter")
#
    ),
#
# 6.1.4. La composante retenue
#
    b_composante = BLOC(condition=" (RESULTAT_N != None) or (CHAM_GD != None) ",
                        fr="Choix de la composante pour l'indicateur",
                        ang="Component selection for error indicator",
#
      NOM_CMP_INDICA = SIMP(statut='o',typ='TXM',
                            fr="Composante retenue pour l'indicateur d'erreur",
                            ang="Selected component for error indicator" ),
#
    ),
#
# 6.1.5. Le paramètre temporel pour l'indicateur
#
    b_parametre_temporel = BLOC(condition="(RESULTAT_N != None)",
                                fr="Choix éventuel du paramètre temporel pour l'indicateur",
                                ang="Time selection for error indicator (option)",
#
      regles=(EXCLUS('NUME_ORDRE','INST'),),
#
# 6.1.5.1. Soit le numero d'ordre
#
      NUME_ORDRE = SIMP(statut='f',typ='I',
                        fr="Numero d ordre",
                        ang="Rank" ),  
#
# 6.1.5.2. Soit l'instant
# 6.1.5.2.1. Sa valeur
#
      INST       = SIMP(statut='f',typ='R',
                        fr="Instant associé",
                        ang="Instant" ),
#
# 6.1.5.2.2. La précision du choix de l'instant
#
      b_precision = BLOC(condition="(INST != None)",
                         fr="Choix de la précision du choix de l'instant",
                         ang="Selection for instant choice",
        PRECISION = SIMP(statut='f',typ='R',defaut=1.0E-3,
                         fr="Précision sur le choix de l'instant associé",
                         ang="Accuracy over instant choice" ),
        CRITERE   = SIMP(statut='f',typ='TXM',defaut="RELATIF",into=("RELATIF","ABSOLU"),
                         fr="Critère de précision sur le choix de l'instant associé",
                         ang="Accuracy criterium over instant choice" ),
      ),
#
    ),
#
# 6.1.6. Type de valeur de l'indicateur : absolue ou relative
#
    b_valeur_indicateur = BLOC(condition=" (RESULTAT_N != None) or (CHAM_GD != None) ",
                               fr="Type de valeur pour l'indicateur",
                               ang="Value type for error indicator",
#
      TYPE_VALEUR_INDICA = SIMP(statut='f',typ='TXM',defaut="V_ABSOLUE",into=("V_ABSOLUE","V_RELATIVE"),
                                fr="Valeur absolue ou relative pour l'indicateur",
                                ang="Absolute or relative value for error indicator" ),
#
    ),
#
  ) ,
#
# 7. Les criteres pour de l'adaptation libre avec un indicateur d'erreur :
#        absolu, relatif, en proportion d'entite
# 7.1. Pour le raffinement :
#
  b_critere_de_raffinement = BLOC( condition = " (ADAPTATION == 'RAFF_DERA') or \
                                                 (ADAPTATION == 'RAFFINEMENT') " ,
                                fr="Critère de raffinement.",
                                ang="Refinement threshold.",
#
    regles=(UN_PARMI ( 'CRIT_RAFF_ABS', 'CRIT_RAFF_REL', 'CRIT_RAFF_PE' ),),
#
    CRIT_RAFF_ABS = SIMP(statut='f',typ='R',
                         fr="Critère absolu",
                         ang="Absolute threshold" ),  
    CRIT_RAFF_REL = SIMP(statut='f',typ='R',
                         fr="Critère relatif : fraction réelle entre 0. et 1.",
                         ang="Relative threshold : ratio between 0. and 1." ),  
    CRIT_RAFF_PE  = SIMP(statut='f',typ='R',
                         fr="Pourcentage d'éléments : fraction réelle entre 0. et 1.",
                         ang="Percentage of elements : ratio between 0. and 1." ),  
  ) ,
#
# 7.2. Pour le deraffinement :
#
  b_critere_de_deraffinement = BLOC( condition = " (ADAPTATION == 'RAFF_DERA') or \
                                                   (ADAPTATION == 'DERAFFINEMENT') " ,
                                     fr="Critère de déraffinement.",
                                     ang="Unrefinement threshold.",
#
    regles=(UN_PARMI ( 'CRIT_DERA_ABS', 'CRIT_DERA_REL', 'CRIT_DERA_PE' ),),
#
    CRIT_DERA_ABS = SIMP(statut='f',typ='R' ,
                         fr="Critère absolu",
                         ang="Absolute threshold" ),  
    CRIT_DERA_REL = SIMP(statut='f',typ='R',
                         fr="Critère relatif : fraction réelle entre 0. et 1.",
                         ang="Relative threshold : ratio between 0. and 1." ),  
    CRIT_DERA_PE  = SIMP(statut='f',typ='R',
                         fr="Pourcentage d'éléments : fraction réelle entre 0. et 1.",
                         ang="Percentage of elements : ratio between 0. and 1." ),  
  ) ,
#
# 8. Pour de l'adaptation par zone, définitions des zones
#
  b_zone = BLOC( condition = " (ADAPTATION == 'RAFFINEMENT_ZONE') " ,
                                fr="Pour une adaptation selon une zone à raffiner",
                                ang="For adaptation among zone",
    ZONE = FACT(statut='f',max='**',
                  fr="Définition de zones à raffiner.",
                  ang="Refined zone definition.",
#
      regles=(AU_MOINS_UN('X_MINI','X_CENTRE'),
              EXCLUS('X_MINI','X_CENTRE',),
              EXCLUS('Z_MINI','X_CENTRE',),
              EXCLUS('X_MINI','Z_CENTRE',),
              EXCLUS('Z_MINI','Z_CENTRE',),
              PRESENT_PRESENT('X_MINI','X_MAXI','Y_MINI','Y_MAXI'),
              PRESENT_PRESENT('Z_MINI','Z_MAXI'),
              PRESENT_PRESENT('X_CENTRE','Y_CENTRE','RAYON'),),
#
# 6.2.1. Une boite parallelepipedique
#
      X_MINI = SIMP(statut='f',typ='R',
                    fr="Abscisse minimum de la boite",
                    ang="Minimum X for the box"),
      X_MAXI = SIMP(statut='f',typ='R',
                    fr="Abscisse maximum de la boite",
                    ang="Maximum X for the box"),
#
      Y_MINI = SIMP(statut='f',typ='R',
                    fr="Orodnnée minimum de la boite",
                    ang="Minimum Y for the box"),
      Y_MAXI = SIMP(statut='f',typ='R',
                    fr="Abscisse maximum de la boite",
                    ang="Maximum Y for the box"),
#
      Z_MINI = SIMP(statut='f',typ='R',
                    fr="Cote minimum de la boite",
                    ang="Minimum Z for the box"),
      Z_MAXI = SIMP(statut='f',typ='R',
                    fr="Cote maximum de la boite",
                    ang="Maximum Z for the box"),
#
# 6.2.2. Une sphere
#
      X_CENTRE = SIMP(statut='f',typ='R',
                      fr="Abscisse du centre de la sphere",
                      ang="X for the center of the sphere"),
      Y_CENTRE = SIMP(statut='f',typ='R',
                      fr="Ordonnee du centre de la sphere",
                      ang="Y for the center of the sphere"),
      Z_CENTRE = SIMP(statut='f',typ='R',
                      fr="Cote du centre de la sphere",
                      ang="Z for the center of the sphere"),
      RAYON = SIMP(statut='f',typ='R',
                   fr="Rayon de la sphere",
                   ang="Radius of the sphere"),
#
    ) ,
#
  ) ,
#
# 9. Les niveaux extremes pour le maillage adapte
# 9.1. Pour le raffinement :
#
  b_niveau_maximum = BLOC( condition = " (ADAPTATION == 'RAFF_DERA') or \
                                         (ADAPTATION == 'RAFFINEMENT') or \
                                         (ADAPTATION == 'RAFFINEMENT_UNIFORME') or \
                                         (ADAPTATION == 'RAFFINEMENT_ZONE') " ,
                           fr="Niveau maximum de profondeur de raffinement",
                           ang="Maximum level for refinement",
    NIVE_MAX = SIMP(statut='f',typ='I',
                    fr="Niveau maximum de profondeur de raffinement",
                    ang="Maximum level for refinement"),
  ) ,
#
# 9.2. Pour le deraffinement :
#
  b_niveau_minimum = BLOC( condition = " (ADAPTATION == 'RAFF_DERA') or \
                                         (ADAPTATION == 'DERAFFINEMENT') or \
                                         (ADAPTATION == 'DERAFFINEMENT_UNIFORME') " ,
                           fr="Niveau minimum de profondeur de déraffinement",
                           ang="Minimum level for unrefinement",
    NIVE_MIN = SIMP(statut='f',typ='I',
                    fr="Niveau minimum de profondeur de déraffinement",
                    ang="Minimum level for unrefinement"),
  ) ,
#
# 10. Suivi d'une frontiere
#
  MAILLAGE_FRONTIERE = SIMP(statut='f',typ=maillage_sdaster,
                           fr="Maillage de la frontiere à suivre",
                           ang="Boundary mesh" ),
#
  b_frontiere = BLOC( condition = " MAILLAGE_FRONTIERE != None " ,
                      fr="Information complémentaire sur la frontière",
                      ang="Further information about boundary",
#
    GROUP_MA = SIMP(statut='f',typ=grma,validators=NoRepeat(),max='**',
                    fr="Liste des groupes de mailles définissant la frontière",
                    ang="Mesh groups which define the boundary" ),
#
  ) ,
#
# 11. Mise à jour de champs sur le nouveau maillage
#
  MAJ_CHAM = FACT(statut='f',max='**',
                  fr="Mise à jour de champs sur le nouveau maillage.",
                  ang="Updating of fields over the new mesh.",
#
# 11.1. Le nom du champ de grandeur qui contiendra le resultat de la mise a jour
#
    CHAM_MAJ = SIMP(statut='o',typ=CO,
                    fr="Nom du champ de grandeur qui contiendra le champ mis à jour",
                    ang="Name of the field for the updated field"),
#
# 11.2. Le type du champ qui contiendra le resultat de la mise a jour
#
    TYPE_CHAM = SIMP(statut='o',typ='TXM',into=C_TYPE_CHAM_INTO(),
                     fr="Type du champ qui contiendra le champ mis à jour",
                     ang="Type of the field for the updated field" ),
#
# 11.3. Le champ a interpoler
#
    regles=(UN_PARMI('CHAM_GD','RESULTAT')),
#
# 11.3.1. Sous forme de champ de grandeur
#
    CHAM_GD = SIMP(statut='f',typ=cham_gd_sdaster,
                   fr="Champ de grandeur Code_Aster contenant le champ à mettre à jour",
                   ang="Champ de grandeur with field to be updated" ),
#
# 11.3.2. Sous forme de champ dans un resultat
#
    RESULTAT = SIMP(statut='f',typ=(evol_elas,evol_noli,evol_ther),
                    fr="Resultat contenant le champ à mettre à jour",
                    ang="Result with field to be updated" ),
#
    b_nom_du_champ = BLOC(condition="(RESULTAT != None)",
                          fr="Choix éventuel du nom du champ à interpoler",
                          ang="Selection for the name of the field (option)",
#
      NOM_CHAM = SIMP(statut='o',typ='TXM',
                      fr="Nom du champ à mettre à jour",
                      ang="Name of the field to be updated" ),
#
    ),
#
# 11.4. Est-ce un champ dérivé
#
    SENSIBILITE = SIMP(statut='f',typ=(para_sensi,theta_geom),
                       fr="Paramètre de sensibilité.",
                       ang="Sensitivity parameter"),
#
# 11.5. Le paramètre temporel pour le champ a interpoler
#
    b_parametre_temporel = BLOC(condition="(RESULTAT != None)",
                                fr="Choix éventuel du paramètre temporel pour le champ à interpoler",
                                ang="Time selection for the field (option)",
#
      regles=(EXCLUS('NUME_ORDRE','INST'),),
#
# 11.5.1. Soit le numero d'ordre
#
      NUME_ORDRE = SIMP(statut='f',typ='I',
                        fr="Numero d ordre du champ à mettre à jour",
                        ang="Rank of the field to be updated" ),
#
# 11.5.2. Soit l'instant
# 11.5.2.1. Sa valeur
#
      INST = SIMP(statut='f',typ='R',
                  fr="Instant associé",
                  ang="Instant" ),
#
# 11.5.2.2. La précision du choix de l'instant
#
      b_precision = BLOC(condition="(INST != None)",
                         fr="Choix de la précision du choix de l'instant",
                         ang="Selection for instant choice",
#
        PRECISION = SIMP(statut='f',typ='R',defaut=1.0E-3,
                         fr="Précision sur le choix de l'instant associé",
                         ang="Accuracy over instant choice" ),
#
        CRITERE = SIMP(statut='f',typ='TXM',defaut="RELATIF",into=("RELATIF","ABSOLU"),
                       fr="Critère de précision sur le choix de l'instant associé",
                       ang="Accuracy criterium over instant choice" ),
#
      ),
#
    ),
  ),
#
# 12. Les options d'analyse de maillage ; par defaut, on ne fait que les nombres
# 12.1. Nombre de noeuds et éléments
#
  NOMBRE         = SIMP(statut='f',typ='TXM',defaut="OUI",into=("OUI","NON"),
                          fr="Nombre de noeuds et éléments du maillage",
                          ang="Number of nodes and éléments in the mesh" ),
#
# 12.2. Determination de la qualité des éléments du maillage
#
  QUALITE        = SIMP(statut='f',typ='TXM',defaut="NON",into=("OUI","NON"),
                          fr="Qualité du maillage",
                          ang="Mesh quality" ),
#
# 12.3. Connexite du maillage
#
  CONNEXITE      = SIMP(statut='f',typ='TXM',defaut="NON",into=("OUI","NON"),
                          fr="Connexité du maillage.",
                          ang="Mesh connexity." ),
#
# 12.4. Taille des sous-domaines du maillage
#
  TAILLE         = SIMP(statut='f',typ='TXM',defaut="NON",into=("OUI","NON"),
                          fr="Tailles des sous-domaines du maillage.",
                          ang="Sizes of mesh sub-domains." ),
#
# 12.5. Controle de la non-interpenetration des éléments
#
  INTERPENETRATION= SIMP(statut='f',typ='TXM',defaut="NON",into=("OUI","NON"),
                          fr="Controle de la non interpénétration des éléments.",
                          ang="Overlapping checking." ),
#
# 13. Gestion des éléments autres que ceux compatibles avec HOMARD
#       "REFUSER" : ils sont refuses (defaut)
#       "IGNORER" : ils sont ignorés
#
  ELEMENTS_NON_HOMARD = SIMP(statut='f',typ='TXM',defaut="REFUSER",into=("REFUSER","IGNORER"),
                             fr="Acceptation d'éléments incompatibles avec HOMARD",
                             ang="Incompatible elements for HOMARD" ),
#
) ;
#& MODIF COMMANDE  DATE 25/09/2006   AUTEUR MJBHHPE J.L.FLEJOU 
#            CONFIGURATION MANAGEMENT OF EDF VERSION
# ======================================================================
# COPYRIGHT (C) 1991 - 2001  EDF R&D                  WWW.CODE-ASTER.ORG
# THIS PROGRAM IS FREE SOFTWARE; YOU CAN REDISTRIBUTE IT AND/OR MODIFY
# IT UNDER THE TERMS OF THE GNU GENERAL PUBLIC LICENSE AS PUBLISHED BY
# THE FREE SOFTWARE FOUNDATION; EITHER VERSION 2 OF THE LICENSE, OR   
# (AT YOUR OPTION) ANY LATER VERSION.                                 
#
# THIS PROGRAM IS DISTRIBUTED IN THE HOPE THAT IT WILL BE USEFUL, BUT 
# WITHOUT ANY WARRANTY; WITHOUT EVEN THE IMPLIED WARRANTY OF          
# MERCHANTABILITY OR FITNESS FOR A PARTICULAR PURPOSE. SEE THE GNU    
# GENERAL PUBLIC LICENSE FOR MORE DETAILS.                            
#
# YOU SHOULD HAVE RECEIVED A COPY OF THE GNU GENERAL PUBLIC LICENSE   
# ALONG WITH THIS PROGRAM; IF NOT, WRITE TO EDF R&D CODE_ASTER,       
#    1 AVENUE DU GENERAL DE GAULLE, 92141 CLAMART CEDEX, FRANCE.      
# ======================================================================
# RESPONSABLE F1BHHAJ J.ANGLES
from Macro.macr_ascouf_calc_ops import macr_ascouf_calc_ops
def macr_ascouf_calc_prod(self,MODELE,CHAM_MATER,CARA_ELEM,FOND_FISS,CHARGE,RESU_THER,**args):
  self.type_sdprod(MODELE,modele_sdaster)
  if CHAM_MATER != None:self.type_sdprod(CHAM_MATER,cham_mater)
  if CARA_ELEM  != None:self.type_sdprod(CARA_ELEM,cara_elem)
  if FOND_FISS  != None:self.type_sdprod(FOND_FISS,fond_fiss)
  if CHARGE     != None:self.type_sdprod(CHARGE,char_meca)
  if RESU_THER  != None:self.type_sdprod(RESU_THER,evol_ther)
  return evol_noli

MACR_ASCOUF_CALC=MACRO(nom="MACR_ASCOUF_CALC",op=macr_ascouf_calc_ops,sd_prod=macr_ascouf_calc_prod,
                      fr="Réalise l'analyse thermomécanique du coude dont le maillage a été concu par MACR_ASCOUF_MAIL",
                      reentrant='n',
            UIinfo={"groupes":("Outils métier",)},
         regles=(UN_PARMI('COMP_INCR','COMP_ELAS'),),

         TYPE_MAILLAGE   =SIMP(statut='o',typ='TXM',
                               into=("SAIN",
                                     "FISS_COUDE",
                                     "FISS_AXIS_DEB",
                                     "SOUS_EPAIS_COUDE"
                                     ) ),

         CL_BOL_P2_GV    =FACT(statut='f',
           ANGLE           =SIMP(statut='o',typ='R' ),
           AZIMUT          =SIMP(statut='f',typ='R',defaut= 90. ),
         ),

         MAILLAGE        =SIMP(statut='o',typ=maillage_sdaster ),
         MODELE          =SIMP(statut='o',typ=CO,),
         CHAM_MATER      =SIMP(statut='f',typ=CO,),
         CARA_ELEM       =SIMP(statut='f',typ=CO,),
         FOND_FISS       =SIMP(statut='f',typ=CO,),
         CHARGE          =SIMP(statut='f',typ=CO,),
         RESU_THER       =SIMP(statut='f',typ=CO,),

         AFFE_MATERIAU   =FACT(statut='o',max=3,
           regles=(UN_PARMI('TOUT','GROUP_MA'),),
           TOUT            =SIMP(statut='f',typ='TXM',into=("OUI",) ),
           GROUP_MA        =SIMP(statut='f',typ='TXM',into=("COUDE","BOL") ),
           MATER           =SIMP(statut='o',typ=mater_sdaster ),
           TEMP_REF        =SIMP(statut='f',typ='R',defaut= 0.E+0 ),
         ),

         PRES_REP        =FACT(statut='f',
           PRES            =SIMP(statut='o',typ='R' ),
           EFFE_FOND_P1    =SIMP(statut='f',typ='TXM',defaut="OUI",into=("OUI","NON") ),
           PRES_LEVRE      =SIMP(statut='f',typ='TXM',defaut="NON",into=("OUI","NON") ),
           FONC_MULT       =SIMP(statut='f',typ=(fonction_sdaster,nappe_sdaster,formule) ),
         ),

         ECHANGE         =FACT(statut='f',
           COEF_H          =SIMP(statut='f',typ=(fonction_sdaster,nappe_sdaster,formule) ),
           TEMP_EXT        =SIMP(statut='f',typ=(fonction_sdaster,nappe_sdaster,formule) ),
         ),

         TORS_P1         =FACT(statut='f',max=6,
           regles=(AU_MOINS_UN('FX','FY','FZ','MX','MY','MZ'),),
           FX              =SIMP(statut='f',typ='R' ),
           FY              =SIMP(statut='f',typ='R' ),
           FZ              =SIMP(statut='f',typ='R' ),
           MX              =SIMP(statut='f',typ='R' ),
           MY              =SIMP(statut='f',typ='R' ),
           MZ              =SIMP(statut='f',typ='R' ),
           FONC_MULT       =SIMP(statut='f',typ=(fonction_sdaster,nappe_sdaster,formule) ),
         ),

         COMP_INCR       =FACT(statut='f',
           RELATION        =SIMP(statut='o',typ='TXM',into=("VMIS_ISOT_TRAC",) ),
           VMIS_ISOT_TRAC  =SIMP(statut='c',typ='I',defaut= 2,into=( 2 ,) ),
           RESI_INTE_RELA  =SIMP(statut='f',typ='R'
                                ,defaut= 1.0E-6),
           ITER_INTE_MAXI  =SIMP(statut='f',typ='I',defaut= 10 ),
           ITER_INTE_PAS   =SIMP(statut='f',typ='I',defaut= 0 ),
           RESO_INTE       =SIMP(statut='f',typ='TXM',defaut="IMPLICITE",
                                 into=("RUNGE_KUTTA_2","RUNGE_KUTTA_4","IMPLICITE")),
         ),

         COMP_ELAS       =FACT(statut='f',
           RELATION        =SIMP(statut='o',typ='TXM',into=("ELAS","ELAS_VMIS_TRAC") ),
           ELAS            =SIMP(statut='c',typ='I',defaut= 1,into=( 1 ,) ),
           ELAS_VMIS_TRAC  =SIMP(statut='c',typ='I',defaut= 1,into=( 1 ,) ),
           RESI_INTE_RELA  =SIMP(statut='f',typ='R',defaut= 1.0E-6),
           ITER_INTE_MAXI  =SIMP(statut='f',typ='I',defaut= 10 ),
           ITER_INTE_PAS   =SIMP(statut='f',typ='I',defaut= 0 ),
           RESO_INTE       =SIMP(statut='f',typ='TXM',defaut="IMPLICITE",
                                 into=("RUNGE_KUTTA_2","RUNGE_KUTTA_4","IMPLICITE")),
         ),

         SOLVEUR         =FACT(statut='d',
           METHODE         =SIMP(statut='f',typ='TXM',defaut="MULT_FRONT",into=("MULT_FRONT","LDLT","GCPC") ),
           b_mult_front    =BLOC(condition = "METHODE == 'MULT_FRONT' ",fr="Paramètres de la méthode multi frontale",
             RENUM           =SIMP(statut='f',typ='TXM',defaut="METIS",into=("MD","MDA","METIS") ),
           ),
           b_ldlt         =BLOC(condition = "METHODE == 'LDLT' ",fr="Paramètres de la méthode LDLT",
             RENUM           =SIMP(statut='f',typ='TXM',defaut="RCMK",into=("RCMK","SANS") ),
           ),
           b_ldlt_mult    =BLOC(condition = "METHODE == 'LDLT' or METHODE == 'MULT_FRONT' ",
                                   fr="Paramètres relatifs à la non inversibilité de la matrice à factorise",
             NPREC           =SIMP(statut='f',typ='I',defaut= 8 ),
             STOP_SINGULIER  =SIMP(statut='f',typ='TXM',defaut="OUI",into=("OUI","NON") ),
           ),
           b_gcpc         =BLOC(condition = "METHODE == 'GCPC' ", fr="Paramètres de la méthode du gradient conjugué",
             PRE_COND        =SIMP(statut='f',typ='TXM',into=("LDLT_INC",),defaut="LDLT_INC" ),
             NIVE_REMPLISSAGE=SIMP(statut='f',typ='I',defaut= 0 ),
             RENUM           =SIMP(statut='f',typ='TXM',defaut="RCMK",into=("SANS","RCMK") ),
             RESI_RELA       =SIMP(statut='f',typ='R',defaut= 1.E-6 ),
             NMAX_ITER       =SIMP(statut='f',typ='I',defaut= 0 ),
           ),
           SYME            =SIMP(statut='f',typ='TXM',defaut="NON",into=("OUI","NON") ),
         ),

         CONVERGENCE     =FACT(statut='d',
           RESI_GLOB_MAXI  =SIMP(statut='f',typ='R'),
           RESI_GLOB_RELA  =SIMP(statut='f',typ='R'),
           ITER_GLOB_MAXI  =SIMP(statut='f',typ='I',defaut=10),
           ARRET           =SIMP(statut='f',typ='TXM',defaut="OUI"),
         ),

         NEWTON          =FACT(statut='d',
           REAC_INCR       =SIMP(statut='f',typ='I',defaut= 1 ),
           PREDICTION      =SIMP(statut='f',typ='TXM',into=("DEPL_CALCULE","TANGENTE","ELASTIQUE","EXTRAPOL") ),
           MATRICE         =SIMP(statut='f',typ='TXM',defaut="TANGENTE",into=("TANGENTE","ELASTIQUE") ),
           REAC_ITER       =SIMP(statut='f',typ='I',defaut=0),
           EVOL_NOLI       =SIMP(statut='f',typ=evol_noli),
         ),

         RECH_LINEAIRE   =FACT(statut='d',
           RESI_LINE_RELA  =SIMP(statut='f',typ='R',defaut= 1.0E-3 ),
           ITER_LINE_MAXI  =SIMP(statut='f',typ='I',defaut= 3),
         ),

         INCREMENT       =FACT(statut='o',
           regles=(EXCLUS('NUME_INST_INIT','INST_INIT'),
                   EXCLUS('NUME_INST_FIN','INST_FIN'),),
           LIST_INST       =SIMP(statut='o',typ=listr8_sdaster),
           EVOLUTION       =SIMP(statut='f',typ='TXM',defaut="CHRONOLOGIQUE",
                                 into=("CHRONOLOGIQUE","RETROGRADE","SANS",) ),
           NUME_INST_INIT  =SIMP(statut='f',typ='I'),
           INST_INIT       =SIMP(statut='f',typ='R'),
           NUME_INST_FIN   =SIMP(statut='f',typ='I'),
           INST_FIN        =SIMP(statut='f',typ='R'),
           PRECISION       =SIMP(statut='f',typ='R',defaut=1.0E-3 ),
           # DEBUT DE BLOC POUR LA SUBDIVISION DES PAS DE TEMPS
           SUBD_METHODE    =SIMP( statut='f',typ='TXM',
              into =("AUCUNE","UNIFORME","EXTRAPOLE"),
              defaut="AUCUNE",
              fr="Méthode de subdivision des pas de temps en cas de non-convergence"
           ),
           b_subd_unif=BLOC(condition = "SUBD_METHODE == 'UNIFORME'",
             regles=(AU_MOINS_UN('SUBD_NIVEAU','SUBD_PAS_MINI'),),
             SUBD_COEF_PAS_1=SIMP(statut='f',typ='R',defaut=1.0,val_min=0.0,
                fr="Coefficient multiplicateur de la 1ère subdivision"),
             SUBD_PAS       =SIMP(statut='f',typ='I',defaut=4,val_min=2,
                fr="Nombre de subdivision d'un pas de temps"),
             SUBD_NIVEAU=SIMP(statut='f',typ='I',val_min=2,
                fr="Nombre maximum de niveau de subdivision d'un pas de temps"),
             SUBD_PAS_MINI=SIMP(statut='f',typ='R',val_min=0.0,
                fr="Pas de temps en dessous duquel on ne subdivise plus"),
           ),
           b_subd_extr=BLOC(condition = "SUBD_METHODE == 'EXTRAPOLE'",
             regles=(AU_MOINS_UN('SUBD_NIVEAU','SUBD_PAS_MINI'),),
             SUBD_OPTION    =SIMP(statut='f',typ='TXM',
                into =("IGNORE_PREMIERES","GARDE_DERNIERES",), 
                defaut="IGNORE_PREMIERES",
                fr="Technique d'extrapolation : les 1ere itérations sont ignorées ou les dernières sont gardées"),
             SUBD_ITER_IGNO =SIMP(statut='c',typ='I',defaut=3,val_min=0,
                fr="Les n premières itérations sont ignorées pour l'extrapolation"),
             SUBD_ITER_FIN  =SIMP(statut='c',typ='I',defaut=8,val_min=3,
                fr="Seules les n dernières itérations sont prises pour l'extrapolation"),
             SUBD_PAS       =SIMP(statut='c',typ='I',defaut=4,val_min=2,
                fr="Nombre de subdivision d'un pas de temps en cas divergence"),
             SUBD_NIVEAU=SIMP(statut='f',typ='I',val_min=2,
                fr="Nombre maximum de niveau de subdivision d'un pas de temps"),
             SUBD_PAS_MINI=SIMP(statut='f',typ='R',val_min=0.0,
                fr="Pas de temps en dessous duquel on ne subdivise plus"),
             SUBD_ITER_PLUS =SIMP(statut='c',typ='I',defaut=50,val_min=20,
                fr="% itération autorisée en plus"),
           ),
           # FIN DE BLOC POUR LA SUBDIVISION DES PAS DE TEMPS 
         ),

         THETA_3D        =FACT(statut='f',max='**',
           R_INF           =SIMP(statut='o',typ='R' ),
           R_SUP           =SIMP(statut='o',typ='R' ),
         ),

         IMPR_TABLE      =FACT(statut='f',
           regles=(UN_PARMI('TOUT_PARA','NOM_PARA', ),
            PRESENT_PRESENT('TOUT_PARA','ANGLE',    ),
            PRESENT_PRESENT('TOUT_PARA','R_CINTR',  ),
                   UN_PARMI('POSI_CURV_LONGI','POSI_ANGUL',),),
           NOM_PARA        =SIMP(statut='f',typ='TXM',validators=NoRepeat(),max=4,
                                 into=("TRESCA_MEMBRANE",
                                       "TRESCA_MFLE",
                                       "TRESCA",
                                       "SI_LONG"
                                       "SI_RADI"
                                       "SI_CIRC"
                                       ) ),
           TOUT_PARA       =SIMP(statut='f',typ='TXM',into=("OUI",) ),
           ANGLE           =SIMP(statut='f',typ='R',max='**' ),
           R_CINTR         =SIMP(statut='f',typ='R',max='**' ),
           POSI_CURV_LONGI =SIMP(statut='f',typ='R',max='**' ),
           POSI_ANGUL      =SIMP(statut='f',typ='R',max='**' ),
           TRANSFORMEE     =SIMP(statut='f',typ='TXM',defaut="COUDE",into=("COUDE","TUBE") ),
         ),

         IMPRESSION      =FACT(statut='f',
           FORMAT          =SIMP(statut='f',typ='TXM',defaut="RESULTAT",
                                 into=("RESULTAT","ASTER","IDEAS","CASTEM") ),
                                 
           b_format_ideas  =BLOC(condition="FORMAT=='IDEAS'",fr="version Ideas",
             VERSION         =SIMP(statut='f',typ='I',defaut=5,into=(4,5)),
           ),  

           b_format_castem =BLOC(condition="FORMAT=='CASTEM'",fr="version Castem",
             NIVE_GIBI       =SIMP(statut='f',typ='I',defaut=10,into=(3,10)),
           ),

         ),

         TITRE           =SIMP(statut='f',typ='TXM' ),

         INFO            =SIMP(statut='f',typ='I',defaut= 1,into=(1,2) ),
)  ;
#& MODIF COMMANDE  DATE 22/06/2005   AUTEUR REZETTE C.REZETTE 
#            CONFIGURATION MANAGEMENT OF EDF VERSION
# ======================================================================
# COPYRIGHT (C) 1991 - 2001  EDF R&D                  WWW.CODE-ASTER.ORG
# THIS PROGRAM IS FREE SOFTWARE; YOU CAN REDISTRIBUTE IT AND/OR MODIFY
# IT UNDER THE TERMS OF THE GNU GENERAL PUBLIC LICENSE AS PUBLISHED BY
# THE FREE SOFTWARE FOUNDATION; EITHER VERSION 2 OF THE LICENSE, OR   
# (AT YOUR OPTION) ANY LATER VERSION.                                 
#
# THIS PROGRAM IS DISTRIBUTED IN THE HOPE THAT IT WILL BE USEFUL, BUT 
# WITHOUT ANY WARRANTY; WITHOUT EVEN THE IMPLIED WARRANTY OF          
# MERCHANTABILITY OR FITNESS FOR A PARTICULAR PURPOSE. SEE THE GNU    
# GENERAL PUBLIC LICENSE FOR MORE DETAILS.                            
#
# YOU SHOULD HAVE RECEIVED A COPY OF THE GNU GENERAL PUBLIC LICENSE   
# ALONG WITH THIS PROGRAM; IF NOT, WRITE TO EDF R&D CODE_ASTER,       
#    1 AVENUE DU GENERAL DE GAULLE, 92141 CLAMART CEDEX, FRANCE.      
# ======================================================================
# RESPONSABLE F1BHHAJ J.ANGLES
from Macro.macr_ascouf_mail_ops import macr_ascouf_mail_ops
MACR_ASCOUF_MAIL=MACRO(nom="MACR_ASCOUF_MAIL",op=macr_ascouf_mail_ops,sd_prod=maillage_sdaster,
            fr="Engendre le maillage d'un coude sain ou comportant une fissure ou une (ou plusieurs) sous-épaisseur(s)",
            UIinfo={"groupes":("Outils métier",)},reentrant='n',

         regles=(EXCLUS('SOUS_EPAIS_COUDE','FISS_COUDE','SOUS_EPAIS_MULTI'),),

         EXEC_MAILLAGE   =FACT(statut='o',
           LOGICIEL        =SIMP(statut='o',typ='TXM',defaut="GIBI2000",into=("GIBI98","GIBI2000") ),
           UNITE_DATG      =SIMP(statut='f',typ='I',defaut=70),  
           UNITE_MGIB      =SIMP(statut='f',typ='I',defaut=19),  
           NIVE_GIBI       =SIMP(statut='f',typ='I',defaut=10,into=(3,4,5,6,7,8,9,10,11)),
         ),

         TYPE_ELEM       =SIMP(statut='f',typ='TXM',defaut="CU20",into=("CU20","CUB8") ),

         COUDE           =FACT(statut='o',
           ANGLE           =SIMP(statut='o',typ='R' ),  
           R_CINTR         =SIMP(statut='o',typ='R' ),  
           L_TUBE_P1       =SIMP(statut='o',typ='R' ),  
           L_TUBE_P2       =SIMP(statut='f',typ='R',defaut= 0.E+0 ),  
           NB_ELEM_EPAIS   =SIMP(statut='f',typ='I',defaut= 3 ),  
           SYME            =SIMP(statut='f',typ='TXM',defaut="ENTIER",into=("ENTIER","QUART","DEMI") ),
           TRANSFORMEE     =SIMP(statut='o',typ='TXM',defaut="COUDE",into=("COUDE","TUBE") ),
           b_transf_coude  =BLOC(condition = "TRANSFORMEE == 'COUDE' ",
              DEXT            =SIMP(statut='o',typ='R' ),  
              EPAIS           =SIMP(statut='o',typ='R' ),  
              SUR_EPAIS       =SIMP(statut='f',typ='R',defaut= 0.E+0 ),  
              BOL_P2          =SIMP(statut='f',typ='TXM',into=("ASP_MPP","CUVE","GV") ),
           ),
           b_transf_tube   =BLOC(condition = "TRANSFORMEE == 'TUBE' ",
              TRAN_EPAIS      =SIMP(statut='o',typ='TXM',defaut="NON",into=("OUI","NON") ),
              b_trans_epais_oui    =BLOC(condition = "TRAN_EPAIS == 'OUI' ",
                      regles=(ENSEMBLE('ANGL_TETA2','EPAIS_TI'),
                              UN_PARMI('ABSC_CURV_TRAN','POSI_ANGU_TRAN'),),
                      DEXT_T1         =SIMP(statut='o',typ='R' ),  
                      EPAIS_T1        =SIMP(statut='o',typ='R' ),  
                      EPAIS_T2        =SIMP(statut='o',typ='R' ),  
                      EPAIS_TI        =SIMP(statut='f',typ='R' ),  
                      ANGL_TETA1      =SIMP(statut='o',typ='R' ),  
                      ANGL_TETA2      =SIMP(statut='f',typ='R' ),  
                      ABSC_CURV_TRAN  =SIMP(statut='f',typ='R' ),  
                      POSI_ANGU_TRAN  =SIMP(statut='f',typ='R' ),  
              ),
              b_trans_epais_non    =BLOC(condition = "TRAN_EPAIS == 'NON' ",
                      DEXT            =SIMP(statut='o',typ='R' ),  
                      EPAIS           =SIMP(statut='o',typ='R' ),  
                      SUR_EPAIS       =SIMP(statut='f',typ='R',defaut= 0.E+0 ),  
                      BOL_P2          =SIMP(statut='f',typ='TXM',into=("ASP_MPP","CUVE","GV") ),
              ),
           ),
         ),

         SOUS_EPAIS_COUDE=FACT(statut='f',
           regles=(UN_PARMI('POSI_CURV_LONGI','POSI_ANGUL'),
                   UN_PARMI('POSI_CURV_CIRC','AZIMUT'),),
           TYPE            =SIMP(statut='o',typ='TXM',into=("AXIS","ELLI") ),
           AXE_CIRC        =SIMP(statut='f',typ='R' ),  
           AXE_LONGI       =SIMP(statut='o',typ='R' ),  
           PROFONDEUR      =SIMP(statut='o',typ='R' ),  
           POSI_CURV_LONGI =SIMP(statut='f',typ='R' ),  
           POSI_ANGUL      =SIMP(statut='f',typ='R' ),  
           POSI_CURV_CIRC  =SIMP(statut='f',typ='R' ),  
           AZIMUT          =SIMP(statut='f',typ='R' ),  
           SOUS_EPAIS      =SIMP(statut='o',typ='TXM',into=("INTERNE","EXTERNE") ),
           NB_ELEM_LONGI   =SIMP(statut='o',typ='I' ),  
           NB_ELEM_CIRC    =SIMP(statut='o',typ='I' ),  
           NB_ELEM_RADI    =SIMP(statut='f',typ='I',defaut= 3 ),  
           EMPREINTE       =SIMP(statut='f',typ='TXM',defaut="OUI",into=("OUI","NON") ),
         ),

         SOUS_EPAIS_MULTI=FACT(statut='f',max='**',
           regles=(UN_PARMI('POSI_CURV_LONGI','POSI_ANGUL'),
                   UN_PARMI('POSI_CURV_CIRC','AZIMUT'),),
           TYPE            =SIMP(statut='o',typ='TXM',into=("AXIS","ELLI") ),
           AXE_CIRC        =SIMP(statut='f',typ='R' ),  
           AXE_LONGI       =SIMP(statut='o',typ='R' ),  
           PROFONDEUR      =SIMP(statut='o',typ='R' ),  
           POSI_CURV_LONGI =SIMP(statut='f',typ='R' ),  
           POSI_ANGUL      =SIMP(statut='f',typ='R' ),  
           POSI_CURV_CIRC  =SIMP(statut='f',typ='R' ),  
           AZIMUT          =SIMP(statut='f',typ='R' ),  
           SOUS_EPAIS      =SIMP(statut='o',typ='TXM',into=("INTERNE","EXTERNE") ),
           NB_ELEM_LONGI   =SIMP(statut='o',typ='I' ),  
           NB_ELEM_CIRC    =SIMP(statut='o',typ='I' ),  
           EMPREINTE       =SIMP(statut='f',typ='TXM',defaut="OUI",into=("OUI","NON") ),
         ),

         FISS_COUDE      =FACT(statut='f',
           regles=(UN_PARMI('ABSC_CURV','POSI_ANGUL'),),
           AXIS            =SIMP(statut='f',typ='TXM',into=("OUI","NON"),defaut="NON" ),  
           b_axis_non    =BLOC(condition = "AXIS == 'NON' ",
                   LONGUEUR        =SIMP(statut='o',typ='R' ),  
           ),
           b_axis_oui    =BLOC(condition = "AXIS == 'OUI' ",
                   LONGUEUR        =SIMP(statut='f',typ='R' ),  
           ),
           PROFONDEUR      =SIMP(statut='o',typ='R' ),  
           ABSC_CURV       =SIMP(statut='f',typ='R' ),  
           POSI_ANGUL      =SIMP(statut='f',typ='R' ),  
           FISSURE         =SIMP(statut='o',typ='TXM',into=("DEB_INT","DEB_EXT") ),
           AZIMUT          =SIMP(statut='f',typ='R',defaut= 90. ),  
           ORIEN           =SIMP(statut='o',typ='R',
                                 into=(45.,-45.,90.,0.E+0) ),
           NB_TRANCHE      =SIMP(statut='o',typ='I' ),  
           NB_SECTEUR      =SIMP(statut='o',typ='I' ),  
           NB_COURONNE     =SIMP(statut='o',typ='I' ),  
           RAYON_TORE      =SIMP(statut='f',typ='R' ),  
           COEF_MULT_RC2   =SIMP(statut='f',typ='R',defaut= 1. ),  
           COEF_MULT_RC3   =SIMP(statut='f',typ='R' ),  
           ANGL_OUVERTURE  =SIMP(statut='f',typ='R',defaut= 0.5 ),  
         ),

         IMPRESSION      =FACT(statut='f',max='**',
           regles=(PRESENT_PRESENT('FICHIER','UNITE'),),
           FORMAT          =SIMP(statut='f',typ='TXM',defaut="ASTER",   
                                 into=("ASTER","IDEAS","CASTEM") ),
           b_format_ideas  =BLOC(condition="FORMAT=='IDEAS'",fr="version Ideas",
             VERSION         =SIMP(statut='f',typ='I',defaut=5,into=(4,5)),
           ),  
           b_format_castem =BLOC(condition="FORMAT=='CASTEM'",fr="version Castem",
             NIVE_GIBI       =SIMP(statut='f',typ='I',defaut=10,into=(3,10)),
           ),
           FICHIER         =SIMP(statut='f',typ='TXM' ),  
           UNITE           =SIMP(statut='f',typ='I' ),  
         ),

         INFO            =SIMP(statut='f',typ='I',defaut= 1,into=(1,2) ),
)  ;
#& MODIF COMMANDE  DATE 25/09/2006   AUTEUR MJBHHPE J.L.FLEJOU 
#            CONFIGURATION MANAGEMENT OF EDF VERSION
# ======================================================================
# COPYRIGHT (C) 1991 - 2001  EDF R&D                  WWW.CODE-ASTER.ORG
# THIS PROGRAM IS FREE SOFTWARE; YOU CAN REDISTRIBUTE IT AND/OR MODIFY
# IT UNDER THE TERMS OF THE GNU GENERAL PUBLIC LICENSE AS PUBLISHED BY
# THE FREE SOFTWARE FOUNDATION; EITHER VERSION 2 OF THE LICENSE, OR   
# (AT YOUR OPTION) ANY LATER VERSION.                                 
#
# THIS PROGRAM IS DISTRIBUTED IN THE HOPE THAT IT WILL BE USEFUL, BUT 
# WITHOUT ANY WARRANTY; WITHOUT EVEN THE IMPLIED WARRANTY OF          
# MERCHANTABILITY OR FITNESS FOR A PARTICULAR PURPOSE. SEE THE GNU    
# GENERAL PUBLIC LICENSE FOR MORE DETAILS.                            
#
# YOU SHOULD HAVE RECEIVED A COPY OF THE GNU GENERAL PUBLIC LICENSE   
# ALONG WITH THIS PROGRAM; IF NOT, WRITE TO EDF R&D CODE_ASTER,       
#    1 AVENUE DU GENERAL DE GAULLE, 92141 CLAMART CEDEX, FRANCE.      
# ======================================================================
# RESPONSABLE F1BHHAJ J.ANGLES
from Macro.macr_aspic_calc_ops import macr_aspic_calc_ops

def macr_aspic_calc_prod(self,MODELE,CHAM_MATER,CARA_ELEM,FOND_FISS_1,FOND_FISS_2,CHARGE,RESU_THER,**args):
  if MODELE      != None:self.type_sdprod(MODELE,modele_sdaster)
  if CHAM_MATER  != None:self.type_sdprod(CHAM_MATER,cham_mater)
  if CARA_ELEM   != None:self.type_sdprod(CARA_ELEM,cara_elem)
  if FOND_FISS_1 != None:self.type_sdprod(FOND_FISS_1,fond_fiss)
  if FOND_FISS_2 != None:self.type_sdprod(FOND_FISS_2,fond_fiss)
  if CHARGE      != None:self.type_sdprod(CHARGE,char_meca)
  if RESU_THER   != None:self.type_sdprod(RESU_THER,evol_ther)
  return evol_noli

MACR_ASPIC_CALC=MACRO(nom="MACR_ASPIC_CALC",op=macr_aspic_calc_ops,sd_prod=macr_aspic_calc_prod,
            fr="Réalise un calcul prédéfini de piquages sains ou fissurés ainsi que les post-traitements associés ",
            UIinfo={"groupes":("Outils métier",)},reentrant='n',
         regles=(UN_PARMI('COMP_INCR','COMP_ELAS'),),

         TYPE_MAILLAGE   =SIMP(statut='o',typ='TXM',
                               into=("SAIN_FIN","SAIN_GROS","FISS_COUR_DEB","FISS_COUR_NONDEB","FISS_LONG_DEB",
                                     "FISS_LONG_NONDEB","FISS_AXIS_DEB","FISS_AXIS_NONDEB") ),

         TUBULURE        =FACT(statut='o',
           TYPE            =SIMP(statut='o',typ='TXM',into=("TYPE_1","TYPE_2") ),
         ),
         MAILLAGE        =SIMP(statut='o',typ=maillage_sdaster),
         MODELE          =SIMP(statut='f',typ=CO,),
         CHAM_MATER      =SIMP(statut='f',typ=CO,),
         CARA_ELEM       =SIMP(statut='f',typ=CO,),
         FOND_FISS_1     =SIMP(statut='f',typ=CO,),
         FOND_FISS_2     =SIMP(statut='f',typ=CO,),
         CHARGE          =SIMP(statut='f',typ=CO,),
         RESU_THER       =SIMP(statut='f',typ=CO,),

         AFFE_MATERIAU   =FACT(statut='o',max=3,
           regles=(UN_PARMI('TOUT','GROUP_MA'),),
           TOUT            =SIMP(statut='f',typ='TXM',into=("OUI",)),
           GROUP_MA        =SIMP(statut='f',typ='TXM',into=("TUBU","CORP","SOUD","SOUDCORP","SOUDTUBU") ),
           MATER           =SIMP(statut='o',typ=mater_sdaster),
           TEMP_REF        =SIMP(statut='f',typ='R',defaut= 0.E+0 ),
           RCCM            =SIMP(statut='o',typ='TXM',into=("OUI","NON")),
         ),

         EQUILIBRE       =FACT(statut='o',
           NOEUD           =SIMP(statut='o',typ=no),
         ),

         PRES_REP        =FACT(statut='o',
           PRES            =SIMP(statut='o',typ='R'),
           NOEUD           =SIMP(statut='f',typ=no),
           EFFE_FOND       =SIMP(statut='f',typ='TXM',defaut="OUI",into=("OUI","NON")),
           PRES_LEVRE      =SIMP(statut='f',typ='TXM',defaut="NON",into=("OUI","NON") ),
           FONC_MULT       =SIMP(statut='f',typ=(fonction_sdaster,nappe_sdaster,formule)),
         ),

         ECHANGE         =FACT(statut='f',
           COEF_H_TUBU     =SIMP(statut='o',typ=(fonction_sdaster,nappe_sdaster,formule)),
           COEF_H_CORP     =SIMP(statut='o',typ=(fonction_sdaster,nappe_sdaster,formule)),
           TEMP_EXT        =SIMP(statut='o',typ=(fonction_sdaster,nappe_sdaster,formule)),
         ),

         TORS_CORP       =FACT(statut='f',max=6,
           regles=(AU_MOINS_UN('FX','FY','FZ','MX','MY','MZ'),),
           NOEUD           =SIMP(statut='o',typ=no),
           FX              =SIMP(statut='f',typ='R'),
           FY              =SIMP(statut='f',typ='R'),
           FZ              =SIMP(statut='f',typ='R'),
           MX              =SIMP(statut='f',typ='R'),
           MY              =SIMP(statut='f',typ='R'),
           MZ              =SIMP(statut='f',typ='R'),
           FONC_MULT       =SIMP(statut='f',typ=(fonction_sdaster,nappe_sdaster,formule)),
         ),

         TORS_TUBU       =FACT(statut='f',max=6,
           regles=(AU_MOINS_UN('FX','FY','FZ','MX','MY','MZ'),),
           FX              =SIMP(statut='f',typ='R'),
           FY              =SIMP(statut='f',typ='R'),
           FZ              =SIMP(statut='f',typ='R'),
           MX              =SIMP(statut='f',typ='R'),
           MY              =SIMP(statut='f',typ='R'),
           MZ              =SIMP(statut='f',typ='R'),
           FONC_MULT       =SIMP(statut='f',typ=(fonction_sdaster,nappe_sdaster,formule)),
         ),

         COMP_INCR       =FACT(statut='f',
           RELATION        =SIMP(statut='o',typ='TXM',into=("VMIS_ISOT_TRAC",) ),
           VMIS_ISOT_TRAC  =SIMP(statut='c',typ='I',defaut= 2,into=( 2 ,) ),
           RESI_INTE_RELA  =SIMP(statut='f',typ='R',defaut=1.0E-6),
           ITER_INTE_MAXI  =SIMP(statut='f',typ='I',defaut=10),
           ITER_INTE_PAS   =SIMP(statut='f',typ='I',defaut=0),
           RESO_INTE       =SIMP(statut='f',typ='TXM',defaut="IMPLICITE",
                                 into=("RUNGE_KUTTA_2","RUNGE_KUTTA_4","IMPLICITE")),
         ),

         COMP_ELAS       =FACT(statut='f',
           RELATION        =SIMP(statut='o',typ='TXM',into=("ELAS","ELAS_VMIS_TRAC") ),
           ELAS            =SIMP(statut='c',typ='I',defaut= 1,into=( 1 ,) ),
           ELAS_VMIS_TRAC  =SIMP(statut='c',typ='I',defaut= 1,into=( 1 ,) ),
           RESI_INTE_RELA  =SIMP(statut='f',typ='R',defaut= 1.0E-6),
           ITER_INTE_MAXI  =SIMP(statut='f',typ='I',defaut= 10 ),
           ITER_INTE_PAS   =SIMP(statut='f',typ='I',defaut= 0 ),
           RESO_INTE       =SIMP(statut='f',typ='TXM',defaut="IMPLICITE",
                                 into=("RUNGE_KUTTA_2","RUNGE_KUTTA_4","IMPLICITE")),
         ),

         THETA_3D        =FACT(statut='f',max='**',
           R_INF           =SIMP(statut='o',typ='R'),
           R_SUP           =SIMP(statut='o',typ='R'),
         ),

         OPTION          =SIMP(statut='f',typ='TXM',into=("CALC_G_MAX","CALC_G_MAX_LOCAL") ),
         BORNES          =FACT(statut='f',max='**',
           NUME_ORDRE      =SIMP(statut='o',typ='I'),
           VALE_MIN        =SIMP(statut='o',typ='R'),
           VALE_MAX        =SIMP(statut='o',typ='R'),
         ),

         SOLVEUR         =FACT(statut='d',
           METHODE         =SIMP(statut='f',typ='TXM',defaut="MULT_FRONT",into=("MULT_FRONT","LDLT","GCPC") ),
           b_mult_front    =BLOC(condition = "METHODE == 'MULT_FRONT' ",fr="Paramètres de la méthode multi frontale",
             RENUM           =SIMP(statut='f',typ='TXM',defaut="METIS",into=("MD","MDA","METIS") ),
           ),
           b_ldlt          =BLOC(condition = "METHODE == 'LDLT' ",fr="Paramètres de la méthode LDLT",
             RENUM           =SIMP(statut='f',typ='TXM',defaut="RCMK",into=("RCMK","SANS") ),
           ),
           b_ldlt_mult     =BLOC(condition = "METHODE == 'LDLT' or METHODE == 'MULT_FRONT' ",
                                   fr="Paramètres relatifs à la non iversibilité de la matrice à factorise",
             NPREC           =SIMP(statut='f',typ='I',defaut= 8 ),
             STOP_SINGULIER  =SIMP(statut='f',typ='TXM',defaut="OUI",into=("OUI","NON") ),
           ),
           b_gcpc          =BLOC(condition = "METHODE == 'GCPC' ", fr="Paramètres de la méthode du gradient conjugué",
             PRE_COND        =SIMP(statut='f',typ='TXM',into=("LDLT_INC",),defaut="LDLT_INC" ),
             NIVE_REMPLISSAGE=SIMP(statut='f',typ='I',defaut= 0 ),
             RENUM           =SIMP(statut='f',typ='TXM',defaut="RCMK",into=("SANS","RCMK") ),
             RESI_RELA       =SIMP(statut='f',typ='R',defaut= 1.E-6 ),
             NMAX_ITER       =SIMP(statut='f',typ='I',defaut= 0 ),
           ),
           SYME            =SIMP(statut='f',typ='TXM',defaut="NON",into=("OUI","NON") ),
         ),

         CONVERGENCE     =FACT(statut='d',
           RESI_GLOB_MAXI  =SIMP(statut='f',typ='R'),
           RESI_GLOB_RELA  =SIMP(statut='f',typ='R'),
           ITER_GLOB_MAXI  =SIMP(statut='f',typ='I',defaut=10),
           ARRET           =SIMP(statut='f',typ='TXM',defaut="OUI"),
         ),

         NEWTON          =FACT(statut='d',
           REAC_INCR       =SIMP(statut='f',typ='I',defaut=1),
           PREDICTION      =SIMP(statut='f',typ='TXM',into=("TANGENTE","ELASTIQUE","EXTRAPOL","DEPL_CALCULE")),
           MATRICE         =SIMP(statut='f',typ='TXM',defaut="TANGENTE",into=("TANGENTE","ELASTIQUE")),
           REAC_ITER       =SIMP(statut='f',typ='I',defaut= 0),
         ),

         RECH_LINEAIRE   =FACT(statut='d',
           RESI_LINE_RELA  =SIMP(statut='f',typ='R',defaut=1.0E-3),
           ITER_LINE_MAXI  =SIMP(statut='f',typ='I',defaut=3),
         ),

         INCREMENT       =FACT(statut='o',
           regles=(EXCLUS('NUME_INST_INIT','INST_INIT'),
                   EXCLUS('NUME_INST_FIN','INST_FIN'),),
           LIST_INST       =SIMP(statut='o',typ=listr8_sdaster),
           EVOLUTION       =SIMP(statut='f',typ='TXM',defaut="CHRONOLOGIQUE",
                                 into=("CHRONOLOGIQUE","RETROGRADE","SANS",) ),
           NUME_INST_INIT  =SIMP(statut='f',typ='I'),
           INST_INIT       =SIMP(statut='f',typ='R'),
           NUME_INST_FIN   =SIMP(statut='f',typ='I'),
           INST_FIN        =SIMP(statut='f',typ='R'),
           PRECISION       =SIMP(statut='f',typ='R',defaut=1.0E-3 ),
           # DEBUT DE BLOC POUR LA SUBDIVISION DES PAS DE TEMPS
           SUBD_METHODE    =SIMP( statut='f',typ='TXM',
              into =("AUCUNE","UNIFORME","EXTRAPOLE"),
              defaut="AUCUNE",
              fr="Méthode de subdivision des pas de temps en cas de non-convergence"
           ),
           b_subd_unif=BLOC(condition = "SUBD_METHODE == 'UNIFORME'",
             regles=(AU_MOINS_UN('SUBD_NIVEAU','SUBD_PAS_MINI'),),
             SUBD_COEF_PAS_1=SIMP(statut='f',typ='R',defaut=1.0,val_min=0.0,
                fr="Coefficient multiplicateur de la 1ère subdivision"),
             SUBD_PAS       =SIMP(statut='f',typ='I',defaut=4,val_min=2,
                fr="Nombre de subdivision d'un pas de temps"),
             SUBD_NIVEAU=SIMP(statut='f',typ='I',val_min=2,
                fr="Nombre maximum de niveau de subdivision d'un pas de temps"),
             SUBD_PAS_MINI=SIMP(statut='f',typ='R',val_min=0.0,
                fr="Pas de temps en dessous duquel on ne subdivise plus"),
           ),
           b_subd_extr=BLOC(condition = "SUBD_METHODE == 'EXTRAPOLE'",
             regles=(AU_MOINS_UN('SUBD_NIVEAU','SUBD_PAS_MINI'),),
             SUBD_OPTION    =SIMP(statut='f',typ='TXM',
                into =("IGNORE_PREMIERES","GARDE_DERNIERES",), 
                defaut="IGNORE_PREMIERES",
                fr="Technique d'extrapolation : les 1ere itérations sont ignorées ou les dernières sont gardées"),
             SUBD_ITER_IGNO =SIMP(statut='c',typ='I',defaut=3,val_min=0,
                fr="Les n premières itérations sont ignorées pour l'extrapolation"),
             SUBD_ITER_FIN  =SIMP(statut='c',typ='I',defaut=8,val_min=3,
                fr="Seules les n dernières itérations sont prises pour l'extrapolation"),
             SUBD_PAS       =SIMP(statut='c',typ='I',defaut=4,val_min=2,
                fr="Nombre de subdivision d'un pas de temps en cas divergence"),
             SUBD_NIVEAU=SIMP(statut='f',typ='I',val_min=2,
                fr="Nombre maximum de niveau de subdivision d'un pas de temps"),
             SUBD_PAS_MINI=SIMP(statut='f',typ='R',val_min=0.0,
                fr="Pas de temps en dessous duquel on ne subdivise plus"),
             SUBD_ITER_PLUS =SIMP(statut='c',typ='I',defaut=50,val_min=20,
                fr="% itération autorisée en plus"),
           ),
           # FIN DE BLOC POUR LA SUBDIVISION DES PAS DE TEMPS 
         ),

         PAS_AZIMUT      =SIMP(statut='f',typ='I',defaut=1),

         IMPRESSION      =FACT(statut='f',
           FORMAT          =SIMP(statut='f',typ='TXM',defaut="RESULTAT",
                                 into=("RESULTAT","ASTER","CASTEM","IDEAS")),
                                 
           b_format_ideas  =BLOC(condition="FORMAT=='IDEAS'",fr="version Ideas",
             VERSION         =SIMP(statut='f',typ='I',defaut=5,into=(4,5)),
           ),  

           b_format_castem =BLOC(condition="FORMAT=='CASTEM'",fr="version Castem",
             NIVE_GIBI       =SIMP(statut='f',typ='I',defaut=10,into=(3,10)),
           ),

           b_extrac        =BLOC(condition="((FORMAT=='IDEAS')or(FORMAT=='CASTEM'))",
                                 fr="extraction d un champ de grandeur",
             regles=(EXCLUS('TOUT_ORDRE','NUME_ORDRE','INST'),),
             NOM_CHAM        =SIMP(statut='f',typ='TXM',validators=NoRepeat(),max=3,
                                   into=("DEPL","EQUI_ELNO_SIGM","TEMP")),
             
             TOUT_ORDRE      =SIMP(statut='f',typ='TXM',into=("OUI",) ),
             NUME_ORDRE      =SIMP(statut='f',typ='I',validators=NoRepeat(),max='**'),
             INST            =SIMP(statut='f',typ='R',validators=NoRepeat(),max='**'),
           ),      
         ),

         INFO            =SIMP(statut='f',typ='I',defaut=1,into=(1,2)),

         TITRE           =SIMP(statut='f',typ='TXM'),
)
#& MODIF COMMANDE  DATE 22/06/2005   AUTEUR REZETTE C.REZETTE 
#            CONFIGURATION MANAGEMENT OF EDF VERSION
# ======================================================================
# COPYRIGHT (C) 1991 - 2001  EDF R&D                  WWW.CODE-ASTER.ORG
# THIS PROGRAM IS FREE SOFTWARE; YOU CAN REDISTRIBUTE IT AND/OR MODIFY
# IT UNDER THE TERMS OF THE GNU GENERAL PUBLIC LICENSE AS PUBLISHED BY
# THE FREE SOFTWARE FOUNDATION; EITHER VERSION 2 OF THE LICENSE, OR   
# (AT YOUR OPTION) ANY LATER VERSION.                                 
#
# THIS PROGRAM IS DISTRIBUTED IN THE HOPE THAT IT WILL BE USEFUL, BUT 
# WITHOUT ANY WARRANTY; WITHOUT EVEN THE IMPLIED WARRANTY OF          
# MERCHANTABILITY OR FITNESS FOR A PARTICULAR PURPOSE. SEE THE GNU    
# GENERAL PUBLIC LICENSE FOR MORE DETAILS.                            
#
# YOU SHOULD HAVE RECEIVED A COPY OF THE GNU GENERAL PUBLIC LICENSE   
# ALONG WITH THIS PROGRAM; IF NOT, WRITE TO EDF R&D CODE_ASTER,       
#    1 AVENUE DU GENERAL DE GAULLE, 92141 CLAMART CEDEX, FRANCE.      
# ======================================================================
# RESPONSABLE F1BHHAJ J.ANGLES

from Macro.macr_aspic_mail_ops import macr_aspic_mail_ops

MACR_ASPIC_MAIL=MACRO(nom="MACR_ASPIC_MAIL",op= macr_aspic_mail_ops,sd_prod=maillage_sdaster,reentrant='n',
            fr="Engendre le maillage d'un piquage sain ou avec fissure (longue ou courte)",
            UIinfo={"groupes":("Outils métier",)},

         EXEC_MAILLAGE   =FACT(statut='o',
           LOGICIEL        =SIMP(statut='o',typ='TXM',defaut="GIBI2000",into=("GIBI98","GIBI2000")),
           UNITE_DATG      =SIMP(statut='f',typ='I',defaut=70),  
           UNITE_MGIB      =SIMP(statut='f',typ='I',defaut=19),  
           NIVE_GIBI       =SIMP(statut='f',typ='I',defaut=10,into=(3,4,5,6,7,8,9,10,11)),
         ),

         TYPE_ELEM       =SIMP(statut='f',typ='TXM',defaut="CU20",into=("CU20","CUB8")),

         RAFF_MAIL       =SIMP(statut='f',typ='TXM',defaut="GROS",into=("GROS","FIN")),

         TUBULURE        =FACT(statut='o',
           E_BASE          =SIMP(statut='o',typ='R'),  
           DEXT_BASE       =SIMP(statut='o',typ='R'),  
           L_BASE          =SIMP(statut='o',typ='R'),  
           L_CHANF         =SIMP(statut='o',typ='R'),  
           E_TUBU          =SIMP(statut='o',typ='R'),  
           DEXT_TUBU       =SIMP(statut='o',typ='R'),  
           Z_MAX           =SIMP(statut='o',typ='R'),  
           TYPE            =SIMP(statut='o',typ='TXM',into=("TYPE_1","TYPE_2")),
           L_PENETR        =SIMP(statut='f',typ='R',defaut= 0.0E+0),  
         ),

         SOUDURE         =FACT(statut='o',
           H_SOUD          =SIMP(statut='o',typ='R'),  
           ANGL_SOUD       =SIMP(statut='o',typ='R'),  
           JEU_SOUD        =SIMP(statut='o',typ='R'),  
         ),

         CORPS           =FACT(statut='o',
           E_CORP          =SIMP(statut='o',typ='R'),  
           DEXT_CORP       =SIMP(statut='o',typ='R'),  
           X_MAX           =SIMP(statut='o',typ='R'),  
         ),

         FISS_SOUDURE    =FACT(statut='f',
           TYPE            =SIMP(statut='o',typ='TXM',into=("LONGUE","COURTE")),
           AXIS            =SIMP(statut='f',typ='TXM',defaut="NON",into=("OUI","NON")),
           PROFONDEUR      =SIMP(statut='o',typ='R'),  
           LONGUEUR        =SIMP(statut='f',typ='R'),  
           AZIMUT          =SIMP(statut='o',typ='R'),  
           RAYON_TORE      =SIMP(statut='f',typ='R'),  
           POSITION        =SIMP(statut='o',typ='TXM',into=("DROIT","INCLINE")),
           FISSURE         =SIMP(statut='o',typ='TXM',into=("DEB_INT","DEB_EXT","NON_DEB","TRAVERS")),
           LIGA_INT        =SIMP(statut='f',typ='R'),  
           ANGL_OUVERTURE  =SIMP(statut='f',typ='R',defaut= 0.0E+0),  
           COEF_MULT_RC1   =SIMP(statut='f',typ='R'),  
           COEF_MULT_RC2   =SIMP(statut='f',typ='R'),  
           COEF_MULT_RC3   =SIMP(statut='f',typ='R'),  
           NB_TRANCHE      =SIMP(statut='f',typ='I'),  
           NB_SECTEUR      =SIMP(statut='f',typ='I'),  
           NB_COURONNE     =SIMP(statut='f',typ='I'),  
         ),

         IMPRESSION      =FACT(statut='f',max='**',
           regles=(PRESENT_PRESENT('FICHIER','UNITE'),),
           FORMAT          =SIMP(statut='f',typ='TXM',defaut="ASTER",into=("ASTER","IDEAS","CASTEM")),

           b_format_ideas  =BLOC(condition="FORMAT=='IDEAS'",fr="version Ideas",
             VERSION         =SIMP(statut='f',typ='I',defaut=5,into=(4,5)),
           ),  

           b_format_castem =BLOC(condition="FORMAT=='CASTEM'",fr="version Castem",
             NIVE_GIBI       =SIMP(statut='f',typ='I',defaut=10,into=(3,10)),
           ),
           FICHIER         =SIMP(statut='f',typ='TXM'),  
           UNITE           =SIMP(statut='f',typ='I'),  
         ),

         INFO            =SIMP(statut='f',typ='I',defaut=1,into=(1,2)),
)  ;
#& MODIF COMMANDE  DATE 25/09/2006   AUTEUR MJBHHPE J.L.FLEJOU 
#            CONFIGURATION MANAGEMENT OF EDF VERSION
# ======================================================================
# COPYRIGHT (C) 1991 - 2003  EDF R&D                  WWW.CODE-ASTER.ORG
# THIS PROGRAM IS FREE SOFTWARE; YOU CAN REDISTRIBUTE IT AND/OR MODIFY  
# IT UNDER THE TERMS OF THE GNU GENERAL PUBLIC LICENSE AS PUBLISHED BY  
# THE FREE SOFTWARE FOUNDATION; EITHER VERSION 2 OF THE LICENSE, OR     
# (AT YOUR OPTION) ANY LATER VERSION.                                                  
#                                                                       
# THIS PROGRAM IS DISTRIBUTED IN THE HOPE THAT IT WILL BE USEFUL, BUT   
# WITHOUT ANY WARRANTY; WITHOUT EVEN THE IMPLIED WARRANTY OF            
# MERCHANTABILITY OR FITNESS FOR A PARTICULAR PURPOSE. SEE THE GNU      
# GENERAL PUBLIC LICENSE FOR MORE DETAILS.                              
#                                                                       
# YOU SHOULD HAVE RECEIVED A COPY OF THE GNU GENERAL PUBLIC LICENSE     
# ALONG WITH THIS PROGRAM; IF NOT, WRITE TO EDF R&D CODE_ASTER,         
#    1 AVENUE DU GENERAL DE GAULLE, 92141 CLAMART CEDEX, FRANCE.        
# ======================================================================

from Macro.macr_cabri_calc_ops import macr_cabri_calc_ops
   
def macr_cabri_calc_prod(self,MODELE_THER,MODELE_MECA,CHAM_MATER,
                         CHAR_THER,CHAR_MECA,RESU_THER,**args):
  if MODELE_THER != None:
   self.type_sdprod(MODELE_THER,modele_sdaster)   
  if MODELE_MECA != None:
   self.type_sdprod(MODELE_MECA,modele_sdaster)  
  if RESU_THER != None:
   self.type_sdprod(RESU_THER,evol_ther)     
  if CHAM_MATER != None:
   self.type_sdprod(CHAM_MATER,cham_mater)     
  if CHAR_THER != None: 
    for m in CHAR_THER:
      self.type_sdprod(m['CHARGE'],char_ther)
  if CHAR_MECA != None: 
    for m in CHAR_MECA:
      self.type_sdprod(m['CHARGE'],char_meca)
  return evol_noli


MACR_CABRI_CALC=MACRO(nom="MACR_CABRI_CALC",
                      op=macr_cabri_calc_ops,
                      sd_prod=macr_cabri_calc_prod,
                      fr="Calcul thermo-mécanique d'une jonction boulonnée de tuyauterie",
                      reentrant='n',
                      UIinfo={"groupes":("Outils métier",)},
                      MAILLAGE   = SIMP(statut='o',typ=maillage_sdaster,),
                      AFFE_MATERIAU = FACT(statut='o',max='**',
                        regles=(UN_PARMI('TOUT','GROUP_MA',),),
                        TOUT     = SIMP(statut='f',typ='TXM',into=("OUI",) ),
                        GROUP_MA = SIMP(statut='f',typ='TXM',into=(
                                                                  "BRIDE",
                                                                  "GOUJON",
                                                                  "ROND",
                                                                  "ECROU",
                                                                  "JOINT",) ),
                        MATER    = SIMP(statut='o',typ=mater_sdaster),
                        TEMP_REF = SIMP(statut='d',typ='R',defaut= 25. ),
                      ),                      
                      CHAM_MATER = SIMP(statut = 'f',typ=CO,),
                      MODELE_THER= SIMP(statut = 'f',typ=CO,),
                      
                      DEFI_CHAR_THER = FACT(statut ='d',
                        TEMP_INIT     = SIMP(statut='d',typ='R',defaut= 25.,),
                        COEF_H_FLUI   = SIMP(statut='f',typ=(fonction_sdaster,nappe_sdaster),),
                        TEMP_EXT_FLUI = SIMP(statut='f',typ=(fonction_sdaster,nappe_sdaster),),
                        COEF_H_AIR    = SIMP(statut='f',typ=(fonction_sdaster,nappe_sdaster),),
                        TEMP_EXT_AIR  = SIMP(statut='f',typ=(fonction_sdaster,nappe_sdaster),),
                        LIST_INST     = SIMP(statut='f',typ=listr8_sdaster),
                      ),                      
                      
                      CHAR_THER  = FACT(statut = 'f',max=4,
                        CHARGE    = SIMP(statut='o',typ=CO),
                        TYPE      = SIMP(statut='o',typ='TXM',
                                 into=("BRIDE_FLUIDE","BRIDE_AIR","ECROU_GOUJON",
                                       "BRIDE_JOINT"),)
                                       ),

                      RESU_THER  = SIMP(statut = 'f',typ=CO,),                                       

                                       
                      MODELE_MECA= SIMP(statut = 'f',typ=CO,),

                      DEFI_CHAR_MECA   = FACT(statut='o',
                        PRETENS    = SIMP(statut='f',typ=(fonction_sdaster,nappe_sdaster),),
                        PRES_REP   = SIMP(statut='f',typ=(fonction_sdaster,nappe_sdaster),),
                        EFFE_FOND  = SIMP(statut='f',typ=(fonction_sdaster,nappe_sdaster),),
                      ),                                                             

                      CHAR_MECA  = FACT(statut = 'f',max=11,
                        CHARGE    = SIMP(statut='o',typ=CO),
                        TYPE      = SIMP(statut='o',typ='TXM',
                                 into=("BLOC_BAS_GOUJ","BLOC_BAS_JOINT",
                                       "BLOC_LAT_ALES","BLOC_LAT_NALES",
                                       "PLAN_TUBE",
                                       "PRES_FLU","EFFET_FOND",
                                       "CONT_JOINT",
                                       "DEFO_THER",
                                       "SERR_ECROU_1","SERR_ECROU_2",),)
                                       ),
                     
                      RELATION = SIMP(statut='f',typ='TXM',
                                       into=('VMIS_ISOT_TRAC','ELAS','ELAS_VMIS_TRAC',),),
                        
                      SOLVEUR   = FACT(statut='d',
                        METHODE  = SIMP(statut='d',typ='TXM',defaut="MULT_FRONT",into=("MULT_FRONT",) ),
                        b_mult_front = BLOC(condition = "METHODE == 'MULT_FRONT' ",
                           fr="Paramètres de la méthode multi frontale",
                           RENUM           = SIMP(statut='d',typ='TXM',defaut="METIS",into=("MD","MDA","METIS") ),
                           NPREC           = SIMP(statut='d',typ='I',defaut=8),
                           STOP_SINGULIER  = SIMP(statut='d',typ='TXM',defaut="OUI",into=("OUI","NON") ),
                           ),                 
                      ),                                             
                      INCREMENT = FACT(statut='f',
                        regles=(EXCLUS('NUME_INST_INIT','INST_INIT'),
                                EXCLUS('NUME_INST_FIN','INST_FIN'),),
                        LIST_INST       =SIMP(statut='f',typ=listr8_sdaster),
                        EVOLUTION       =SIMP(statut='f',typ='TXM',defaut="CHRONOLOGIQUE",
                                 into=("CHRONOLOGIQUE",) ),                                 
                        NUME_INST_INIT  =SIMP(statut='f',typ='I'),
                        INST_INIT       =SIMP(statut='f',typ='R'),
                        NUME_INST_FIN   =SIMP(statut='f',typ='I'),
                        INST_FIN        =SIMP(statut='f',typ='R'),
                        PRECISION       =SIMP(statut='f',typ='R',defaut=1.0E-3 ),
           # DEBUT DE BLOC POUR LA SUBDIVISION DES PAS DE TEMPS
           SUBD_METHODE    =SIMP( statut='f',typ='TXM',
              into =("AUCUNE","UNIFORME","EXTRAPOLE"),
              defaut="AUCUNE",
              fr="Méthode de subdivision des pas de temps en cas de non-convergence"
           ),
           b_subd_unif=BLOC(condition = "SUBD_METHODE == 'UNIFORME'",
             regles=(AU_MOINS_UN('SUBD_NIVEAU','SUBD_PAS_MINI'),),
             SUBD_COEF_PAS_1=SIMP(statut='f',typ='R',defaut=1.0,val_min=0.0,
                fr="Coefficient multiplicateur de la 1ère subdivision"),
             SUBD_PAS       =SIMP(statut='f',typ='I',defaut=4,val_min=2,
                fr="Nombre de subdivision d'un pas de temps"),
             SUBD_NIVEAU=SIMP(statut='f',typ='I',val_min=2,
                fr="Nombre maximum de niveau de subdivision d'un pas de temps"),
             SUBD_PAS_MINI=SIMP(statut='f',typ='R',val_min=0.0,
                fr="Pas de temps en dessous duquel on ne subdivise plus"),
           ),
           b_subd_extr=BLOC(condition = "SUBD_METHODE == 'EXTRAPOLE'",
             regles=(AU_MOINS_UN('SUBD_NIVEAU','SUBD_PAS_MINI'),),
             SUBD_OPTION    =SIMP(statut='f',typ='TXM',
                into =("IGNORE_PREMIERES","GARDE_DERNIERES",), 
                defaut="IGNORE_PREMIERES",
                fr="Technique d'extrapolation : les 1ere itérations sont ignorées ou les dernières sont gardées"),
             SUBD_ITER_IGNO =SIMP(statut='c',typ='I',defaut=3,val_min=0,
                fr="Les n premières itérations sont ignorées pour l'extrapolation"),
             SUBD_ITER_FIN  =SIMP(statut='c',typ='I',defaut=8,val_min=3,
                fr="Seules les n dernières itérations sont prises pour l'extrapolation"),
             SUBD_PAS       =SIMP(statut='c',typ='I',defaut=4,val_min=2,
                fr="Nombre de subdivision d'un pas de temps en cas divergence"),
             SUBD_NIVEAU=SIMP(statut='f',typ='I',val_min=2,
                fr="Nombre maximum de niveau de subdivision d'un pas de temps"),
             SUBD_PAS_MINI=SIMP(statut='f',typ='R',val_min=0.0,
                fr="Pas de temps en dessous duquel on ne subdivise plus"),
             SUBD_ITER_PLUS =SIMP(statut='c',typ='I',defaut=50,val_min=20,
                fr="% itération autorisée en plus"),
           ),
           # FIN DE BLOC POUR LA SUBDIVISION DES PAS DE TEMPS 
                        OPTI_LIST_INST  =SIMP(statut='f',typ='TXM',into=("INCR_MAXI",),),
                        NOM_CHAM        =SIMP(statut='f',typ='TXM',),
                        NOM_CMP         =SIMP(statut='f',typ='TXM',),
                        VALE            =SIMP(statut='f',typ='R'),
                      ),
                      NEWTON          =FACT(statut='d',
                        REAC_INCR       =SIMP(statut='f',typ='I',defaut= 1 ),
                        PREDICTION      =SIMP(statut='f',typ='TXM',into=("TANGENTE","ELASTIQUE","EXTRAPOL") ),
                        MATRICE         =SIMP(statut='f',typ='TXM',defaut="TANGENTE",into=("TANGENTE","ELASTIQUE") ),
                        PAS_MINI_ELAS   =SIMP(statut='f',typ='R',defaut=0.0E+0),
                        REAC_ITER       =SIMP(statut='f',typ='I',defaut=0),
                        EVOL_NOLI       =SIMP(statut='f',typ=evol_noli),
                      ),
                      RESO_INTE       =SIMP(statut='f',typ='TXM',defaut="IMPLICITE",
                                into=("IMPLICITE",)),
                      CONVERGENCE     =FACT(statut='d',
                        regles=(PRESENT_ABSENT('RESI_REFE_RELA','RESI_GLOB_MAXI','RESI_GLOB_RELA'),),
                        SIGM_REFE       =SIMP(statut='f',typ='R'),
                        EPSI_REFE       =SIMP(statut='f',typ='R'),
                        FLUX_THER_REFE  =SIMP(statut='f',typ='R'),        
                        RESI_REFE_RELA  =SIMP(statut='f',typ='R'),
                        RESI_GLOB_MAXI  =SIMP(statut='f',typ='R'),
                        RESI_GLOB_RELA  =SIMP(statut='f',typ='R'),
                        ITER_GLOB_MAXI  =SIMP(statut='f',typ='I',defaut=10),
                        ITER_GLOB_ELAS  =SIMP(statut='f',typ='I',defaut=25),
                      ),
                     );

#& MODIF COMMANDE  DATE 07/02/2005   AUTEUR MABBAS M.ABBAS 
#            CONFIGURATION MANAGEMENT OF EDF VERSION
# ======================================================================
# COPYRIGHT (C) 1991 - 2003  EDF R&D                  WWW.CODE-ASTER.ORG
# THIS PROGRAM IS FREE SOFTWARE; YOU CAN REDISTRIBUTE IT AND/OR MODIFY  
# IT UNDER THE TERMS OF THE GNU GENERAL PUBLIC LICENSE AS PUBLISHED BY  
# THE FREE SOFTWARE FOUNDATION; EITHER VERSION 2 OF THE LICENSE, OR     
# (AT YOUR OPTION) ANY LATER VERSION.                                                  
#                                                                       
# THIS PROGRAM IS DISTRIBUTED IN THE HOPE THAT IT WILL BE USEFUL, BUT   
# WITHOUT ANY WARRANTY; WITHOUT EVEN THE IMPLIED WARRANTY OF            
# MERCHANTABILITY OR FITNESS FOR A PARTICULAR PURPOSE. SEE THE GNU      
# GENERAL PUBLIC LICENSE FOR MORE DETAILS.                              
#                                                                       
# YOU SHOULD HAVE RECEIVED A COPY OF THE GNU GENERAL PUBLIC LICENSE     
# ALONG WITH THIS PROGRAM; IF NOT, WRITE TO EDF R&D CODE_ASTER,         
#    1 AVENUE DU GENERAL DE GAULLE, 92141 CLAMART CEDEX, FRANCE.        
# ======================================================================

from Macro.macr_cabri_mail_ops import macr_cabri_mail_ops

MACR_CABRI_MAIL=MACRO(nom="MACR_CABRI_MAIL",
                      op=macr_cabri_mail_ops,
                      sd_prod=maillage_sdaster,
                      fr="maillage d'une jonction boulonnée de tuyauterie",
                      reentrant='n',
                      UIinfo={"groupes":("Outils métier",)},
                      EXEC_MAILLAGE = FACT(statut='o',
                        LOGICIEL      = SIMP(statut = 'o',typ='TXM',into=("GIBI2000",),),
                        UNITE_DATG    = SIMP(statut = 'f',typ='I',defaut=70,),
                        UNITE_MGIB    = SIMP(statut = 'f',typ='I',defaut=19,),
                        NIVE_GIBI     = SIMP(statut = 'f',typ='I',defaut=10,
                                          into = (3,4,5,6,7,8,9,10,11),
                                            ),
                                          ),
                      RAFF_MAILLAGE   = FACT(statut = 'd',
                        NB_RADIAL    = SIMP(statut = 'f',typ='I',defaut=2,),
                        NB_CIRCONF   = SIMP(statut = 'f',typ='I',defaut=3,),
                        NB_VERTICAL  = SIMP(statut = 'f',typ='I',defaut=6,),
                        NB_ALESAGE   = SIMP(statut = 'f',typ='I',defaut=5,),
                                          ),
                      VERI_MAIL     = FACT(statut='d',
                        VERIF         = SIMP(statut='f',typ='TXM',defaut="OUI",into=("OUI","NON") ),  
                        APLAT         = SIMP(statut='f',typ='R',defaut= 1.0E-3 ),  
                                          ),                                          
                      GEOM_BRID     = FACT(statut = 'o',
                        NORME         = SIMP(statut = 'o',typ='TXM',into=("OUI","NON"),),
                        b_bride_iso   = BLOC(condition = "NORME == 'OUI'",
                          TYPE           = SIMP(statut='o',typ='TXM',
                                                into=('A','AA','B','B1','C','D','D1','E','F',
                                                      'FF','G','GG','H','H1','I','J','J1',
                                                      'K','L','L1','M','N','O','P','S','T','W'), 
                                               ),
                                            ),
                        b_bride_niso  = BLOC(condition = "NORME == 'NON'",
                          TUBU_D_EXT     = SIMP(statut='o',typ='R',),
                          TUBU_H         = SIMP(statut='o',typ='R',),
                          BRID_D_EXT     = SIMP(statut='o',typ='R',),
                          BRID_D_INT     = SIMP(statut='o',typ='R',),
                          BRID_H         = SIMP(statut='o',typ='R',),
                          BRID_D_CONGE   = SIMP(statut='o',typ='R',),
                          BRID_R_CONGE   = SIMP(statut='o',typ='R',),
                          BRID_D_EPAUL   = SIMP(statut='o',typ='R',),
                          BRID_H_EPAUL   = SIMP(statut='o',typ='R',),
                          BRID_D_ALESAG  = SIMP(statut='o',typ='R',),
                          BRID_P_ALESAG  = SIMP(statut='o',typ='R',),
                          BRID_H_ALESAG  = SIMP(statut='o',typ='R',),
                          GOUJ_N_GOUJON  = SIMP(statut='o',typ='I',),
                          GOUJ_D_GOUJON  = SIMP(statut='o',typ='R',),
                          GOUJ_E_FILET   = SIMP(statut='o',typ='R',),
                          GOUJ_D_RONDEL  = SIMP(statut='o',typ='R',),
                          GOUJ_E_RONDEL  = SIMP(statut='o',typ='R',),
                          GOUJ_D_ECROU   = SIMP(statut='o',typ='R',),
                          GOUJ_E_ECROU   = SIMP(statut='o',typ='R',),
                          ETAN_E_JOINT   = SIMP(statut='o',typ='R',),
                                            ),
                                         ),
                      IMPRESSION    = FACT(statut='d',
                        UNITE          = SIMP(statut='f',typ='I'),
                        FORMAT         = SIMP(statut='f',typ='TXM',defaut="ASTER",    
                                              into=("ASTER","CASTEM","IDEAS"),
                                             ),
                        b_impr_castem = BLOC(condition = "FORMAT == 'CASTEM'",
                          NIVE_GIBI      = SIMP(statut='f',typ='I',defaut=10,into=(3,10),),
                                            ),
                        b_impr_ideas  = BLOC(condition = "FORMAT == 'IDEAS'",
                          VERSION        = SIMP(statut='f',typ='I',defaut=5,into=(4,5),),
                                            ),
                                          ),
                     );

#& MODIF COMMANDE  DATE 03/01/2006   AUTEUR REZETTE C.REZETTE 
#            CONFIGURATION MANAGEMENT OF EDF VERSION
# ======================================================================
# COPYRIGHT (C) 1991 - 2003  EDF R&D                  WWW.CODE-ASTER.ORG
# THIS PROGRAM IS FREE SOFTWARE; YOU CAN REDISTRIBUTE IT AND/OR MODIFY  
# IT UNDER THE TERMS OF THE GNU GENERAL PUBLIC LICENSE AS PUBLISHED BY  
# THE FREE SOFTWARE FOUNDATION; EITHER VERSION 2 OF THE LICENSE, OR     
# (AT YOUR OPTION) ANY LATER VERSION.                                                  
#                                                                       
# THIS PROGRAM IS DISTRIBUTED IN THE HOPE THAT IT WILL BE USEFUL, BUT   
# WITHOUT ANY WARRANTY; WITHOUT EVEN THE IMPLIED WARRANTY OF            
# MERCHANTABILITY OR FITNESS FOR A PARTICULAR PURPOSE. SEE THE GNU      
# GENERAL PUBLIC LICENSE FOR MORE DETAILS.                              
#                                                                       
# YOU SHOULD HAVE RECEIVED A COPY OF THE GNU GENERAL PUBLIC LICENSE     
# ALONG WITH THIS PROGRAM; IF NOT, WRITE TO EDF R&D CODE_ASTER,         
#    1 AVENUE DU GENERAL DE GAULLE, 92141 CLAMART CEDEX, FRANCE.        
# ======================================================================
# RESPONSABLE JMBHH01 J.M.PROIX

from Macro.macr_cara_poutre_ops import macr_cara_poutre_ops

MACR_CARA_POUTRE=MACRO(nom="MACR_CARA_POUTRE",op=macr_cara_poutre_ops,sd_prod=table_sdaster,
                       reentrant='n',
          UIinfo={"groupes":("Modélisation",)},
          fr="Calculer les caractéristiques d'une section transversale de poutre à partir d'un maillage 2D de la section",
          regles=(EXCLUS('SYME_X','GROUP_MA_BORD'),
                  EXCLUS('SYME_Y','GROUP_MA_BORD'),),
                 
          UNITE_MAILLAGE  =SIMP(statut='f',typ='I',defaut= 20 ),  
          ORIG_INER       =SIMP(statut='f',typ='R',max=3,defaut=(0.E+0,0.E+0),
                                fr="Point par rapport auquel sont calculées les inerties"),  
          INFO            =SIMP(statut='f',typ='I',defaut=1,into=(1,2)),
         
          SYME_X          =SIMP(statut='f',typ='TXM',into=("OUI",),fr="demi maillage par rapport a x=0"),
          SYME_Y          =SIMP(statut='f',typ='TXM',into=("OUI",),fr="demi maillage par rapport a y=0"),
         
          GROUP_MA        =SIMP(statut='f',typ=grma,validators=NoRepeat(),max='**',
          fr="Calcul des caractéristiques équivalentes a plusieurs sections disjointes"),
          
          GROUP_MA_BORD   =SIMP(statut='f',typ=grma,validators=NoRepeat(),max='**',
                               fr="Groupe(s) de mailles linéiques, bord(s) de(s) section(s)"),
         
               b_gma_bord = BLOC( condition = "GROUP_MA_BORD != None",
                            fr=" calcul des carac. mecaniques",

                    NOEUD           =SIMP(statut='f',typ=no,max='**',
                    fr="Simplement pour empecher des pivots nuls le cas echeant. Fournir un noeud quelconque"),
                    GROUP_MA_INTE   =SIMP(statut='f',typ=grma,validators=NoRepeat(),max='**',
                    fr="groupes de mailles linéiques bordant des trous dans la section"),
                    ),
                    
               b_reseau = BLOC( condition ="""(GROUP_MA_BORD != None) and (GROUP_MA != None)""",
                           fr=" calcul des coef de cisaillement équivalents a un reseau de poutres",
                            regles=(ENSEMBLE('LONGUEUR','LIAISON','MATERIAU') ,),
                            LONGUEUR        =SIMP(statut='f',typ='R',fr="Longueur du réseau de poutres"),  
                            MATERIAU        =SIMP(statut='f',typ=mater_sdaster,fr="Materiau elastique lineaire du reseau"),
                            LIAISON         =SIMP(statut='f',typ='TXM',into=("ROTULE","ENCASTREMENT"),
                            fr="type de conditions aux limites sur le plancher supérieur" ),
                              ), 
                    )
#& MODIF COMMANDE  DATE 22/06/2005   AUTEUR REZETTE C.REZETTE 
#            CONFIGURATION MANAGEMENT OF EDF VERSION
# ======================================================================
# COPYRIGHT (C) 1991 - 2004  EDF R&D                  WWW.CODE-ASTER.ORG
# THIS PROGRAM IS FREE SOFTWARE; YOU CAN REDISTRIBUTE IT AND/OR MODIFY  
# IT UNDER THE TERMS OF THE GNU GENERAL PUBLIC LICENSE AS PUBLISHED BY  
# THE FREE SOFTWARE FOUNDATION; EITHER VERSION 2 OF THE LICENSE, OR     
# (AT YOUR OPTION) ANY LATER VERSION.                                                  
#                                                                       
# THIS PROGRAM IS DISTRIBUTED IN THE HOPE THAT IT WILL BE USEFUL, BUT   
# WITHOUT ANY WARRANTY; WITHOUT EVEN THE IMPLIED WARRANTY OF            
# MERCHANTABILITY OR FITNESS FOR A PARTICULAR PURPOSE. SEE THE GNU      
# GENERAL PUBLIC LICENSE FOR MORE DETAILS.                              
#                                                                       
# YOU SHOULD HAVE RECEIVED A COPY OF THE GNU GENERAL PUBLIC LICENSE     
# ALONG WITH THIS PROGRAM; IF NOT, WRITE TO EDF R&D CODE_ASTER,         
#    1 AVENUE DU GENERAL DE GAULLE, 92141 CLAMART CEDEX, FRANCE.        
# ======================================================================


from Macro.macr_ecla_pg_ops import macr_ecla_pg_ops

def macr_ecla_pg_prod(self,RESULTAT,MAILLAGE,RESU_INIT,**args):
  self.type_sdprod(RESULTAT,AsType(RESU_INIT))   
  self.type_sdprod(MAILLAGE,maillage_sdaster)
  return None


MACR_ECLA_PG=MACRO(nom="MACR_ECLA_PG",op=macr_ecla_pg_ops,sd_prod=macr_ecla_pg_prod, reentrant='n',
             UIinfo={"groupes":("Post traitements",)},
             fr="Permettre la visualisation des champs aux points de Gauss d'une SD_RESULTAT sans lissage ni interpolation",
                    

             # SD résultat ,modèle et champs à "éclater" :
             RESU_INIT       =SIMP(statut='o',typ=resultat_sdaster,fr="RESULTAT à éclater",),
             MODELE_INIT     =SIMP(statut='o',typ=modele_sdaster,fr="MODELE à éclater"),
             NOM_CHAM        =SIMP(statut='o',typ='TXM',validators=NoRepeat(),max='**',
                                   into=("SIEF_ELGA","VARI_ELGA","SIEF_ELGA_DEPL","FLUX_ELGA_TEMP",) ),
                                   
             # paramètres numériques de la commande :
             SHRINK          =SIMP(statut='f',typ='R',defaut= 0.9, fr="Facteur de réduction" ),
             TAILLE_MIN      =SIMP(statut='f',typ='R',defaut= 0.0, fr="Taille minimale d'un coté" ),
             
             # concepts produits par la commande :
             RESULTAT        =SIMP(statut='o',typ=CO,fr="SD_RESULTAT résultat de la commande"),
             MAILLAGE        =SIMP(statut='o',typ=CO,fr="MAILLAGE associé aux cham_no de la SD_RESULTAT"),
                     
             # Sélection éventuelle d'un sous-ensemble des éléments à visualiser :           
             TOUT            =SIMP(statut='f',typ='TXM',into=("OUI",) ),
             MAILLE          =SIMP(statut='f',typ=ma  ,validators=NoRepeat(),max='**'),
             GROUP_MA        =SIMP(statut='f',typ=grma,validators=NoRepeat(),max='**'),
             
             # Sélection des numéros d'ordre :
             regles=(EXCLUS('TOUT_ORDRE','NUME_ORDRE','INST','LIST_INST','LIST_ORDRE'),),
             TOUT_ORDRE      =SIMP(statut='f',typ='TXM',into=("OUI",) ),
             NUME_ORDRE      =SIMP(statut='f',typ='I',validators=NoRepeat(),max='**'),
             LIST_ORDRE      =SIMP(statut='f',typ=listis_sdaster),
             INST            =SIMP(statut='f',typ='R',validators=NoRepeat(),max='**'),
             LIST_INST       =SIMP(statut='f',typ=listr8_sdaster),
             PRECISION       =SIMP(statut='f',typ='R',defaut= 1.0E-3),
             CRITERE         =SIMP(statut='f',typ='TXM',defaut="RELATIF",into=("RELATIF","ABSOLU",) ),
            )
#& MODIF COMMANDE  DATE 22/06/2005   AUTEUR REZETTE C.REZETTE 
#            CONFIGURATION MANAGEMENT OF EDF VERSION
# ======================================================================
# COPYRIGHT (C) 1991 - 2001  EDF R&D                  WWW.CODE-ASTER.ORG
# THIS PROGRAM IS FREE SOFTWARE; YOU CAN REDISTRIBUTE IT AND/OR MODIFY
# IT UNDER THE TERMS OF THE GNU GENERAL PUBLIC LICENSE AS PUBLISHED BY
# THE FREE SOFTWARE FOUNDATION; EITHER VERSION 2 OF THE LICENSE, OR   
# (AT YOUR OPTION) ANY LATER VERSION.                                 
#
# THIS PROGRAM IS DISTRIBUTED IN THE HOPE THAT IT WILL BE USEFUL, BUT 
# WITHOUT ANY WARRANTY; WITHOUT EVEN THE IMPLIED WARRANTY OF          
# MERCHANTABILITY OR FITNESS FOR A PARTICULAR PURPOSE. SEE THE GNU    
# GENERAL PUBLIC LICENSE FOR MORE DETAILS.                            
#
# YOU SHOULD HAVE RECEIVED A COPY OF THE GNU GENERAL PUBLIC LICENSE   
# ALONG WITH THIS PROGRAM; IF NOT, WRITE TO EDF R&D CODE_ASTER,       
#    1 AVENUE DU GENERAL DE GAULLE, 92141 CLAMART CEDEX, FRANCE.      
# ======================================================================
MACR_ELEM_DYNA=OPER(nom="MACR_ELEM_DYNA",op=  81,sd_prod=macr_elem_dyna,
                    fr="Définition d'un macro élément pour analyse modale ou harmonique par sous structuration dynamique",
                    reentrant='n',
            UIinfo={"groupes":("Matrices/vecteurs",)},
         regles=(EXCLUS('MATR_AMOR','AMOR_REDUIT' ),),
         BASE_MODALE     =SIMP(statut='o',typ=base_modale ),
         MATR_RIGI       =SIMP(statut='f',typ=matr_asse_depl_r ),
         MATR_MASS       =SIMP(statut='f',typ=matr_asse_depl_r ),
         MATR_AMOR       =SIMP(statut='f',typ=matr_asse_depl_r ),
         AMOR_REDUIT     =SIMP(statut='f',typ='R',max='**'),         
         OPTION          =SIMP(statut='f',typ='TXM',defaut="CLASSIQUE",into=("CLASSIQUE","RITZ",
                          "DIAG_MASS") ),
)  ;
#& MODIF COMMANDE  DATE 31/10/2006   AUTEUR A3BHHAE H.ANDRIAMBOLOLONA 
#            CONFIGURATION MANAGEMENT OF EDF VERSION
# ======================================================================
# COPYRIGHT (C) 1991 - 2001  EDF R&D                  WWW.CODE-ASTER.ORG
# THIS PROGRAM IS FREE SOFTWARE; YOU CAN REDISTRIBUTE IT AND/OR MODIFY
# IT UNDER THE TERMS OF THE GNU GENERAL PUBLIC LICENSE AS PUBLISHED BY
# THE FREE SOFTWARE FOUNDATION; EITHER VERSION 2 OF THE LICENSE, OR   
# (AT YOUR OPTION) ANY LATER VERSION.                                 
#
# THIS PROGRAM IS DISTRIBUTED IN THE HOPE THAT IT WILL BE USEFUL, BUT 
# WITHOUT ANY WARRANTY; WITHOUT EVEN THE IMPLIED WARRANTY OF          
# MERCHANTABILITY OR FITNESS FOR A PARTICULAR PURPOSE. SEE THE GNU    
# GENERAL PUBLIC LICENSE FOR MORE DETAILS.                            
#
# YOU SHOULD HAVE RECEIVED A COPY OF THE GNU GENERAL PUBLIC LICENSE   
# ALONG WITH THIS PROGRAM; IF NOT, WRITE TO EDF R&D CODE_ASTER,       
#    1 AVENUE DU GENERAL DE GAULLE, 92141 CLAMART CEDEX, FRANCE.      
# ======================================================================
MACR_ELEM_STAT=OPER(nom="MACR_ELEM_STAT",op=86,sd_prod=macr_elem_stat,reentrant='f',
            UIinfo={"groupes":("Matrices/vecteurs",)},
                    fr="Définition d'un macro-élément pour l'analyse statique par sous-structuration",
        regles=(AU_MOINS_UN('DEFINITION','RIGI_MECA','MASS_MECA','CAS_CHARGE'),
                ENSEMBLE('DEFINITION','EXTERIEUR'),),
         DEFINITION      =FACT(statut='f',
           regles=(PRESENT_PRESENT('PROJ_MESU','MODE_MESURE'),),
           MODELE          =SIMP(statut='o',typ=modele_sdaster),
           CHAM_MATER      =SIMP(statut='f',typ=cham_mater),
           CARA_ELEM       =SIMP(statut='f',typ=cara_elem),
           CHAR_MACR_ELEM  =SIMP(statut='f',typ=char_meca),
           INST            =SIMP(statut='f',typ='R',defaut=0.0E+0 ),
           NMAX_CAS        =SIMP(statut='f',typ='I',defaut=10),
           NMAX_CHAR       =SIMP(statut='f',typ='I',defaut=10),
           PROJ_MESU       =SIMP(statut='f',typ=(mode_gene,tran_gene,harm_gene),max=1),
           MODE_MESURE     =SIMP(statut='f',typ=( mode_meca,base_modale) ),
         ),
         EXTERIEUR       =FACT(statut='f',
           regles=(AU_MOINS_UN('NOEUD','GROUP_NO'),),
           NOEUD           =SIMP(statut='f',typ=no  ,validators=NoRepeat(),max='**'),
           GROUP_NO        =SIMP(statut='f',typ=grno,validators=NoRepeat(),max='**'),
         ),
         RIGI_MECA       =FACT(statut='f',
         ),
         MASS_MECA       =FACT(statut='f',
         ),
         CAS_CHARGE      =FACT(statut='f',max='**',
           NOM_CAS         =SIMP(statut='o',typ='TXM'),
           SUIV            =SIMP(statut='f',typ='TXM',defaut="OUI",into=("OUI","NON")),
           CHARGE          =SIMP(statut='f',typ=char_meca,validators=NoRepeat(),max='**'),
           INST            =SIMP(statut='f',typ='R',defaut=0.E+0),
         ),

)  ;
#& MODIF COMMANDE  DATE 27/11/2006   AUTEUR GNICOLAS G.NICOLAS 
#            CONFIGURATION MANAGEMENT OF EDF VERSION
# ======================================================================
# COPYRIGHT (C) 1991 - 2004  EDF R&D                  WWW.CODE-ASTER.ORG
# THIS PROGRAM IS FREE SOFTWARE; YOU CAN REDISTRIBUTE IT AND/OR MODIFY  
# IT UNDER THE TERMS OF THE GNU GENERAL PUBLIC LICENSE AS PUBLISHED BY  
# THE FREE SOFTWARE FOUNDATION; EITHER VERSION 2 OF THE LICENSE, OR     
# (AT YOUR OPTION) ANY LATER VERSION.                                                  
#                                                                       
# THIS PROGRAM IS DISTRIBUTED IN THE HOPE THAT IT WILL BE USEFUL, BUT   
# WITHOUT ANY WARRANTY; WITHOUT EVEN THE IMPLIED WARRANTY OF            
# MERCHANTABILITY OR FITNESS FOR A PARTICULAR PURPOSE. SEE THE GNU      
# GENERAL PUBLIC LICENSE FOR MORE DETAILS.                              
#                                                                       
# YOU SHOULD HAVE RECEIVED A COPY OF THE GNU GENERAL PUBLIC LICENSE     
# ALONG WITH THIS PROGRAM; IF NOT, WRITE TO EDF R&D CODE_ASTER,         
#    1 AVENUE DU GENERAL DE GAULLE, 92141 CLAMART CEDEX, FRANCE.        
# ======================================================================
# RESPONSABLE GNICOLAS G.NICOLAS

from Macro.macr_fiabilite_ops import macr_fiabilite_ops

#
#====
# 1. Le retour : une liste de rééls.
#====
#
def macr_fiabilite_prod ( self , **args ):
  return listr8_sdaster
#
#====
# 2. L'entete
#====
#
MACR_FIABILITE = MACRO ( nom="MACR_FIABILITE",op=macr_fiabilite_ops,
                         docu="U7.03.31",UIinfo={"groupe":("Post traitements",)},
                         sd_prod=macr_fiabilite_prod,
                         fr="Calcule les probabiltés de dépassement de seuil (mécanique de fiabilité).",
                         ang="Fiability mechanics.",
#
#====
# 3. Le niveau d'information
#====
#
   INFO           = SIMP(statut="f",typ="I",defaut=1,into=(1,2)),
#
#====
# 4. Nom et Version du logiciel de fiabilité
#====
#
   LOGICIEL = SIMP(statut="f",typ="TXM",defaut="MEFISTO",
                   into=("MEFISTO",),
                   fr="Nom du logiciel de fiabilité.",
                   ang="Fiability software name."),
#
   VERSION = SIMP(statut="f",typ="TXM",defaut="V3_2",
                  into=("V3_2", "V3_N"),
                  fr="Version du logiciel de fiabilité.",
                  ang="Fiability software release."),
#
#====
# 5. Les entrees-sorties du calcul ASTER déterministe
#====
#
# 5.1. ==> Le jeu de commandes déterministe
#
   UNITE_ESCL = SIMP(statut="o",typ="I",
                     fr="Unité logique associée aux commandes du calcul ASTER déterministe.",
                     ang="Logical unit for the commands of the ASTER deterministic calculation."),
#
# 5.2. ==> Le destin des messages produits par ASTER
#
   MESS_ASTER = SIMP(statut="f",typ="TXM",defaut="DERNIER",
                        into=("AUCUN", "DERNIER", "TOUS"),
                        fr="Quels messages ASTER récupérer.",
                        ang="Which ASTER messages must be kept."),
#
#====
# 6. Options
#====
# 6.1. ==> Générales
#
# 6.1.1. ==> La valeur du seuil
#
   SEUIL = SIMP(statut="o",typ="R",max=1,
                fr="Le seuil de défaillance.",
                ang="Failure threshold."),
#
# 6.1.2. ==> Le type du seuil : on a deux cas de figure selon que
#            la défaillance a lieu au dessus d'un seuil maximum ou
#            en dessous d'un seuil minimum
#
   SEUIL_TYPE = SIMP(statut="o",typ="TXM",max=1,
                     into=("MINIMUM","MAXIMUM"),
                     fr="Que faut-il ne pas dépasser : un maximum ou un minimum.",
                     ang="What is the failure threshold : maximum or minimum."),
#
# 6.2. ==> Pour MEFISTO
#
### en attente de résolution de AL 2004-006 (1/2)   b_mefisto=BLOC( condition = "LOGICIEL=='MEFISTO'",
#
# 6.2.1. ==> Pilotage de la recherche du point de conception
#
     RECH_PT_CONCEPT = SIMP(statut="f",typ="TXM",defaut="OUI",
                            into=("OUI","NON"),
                            fr="Pour trouver le point de conception.",
                            ang="To find the design point."),
#
     b_rech_pt_concept=BLOC( condition = "RECH_PT_CONCEPT=='OUI'",
#
       EPSILON_U = SIMP(statut="f",typ="R",defaut=1.0E-2,
                        fr="Précision du test d'arret sur les points itératifs dans l'espace standard.",
                        ang="Precision of stop test for iterative points in standard space."),
#
       EPSILON_G = SIMP(statut="f",typ="R",defaut=1.0E-2,
                        fr="Précision du test d'arret sur la proximité de la surface d'état limite.",
                        ang="Precision of stop test for limit state surface."),
#
       TAU       = SIMP(statut="f",typ="R",defaut=5.0E-1,
                        fr="Paramètre de la méthode de minimisation.",
                        ang="Parameter for the minimization method."),
#
       OMEGA     = SIMP(statut="f",typ="R",defaut=1.0E-4,
                        fr="Paramètre de la méthode de minimisation.",
                        ang="Parameter for the minimization method."),
#
       ITER_MAX  = SIMP(statut="f",typ="I",defaut=50,
                        fr="Nombre maximum d'itérations.",
                        ang="Maximum number of iterations."),
     ),
#
# 6.2.2. ==> Méthode(s) employée(s) pour la probabilité de défaillance
#
     METHODE_FORM = SIMP(statut="f",typ="TXM",defaut="OUI",
                         into=("OUI","NON"),
                         fr="Recherche de la probabilité de défaillance avec la méthode FORM.",
                         ang="Research of failure probability with FORM method."),
#
     METHODE_SORM = SIMP(statut="f",typ="TXM",defaut="NON",
                         into=("OUI","NON"),
                         fr="Recherche de la probabilité de défaillance avec la méthode SORM.",
                         ang="Research of failure probability with SORM method."),
#
     TIRAGE_IMPORTANCE = SIMP(statut="f",typ="TXM",defaut="NON",
                              into=("OUI","NON"),
                              fr="Recherche de la probabilité de défaillance avec le tirage d'importance.",
                              ang="Research of failure probability with ."),
#
     b_tirage_importance=BLOC( condition = "TIRAGE_IMPORTANCE=='OUI'",
#
       NB_SIMULATION = SIMP(statut="f",typ="I",defaut=3,
                            fr="Nombre de simulations pour le tirage d'importance.",
                            ang="Number of simulation for."),
#
     ),
#
# 6.2.3. ==> Création d'une surface de réponse polynomiale
#
     POLYNOME_TAYLOR   = SIMP(statut="f",typ="TXM",defaut="NON",into=("OUI","NON"),),
     HGRAD             = SIMP(statut="f",typ="R",defaut=1.0E-2,
                              fr="Pas incrémental pour le calcul des gradients.",
                              ang="Step for calculation of gradients."),
     HHESS             = SIMP(statut="f",typ="R",defaut=1.0E-2,
                              fr="Pas incrémental pour le calcul des dérivées secondes.",
                              ang="Step for calculation of second derivatives."),
#
# 6.2.4. ==> Recherche d'un plan d'expérience
#
     PLAN_EXPERIENCE   = SIMP(statut="f",typ="TXM",defaut="NON",into=("OUI","NON"),
                              fr="Construction d'un plan d'expérience.",
                              ang="Construction of an experiment plan."),
#
     b_plan_experience=BLOC( condition = "PLAN_EXPERIENCE=='OUI'",
#
       ALPHA         = SIMP(statut="f",typ="R",defaut=2.0E-1,
                            fr="Plan d'expérience : maille du plan de type composite centré.",
                            ang="Experiment plane : mesh centered composite."),
#
       BETA          = SIMP(statut="f",typ="R",defaut=4.0E-1,
                            fr="Plan d'expérience : maille du plan de type factoriel.",
                            ang="Experiment plane : mesh factor."),
#
     ),
#
# 6.2.5. ==> Les tests
# 6.2.5.1. ==> Test de la sphere
#
     T_SPHERE = SIMP(statut="f",typ="TXM",defaut="NON",into=("OUI","NON"),
                     fr="Test de la sphère.",
                     ang="Sphere test."),
#
     b_test_de_la_sphere=BLOC( condition = "T_SPHERE=='OUI'",
#
       METHODE_TEST = SIMP(statut="f",typ="TXM",defaut="GAUSSIENNE",
                           into=("GAUSSIENNE","PARAMETRIQUE","REJECTION"),
                           fr="Type de méthode.",
                           ang="Method."),
#
       NB_POINT     = SIMP(statut="f",typ="I",max=1,defaut=60,
                           fr="Nombre de points de la sphere.",
                           ang="Number of points over the sphere.")
     ),
#
# 6.2.5.2. ==> Test du maximum fort
#
     T_MAXIMUM_FORT = SIMP(statut="f",typ="TXM",defaut="NON",into=("OUI","NON"),
                           fr="Test du maximum fort.",
                           ang="Strong maximum test."),
#
     b_test_du_maximum_fort=BLOC( condition = "T_MAXIMUM_FORT=='OUI'",
#
       COS_LIM = SIMP(statut="f",typ="R",max=1,defaut=1.0,
                      fr="Cosinus de l'angle d'exclusion.",
                      ang="Cosine of angle of exclusion."),
#
       DPROB   = SIMP(statut="f",typ="R",max=1,defaut=4.3E-1,
                      fr="Fraction d'iso-densité de probabilité de défaillance.",
                      ang="Fraction.")
#
     ),
#
# 6.2.5.3. ==> Test du hessien
#
     T_HESSIEN = SIMP(statut="f",typ="TXM",defaut="NON",into=("OUI","NON"),
                      fr="Test du hessien.",
                      ang="Hessian test."),
#
# 6.2.6. ==> Les correlations entre les variables
#
     MATRICE = SIMP(statut="f",typ="R",max="**",
                    fr="Matrice de corrélation entre les variables.",
                    ang="Correlation matrix."), 
#
### en attente de résolution de AL 2004-006 (2/2)   ),
#
#====
# 7. Definition des paramètres
#====
#
   VARIABLE = FACT(statut="o",min=1,max="**",
#
# 7.1. ==> Nom de la variable
#
       NOM = SIMP(statut="o",typ="TXM",
                  fr="Nom de la variable, identique au nom de concept PARA_SENSI.",
                  ang="Name of the variable, identical to the name of the PARA_SENSI conceipt."),
#
# 7.2. ==> Loi de distribution
#
       LOI = SIMP(statut="o",typ="TXM",
                  into=("UNIFORME","NORMALE","LOGNORMALE","NORMALE_TRONQUEE"),
                  fr="Choix de la loi",
                  ang="Law."),
#
# 7.2.1. ==> Loi normale
#
       b_normale=BLOC(condition="LOI=='NORMALE'",
#
         VALE_MOY   = SIMP(statut="o",typ="R",max=1,
                               fr="Valeur moyenne.",
                               ang="Mean value."),
#
         ECART_TYPE = SIMP(statut="o",typ="R",max=1,
                               fr="Ecart type.",
                               ang="Standard deviation."),
#
       ),
#
# 7.2.2. ==> Loi lognormale
#
       b_lognormale=BLOC(condition="LOI=='LOGNORMALE'",
#
         VALE_MIN       = SIMP(statut="o",typ="R",max=1,
                                   fr="Valeur minimale.",
                                   ang="Minimal value."),
#
         VALE_MOY       = SIMP(statut="f",typ="R",max=1,
                                   fr="Valeur moyenne dans l'espace de la loi normale.",
                                   ang="Mean value in the space of the normal law."),
#
         ECART_TYPE     = SIMP(statut="f",typ="R",max=1,
                                   fr="Ecart type dans l'espace de la loi normale.",
                                   ang="Standard deviation in the space of the normal law."),
#
         VALE_MOY_PHY   = SIMP(statut="f",typ="R",max=1,
                                   fr="Valeur moyenne dans l'espace physique.",
                                   ang="Mean value in the physical space."),
#
         ECART_TYPE_PHY = SIMP(statut="f",typ="R",max=1,
                                   fr="Ecart type dans l'espace physique.",
                                   ang="Standard deviation in the physical space."),
#
         regles=(AU_MOINS_UN("VALE_MOY"  ,"VALE_MOY_PHY"),
                 AU_MOINS_UN("ECART_TYPE","ECART_TYPE_PHY"),
                 EXCLUS  ("VALE_MOY"  ,"VALE_MOY_PHY"),
                 EXCLUS  ("VALE_MOY"  ,"ECART_TYPE_PHY"),
                 EXCLUS  ("ECART_TYPE","VALE_MOY_PHY"),
                 EXCLUS  ("ECART_TYPE","ECART_TYPE_PHY")),
#
       ),
#
# 7.2.3. ==> Loi uniforme
#
       b_uniforme=BLOC(condition="LOI=='UNIFORME'",
#
         VALE_MIN = SIMP(statut="o",typ="R",max=1,
                             fr="Valeur minimale.",
                             ang="Minimal value."),
#
         VALE_MAX = SIMP(statut="o",typ="R",max=1,
                             fr="Valeur maximale.",
                             ang="Maximal value."),
#
       ),
#
# 7.2.4. ==> Loi normale tronquée
#
       b_normale_tronquee=BLOC(condition="LOI=='NORMALE_TRONQUEE'",
#
         VALE_MOY   = SIMP(statut="o",typ="R",max=1,
                               fr="Valeur moyenne de la loi normale complète.",
                               ang="Mean value for the entire normal law."),
#
         ECART_TYPE = SIMP(statut="o",typ="R",max=1,
                               fr="Ecart type de la loi normale complète.",
                               ang="Standard deviation for the entire normal law."),
#
         VALE_MIN   = SIMP(statut="o",typ="R",max=1,
                               fr="Valeur minimale.",
                               ang="Minimal value."),
#
         VALE_MAX   = SIMP(statut="o",typ="R",max=1,
                               fr="Valeur maximale.",
                               ang="Maximal value."),
#
       ),
#
# 7.3. ==> Paramètres de calcul
# 7.3.1. ==> Soit on cherche le point de conception, soit on le connait deja
#
       regles=(EXCLUS("POINT_INI","POINT_CONCEPT"),
               EXCLUS("POINT_REF","POINT_CONCEPT"),),
#
# 7.3.2. ==> Quand on cherche le point de conception, on peut préciser le départ de l'algorithme.
#            Si on ne le fait pas, le programme prendra la valeur moyenne.
#
       POINT_INI = SIMP(statut="f",typ="R",max=1,
                          fr="Point de démarrage de l'algorithme itératif.",
                          ang="Initial point for iterative process."),
#
# 7.3.3. ==> Quand on cherche le point de conception, on peut préciser un point de référence pour normaliser.
#            Si on ne le fait pas, le programme prendra la valeur moyenne.
#
       POINT_REF = SIMP(statut="f",typ="R",max=1,
                          fr="Point de référence de l'algorithme itératif.",
                          ang="Reference point for iterative process."),
#
# 7.3.4. ==> Quand on cherche uniquement la probabilité de défaillance, il faut donner le point de conception
#
       POINT_CONCEPT = SIMP(statut="f",typ="R",max=1,
                              fr="Point de conception.",
                              ang="Design point."),
#
# 7.4. ==> Mode d'obtention du gradient par rapport à ce paramètre
#
       GRADIENT = SIMP(statut="o",typ="TXM",max=1,
                           into=("OUI","NON"),
                           fr="ASTER calcule directement le gradient.",
                       ang="ASTER computes the gradient for this parameter."),

       b_gradient=BLOC(condition="GRADIENT=='NON'",
         INCREMENT = SIMP(statut="o",typ="R",max=1,
                             fr="Incrément dans la direction.",
                         ang="Direction increment."),
       ),

   ),
#
);
#& MODIF COMMANDE  DATE 22/06/2005   AUTEUR REZETTE C.REZETTE 
#            CONFIGURATION MANAGEMENT OF EDF VERSION
# ======================================================================
# COPYRIGHT (C) 1991 - 2004  EDF R&D                  WWW.CODE-ASTER.ORG
# THIS PROGRAM IS FREE SOFTWARE; YOU CAN REDISTRIBUTE IT AND/OR MODIFY  
# IT UNDER THE TERMS OF THE GNU GENERAL PUBLIC LICENSE AS PUBLISHED BY  
# THE FREE SOFTWARE FOUNDATION; EITHER VERSION 2 OF THE LICENSE, OR     
# (AT YOUR OPTION) ANY LATER VERSION.                                                  
#                                                                       
# THIS PROGRAM IS DISTRIBUTED IN THE HOPE THAT IT WILL BE USEFUL, BUT   
# WITHOUT ANY WARRANTY; WITHOUT EVEN THE IMPLIED WARRANTY OF            
# MERCHANTABILITY OR FITNESS FOR A PARTICULAR PURPOSE. SEE THE GNU      
# GENERAL PUBLIC LICENSE FOR MORE DETAILS.                              
#                                                                       
# YOU SHOULD HAVE RECEIVED A COPY OF THE GNU GENERAL PUBLIC LICENSE     
# ALONG WITH THIS PROGRAM; IF NOT, WRITE TO EDF R&D CODE_ASTER,         
#    1 AVENUE DU GENERAL DE GAULLE, 92141 CLAMART CEDEX, FRANCE.        
# ======================================================================
# RESPONSABLE GNICOLAS G.NICOLAS

from Macro.macr_fiab_impr_ops import macr_fiab_impr_ops

MACR_FIAB_IMPR=MACRO(nom="MACR_FIAB_IMPR",op=macr_fiab_impr_ops,
                     docu="U7.04.41",UIinfo={"groupe":("Impression",)},
                     fr="Imprimer les valeurs à transmettre au logiciel de fiabilité.",
                     ang="Print values for the fiability software",
#
# 1. Le niveau d'information
#
   INFO           = SIMP(statut='f',typ='I',defaut=1,into=(1,2)),
#
# 2. Impression de la valeur de la cible
#
# 2.1. ==> La table contenant la valeur à imprimer
#
   TABLE_CIBLE = SIMP(statut='o',typ=table_sdaster,
                 fr="Table contenant la valeur cible.",
                 ang="Table which includes the target value."),
#
# 2.2. ==> Le nom du paramètre associé à la valeur cible dans cette table
#
   NOM_PARA_CIBLE = SIMP(statut='o',typ='TXM',
                    fr="Nom du paramètre associé à la valeur cible.",
                    ang="Name of the parameter connected to the target value."),
#
# 3. Impressions des valeurs des éventuels gradients
#
   GRADIENTS = FACT(statut='f',min=1,max='**',
#
# 3.1. ==> La table contenant la valeur à imprimer
#
       TABLE = SIMP(statut='o',typ=table_sdaster,
                    fr="Table contenant le gradient.",
                    ang="Table which includes the gradient."),
#
# 3.2. ==> Le paramètre sensible
#
       PARA_SENSI = SIMP(statut='o',typ=(para_sensi,theta_geom),
                       fr="Paramètre sensible associé au gradient.",
                       ang="Sensitivity parameter connected to the gradient."),
#
# 3.3. ==> Le nom du paramètre associé au gradient dans cette table
#
       NOM_PARA = SIMP(statut='o',typ='TXM',
                       fr="Nom du paramètre associé au gradient.",
                       ang="Name of the parameter connected to the gradient."),
#
         ),
#
);
#& MODIF COMMANDE  DATE 30/10/2006   AUTEUR DURAND C.DURAND 
#            CONFIGURATION MANAGEMENT OF EDF VERSION
# ======================================================================
# COPYRIGHT (C) 1991 - 2001  EDF R&D                  WWW.CODE-ASTER.ORG
# THIS PROGRAM IS FREE SOFTWARE; YOU CAN REDISTRIBUTE IT AND/OR MODIFY
# IT UNDER THE TERMS OF THE GNU GENERAL PUBLIC LICENSE AS PUBLISHED BY
# THE FREE SOFTWARE FOUNDATION; EITHER VERSION 2 OF THE LICENSE, OR   
# (AT YOUR OPTION) ANY LATER VERSION.                                 
#
# THIS PROGRAM IS DISTRIBUTED IN THE HOPE THAT IT WILL BE USEFUL, BUT 
# WITHOUT ANY WARRANTY; WITHOUT EVEN THE IMPLIED WARRANTY OF          
# MERCHANTABILITY OR FITNESS FOR A PARTICULAR PURPOSE. SEE THE GNU    
# GENERAL PUBLIC LICENSE FOR MORE DETAILS.                            
#
# YOU SHOULD HAVE RECEIVED A COPY OF THE GNU GENERAL PUBLIC LICENSE   
# ALONG WITH THIS PROGRAM; IF NOT, WRITE TO EDF R&D CODE_ASTER,       
#    1 AVENUE DU GENERAL DE GAULLE, 92141 CLAMART CEDEX, FRANCE.      
# ======================================================================
# RESPONSABLE GNICOLAS G.NICOLAS

from Macro.macr_adap_mail_ops import macr_adap_mail_ops

MACR_INFO_MAIL=MACRO(nom="MACR_INFO_MAIL",op=macr_adap_mail_ops,
                     docu="U7.03.02-b",UIinfo={"groupe":("Maillage",)},
                     fr="Donner des informations sur un maillage.",
                     ang="To give information about a mesh.",
#
# 1. Le niveau d'information
#
  INFO = SIMP(statut='f',typ='I',defaut=1,into=(1,2)),
#
# 2. Version de HOMARD
#
  VERSION_HOMARD = SIMP(statut='f',typ='TXM',defaut="V8_5",
                        into=("V8_5", "V8_N", "V8_N_PERSO"),
                        fr="Version de HOMARD",
                        ang="HOMARD release"),
#
# 3. Langue des messages issus de HOMARD
#
  LANGUE = SIMP(statut='f',typ='TXM',defaut="FRANCAIS",    
                into=("FRANCAIS","FRENCH","ANGLAIS","ENGLISH",),
                fr="Langue des messages issus de HOMARD.",
                ang="Language for HOMARD messages." ),
#
# 4. Le nom du maillage a analyser
#
  MAILLAGE = SIMP(statut='o',typ=maillage_sdaster,
                  fr="Maillage à analyser.",
                  ang="Mesh to be checked." ),
#
# 5. Suivi d'une frontiere
#
  MAILLAGE_FRONTIERE = SIMP(statut='f',typ=maillage_sdaster,
                           fr="Maillage de la frontiere à suivre",
                           ang="Boundary mesh" ),
#
  b_frontiere = BLOC( condition = " MAILLAGE_FRONTIERE != None " ,
                      fr="Information complémentaire sur la frontière",
                      ang="Further information about boundary",
#
    GROUP_MA = SIMP(statut='f',typ=grma,validators=NoRepeat(),max='**',
                    fr="Groupes de mailles définissant la frontière",
                    ang="Mesh groups which define the boundary" ),
#
                    ) ,
#
# 6. Les options ; par defaut, on controle tout
# 6.1. Nombre de noeuds et elements
#
  NOMBRE         = SIMP(statut='f',typ='TXM',defaut="OUI",into=("OUI","NON"),
                        fr="Nombre de noeuds et éléments du maillage",
                        ang="Number of nodes and elements in the mesh" ),
#
# 6.2. Determination de la qualite des elements du maillage
#
  QUALITE        = SIMP(statut='f',typ='TXM',defaut="OUI",into=("OUI","NON"),
                        fr="Qualité du maillage",
                        ang="Mesh quality" ),
#
# 6.3. Connexite du maillage
#
  CONNEXITE      = SIMP(statut='f',typ='TXM',defaut="OUI",into=("OUI","NON"),
                        fr="Connexité du maillage.",
                        ang="Mesh connexity." ),
#
# 6.4. Taille des sous-domaines du maillage
#
  TAILLE         = SIMP(statut='f',typ='TXM',defaut="OUI",into=("OUI","NON"),
                        fr="Tailles des sous-domaines du maillage.",
                        ang="Sizes of mesh sub-domains." ),
#
# 6.5. Controle de la non-interpenetration des elements
#
  INTERPENETRATION=SIMP(statut='f',typ='TXM',defaut="NON",into=("OUI","NON"),
                        fr="Controle de la non interpénétration des éléments.",
                        ang="Overlapping checking." ),
#
# 7. Gestion des éléments autres que ceux compatibles avec HOMARD
#       "REFUSER" : ils sont refuses (defaut)
#       "IGNORER" : ils sont ignorés
#
  ELEMENTS_NON_HOMARD = SIMP(statut='f',typ='TXM',defaut="REFUSER",into=("REFUSER","IGNORER"),
                             fr="Acceptation d'éléments incompatibles avec HOMARD",
                             ang="Incompatible elements for HOMARD" ),
)  ;
#& MODIF COMMANDE  DATE 09/05/2006   AUTEUR GALENNE E.GALENNE 
#            CONFIGURATION MANAGEMENT OF EDF VERSION
# ======================================================================
# COPYRIGHT (C) 1991 - 2002  EDF R&D                  WWW.CODE-ASTER.ORG
# THIS PROGRAM IS FREE SOFTWARE; YOU CAN REDISTRIBUTE IT AND/OR MODIFY  
# IT UNDER THE TERMS OF THE GNU GENERAL PUBLIC LICENSE AS PUBLISHED BY  
# THE FREE SOFTWARE FOUNDATION; EITHER VERSION 2 OF THE LICENSE, OR     
# (AT YOUR OPTION) ANY LATER VERSION.                                                  
#                                                                       
# THIS PROGRAM IS DISTRIBUTED IN THE HOPE THAT IT WILL BE USEFUL, BUT   
# WITHOUT ANY WARRANTY; WITHOUT EVEN THE IMPLIED WARRANTY OF            
# MERCHANTABILITY OR FITNESS FOR A PARTICULAR PURPOSE. SEE THE GNU      
# GENERAL PUBLIC LICENSE FOR MORE DETAILS.                              
#                                                                       
# YOU SHOULD HAVE RECEIVED A COPY OF THE GNU GENERAL PUBLIC LICENSE     
# ALONG WITH THIS PROGRAM; IF NOT, WRITE TO EDF R&D CODE_ASTER,         
#    1 AVENUE DU GENERAL DE GAULLE, 92141 CLAMART CEDEX, FRANCE.        
# ======================================================================

from Macro.macr_lign_coupe_ops import macr_lign_coupe_ops

MACR_LIGN_COUPE=MACRO(nom="MACR_LIGN_COUPE",op=macr_lign_coupe_ops,sd_prod=table_sdaster,
                       reentrant='n',
            UIinfo={"groupes":("Outils métier",)},
            fr="Extraction des valeurs d'un résultat dans une ou plusieurs tables sur des lignes de coupe définies"
             +" par deux points et un intervalle",
         RESULTAT        =SIMP(statut='o',typ=(evol_elas,evol_noli,evol_ther) ),
# extraction des résultats
         b_meca        =BLOC(condition = "AsType(RESULTAT) in (evol_elas,evol_noli)",fr="résultat mécanique",
           NOM_CHAM        =SIMP(statut='f',typ='TXM',defaut='SIGM_NOEU_DEPL' ),  
         ),
         b_ther        =BLOC(condition = "AsType(RESULTAT) in (evol_ther,)",fr="résultat thermique",
           NOM_CHAM        =SIMP(statut='f',typ='TXM',defaut='TEMP' ),  
         ),
         UNITE_MAILLAGE  =SIMP(statut='f',typ='I',defaut=25),  
         MODELE          =SIMP(statut='f',typ=modele_sdaster ),
         GROUP_MA        =SIMP(statut='f',typ=grma),
         MAILLE          =SIMP(statut='f',typ=ma,max='**'),
         regles=(EXCLUS('GROUP_MA','MAILLE'),),
         LIGN_COUPE     =FACT(statut='o',max='**',
           regles=(UN_PARMI('NB_POINTS','GROUP_NO'),),
           INTITULE        =SIMP(statut='f',typ='TXM',),
           GROUP_NO        =SIMP(statut='f',typ=grno),
           NB_POINTS       =SIMP(statut='f',typ='I'),
           b_nbpts = BLOC(condition = "NB_POINTS != None",
              COOR_ORIG       =SIMP(statut='o',typ='R',min=2,max=3),  
              COOR_EXTR       =SIMP(statut='o',typ='R',min=2,max=3),
              VECT_Y          =SIMP(statut='f',typ='R',min=2,max=3),), 
         ),
)  ;


#& MODIF COMMANDE  DATE 04/04/2006   AUTEUR CIBHHLV L.VIVAN 
#            CONFIGURATION MANAGEMENT OF EDF VERSION
# ======================================================================
# COPYRIGHT (C) 1991 - 2001  EDF R&D                  WWW.CODE-ASTER.ORG
# THIS PROGRAM IS FREE SOFTWARE; YOU CAN REDISTRIBUTE IT AND/OR MODIFY
# IT UNDER THE TERMS OF THE GNU GENERAL PUBLIC LICENSE AS PUBLISHED BY
# THE FREE SOFTWARE FOUNDATION; EITHER VERSION 2 OF THE LICENSE, OR   
# (AT YOUR OPTION) ANY LATER VERSION.                                 
#
# THIS PROGRAM IS DISTRIBUTED IN THE HOPE THAT IT WILL BE USEFUL, BUT 
# WITHOUT ANY WARRANTY; WITHOUT EVEN THE IMPLIED WARRANTY OF          
# MERCHANTABILITY OR FITNESS FOR A PARTICULAR PURPOSE. SEE THE GNU    
# GENERAL PUBLIC LICENSE FOR MORE DETAILS.                            
#
# YOU SHOULD HAVE RECEIVED A COPY OF THE GNU GENERAL PUBLIC LICENSE   
# ALONG WITH THIS PROGRAM; IF NOT, WRITE TO EDF R&D CODE_ASTER,       
#    1 AVENUE DU GENERAL DE GAULLE, 92141 CLAMART CEDEX, FRANCE.      
# ======================================================================
# RESPONSABLE G8BHHXD X.DESROCHES

from Macro.macro_elas_mult_ops import macro_elas_mult_ops

def macro_elas_mult_prod(self,NUME_DDL,CAS_CHARGE,**args ):
  if isinstance(NUME_DDL,CO) :
    self.type_sdprod(NUME_DDL,nume_ddl_sdaster)
  else:
    self.type_sdprod(NUME_DDL,NUME_DDL.__class__)
  if CAS_CHARGE[0]['NOM_CAS']      != None : return mult_elas
  if CAS_CHARGE[0]['MODE_FOURIER'] != None : return fourier_elas
  raise AsException("type de concept resultat non prevu")

MACRO_ELAS_MULT=MACRO(nom="MACRO_ELAS_MULT",op=macro_elas_mult_ops,sd_prod=macro_elas_mult_prod,reentrant='f',
            UIinfo={"groupes":("Résolution",)},
         fr="Calculer les réponses statiques linéaires pour différents cas de charges ou modes de Fourier",
         regles=(UN_PARMI('CHAR_MECA_GLOBAL','CHAR_CINE_GLOBAL','LIAISON_DISCRET', ),),
         MODELE          =SIMP(statut='o',typ=modele_sdaster),
         CHAM_MATER      =SIMP(statut='f',typ=cham_mater),
         CARA_ELEM       =SIMP(statut='f',typ=cara_elem),
         NUME_DDL        =SIMP(statut='f',typ=(nume_ddl_sdaster,CO)),
         CHAR_MECA_GLOBAL=SIMP(statut='f',typ=char_meca,validators=NoRepeat(),max='**'),
         CHAR_CINE_GLOBAL=SIMP(statut='f',typ=char_meca,validators=NoRepeat(),max='**'),
         LIAISON_DISCRET =SIMP(statut='f',typ='TXM',into=("OUI",)),
         CAS_CHARGE      =FACT(statut='o',max='**',
           regles=(UN_PARMI('NOM_CAS','MODE_FOURIER'),
                   UN_PARMI('CHAR_MECA','CHAR_CINE','VECT_ASSE'),),
           NOM_CAS         =SIMP(statut='f',typ='TXM' ),
           MODE_FOURIER    =SIMP(statut='f',typ='I' ),
           TYPE_MODE       =SIMP(statut='f',typ='TXM',defaut="SYME",into=("SYME","ANTI","TOUS") ),
           CHAR_MECA       =SIMP(statut='f',typ=char_meca,validators=NoRepeat(),max='**'),
           CHAR_CINE       =SIMP(statut='f',typ=char_meca,validators=NoRepeat(),max='**'),
           OPTION          =SIMP(statut='f',typ='TXM',validators=NoRepeat(),max='**',
                                 into=("EFGE_ELNO_DEPL","EPOT_ELEM_DEPL","SIGM_ELNO_DEPL","SIEF_ELGA_DEPL",
                                       "SIGM_ELNO_CART","EFGE_ELNO_CART","DEGE_ELNO_DEPL","EPSI_ELNO_DEPL",
                                       "EPSI_ELGA_DEPL","EPSG_ELNO_DEPL","EPSG_ELGA_DEPL","EPSP_ELNO","EPSP_ELGA",
                                       "ECIN_ELEM_DEPL","FLUX_ELGA_TEMP","FLUX_ELNO_TEMP","SOUR_ELGA_ELEC",
                                       "PRES_ELNO_DBEL","PRES_ELNO_REEL","PRES_ELNO_IMAG","INTE_ELNO_ACTI",
                                       "INTE_ELNO_REAC","SIGM_NOZ1_ELGA","ERZ1_ELEM_SIGM","SIGM_NOZ2_ELGA",
                                       "ERZ2_ELEM_SIGM","VNOR_ELEM_DEPL","ERRE_ELNO_ELEM","SIRE_ELNO_DEPL",
                                       "ERRE_ELEM_SIGM","EQUI_ELNO_SIGM","EQUI_ELGA_SIGM","EQUI_ELNO_EPSI",
                                       "QIRE_ELEM_SIGM","QIRE_ELNO_ELEM","QIZ1_ELEM_SIGM","QIZ2_ELEM_SIGM",
                                       "EQUI_ELGA_EPSI","FORC_NODA","REAC_NODA","EPSI_NOEU_DEPL","SIGM_NOEU_DEPL",
                                       "EFGE_NOEU_DEPL","EQUI_NOEU_SIGM","EQUI_NOEU_EPSI","FLUX_NOEU_TEMP") ),
           NUME_COUCHE     =SIMP(statut='f',typ='I',defaut=1),
           NIVE_COUCHE     =SIMP(statut='f',typ='TXM',defaut="MOY",into=("SUP","INF","MOY")),
           SOUS_TITRE      =SIMP(statut='f',typ='TXM',max='**'),
           VECT_ASSE       =SIMP(statut='f',typ=cham_no_sdaster),
         ),
         SOLVEUR         =FACT(statut='d',
           METHODE         =SIMP(statut='f',typ='TXM',defaut="MULT_FRONT",into=("MULT_FRONT","LDLT") ),
           b_mult_front    = BLOC ( condition = "METHODE == 'MULT_FRONT' ",
                                    fr="Paramètres de la méthode multi frontale",
             RENUM           =SIMP(statut='f',typ='TXM',defaut="METIS",into=("MD","MDA","METIS") ),
           ),
           b_ldlt          =BLOC(condition = "METHODE == 'LDLT' ",fr="Paramètres de la méthode LDLT",
             RENUM           =SIMP(statut='f',typ='TXM',defaut="RCMK",into=("RCMK","SANS") ),
            ),
           b_ldlt_mult     =BLOC(condition = "METHODE == 'LDLT' or METHODE == 'MULT_FRONT' ",
                                   fr="Paramètres relatifs à la non inversibilité de la matrice à factorise",
             NPREC           =SIMP(statut='f',typ='I',defaut= 8 ),
             STOP_SINGULIER  =SIMP(statut='f',typ='TXM',defaut="OUI",into=("OUI","NON") ),
           ),
         ),
         INFO            =SIMP(statut='f',typ='I',defaut= 1,into=(1,2)),
         TITRE           =SIMP(statut='f',typ='TXM',max='**'),
)  ;
#& MODIF COMMANDE  DATE 21/02/2006   AUTEUR REZETTE C.REZETTE 
#            CONFIGURATION MANAGEMENT OF EDF VERSION
# ======================================================================
# COPYRIGHT (C) 1991 - 2001  EDF R&D                  WWW.CODE-ASTER.ORG
# THIS PROGRAM IS FREE SOFTWARE; YOU CAN REDISTRIBUTE IT AND/OR MODIFY
# IT UNDER THE TERMS OF THE GNU GENERAL PUBLIC LICENSE AS PUBLISHED BY
# THE FREE SOFTWARE FOUNDATION; EITHER VERSION 2 OF THE LICENSE, OR   
# (AT YOUR OPTION) ANY LATER VERSION.                                 
#
# THIS PROGRAM IS DISTRIBUTED IN THE HOPE THAT IT WILL BE USEFUL, BUT 
# WITHOUT ANY WARRANTY; WITHOUT EVEN THE IMPLIED WARRANTY OF          
# MERCHANTABILITY OR FITNESS FOR A PARTICULAR PURPOSE. SEE THE GNU    
# GENERAL PUBLIC LICENSE FOR MORE DETAILS.                            
#
# YOU SHOULD HAVE RECEIVED A COPY OF THE GNU GENERAL PUBLIC LICENSE   
# ALONG WITH THIS PROGRAM; IF NOT, WRITE TO EDF R&D CODE_ASTER,       
#    1 AVENUE DU GENERAL DE GAULLE, 92141 CLAMART CEDEX, FRANCE.      
# ======================================================================

from Macro.macro_matr_ajou_ops import macro_matr_ajou_ops

def macro_matr_ajou_prod(self,MATR_AMOR_AJOU,MATR_MASS_AJOU,MATR_RIGI_AJOU,FORC_AJOU,**args):
  self.type_sdprod(MATR_AMOR_AJOU,matr_asse_gene_r)
  self.type_sdprod(MATR_MASS_AJOU,matr_asse_gene_r)
  self.type_sdprod(MATR_RIGI_AJOU,matr_asse_gene_r)
  if FORC_AJOU != None:
    for m in FORC_AJOU:
      self.type_sdprod(m['VECTEUR'],vect_asse_gene)

  return None

MACRO_MATR_AJOU=MACRO(nom="MACRO_MATR_AJOU",op=macro_matr_ajou_ops,sd_prod=macro_matr_ajou_prod,
            UIinfo={"groupes":("Matrices/vecteurs",)},
            fr="Calculer de facon plus condensée qu'avec CALC_MATR_AJOU des matrices de masse, d'amortissement"
              +" ou de rigidité ajoutés",
      regles=(AU_MOINS_UN('MODE_MECA','DEPL_IMPO','MODELE_GENE'),
              AU_MOINS_UN('MATR_MASS_AJOU','MATR_AMOR_AJOU','MATR_RIGI_AJOU'),
              EXCLUS('MODE_MECA','DEPL_IMPO','MODELE_GENE'),
              EXCLUS('MONO_APPUI','MODE_STAT',),
             ),
         MAILLAGE        =SIMP(statut='o',typ=maillage_sdaster),
         GROUP_MA_FLUIDE =SIMP(statut='o',typ=grma),
         GROUP_MA_INTERF =SIMP(statut='o',typ=grma),
         MODELISATION    =SIMP(statut='o',typ='TXM',into=("PLAN","AXIS","3D")),
         FLUIDE          =FACT(statut='o',max='**',
           RHO             =SIMP(statut='o',typ='R'),
           TOUT            =SIMP(statut='f',typ='TXM',into=("OUI",)),
           GROUP_MA        =SIMP(statut='f',typ=grma),
           MAILLE          =SIMP(statut='f',typ=ma),
         ),
         DDL_IMPO        =FACT(statut='o',max='**',
           regles=(UN_PARMI('NOEUD','GROUP_NO'),
                   UN_PARMI('PRES_FLUIDE','PRES_SORTIE'),),
           NOEUD           =SIMP(statut='f',typ=no),
           GROUP_NO        =SIMP(statut='f',typ=grno),
           PRES_FLUIDE     =SIMP(statut='f',typ='R'),
           PRES_SORTIE     =SIMP(statut='f',typ='R'),
         ),
         ECOULEMENT      =FACT(statut='f',
           GROUP_MA_1      =SIMP(statut='o',typ=grma),
           GROUP_MA_2      =SIMP(statut='o',typ=grma),
           VNOR_1          =SIMP(statut='o',typ='R'),
           VNOR_2          =SIMP(statut='f',typ='R'),
           POTENTIEL       =SIMP(statut='f',typ=evol_ther),
         ),
         MODE_MECA       =SIMP(statut='f',typ=mode_meca),
         DEPL_IMPO       =SIMP(statut='f',typ=cham_no_sdaster),
         MODELE_GENE     =SIMP(statut='f',typ=modele_gene),
         NUME_DDL_GENE   =SIMP(statut='f',typ=nume_ddl_gene),
         DIST_REFE       =SIMP(statut='f',typ='R',defaut= 1.0E-2),
         MATR_MASS_AJOU  =SIMP(statut='f',typ=CO,),
         MATR_RIGI_AJOU  =SIMP(statut='f',typ=CO,),
         MATR_AMOR_AJOU  =SIMP(statut='f',typ=CO,),
         MONO_APPUI      =SIMP(statut='f',typ='TXM',into=("OUI",),),
         MODE_STAT       =SIMP(statut='f',typ=(mode_stat_depl,mode_stat_acce,mode_stat_forc,),),
         FORC_AJOU       =FACT(statut='f',max='**',
           DIRECTION     =SIMP(statut='o',typ='R',max=3),
           NOEUD         =SIMP(statut='f',typ=no  ,validators=NoRepeat(),max='**'),
           GROUP_NO      =SIMP(statut='f',typ=grno,validators=NoRepeat(),max='**'),
           VECTEUR       =SIMP(statut='o',typ=CO),
         ),
         SOLVEUR         =FACT(statut='d',
           METHODE         =SIMP(statut='f',typ='TXM',defaut="MULT_FRONT",into=("MULT_FRONT","LDLT","GCPC") ),
           b_mult_front    =BLOC(condition = "METHODE == 'MULT_FRONT' ",fr="Paramètres de la méthode multi frontale",
             RENUM           =SIMP(statut='f',typ='TXM',defaut="METIS",into=("MD","MDA","METIS") ),
           ),
           b_ldlt         =BLOC(condition = "METHODE == 'LDLT' ",fr="Paramètres de la méthode LDLT",
             RENUM           =SIMP(statut='f',typ='TXM',defaut="RCMK",into=("RCMK","SANS") ),
           ),
           b_ldlt_mult    =BLOC(condition = "METHODE == 'LDLT' or METHODE == 'MULT_FRONT' ",
                                   fr="Paramètres relatifs à la non iversibilité de la matrice à factorise",
             NPREC           =SIMP(statut='f',typ='I',defaut= 8 ),
             STOP_SINGULIER  =SIMP(statut='f',typ='TXM',defaut="OUI",into=("OUI","NON") ),
           ),
           b_gcpc          =BLOC(condition = "METHODE == 'GCPC' ", fr="Paramètres de la méthode du gradient conjugué",
             PRE_COND        =SIMP(statut='f',typ='TXM',into=("LDLT_INC",),defaut="LDLT_INC" ),
             NIVE_REMPLISSAGE=SIMP(statut='f',typ='I',defaut= 0 ),
             RENUM           =SIMP(statut='f',typ='TXM',defaut="RCMK",into=("SANS","RCMK") ),
             RESI_RELA       =SIMP(statut='f',typ='R',defaut= 1.E-6 ),
             NMAX_ITER       =SIMP(statut='f',typ='I',defaut= 0 ),
           ),
         ),
         INFO            =SIMP(statut='f',typ='I',defaut=1,into=(1,2)),
         NOEUD_DOUBLE    =SIMP(statut='f',typ='TXM',defaut="NON",into=("OUI","NON")),
         AVEC_MODE_STAT  =SIMP(statut='f',typ='TXM',defaut="OUI",into=("OUI","NON")),
)
#& MODIF COMMANDE  DATE 12/06/2006   AUTEUR CIBHHLV L.VIVAN 
#            CONFIGURATION MANAGEMENT OF EDF VERSION
# ======================================================================
# COPYRIGHT (C) 1991 - 2001  EDF R&D                  WWW.CODE-ASTER.ORG
# THIS PROGRAM IS FREE SOFTWARE; YOU CAN REDISTRIBUTE IT AND/OR MODIFY
# IT UNDER THE TERMS OF THE GNU GENERAL PUBLIC LICENSE AS PUBLISHED BY
# THE FREE SOFTWARE FOUNDATION; EITHER VERSION 2 OF THE LICENSE, OR
# (AT YOUR OPTION) ANY LATER VERSION.
#
# THIS PROGRAM IS DISTRIBUTED IN THE HOPE THAT IT WILL BE USEFUL, BUT
# WITHOUT ANY WARRANTY; WITHOUT EVEN THE IMPLIED WARRANTY OF
# MERCHANTABILITY OR FITNESS FOR A PARTICULAR PURPOSE. SEE THE GNU
# GENERAL PUBLIC LICENSE FOR MORE DETAILS.
#
# YOU SHOULD HAVE RECEIVED A COPY OF THE GNU GENERAL PUBLIC LICENSE
# ALONG WITH THIS PROGRAM; IF NOT, WRITE TO EDF R&D CODE_ASTER,
#    1 AVENUE DU GENERAL DE GAULLE, 92141 CLAMART CEDEX, FRANCE.
# ======================================================================

from Macro.macro_matr_asse_ops import macro_matr_asse_ops

def macro_matr_asse_prod(self,NUME_DDL,MATR_ASSE,**args):
  if not MATR_ASSE:  raise AsException("Impossible de typer les concepts resultats")
  if not NUME_DDL :  raise AsException("Impossible de typer les concepts resultats")
  if isinstance(NUME_DDL,CO) :
    self.type_sdprod(NUME_DDL,nume_ddl_sdaster)
  else:
    self.type_sdprod(NUME_DDL,NUME_DDL.__class__)
  for m in MATR_ASSE:
    opti=m['OPTION']

    if opti in ( "RIGI_MECA","RIGI_FLUI_STRU","RIGI_MECA_LAGR" ,
       "MASS_MECA" , "MASS_FLUI_STRU" ,"RIGI_GEOM" ,"RIGI_ROTA",
       "AMOR_MECA","IMPE_MECA","MASS_ID_MDEP_R","MASS_ID_MDNS_R",
       "ONDE_FLUI","MASS_MECA_DIAG" ) : t=matr_asse_depl_r

    if opti in ( "RIGI_ACOU","MASS_ACOU","AMOR_ACOU",) : t=matr_asse_pres_c

    if opti in ( "RIGI_THER","MASS_THER","RIGI_THER_CONV" ,
       "RIGI_THER_CONV_D","MASS_ID_MTEM_R","MASS_ID_MTNS_R",) : t=matr_asse_temp_r

    if opti == "RIGI_MECA_HYST"   : t= matr_asse_depl_c

    self.type_sdprod(m['MATRICE'],t)
  return None

MACRO_MATR_ASSE=MACRO(nom="MACRO_MATR_ASSE",op=macro_matr_asse_ops,
            UIinfo={"groupes":("Matrices/vecteurs",)},
                      sd_prod=macro_matr_asse_prod,
                      fr="Calcul des matrices assemblées (rigidité, masse, amortissement,...) ",
         MODELE          =SIMP(statut='o',typ=modele_sdaster),
         CHAM_MATER      =SIMP(statut='f',typ=cham_mater),
         INST            =SIMP(statut='f',typ='R',defaut=0.),
         CARA_ELEM       =SIMP(statut='f',typ=cara_elem),
         CHARGE          =SIMP(statut='f',typ=(char_meca,char_ther,char_acou),validators=NoRepeat(),max='**'),
         CHAR_CINE       =SIMP(statut='f',typ=(char_cine_meca,char_cine_ther,char_cine_acou) ),
         NUME_DDL        =SIMP(statut='o',typ=(nume_ddl_sdaster,CO)),
         SOLVEUR         =FACT(statut='d',
           METHODE         =SIMP(statut='f',typ='TXM',defaut="MULT_FRONT",
                                 into=("LDLT","MULT_FRONT","GCPC","MUMPS")),
           RENUM           =SIMP(statut='f',typ='TXM',into=("SANS","RCMK","MD","MDA","METIS")),
         ),

         MATR_ASSE       =FACT(statut='o',max='**',
             MATRICE         =SIMP(statut='o',typ=CO),
             OPTION          =SIMP(statut='o',typ='TXM',
                                   into=("RIGI_MECA","MASS_MECA","MASS_MECA_DIAG",
                                         "AMOR_MECA","RIGI_MECA_HYST","IMPE_MECA",
                                         "ONDE_FLUI","RIGI_FLUI_STRU","MASS_FLUI_STRU",
                                         "RIGI_ROTA","RIGI_GEOM","RIGI_MECA_LAGR",
                                         "RIGI_THER","MASS_THER",
                                         "RIGI_ACOU","MASS_ACOU","AMOR_ACOU",
                                         "MASS_ID_MTEM_R","MASS_ID_MTNS_R","MASS_ID_MDEP_R","MASS_ID_MDNS_R",)
                                   ),

             b_rigi_meca = BLOC( condition = "OPTION=='RIGI_MECA'",
               MODE_FOURIER    =SIMP(statut='f',typ='I',defaut= 0),
             ),

             b_rigi_geom = BLOC( condition = "OPTION=='RIGI_GEOM'",
               SIEF_ELGA       =SIMP(statut='o',typ=cham_elem),
               MODE_FOURIER    =SIMP(statut='f',typ='I',defaut= 0),
             ),

             b_rigi_meca_lagr = BLOC( condition = "OPTION=='RIGI_MECA_LAGR'",
               THETA           =SIMP(statut='o',typ=theta_geom),
               PROPAGATION     =SIMP(statut='f',typ='R'),
             ),

             b_rigi_ther = BLOC( condition = "OPTION=='RIGI_THER'",
               MODE_FOURIER    =SIMP(statut='f',typ='I',defaut= 0),
             ),

         ), # fin MATR_ASSE

         TITRE           =SIMP(statut='f',typ='TXM',max='**'),
         INFO            =SIMP(statut='f',typ='I',defaut=1,into=(1,2)),
)  ;
#& MODIF COMMANDE  DATE 19/09/2006   AUTEUR ACBHHCD G.DEVESA 
#            CONFIGURATION MANAGEMENT OF EDF VERSION
# ======================================================================
# COPYRIGHT (C) 1991 - 2001  EDF R&D                  WWW.CODE-ASTER.ORG
# THIS PROGRAM IS FREE SOFTWARE; YOU CAN REDISTRIBUTE IT AND/OR MODIFY
# IT UNDER THE TERMS OF THE GNU GENERAL PUBLIC LICENSE AS PUBLISHED BY
# THE FREE SOFTWARE FOUNDATION; EITHER VERSION 2 OF THE LICENSE, OR   
# (AT YOUR OPTION) ANY LATER VERSION.                                 
#
# THIS PROGRAM IS DISTRIBUTED IN THE HOPE THAT IT WILL BE USEFUL, BUT 
# WITHOUT ANY WARRANTY; WITHOUT EVEN THE IMPLIED WARRANTY OF          
# MERCHANTABILITY OR FITNESS FOR A PARTICULAR PURPOSE. SEE THE GNU    
# GENERAL PUBLIC LICENSE FOR MORE DETAILS.                            
#
# YOU SHOULD HAVE RECEIVED A COPY OF THE GNU GENERAL PUBLIC LICENSE   
# ALONG WITH THIS PROGRAM; IF NOT, WRITE TO EDF R&D CODE_ASTER,       
#    1 AVENUE DU GENERAL DE GAULLE, 92141 CLAMART CEDEX, FRANCE.      
# ======================================================================

from Macro.macro_miss_3d_ops import macro_miss_3d_ops

MACRO_MISS_3D=MACRO(nom="MACRO_MISS_3D",op=macro_miss_3d_ops,
            fr="Préparation des données puis exécution du logiciel MISS3D",
            UIinfo={"groupes":("Matrices/vecteurs",)},
         OPTION          =FACT(statut='o',
           regles=(UN_PARMI('TOUT','MODULE'),),
           TOUT            =SIMP(statut='f',typ='TXM',into=("OUI",)),
           MODULE          =SIMP(statut='f',typ='TXM',into=("PRE_MISS","MISS_EVOL","MISS_IMPE")),
         ),
         PROJET          =SIMP(statut='o',typ='TXM'),  
         REPERTOIRE      =SIMP(statut='f',typ='TXM'),
         VERSION         =SIMP(statut='f',typ='TXM',into=("V1_2","V1_3",),defaut="V1_2"),
         UNITE_IMPR_ASTER=SIMP(statut='f',typ='I',defaut=25),  
         UNITE_OPTI_MISS =SIMP(statut='f',typ='I',defaut=26),  
         UNITE_MODELE_SOL=SIMP(statut='f',typ='I',defaut=27),  
         UNITE_RESU_IMPE =SIMP(statut='f',typ='I',defaut=30),
         UNITE_RESU_FORC =SIMP(statut='f',typ='I',defaut=0),
         PARAMETRE       =FACT(statut='f',         
           regles=(PRESENT_PRESENT('FREQ_MIN','FREQ_MAX','FREQ_PAS'),
                   PRESENT_PRESENT('CONTR_NB','CONTR_LISTE'),
                   PRESENT_PRESENT('LFREQ_NB','LFREQ_LISTE'),
                   PRESENT_PRESENT('OFFSET_MAX','OFFSET_NB'),
                   PRESENT_PRESENT('SPEC_MAX','SPEC_NB'),),
           FREQ_MIN        =SIMP(statut='f',typ='R'), 
           FREQ_MAX        =SIMP(statut='f',typ='R'),
           FREQ_PAS        =SIMP(statut='f',typ='R'),
           Z0              =SIMP(statut='f',typ='R'), 
           SURF            =SIMP(statut='f',typ='TXM',into=("OUI","NON",),defaut="NON"),
           RFIC            =SIMP(statut='f',typ='R'),
           FICH_RESU_IMPE  =SIMP(statut='f',typ='TXM'),
           FICH_RESU_FORC  =SIMP(statut='f',typ='TXM'),
           TYPE            =SIMP(statut='f',typ='TXM',into=("BINAIRE","ASCII",),defaut="ASCII"),
           DREF            =SIMP(statut='f',typ='R'),
           ALGO            =SIMP(statut='f',typ='TXM',into=("DEPL","REGU")),
           OFFSET_MAX      =SIMP(statut='f',typ='R'),
           OFFSET_NB       =SIMP(statut='f',typ='I'),
           SPEC_MAX        =SIMP(statut='f',typ='R'),
           SPEC_NB         =SIMP(statut='f',typ='I'),
           ISSF            =SIMP(statut='f',typ='TXM',into=("OUI","NON",),defaut="NON"),
           FICH_POST_TRAI  =SIMP(statut='f',typ='TXM'),
           CONTR_NB        =SIMP(statut='f',typ='I'),
           CONTR_LISTE     =SIMP(statut='f',typ='R',max='**'),
           LFREQ_NB        =SIMP(statut='f',typ='I'),
           LFREQ_LISTE     =SIMP(statut='f',typ='R',max='**'),
         ),
)  ;
#& MODIF COMMANDE  DATE 03/01/2006   AUTEUR REZETTE C.REZETTE 
#            CONFIGURATION MANAGEMENT OF EDF VERSION
# ======================================================================
# COPYRIGHT (C) 1991 - 2001  EDF R&D                  WWW.CODE-ASTER.ORG
# THIS PROGRAM IS FREE SOFTWARE; YOU CAN REDISTRIBUTE IT AND/OR MODIFY
# IT UNDER THE TERMS OF THE GNU GENERAL PUBLIC LICENSE AS PUBLISHED BY
# THE FREE SOFTWARE FOUNDATION; EITHER VERSION 2 OF THE LICENSE, OR   
# (AT YOUR OPTION) ANY LATER VERSION.                                 
#
# THIS PROGRAM IS DISTRIBUTED IN THE HOPE THAT IT WILL BE USEFUL, BUT 
# WITHOUT ANY WARRANTY; WITHOUT EVEN THE IMPLIED WARRANTY OF          
# MERCHANTABILITY OR FITNESS FOR A PARTICULAR PURPOSE. SEE THE GNU    
# GENERAL PUBLIC LICENSE FOR MORE DETAILS.                            
#
# YOU SHOULD HAVE RECEIVED A COPY OF THE GNU GENERAL PUBLIC LICENSE   
# ALONG WITH THIS PROGRAM; IF NOT, WRITE TO EDF R&D CODE_ASTER,       
#    1 AVENUE DU GENERAL DE GAULLE, 92141 CLAMART CEDEX, FRANCE.      
# ======================================================================

from Macro.macro_mode_meca_ops import macro_mode_meca_ops

MACRO_MODE_MECA=MACRO(nom="MACRO_MODE_MECA",op=macro_mode_meca_ops,sd_prod=mode_meca,
                     reentrant='n',fr="Lancer une succession de calculs de modes propres réels",
            UIinfo={"groupes":("Résolution",)},
         MATR_A          =SIMP(statut='o',typ=matr_asse_depl_r ),
         MATR_B          =SIMP(statut='o',typ=matr_asse_depl_r ),
         INFO            =SIMP(statut='f',typ='I',defaut= 1,into=(1,2) ),
#  ce mot cle ne devrait il pas etre dans calc_freq  
         METHODE         =SIMP(statut='f',typ='TXM',defaut="SORENSEN",    
                               into=("TRI_DIAG","JACOBI","SORENSEN",) ),
         b_tri_diag =BLOC(condition = "METHODE == 'TRI_DIAG'",
           PREC_ORTHO      =SIMP(statut='f',typ='R',defaut= 1.E-12,val_min=0.E+0 ),
           NMAX_ITER_ORTHO =SIMP(statut='f',typ='I',defaut= 5,val_min=0 ),
           PREC_LANCZOS    =SIMP(statut='f',typ='R',defaut= 1.E-8,val_min=0.E+0 ),
           NMAX_ITER_QR    =SIMP(statut='f',typ='I',defaut= 30,val_min=0 ), 
         ),
         b_jacobi =BLOC(condition = "METHODE == 'JACOBI'",
           PREC_BATHE      =SIMP(statut='f',typ='R',defaut= 1.E-10,val_min=0.E+0 ),
           NMAX_ITER_BATHE =SIMP(statut='f',typ='I',defaut= 40,val_min=0 ),
           PREC_JACOBI     =SIMP(statut='f',typ='R',defaut= 1.E-2,val_min=0.E+0 ),
           NMAX_ITER_JACOBI=SIMP(statut='f',typ='I',defaut= 12,val_min=0 ),
         ),
         b_sorensen =BLOC(condition = "METHODE == 'SORENSEN'",
           PREC_SOREN      =SIMP(statut='f',typ='R',defaut= 0.E+0,val_min=0.E+0 ),  
           NMAX_ITER_SOREN =SIMP(statut='f',typ='I',defaut= 20,val_min=0 ),  
           PARA_ORTHO_SOREN=SIMP(statut='f',typ='R',defaut= 0.717,val_min=0.E+0 ),
         ),
         OPTION          =SIMP(statut='f',typ='TXM',defaut="SANS",    
                               into=("MODE_RIGIDE","SANS") ),
         CALC_FREQ       =FACT(statut='d',min=0,
           regles=(UN_PARMI('FREQ','FREQ_MAX'),
                   PRESENT_PRESENT('FREQ_MIN','FREQ_MAX'),
                   PRESENT_PRESENT('FREQ_MAX','NB_BLOC_FREQ'),
                   EXCLUS('DIM_SOUS_ESPACE','COEF_DIM_ESPACE'),),
           FREQ            =SIMP(statut='f',typ='R',min=2,validators=NoRepeat(),max='**',val_min=0.E+0 ),  
           FREQ_MIN        =SIMP(statut='f',typ='R' ),  
           FREQ_MAX        =SIMP(statut='f',typ='R' ),  
           NB_BLOC_FREQ    =SIMP(statut='f',typ='I' ),  
           DIM_SOUS_ESPACE =SIMP(statut='f',typ='I' ),  
           COEF_DIM_ESPACE =SIMP(statut='f',typ='I' ),
           NPREC_SOLVEUR   =SIMP(statut='f',typ='I',defaut= 8 ),  
           NMAX_ITER_SHIFT =SIMP(statut='f',typ='I',defaut= 5 ),  
           PREC_SHIFT      =SIMP(statut='f',typ='R',defaut= 5.E-2 ),  
           SEUIL_FREQ      =SIMP(statut='f',typ='R' ,defaut= 1.E-2 ),  
           STOP_FREQ_VIDE  =SIMP(statut='f',typ='TXM',defaut="NON" ,into=("OUI","NON") ),
         ),
         VERI_MODE       =FACT(statut='d',min=0,
           STOP_ERREUR     =SIMP(statut='f',typ='TXM',defaut="OUI",into=("OUI","NON") ),
           SEUIL           =SIMP(statut='f',typ='R',defaut= 1.E-6 ),  
           PREC_SHIFT      =SIMP(statut='f',typ='R',defaut= 5.E-3 ),  
           STURM           =SIMP(statut='f',typ='TXM',defaut="OUI",into=("OUI","NON") ),
         ),
         NORM_MODE       =FACT(statut='o',max='**',
           MASS_INER       =SIMP(statut='o',typ=table_sdaster),
           NORME           =SIMP(statut='f',typ='TXM',defaut="TRAN_ROTA",    
                                 into=("MASS_GENE","RIGI_GENE","EUCL",           
                                       "EUCL_TRAN","TRAN","TRAN_ROTA") ),
           INFO            =SIMP(statut='f',typ='I',defaut= 1 ,into=(1,2) ),
         ),
         FILTRE_MODE     =FACT(statut='f',
           CRIT_EXTR       =SIMP(statut='f',typ='TXM',defaut="MASS_EFFE_UN",    
                                 into=("MASS_EFFE_UN","MASS_GENE") ),
           SEUIL           =SIMP(statut='f',typ='R',defaut= 1.E-3 ),  
         ),
         IMPRESSION      =FACT(statut='d',
           TOUT_PARA       =SIMP(statut='f',typ='TXM',defaut="OUI",into=("OUI","NON") ),
           CUMUL           =SIMP(statut='f',typ='TXM',defaut="OUI",into=("OUI","NON") ),
           CRIT_EXTR       =SIMP(statut='f',typ='TXM',defaut="MASS_EFFE_UN",    
                                 into=("MASS_EFFE_UN","MASS_GENE",) ),
         ),
)  ;
#& MODIF COMMANDE  DATE 21/02/2006   AUTEUR REZETTE C.REZETTE 
#            CONFIGURATION MANAGEMENT OF EDF VERSION
# ======================================================================
# COPYRIGHT (C) 1991 - 2001  EDF R&D                  WWW.CODE-ASTER.ORG
# THIS PROGRAM IS FREE SOFTWARE; YOU CAN REDISTRIBUTE IT AND/OR MODIFY
# IT UNDER THE TERMS OF THE GNU GENERAL PUBLIC LICENSE AS PUBLISHED BY
# THE FREE SOFTWARE FOUNDATION; EITHER VERSION 2 OF THE LICENSE, OR   
# (AT YOUR OPTION) ANY LATER VERSION.                                 
#
# THIS PROGRAM IS DISTRIBUTED IN THE HOPE THAT IT WILL BE USEFUL, BUT 
# WITHOUT ANY WARRANTY; WITHOUT EVEN THE IMPLIED WARRANTY OF          
# MERCHANTABILITY OR FITNESS FOR A PARTICULAR PURPOSE. SEE THE GNU    
# GENERAL PUBLIC LICENSE FOR MORE DETAILS.                            
#
# YOU SHOULD HAVE RECEIVED A COPY OF THE GNU GENERAL PUBLIC LICENSE   
# ALONG WITH THIS PROGRAM; IF NOT, WRITE TO EDF R&D CODE_ASTER,       
#    1 AVENUE DU GENERAL DE GAULLE, 92141 CLAMART CEDEX, FRANCE.      
# ======================================================================

from Macro.macro_proj_base_ops import macro_proj_base_ops

def macro_proj_base_prod(self,MATR_ASSE_GENE,VECT_ASSE_GENE,PROFIL,**args ):
  if MATR_ASSE_GENE != None:
    for m in MATR_ASSE_GENE:
      self.type_sdprod(m['MATRICE'],matr_asse_gene_r)
  if VECT_ASSE_GENE != None:
    for v in VECT_ASSE_GENE:
      self.type_sdprod(v['VECTEUR'],vect_asse_gene)
  return None

MACRO_PROJ_BASE=MACRO(nom="MACRO_PROJ_BASE",op=macro_proj_base_ops,
         regles=(AU_MOINS_UN('MATR_ASSE_GENE','VECT_ASSE_GENE')),
            UIinfo={"groupes":("Matrices/vecteurs",)},
                      sd_prod=macro_proj_base_prod,
         fr="Projection des matrices et/ou vecteurs assemblés sur une base (modale ou de RITZ)",
         BASE            =SIMP(statut='o',typ=(mode_meca,mode_stat,base_modale,mode_gene) ),
         NB_VECT         =SIMP(statut='f',typ='I',defaut= 9999),
         PROFIL          =SIMP(statut='f',typ='TXM',defaut="DIAG",into=("PLEIN","DIAG") ),
         MATR_ASSE_GENE  =FACT(statut='f',max='**',
           MATRICE         =SIMP(statut='o',typ=CO,),
           regles=(UN_PARMI('MATR_ASSE','MATR_ASSE_GENE',),),
           MATR_ASSE       =SIMP(statut='f',typ=matr_asse_depl_r),
           MATR_ASSE_GENE  =SIMP(statut='f',typ=matr_asse_gene_r),
         ),
         VECT_ASSE_GENE  =FACT(statut='f',max='**',
           VECTEUR         =SIMP(statut='o',typ=CO,),
           regles=(UN_PARMI('VECT_ASSE','VECT_ASSE_GENE',),),
           TYPE_VECT       =SIMP(statut='f',typ='TXM',defaut="FORC"),
           VECT_ASSE       =SIMP(statut='f',typ=cham_no_sdaster),
           VECT_ASSE_GENE  =SIMP(statut='f',typ=vect_asse_gene),
         ),
         INFO            =SIMP(statut='f',typ='I',defaut=1,into=(1,2)),
)  ;
#& MODIF COMMANDE  DATE 31/10/2006   AUTEUR ASSIRE A.ASSIRE 
#            CONFIGURATION MANAGEMENT OF EDF VERSION
# ======================================================================
# COPYRIGHT (C) 1991 - 2002  EDF R&D                  WWW.CODE-ASTER.ORG
# THIS PROGRAM IS FREE SOFTWARE; YOU CAN REDISTRIBUTE IT AND/OR MODIFY  
# IT UNDER THE TERMS OF THE GNU GENERAL PUBLIC LICENSE AS PUBLISHED BY  
# THE FREE SOFTWARE FOUNDATION; EITHER VERSION 2 OF THE LICENSE, OR     
# (AT YOUR OPTION) ANY LATER VERSION.                                                  
#                                                                       
# THIS PROGRAM IS DISTRIBUTED IN THE HOPE THAT IT WILL BE USEFUL, BUT   
# WITHOUT ANY WARRANTY; WITHOUT EVEN THE IMPLIED WARRANTY OF            
# MERCHANTABILITY OR FITNESS FOR A PARTICULAR PURPOSE. SEE THE GNU      
# GENERAL PUBLIC LICENSE FOR MORE DETAILS.                              
#                                                                       
# YOU SHOULD HAVE RECEIVED A COPY OF THE GNU GENERAL PUBLIC LICENSE     
# ALONG WITH THIS PROGRAM; IF NOT, WRITE TO EDF R&D CODE_ASTER,         
#    1 AVENUE DU GENERAL DE GAULLE, 92141 CLAMART CEDEX, FRANCE.        
# ======================================================================
   
from Macro.macr_recal_ops import macr_recal_ops

def macr_recal_prod(self,**args ):
  return listr8_sdaster

MACR_RECAL = MACRO(nom="MACR_RECAL",op=macr_recal_ops,
            UIinfo={"groupes":("Résultats et champs",)},
                      sd_prod=macr_recal_prod,
                      fr="Réalise le recalage des calculs Aster sur des résultats expérimentaux"
                        +" ou sur d'autres résultats de calculs",
         UNITE_ESCL      =SIMP(statut='o',typ='I'),
         RESU_EXP        =SIMP(statut='o',typ=assd,max='**'),
         POIDS           =SIMP(statut='f',typ=assd,max='**'),
         RESU_CALC       =SIMP(statut='o',typ=assd,max='**'),
         LIST_PARA       =SIMP(statut='o',typ=assd,max='**'),
         LIST_DERIV      =SIMP(statut='f',typ=assd,max='**'),
         ITER_MAXI       =SIMP(statut='f',typ='I',defaut=10),
         ITER_FONC_MAXI  =SIMP(statut='f',typ='I',defaut=100),
         RESI_GLOB_RELA  =SIMP(statut='f',typ='R',defaut=1.E-3),
         UNITE_RESU      =SIMP(statut='f',typ='I',defaut=91),
         PARA_DIFF_FINI  =SIMP(statut='f',typ='R',defaut=0.001),
#         GRAPHIQUE       =FACT(statut='d',
         GRAPHIQUE       =FACT(statut='f',
           UNITE           =SIMP(statut='f',typ='I',defaut=90),
           FORMAT          =SIMP(statut='f',typ='TXM',defaut='XMGRACE',into=("XMGRACE","GNUPLOT")),
           INTERACTIF      =SIMP(statut='f',typ='TXM',defaut='NON',into=("OUI","NON")),
           AFFICHAGE       =SIMP(statut='f',typ='TXM',defaut='TOUTE_ITERATION',into=("TOUTE_ITERATION","ITERATION_FINALE")),),
         SUIVI_ESCLAVE   =SIMP(statut='f',typ='TXM',defaut='NON',into=("OUI","NON"),),

         METHODE         =SIMP(statut='f',typ='TXM',defaut='LEVENBERG',into=("LEVENBERG","FMIN","FMINBFGS","FMINNCG","EXTERNE")),

         b_gradient =BLOC(condition = "METHODE == 'FMINBFGS' or METHODE == 'FMINNCG'" ,
            GRADIENT        =SIMP(statut='f',typ='TXM',defaut='NON_CALCULE', into=("NON_CALCULE", "NORMAL", "ADIMENSIONNE" )),
         ),

         b_gradient_externe =BLOC(condition = "METHODE == 'EXTERNE'" ,
            GRADIENT        =SIMP(statut='f',typ='TXM',defaut='NON_CALCULE', into=("NON_CALCULE", "NORMAL", "ADIMENSIONNE" )),
         ),

         b_type_fonctionnelle =BLOC(condition = "METHODE == 'EXTERNE'" ,
            FONCTIONNELLE   =SIMP(statut='f',typ='TXM',defaut='SCALAIRE',into=("SCALAIRE","VECTORIELLE")),
         ),

         INFO            =SIMP(statut='f',typ='I',defaut=2,into=( 1, 2 ) ),
);
#& MODIF COMMANDE  DATE 07/11/2006   AUTEUR DURAND C.DURAND 
#            CONFIGURATION MANAGEMENT OF EDF VERSION
# ======================================================================
# COPYRIGHT (C) 1991 - 2006  EDF R&D                  WWW.CODE-ASTER.ORG
# THIS PROGRAM IS FREE SOFTWARE; YOU CAN REDISTRIBUTE IT AND/OR MODIFY  
# IT UNDER THE TERMS OF THE GNU GENERAL PUBLIC LICENSE AS PUBLISHED BY  
# THE FREE SOFTWARE FOUNDATION; EITHER VERSION 2 OF THE LICENSE, OR     
# (AT YOUR OPTION) ANY LATER VERSION.                                                  
#                                                                       
# THIS PROGRAM IS DISTRIBUTED IN THE HOPE THAT IT WILL BE USEFUL, BUT   
# WITHOUT ANY WARRANTY; WITHOUT EVEN THE IMPLIED WARRANTY OF            
# MERCHANTABILITY OR FITNESS FOR A PARTICULAR PURPOSE. SEE THE GNU      
# GENERAL PUBLIC LICENSE FOR MORE DETAILS.                              
#                                                                       
# YOU SHOULD HAVE RECEIVED A COPY OF THE GNU GENERAL PUBLIC LICENSE     
# ALONG WITH THIS PROGRAM; IF NOT, WRITE TO EDF R&D CODE_ASTER,         
#    1 AVENUE DU GENERAL DE GAULLE, 92141 CLAMART CEDEX, FRANCE.        
# ======================================================================

from Macro.macr_spectre_ops import macr_spectre_ops

MACR_SPECTRE=MACRO(nom="MACR_SPECTRE",op=macr_spectre_ops,sd_prod=table_sdaster,
                       reentrant='n', UIinfo={"groupes":("Outils métier",)},
                       fr="calcul de spectre, post-traitement de séisme",
         MAILLAGE      =SIMP(statut='o',typ=maillage_sdaster,),
         PLANCHER      =FACT(statut='o',max='**',
            regles=(AU_MOINS_UN('NOEUD','GROUP_NO' ),),
            NOM           =SIMP(statut='o',typ='TXM',),
            GROUP_NO      =SIMP(statut='f',typ=grno,validators=NoRepeat(),max='**'),
            NOEUD         =SIMP(statut='f',typ=no  ,validators=NoRepeat(),max='**'), ),
         NOM_CHAM      =SIMP(statut='o',typ='TXM' ,into=('ACCE','DEPL')),
         CALCUL        =SIMP(statut='o',typ='TXM' ,into=('ABSOLU','RELATIF'),position='global'),
         b_acce  =BLOC( condition = "NOM_CHAM=='ACCE'",
           regles=(UN_PARMI('LIST_FREQ','FREQ'),),
           AMOR_SPEC     =SIMP(statut='o',typ='R',max='**'),
           LIST_INST     =SIMP(statut='f',typ=listr8_sdaster ),
           LIST_FREQ     =SIMP(statut='f',typ=listr8_sdaster ),
           FREQ          =SIMP(statut='f',typ='R',max='**'),
           NORME         =SIMP(statut='f',typ='R',defaut=9.81),  
           RESU          =FACT(statut='o',max='**',
                regles=(UN_PARMI('RESU_GENE','RESULTAT'),),
                RESU_GENE     =SIMP(statut='f',typ=tran_gene),
                RESULTAT      =SIMP(statut='f',typ=(dyna_trans,evol_noli)),
                b_calc  =BLOC( condition = "CALCUL=='RELATIF'",
                   ACCE_X        =SIMP(statut='o',typ=fonction_sdaster),
                   ACCE_Y        =SIMP(statut='o',typ=fonction_sdaster),
                   ACCE_Z        =SIMP(statut='o',typ=fonction_sdaster),), ),
           IMPRESSION    =FACT(statut='f',
                TRI           =SIMP(statut='f',typ='TXM',defaut='AMOR_SPEC',into=("AMOR_SPEC","DIRECTION",),),
                FORMAT        =SIMP(statut='f',typ='TXM',defaut='TABLEAU',into=("TABLEAU","XMGRACE",),),
                UNITE         =SIMP(statut='f',typ='I',val_min=10,val_max=90,defaut=29,
                                    fr="Unité logique définissant le fichier (fort.N) dans lequel on écrit"),
                b_pilote = BLOC(condition = "FORMAT == 'XMGRACE'",
                   PILOTE        =SIMP(statut='f',typ='TXM',defaut='',
                                 into=('','POSTSCRIPT','EPS','MIF','SVG','PNM','PNG','JPEG','PDF','INTERACTIF'),),),
                TOUT          =SIMP(statut='f',typ='TXM',defaut='NON',into=("OUI","NON",),),
                              ),
         ),
         b_depl  =BLOC( condition = "NOM_CHAM=='DEPL'",
           LIST_INST     =SIMP(statut='f',typ=listr8_sdaster),  
           RESU          =FACT(statut='o',max=3,
                regles=(UN_PARMI('RESU_GENE','RESULTAT'),),
                RESU_GENE     =SIMP(statut='f',typ=tran_gene),
                RESULTAT      =SIMP(statut='f',typ=(dyna_trans,evol_noli)),
                b_calc  =BLOC( condition = "CALCUL=='ABSOLU'",
                   DEPL_X        =SIMP(statut='o',typ=fonction_sdaster),
                   DEPL_Y        =SIMP(statut='o',typ=fonction_sdaster),
                   DEPL_Z        =SIMP(statut='o',typ=fonction_sdaster),),),
         ),
)
#& MODIF COMMANDE  DATE 22/06/2005   AUTEUR REZETTE C.REZETTE 
#            CONFIGURATION MANAGEMENT OF EDF VERSION
# ======================================================================
# COPYRIGHT (C) 1991 - 2001  EDF R&D                  WWW.CODE-ASTER.ORG
# THIS PROGRAM IS FREE SOFTWARE; YOU CAN REDISTRIBUTE IT AND/OR MODIFY
# IT UNDER THE TERMS OF THE GNU GENERAL PUBLIC LICENSE AS PUBLISHED BY
# THE FREE SOFTWARE FOUNDATION; EITHER VERSION 2 OF THE LICENSE, OR   
# (AT YOUR OPTION) ANY LATER VERSION.                                 
#
# THIS PROGRAM IS DISTRIBUTED IN THE HOPE THAT IT WILL BE USEFUL, BUT 
# WITHOUT ANY WARRANTY; WITHOUT EVEN THE IMPLIED WARRANTY OF          
# MERCHANTABILITY OR FITNESS FOR A PARTICULAR PURPOSE. SEE THE GNU    
# GENERAL PUBLIC LICENSE FOR MORE DETAILS.                            
#
# YOU SHOULD HAVE RECEIVED A COPY OF THE GNU GENERAL PUBLIC LICENSE   
# ALONG WITH THIS PROGRAM; IF NOT, WRITE TO EDF R&D CODE_ASTER,       
#    1 AVENUE DU GENERAL DE GAULLE, 92141 CLAMART CEDEX, FRANCE.      
# ======================================================================
MAJ_CATA=PROC(nom="MAJ_CATA",op=20,
            UIinfo={"groupes":("Gestion du travail",)},
              fr="Compilation des catalogues de commandes et d'éléments",

         ELEMENT         =FACT(statut='f',),

)  ;
#& MODIF COMMANDE  DATE 12/06/2006   AUTEUR BOITEAU O.BOITEAU 
#            CONFIGURATION MANAGEMENT OF EDF VERSION
# ======================================================================
# COPYRIGHT (C) 1991 - 2001  EDF R&D                  WWW.CODE-ASTER.ORG
# THIS PROGRAM IS FREE SOFTWARE; YOU CAN REDISTRIBUTE IT AND/OR MODIFY
# IT UNDER THE TERMS OF THE GNU GENERAL PUBLIC LICENSE AS PUBLISHED BY
# THE FREE SOFTWARE FOUNDATION; EITHER VERSION 2 OF THE LICENSE, OR
# (AT YOUR OPTION) ANY LATER VERSION.
#
# THIS PROGRAM IS DISTRIBUTED IN THE HOPE THAT IT WILL BE USEFUL, BUT
# WITHOUT ANY WARRANTY; WITHOUT EVEN THE IMPLIED WARRANTY OF
# MERCHANTABILITY OR FITNESS FOR A PARTICULAR PURPOSE. SEE THE GNU
# GENERAL PUBLIC LICENSE FOR MORE DETAILS.
#
# YOU SHOULD HAVE RECEIVED A COPY OF THE GNU GENERAL PUBLIC LICENSE
# ALONG WITH THIS PROGRAM; IF NOT, WRITE TO EDF R&D CODE_ASTER,
#    1 AVENUE DU GENERAL DE GAULLE, 92141 CLAMART CEDEX, FRANCE.
# ======================================================================
# RESPONSABLE VABHHTS J.PELLET
MECA_STATIQUE=OPER(nom="MECA_STATIQUE",op=46,sd_prod=evol_elas,
                   fr="Résoudre un problème de mécanique statique linéaire",reentrant='f',
            UIinfo={"groupes":("Résolution",)},
         regles=(EXCLUS("INST","LIST_INST"),
                 AU_MOINS_UN('CHAM_MATER','CARA_ELEM',),
                 CONCEPT_SENSIBLE('ENSEMBLE'),),
         MODELE          =SIMP(statut='o',typ=modele_sdaster),
         CHAM_MATER      =SIMP(statut='f',typ=cham_mater,
         fr="le CHAM_MATER est nécessaire, sauf si le modèle ne contient que des éléments discrets (modélisations DIS_XXX)",
         ang="CHAM_MATER is compulsory, except if the model contains only discret elements (modelizations DIS_XXX)"),
         CARA_ELEM       =SIMP(statut='f',typ=cara_elem,
         fr="le CARA_ELEM est nécessaire dès que le modèle contient des éléments de structure : coques, poutres, ...",
         ang="CARA_ELEM is compulsory as soon as the model contains structural elements : plates, beams, ..."),
         TITRE           =SIMP(statut='f',typ='TXM',max='**'),
         EXCIT           =FACT(statut='o',max='**',
           CHARGE          =SIMP(statut='o',typ=(char_meca,char_cine_meca)),
           FONC_MULT       =SIMP(statut='f',typ=(fonction_sdaster,nappe_sdaster,formule)),
           TYPE_CHARGE     =SIMP(statut='f',typ='TXM',defaut="FIXE",into=("FIXE",) ),
         ),
         INST            =SIMP(statut='f',typ='R',defaut= 0.E+0 ),
         LIST_INST       =SIMP(statut='f',typ=listr8_sdaster),
         INST_FIN        =SIMP(statut='f',typ='R'),
         OPTION          =SIMP(statut='f',typ='TXM',into=("SIEF_ELGA_DEPL","SANS"),defaut="SIEF_ELGA_DEPL",max=1,
             fr="seule option : contraintes aux points de Gauss. Utiliser CALC_ELEM pour les autres.",
                          ),
         SENSIBILITE     =SIMP(statut='f',typ=(para_sensi,theta_geom),validators=NoRepeat(),max='**',
                               fr="Liste des paramètres de sensibilité.",
                               ang="List of sensitivity parameters"),

         SOLVEUR         =FACT(statut='d',
         METHODE         =SIMP(statut='f',typ='TXM',defaut="MULT_FRONT",into=("MULT_FRONT","LDLT","GCPC","FETI","MUMPS") ),

           b_feti          =BLOC(condition = "METHODE == 'FETI' ",fr="Paramètres de la méthode FETI 1",
             PARTITION       =SIMP(statut='o',typ=sd_feti_sdaster),
             RENUM           =SIMP(statut='f',typ='TXM',defaut="METIS",into=("MD","MDA","METIS") ),
             RESI_RELA       =SIMP(statut='f',typ='R',defaut=1.E-6,val_min=0.),
             NMAX_ITER       =SIMP(statut='f',typ='I',defaut=0,val_min=0),
             TYPE_REORTHO_DD =SIMP(statut='f',typ='TXM',defaut="GSM",into=("SANS","GS","GSM","IGSM") ),
             NB_REORTHO_DD   =SIMP(statut='f',typ='I',defaut=0,val_min=0),
             NB_REORTHO_INST =SIMP(statut='f',typ='I',defaut=0,val_min=0),
             PRE_COND        =SIMP(statut='f',typ='TXM',defaut="LUMPE",into=("LUMPE","SANS") ),
             SCALING         =SIMP(statut='f',typ='TXM',defaut="MULT",into=("SANS","MULT") ),
             VERIF_SDFETI    =SIMP(statut='f',typ='TXM',defaut="OUI",into=("OUI","NON") ),
             TEST_CONTINU    =SIMP(statut='f',typ='R',defaut=1.E-8,val_min=0.),
             INFO_FETI       =SIMP(statut='f',typ='TXM',defaut='FFFFFFFFFFFFFFFFFFFFFFFF'),
             STOCKAGE_GI     =SIMP(statut='f',typ='TXM',defaut="OUI",into=("OUI","NON","CAL") ),
             NB_SD_PROC0     =SIMP(statut='f',typ='I',defaut=0,val_min=0),
             ACCELERATION_SM =SIMP(statut='f',typ='TXM',defaut="OUI",into=("OUI","NON") ),
           ),

           b_mult_front    =BLOC(condition = "METHODE == 'MULT_FRONT' ",fr="Paramètres de la méthode multi frontale",
             RENUM           =SIMP(statut='f',typ='TXM',defaut="METIS",into=("MD","MDA","METIS") ),
           ),

           b_ldlt          =BLOC(condition = "METHODE == 'LDLT' ",fr="Paramètres de la méthode LDLT",
             RENUM           =SIMP(statut='f',typ='TXM',defaut="RCMK",into=("RCMK","SANS") ),
           ),

           b_ldlt_mult     =BLOC(condition = "METHODE == 'LDLT' or METHODE == 'MULT_FRONT' or METHODE == 'FETI' ",
                                   fr="Paramètres relatifs à la non inversibilité de la matrice à factorise",
             NPREC           =SIMP(statut='f',typ='I',defaut=8),
             STOP_SINGULIER  =SIMP(statut='f',typ='TXM',defaut="OUI",into=("OUI","NON") ),
           ),

           b_gcpc         =BLOC(condition = "METHODE == 'GCPC' ", fr="Paramètres de la méthode du gradient conjugué",
             PRE_COND        =SIMP(statut='f',typ='TXM',into=("LDLT_INC",),defaut="LDLT_INC" ),
             NIVE_REMPLISSAGE=SIMP(statut='f',typ='I',defaut= 0 ),
             RENUM           =SIMP(statut='f',typ='TXM',defaut="RCMK",into=("SANS","RCMK") ),
             RESI_RELA       =SIMP(statut='f',typ='R',defaut=1.E-6),
             NMAX_ITER       =SIMP(statut='f',typ='I',defaut= 0 ),
           ),

           b_mumps        =BLOC(condition = "METHODE == 'MUMPS' ",fr="Paramètres de la méthode MUMPS",
             TYPE_RESOL      =SIMP(statut='f',typ='TXM',defaut="AUTO",into=("NONSYM","SYMGEN","SYMDEF","AUTO")),
             SCALING         =SIMP(statut='f',typ='TXM',defaut="AUTO",into=("SANS","AUTO")),
             RENUM           =SIMP(statut='f',typ='TXM',defaut="AUTO",into=("AMD","AMF","PORD","METIS","QAMD","AUTO")),
             PCENT_PIVOT     =SIMP(statut='f',typ='I',defaut=80,),
             RESI_RELA       =SIMP(statut='f',typ='R',defaut=1.E-6,),
             ),
         ),
         INFO            =SIMP(statut='f',typ='I',defaut=1,into=(1,2) ),
)  ;
#& MODIF COMMANDE  DATE 10/06/2004   AUTEUR REZETTE C.REZETTE 
#            CONFIGURATION MANAGEMENT OF EDF VERSION
# ======================================================================
# COPYRIGHT (C) 1991 - 2001  EDF R&D                  WWW.CODE-ASTER.ORG
# THIS PROGRAM IS FREE SOFTWARE; YOU CAN REDISTRIBUTE IT AND/OR MODIFY
# IT UNDER THE TERMS OF THE GNU GENERAL PUBLIC LICENSE AS PUBLISHED BY
# THE FREE SOFTWARE FOUNDATION; EITHER VERSION 2 OF THE LICENSE, OR   
# (AT YOUR OPTION) ANY LATER VERSION.                                 
#
# THIS PROGRAM IS DISTRIBUTED IN THE HOPE THAT IT WILL BE USEFUL, BUT 
# WITHOUT ANY WARRANTY; WITHOUT EVEN THE IMPLIED WARRANTY OF          
# MERCHANTABILITY OR FITNESS FOR A PARTICULAR PURPOSE. SEE THE GNU    
# GENERAL PUBLIC LICENSE FOR MORE DETAILS.                            
#
# YOU SHOULD HAVE RECEIVED A COPY OF THE GNU GENERAL PUBLIC LICENSE   
# ALONG WITH THIS PROGRAM; IF NOT, WRITE TO EDF R&D CODE_ASTER,       
#    1 AVENUE DU GENERAL DE GAULLE, 92141 CLAMART CEDEX, FRANCE.      
# ======================================================================
# RESPONSABLE GNICOLAS G.NICOLAS
MEMO_NOM_SENSI=PROC(nom="MEMO_NOM_SENSI",op=129,
            UIinfo={"groupes":("Fonction",)},
                    fr="Mémorisation des noms des concepts dérivés.",
                    ang="Memorisation of the names of the sensitive concepts.",

         regles=(AU_MOINS_UN('NOM','NOM_ZERO','NOM_UN'),),

         NOM=FACT(statut='f',max='**',
             regles=(PRESENT_PRESENT('MOT_CLE','VALEUR','MOT_FACT' ),),

             NOM_SD=SIMP(statut='o',typ='TXM',
                         fr="Nom de la structure de base",
                         ang="Name of the basic structure"),

             PARA_SENSI=SIMP(statut='o',typ=(para_sensi,theta_geom),
                         fr="Nom du paramètre sensible",
                         ang="Name of the sensitive parameter"),

             NOM_COMPOSE=SIMP(statut='f',typ='TXM',defaut=" ",
                         fr="Nom de la structure composée",
                         ang="Name of the built structure"),

             MOT_FACT=SIMP(statut='f',typ='TXM',max='**',
                         fr="Liste des mots clés facteurs concernés par la dérivation",
                         ang="Factor keyword list involved in derivation"),

             MOT_CLE=SIMP(statut='f',typ='TXM',max='**',
                         fr="Liste des mots clés concernés par la dérivation",
                         ang="Keyword list involved in derivation"),

             VALEUR=SIMP(statut='f',typ='TXM',max='**',
                         fr="Liste des objets concernés par la dérivation",
                         ang="Object list involved in derivation"),

                 ),

         NOM_ZERO=SIMP(statut='f',typ=fonction_sdaster,
                       fr="Nom de la fonction nulle",
                       ang="Name of the zero fonction"),

         NOM_UN  =SIMP(statut='f',typ=fonction_sdaster,
                       fr="Nom de la fonction unité",
                       ang="Name of the one fonction"),

)  ;
#& MODIF COMMANDE  DATE 22/06/2005   AUTEUR REZETTE C.REZETTE 
#            CONFIGURATION MANAGEMENT OF EDF VERSION
# ======================================================================
# COPYRIGHT (C) 1991 - 2001  EDF R&D                  WWW.CODE-ASTER.ORG
# THIS PROGRAM IS FREE SOFTWARE; YOU CAN REDISTRIBUTE IT AND/OR MODIFY
# IT UNDER THE TERMS OF THE GNU GENERAL PUBLIC LICENSE AS PUBLISHED BY
# THE FREE SOFTWARE FOUNDATION; EITHER VERSION 2 OF THE LICENSE, OR   
# (AT YOUR OPTION) ANY LATER VERSION.                                 
#
# THIS PROGRAM IS DISTRIBUTED IN THE HOPE THAT IT WILL BE USEFUL, BUT 
# WITHOUT ANY WARRANTY; WITHOUT EVEN THE IMPLIED WARRANTY OF          
# MERCHANTABILITY OR FITNESS FOR A PARTICULAR PURPOSE. SEE THE GNU    
# GENERAL PUBLIC LICENSE FOR MORE DETAILS.                            
#
# YOU SHOULD HAVE RECEIVED A COPY OF THE GNU GENERAL PUBLIC LICENSE   
# ALONG WITH THIS PROGRAM; IF NOT, WRITE TO EDF R&D CODE_ASTER,       
#    1 AVENUE DU GENERAL DE GAULLE, 92141 CLAMART CEDEX, FRANCE.      
# ======================================================================
MODE_ITER_CYCL=OPER(nom="MODE_ITER_CYCL",op=  80,sd_prod=mode_cycl,
                    fr="Calcul des modes propres d'une structure à répétitivité cyclique à partir"
                        +" d'une base de modes propres réels",
                    reentrant='n',
            UIinfo={"groupes":("Résolution",)},
         BASE_MODALE     =SIMP(statut='o',typ=base_modale ),
         NB_MODE         =SIMP(statut='f',typ='I',defaut= 999 ),
         NB_SECTEUR      =SIMP(statut='o',typ='I' ),
         LIAISON         =FACT(statut='o',
           DROITE          =SIMP(statut='o',typ='TXM' ),
           GAUCHE          =SIMP(statut='o',typ='TXM' ),
           AXE             =SIMP(statut='f',typ='TXM' ),
         ),
         VERI_CYCL       =FACT(statut='f',
           PRECISION       =SIMP(statut='f',typ='R',defaut= 1.E-3 ),
           CRITERE         =SIMP(statut='f',typ='TXM',defaut="RELATIF",into=("RELATIF",) ),
           DIST_REFE       =SIMP(statut='f',typ='R' ),
         ),
         CALCUL          =FACT(statut='o',
           TOUT_DIAM       =SIMP(statut='f',typ='TXM',into=("OUI",) ),
           NB_DIAM         =SIMP(statut='f',typ='I',validators=NoRepeat(),max='**'),
           OPTION          =SIMP(statut='f',typ='TXM',defaut="PLUS_PETITE"
                                ,into=("PLUS_PETITE","CENTRE","BANDE") ),
           b_centre      =BLOC(condition = "OPTION == 'CENTRE'",
             FREQ            =SIMP(statut='o',typ='R',),
           ),
           b_bande       =BLOC(condition = "OPTION == 'BANDE'",
             FREQ            =SIMP(statut='o',typ='R',min=2,validators=NoRepeat(),max=2),
           ),
#  NMAX_FREQ n a-t-il pas un sens qu avec OPTION CENTRE                                
           NMAX_FREQ       =SIMP(statut='f',typ='I',defaut= 10 ),
           PREC_SEPARE     =SIMP(statut='f',typ='R',defaut= 100. ),
           PREC_AJUSTE     =SIMP(statut='f',typ='R',defaut= 1.E-6 ),
           NMAX_ITER       =SIMP(statut='f',typ='I',defaut= 50 ),
         ),
         INFO            =SIMP(statut='f',typ='I',defaut= 1,into=( 1 , 2) ),
)  ;
#& MODIF COMMANDE  DATE 10/05/2006   AUTEUR MCOURTOI M.COURTOIS 
#            CONFIGURATION MANAGEMENT OF EDF VERSION
# ======================================================================
# COPYRIGHT (C) 1991 - 2001  EDF R&D                  WWW.CODE-ASTER.ORG
# THIS PROGRAM IS FREE SOFTWARE; YOU CAN REDISTRIBUTE IT AND/OR MODIFY
# IT UNDER THE TERMS OF THE GNU GENERAL PUBLIC LICENSE AS PUBLISHED BY
# THE FREE SOFTWARE FOUNDATION; EITHER VERSION 2 OF THE LICENSE, OR   
# (AT YOUR OPTION) ANY LATER VERSION.                                 
#
# THIS PROGRAM IS DISTRIBUTED IN THE HOPE THAT IT WILL BE USEFUL, BUT 
# WITHOUT ANY WARRANTY; WITHOUT EVEN THE IMPLIED WARRANTY OF          
# MERCHANTABILITY OR FITNESS FOR A PARTICULAR PURPOSE. SEE THE GNU    
# GENERAL PUBLIC LICENSE FOR MORE DETAILS.                            
#
# YOU SHOULD HAVE RECEIVED A COPY OF THE GNU GENERAL PUBLIC LICENSE   
# ALONG WITH THIS PROGRAM; IF NOT, WRITE TO EDF R&D CODE_ASTER,       
#    1 AVENUE DU GENERAL DE GAULLE, 92141 CLAMART CEDEX, FRANCE.      
# ======================================================================
def mode_iter_inv_prod(MATR_A,MATR_C,TYPE_RESU,**args ):
  if TYPE_RESU == "MODE_FLAMB" : return mode_flamb
  if AsType(MATR_C) == matr_asse_depl_r : return mode_meca_c
  if AsType(MATR_A) == matr_asse_depl_r : return mode_meca
  if AsType(MATR_A) == matr_asse_pres_r : return mode_acou
  if AsType(MATR_A) == matr_asse_gene_r : return mode_gene
  raise AsException("type de concept resultat non prevu")

MODE_ITER_INV=OPER(nom="MODE_ITER_INV",op=  44,sd_prod=mode_iter_inv_prod
                    ,fr="Calcul des modes propres par itérations inverses ; valeurs propres et modes réels ou complexes",
                     reentrant='n',
            UIinfo={"groupes":("Résolution",)},
         regles=(CONCEPT_SENSIBLE('ENSEMBLE'),),
         MATR_A          =SIMP(statut='o',typ=(matr_asse_depl_r,matr_asse_gene_r,matr_asse_pres_r ) ),
         MATR_B          =SIMP(statut='o',typ=(matr_asse_depl_r,matr_asse_gene_r,matr_asse_pres_r ) ),
         MATR_C          =SIMP(statut='f',typ=matr_asse_depl_r ),
         TYPE_RESU       =SIMP(statut='f',typ='TXM',defaut="DYNAMIQUE",   
                               into=("MODE_FLAMB","DYNAMIQUE"),fr="Type d analyse" ),
         b_dynam         =BLOC(condition = "TYPE_RESU == 'DYNAMIQUE'",
           CALC_FREQ       =FACT(statut='o',fr="Choix des paramètres pour le calcul des valeurs propres",
           
             OPTION          =SIMP(statut='f',typ='TXM',defaut="AJUSTE",into=("SEPARE","AJUSTE","PROCHE"),
                                   fr="Choix de l option pour estimer les valeurs propres"  ),
             FREQ            =SIMP(statut='o',typ='R',max='**'),
             AMOR_REDUIT     =SIMP(statut='f',typ='R',max='**'),     
             NMAX_FREQ       =SIMP(statut='f',typ='I',defaut= 0,val_min=0 ),           
             NMAX_ITER_SEPARE=SIMP(statut='f',typ='I' ,defaut= 30,val_min=0 ),
             PREC_SEPARE     =SIMP(statut='f',typ='R',defaut= 1.E-4,val_min=0.E+0 ),
             NMAX_ITER_AJUSTE=SIMP(statut='f',typ='I',defaut= 15,val_min=0 ),
             PREC_AJUSTE     =SIMP(statut='f',typ='R',defaut= 1.E-4,val_min=0.E+0 ),

             NPREC_SOLVEUR   =SIMP(statut='f',typ='I',defaut= 8,val_min=0 ),
             NMAX_ITER_SHIFT =SIMP(statut='f',typ='I',defaut= 5,val_min=0 ),
             PREC_SHIFT      =SIMP(statut='f',typ='R',defaut= 5.E-2,val_min=0.E+0, ),
             SEUIL_FREQ      =SIMP(statut='f',typ='R',defaut= 1.E-2,val_min=0.E+0, ),
           ),
         ),
         b_flamb        =BLOC(condition = "TYPE_RESU == 'MODE_FLAMB'",
           CALC_FREQ       =FACT(statut='o',fr="Choix des paramètres pour le calcul des valeurs propres",
           
             OPTION          =SIMP(statut='f',typ='TXM',defaut="AJUSTE",into=("SEPARE","AJUSTE","PROCHE"),
                                 fr="Choix de l option pour estimer les valeurs propres"  ),
             CHAR_CRIT       =SIMP(statut='o',typ='R',validators=NoRepeat(),max='**' ),
             NMAX_FREQ       =SIMP(statut='f',typ='I',defaut= 0,val_min=0 ),           
             NMAX_ITER_SEPARE=SIMP(statut='f',typ='I' ,defaut= 30,val_min=0 ),
             PREC_SEPARE     =SIMP(statut='f',typ='R',defaut= 1.E-4,val_min=0.E+0, ),
             NMAX_ITER_AJUSTE=SIMP(statut='f',typ='I',defaut= 15 ),
             PREC_AJUSTE     =SIMP(statut='f',typ='R',defaut= 1.E-4,val_min=0.E+0, ),
           
             NPREC_SOLVEUR   =SIMP(statut='f',typ='I',defaut= 8,val_min=0 ),
             NMAX_ITER_SHIFT =SIMP(statut='f',typ='I',defaut= 5,val_min=0 ),
             PREC_SHIFT      =SIMP(statut='f',typ='R',defaut= 5.E-2,val_min=0.E+0, ),
             SEUIL_FREQ      =SIMP(statut='f',typ='R',defaut= 1.E-2,val_min=0.E+0, ),
           ),
         ),
         CALC_MODE       =FACT(statut='d',min=0,fr="Choix des paramètres pour le calcul des vecteurs propres",
           OPTION          =SIMP(statut='f',typ='TXM',defaut="DIRECT",into=("DIRECT","RAYLEIGH") ),
           PREC            =SIMP(statut='f',typ='R',defaut= 1.E-5,val_min=0.E+0,fr="Précision de convergence" ),
           NMAX_ITER       =SIMP(statut='f',typ='I',defaut= 30,val_min=0 ),
         ),
         VERI_MODE       =FACT(statut='d',min=0,
           STOP_ERREUR     =SIMP(statut='f',typ='TXM',defaut="OUI",into=("OUI","NON") ),
           SEUIL           =SIMP(statut='f',typ='R',defaut= 1.E-2,val_min=0.E+0,
                                 fr="Valeur limite admise pour l ereur a posteriori des modes"  ),
         ),
         SENSIBILITE     =SIMP(statut='f',typ=(para_sensi,theta_geom),validators=NoRepeat(),max='**',
                               fr="Liste des param\350tres de sensibilit\351.",
                               ang="List of sensitivity parameters",
         ),
         b_sensibilite   =BLOC(condition = "SENSIBILITE != None",
             CHAM_MATER      =SIMP(statut='f',typ=cham_mater ),
             CARA_ELEM       =SIMP(statut='f',typ=cara_elem ),
             EXCIT           =FACT(statut='f',max='**',),  # que pour NMDOME
         ),
         INFO            =SIMP(statut='f',typ='I',defaut= 1,into=( 1 , 2) ),
         TITRE           =SIMP(statut='f',typ='TXM',validators=NoRepeat(),max='**'),
)  ;
#& MODIF COMMANDE  DATE 10/05/2006   AUTEUR MCOURTOI M.COURTOIS 
#            CONFIGURATION MANAGEMENT OF EDF VERSION
# ======================================================================
# COPYRIGHT (C) 1991 - 2001  EDF R&D                  WWW.CODE-ASTER.ORG
# THIS PROGRAM IS FREE SOFTWARE; YOU CAN REDISTRIBUTE IT AND/OR MODIFY
# IT UNDER THE TERMS OF THE GNU GENERAL PUBLIC LICENSE AS PUBLISHED BY
# THE FREE SOFTWARE FOUNDATION; EITHER VERSION 2 OF THE LICENSE, OR   
# (AT YOUR OPTION) ANY LATER VERSION.                                 
#
# THIS PROGRAM IS DISTRIBUTED IN THE HOPE THAT IT WILL BE USEFUL, BUT 
# WITHOUT ANY WARRANTY; WITHOUT EVEN THE IMPLIED WARRANTY OF          
# MERCHANTABILITY OR FITNESS FOR A PARTICULAR PURPOSE. SEE THE GNU    
# GENERAL PUBLIC LICENSE FOR MORE DETAILS.                            
#
# YOU SHOULD HAVE RECEIVED A COPY OF THE GNU GENERAL PUBLIC LICENSE   
# ALONG WITH THIS PROGRAM; IF NOT, WRITE TO EDF R&D CODE_ASTER,       
#    1 AVENUE DU GENERAL DE GAULLE, 92141 CLAMART CEDEX, FRANCE.      
# ======================================================================
def mode_iter_simult_prod(MATR_A,MATR_C,TYPE_RESU,**args ):
  if TYPE_RESU == "MODE_FLAMB" : return mode_flamb
  if AsType(MATR_C) == matr_asse_depl_r : return mode_meca_c
  if AsType(MATR_A) == matr_asse_depl_r : return mode_meca
  if AsType(MATR_A) == matr_asse_depl_c : return mode_meca_c
  if AsType(MATR_A) == matr_asse_pres_r : return mode_acou
  if AsType(MATR_A) == matr_asse_gene_r : return mode_gene
  raise AsException("type de concept resultat non prevu")

MODE_ITER_SIMULT=OPER(nom="MODE_ITER_SIMULT",op=  45,sd_prod=mode_iter_simult_prod,
                      fr="Calcul des modes propres par itérations simultanées ; valeurs propres et"
                         +" modes propres réels ou complexes",
                      reentrant='n',
            UIinfo={"groupes":("Résolution",)},
         regles=(CONCEPT_SENSIBLE('ENSEMBLE'),),
         MATR_A          =SIMP(statut='o',typ=(matr_asse_depl_r,matr_asse_depl_c,matr_asse_gene_r,matr_asse_pres_r ) ),
         MATR_B          =SIMP(statut='o',typ=(matr_asse_depl_r,matr_asse_gene_r,matr_asse_pres_r ) ),
         MATR_C          =SIMP(statut='f',typ=(matr_asse_depl_r,matr_asse_gene_r) ),
         METHODE         =SIMP(statut='f',typ='TXM',defaut="SORENSEN",
                               into=("TRI_DIAG","JACOBI","SORENSEN") ),
         b_tri_diag =BLOC(condition = "METHODE == 'TRI_DIAG'",
           PREC_ORTHO      =SIMP(statut='f',typ='R',defaut= 1.E-12,val_min=0.E+0 ),
           NMAX_ITER_ORTHO =SIMP(statut='f',typ='I',defaut= 5,val_min=0 ),
           PREC_LANCZOS    =SIMP(statut='f',typ='R',defaut= 1.E-8,val_min=0.E+0 ),
           NMAX_ITER_QR    =SIMP(statut='f',typ='I',defaut= 30,val_min=0 ), 
         ),
         b_jacobi =BLOC(condition = "METHODE == 'JACOBI'",
           PREC_BATHE      =SIMP(statut='f',typ='R',defaut= 1.E-10,val_min=0.E+0 ),
           NMAX_ITER_BATHE =SIMP(statut='f',typ='I',defaut= 40,val_min=0 ),
           PREC_JACOBI     =SIMP(statut='f',typ='R',defaut= 1.E-2,val_min=0.E+0 ),
           NMAX_ITER_JACOBI=SIMP(statut='f',typ='I',defaut= 12,val_min=0 ),
         ),
         b_sorensen =BLOC(condition = "METHODE == 'SORENSEN'",
           PREC_SOREN      =SIMP(statut='f',typ='R',defaut= 0.E+0,val_min=0.E+0 ),  
           NMAX_ITER_SOREN =SIMP(statut='f',typ='I',defaut= 20,val_min=0 ),  
           PARA_ORTHO_SOREN=SIMP(statut='f',typ='R',defaut= 0.717,val_min=0.E+0 ),
         ),
         TYPE_RESU       =SIMP(statut='f',typ='TXM',defaut="DYNAMIQUE",
                               into=("MODE_FLAMB","DYNAMIQUE"),
                               fr="Type d analyse" ),
         OPTION          =SIMP(statut='f',typ='TXM',defaut="SANS",into=("MODE_RIGIDE","SANS"),
                               fr="Calcul des modes de corps rigide, uniquement pour la méthode TRI_DIAG" ),

         b_flamb         =BLOC(condition = "TYPE_RESU == 'MODE_FLAMB'",
           CALC_FREQ       =FACT(statut='d',min=0,
             OPTION          =SIMP(statut='f',typ='TXM',defaut="PLUS_PETITE",into=("PLUS_PETITE","BANDE","CENTRE"),
                                   fr="Choix de l option et par conséquent du shift du problème modal" ),
             b_plus_petite =BLOC(condition = "OPTION == 'PLUS_PETITE'",fr="Recherche des plus petites valeurs propres",
               NMAX_FREQ       =SIMP(statut='f',typ='I',defaut= 10,val_min=0 ),
             ),
             b_centre      =BLOC(condition = "OPTION == 'CENTRE'",
                                 fr="Recherche des valeurs propres les plus proches d une valeur donnée",
               CHAR_CRIT       =SIMP(statut='o',typ='R',
                                     fr="Charge critique autour de laquelle on cherche les charges critiques propres"),
               NMAX_FREQ       =SIMP(statut='f',typ='I',defaut= 10,val_min=0 ),
             ),
             b_bande       =BLOC(condition = "(OPTION == 'BANDE')",
                                 fr="Recherche des valeurs propres dans une bande donnée",
               CHAR_CRIT       =SIMP(statut='o',typ='R',min=2,validators=NoRepeat(),max=2,
                                     fr="Valeur des deux charges critiques délimitant la bande de recherche"),
             ),           
             APPROCHE        =SIMP(statut='f',typ='TXM',defaut="REEL",into=("REEL","IMAG"),
                                   fr="Choix du pseudo-produit scalaire pour la résolution du problème quadratique" ),           
             regles=(EXCLUS('DIM_SOUS_ESPACE','COEF_DIM_ESPACE'),),
             DIM_SOUS_ESPACE =SIMP(statut='f',typ='I' ),
             COEF_DIM_ESPACE =SIMP(statut='f',typ='I' ),
             NPREC_SOLVEUR   =SIMP(statut='f',typ='I',defaut= 8,val_min=0 ),
             NMAX_ITER_SHIFT =SIMP(statut='f',typ='I',defaut= 5,val_min=0 ),
             PREC_SHIFT      =SIMP(statut='f',typ='R',defaut= 5.E-2,val_min=0.E+0 ),
             SEUIL_FREQ      =SIMP(statut='f',typ='R',defaut= 1.E-2,val_min=0.E+0 ),
           ),
         ),

         b_dynam        =BLOC(condition = "TYPE_RESU == 'DYNAMIQUE'",
           CALC_FREQ       =FACT(statut='d',min=0,
             OPTION          =SIMP(statut='f',typ='TXM',defaut="PLUS_PETITE",into=("PLUS_PETITE","BANDE","CENTRE"),
                                   fr="Choix de l option et par conséquent du shift du problème modal" ),
             b_plus_petite =BLOC(condition = "OPTION == 'PLUS_PETITE'",fr="Recherche des plus petites valeurs propres",
               NMAX_FREQ       =SIMP(statut='f',typ='I',defaut= 10,val_min=0 ),
             ),
             b_centre       =BLOC(condition = "OPTION == 'CENTRE'",
                                  fr="Recherche des valeurs propres les plus proches d une valeur donnée",
               FREQ            =SIMP(statut='o',typ='R',
                                     fr="Fréquence autour de laquelle on cherche les fréquences propres"),
               AMOR_REDUIT     =SIMP(statut='f',typ='R',),
               NMAX_FREQ       =SIMP(statut='f',typ='I',defaut= 10,val_min=0 ),
             ),
             b_bande         =BLOC(condition = "(OPTION == 'BANDE')",
                                   fr="Recherche des valeurs propres dans une bande donnée",
               FREQ            =SIMP(statut='o',typ='R',min=2,validators=NoRepeat(),max=2,
                                     fr="Valeur des deux fréquences délimitant la bande de recherche"),
             ),           
             APPROCHE        =SIMP(statut='f',typ='TXM',defaut="REEL",into=("REEL","IMAG","COMPLEXE"),
                                   fr="Choix du pseudo-produit scalaire pour la résolution du problème quadratique" ),           
             regles=(EXCLUS('DIM_SOUS_ESPACE','COEF_DIM_ESPACE'),),
             DIM_SOUS_ESPACE =SIMP(statut='f',typ='I' ),
             COEF_DIM_ESPACE =SIMP(statut='f',typ='I' ),
             NPREC_SOLVEUR   =SIMP(statut='f',typ='I',defaut= 8,val_min=0 ),
             NMAX_ITER_SHIFT =SIMP(statut='f',typ='I',defaut= 5,val_min=0 ),
             PREC_SHIFT      =SIMP(statut='f',typ='R',defaut= 5.E-2,val_min=0.E+0 ),
             SEUIL_FREQ      =SIMP(statut='f',typ='R',defaut= 1.E-2,val_min=0.E+0 ),
           ),
         ),

         VERI_MODE       =FACT(statut='d',min=0,
           STOP_ERREUR     =SIMP(statut='f',typ='TXM',defaut="OUI",into=("OUI","NON") ),
           PREC_SHIFT      =SIMP(statut='f',typ='R',defaut= 5.E-3,val_min=0.E+0 ),
           SEUIL           =SIMP(statut='f',typ='R',defaut= 1.E-6,val_min=0.E+0,
                                 fr="Valeur limite admise pour l ereur a posteriori des modes" ),
           STURM           =SIMP(statut='f',typ='TXM',defaut="OUI",into=("OUI","NON") ),
         ),
         SENSIBILITE     =SIMP(statut='f',typ=(para_sensi,theta_geom),validators=NoRepeat(),max='**',
                               fr="Liste des param\350tres de sensibilit\351.",
                               ang="List of sensitivity parameters",
         ),
         b_sensibilite   =BLOC(condition = "SENSIBILITE != None",
             CHAM_MATER      =SIMP(statut='f',typ=cham_mater ),
             CARA_ELEM       =SIMP(statut='f',typ=cara_elem ),
             EXCIT           =FACT(statut='f',max='**',),  # que pour NMDOME
         ),
         STOP_FREQ_VIDE  =SIMP(statut='f',typ='TXM',defaut="OUI",into=("OUI","NON") ),
         INFO            =SIMP(statut='f',typ='I',defaut= 1,into=( 1 , 2) ),
         TITRE           =SIMP(statut='f',typ='TXM',max='**'),        
)  ;
#& MODIF COMMANDE  DATE 22/06/2005   AUTEUR REZETTE C.REZETTE 
#            CONFIGURATION MANAGEMENT OF EDF VERSION
# ======================================================================
# COPYRIGHT (C) 1991 - 2001  EDF R&D                  WWW.CODE-ASTER.ORG
# THIS PROGRAM IS FREE SOFTWARE; YOU CAN REDISTRIBUTE IT AND/OR MODIFY
# IT UNDER THE TERMS OF THE GNU GENERAL PUBLIC LICENSE AS PUBLISHED BY
# THE FREE SOFTWARE FOUNDATION; EITHER VERSION 2 OF THE LICENSE, OR   
# (AT YOUR OPTION) ANY LATER VERSION.                                 
#
# THIS PROGRAM IS DISTRIBUTED IN THE HOPE THAT IT WILL BE USEFUL, BUT 
# WITHOUT ANY WARRANTY; WITHOUT EVEN THE IMPLIED WARRANTY OF          
# MERCHANTABILITY OR FITNESS FOR A PARTICULAR PURPOSE. SEE THE GNU    
# GENERAL PUBLIC LICENSE FOR MORE DETAILS.                            
#
# YOU SHOULD HAVE RECEIVED A COPY OF THE GNU GENERAL PUBLIC LICENSE   
# ALONG WITH THIS PROGRAM; IF NOT, WRITE TO EDF R&D CODE_ASTER,       
#    1 AVENUE DU GENERAL DE GAULLE, 92141 CLAMART CEDEX, FRANCE.      
# ======================================================================
def mode_stat_prod(MODE_STAT,FORCE_NODALE,PSEUDO_MODE,**args):
 if (MODE_STAT != None)          : return mode_stat_depl
 if (PSEUDO_MODE !=None)         : return mode_stat_acce
 if (FORCE_NODALE != None)       : return mode_stat_forc
 raise AsException("type de concept resultat non prevu")
MODE_STATIQUE=OPER(nom="MODE_STATIQUE",op= 93,sd_prod=mode_stat_prod,
                   fr="Calcul de modes statiques pour un déplacement, une force ou une accélération unitaire imposé",
                   reentrant='n',
            UIinfo={"groupes":("Résolution",)},
         MATR_RIGI       =SIMP(statut='o',typ=matr_asse_depl_r ),
         MATR_MASS       =SIMP(statut='f',typ=matr_asse_depl_r ),
               regles=(UN_PARMI('MODE_STAT','FORCE_NODALE','PSEUDO_MODE'),),
         MODE_STAT       =FACT(statut='f',max='**',
           regles=(UN_PARMI('TOUT','NOEUD','GROUP_NO'),
                   UN_PARMI('TOUT_CMP','AVEC_CMP','SANS_CMP'),),
           TOUT            =SIMP(statut='f',typ='TXM',into=("OUI",) ,),
           NOEUD           =SIMP(statut='f',typ=no   ,max='**'),
           GROUP_NO        =SIMP(statut='f',typ=grno ,max='**'),
           TOUT_CMP        =SIMP(statut='f',typ='TXM',into=("OUI",) ,),
           AVEC_CMP        =SIMP(statut='f',typ='TXM',max='**'),
           SANS_CMP        =SIMP(statut='f',typ='TXM',max='**'),
         ),
         FORCE_NODALE    =FACT(statut='f',max='**',
           regles=(UN_PARMI('TOUT','NOEUD','GROUP_NO'),
                   UN_PARMI('TOUT_CMP','AVEC_CMP','SANS_CMP'),),
           TOUT            =SIMP(statut='f',typ='TXM',into=("OUI",), ),
           NOEUD           =SIMP(statut='f',typ=no   ,max='**'),
           GROUP_NO        =SIMP(statut='f',typ=grno ,max='**'),
           TOUT_CMP        =SIMP(statut='f',typ='TXM',into=("OUI",), ),
           AVEC_CMP        =SIMP(statut='f',typ='TXM',max='**'),
           SANS_CMP        =SIMP(statut='f',typ='TXM',max='**'),
         ),
         PSEUDO_MODE       =FACT(statut='f',max='**',
           regles=(UN_PARMI('AXE','DIRECTION','TOUT','NOEUD','GROUP_NO' ),),
           AXE             =SIMP(statut='f',typ='TXM',into=("X","Y","Z"),max=3),
           DIRECTION       =SIMP(statut='f',typ='R',min=3,max=3),
           TOUT            =SIMP(statut='f',typ='TXM',into=("OUI",)),
           NOEUD           =SIMP(statut='f',typ=no   ,max='**'),
           GROUP_NO        =SIMP(statut='f',typ=grno ,max='**'),
           b_dir           =BLOC(condition = "DIRECTION != None",
             NOM_DIR         =SIMP(statut='f',typ='TXM' ),),
           b_cmp          =BLOC(condition="TOUT!= None or NOEUD!=None or GROUP_NO!=None",
             regles=(UN_PARMI('TOUT_CMP','AVEC_CMP','SANS_CMP'),),
             TOUT_CMP        =SIMP(statut='f',typ='TXM',into=("OUI",) ),
             AVEC_CMP        =SIMP(statut='f',typ='TXM',max='**'),
             SANS_CMP        =SIMP(statut='f',typ='TXM',max='**'), 
        ),
         ),
         TITRE           =SIMP(statut='f',typ='TXM',max='**'),
         INFO            =SIMP(statut='f',typ='I',defaut= 1,into=( 1 , 2 ,) ),
)  ;
#& MODIF COMMANDE  DATE 22/06/2005   AUTEUR REZETTE C.REZETTE 
#            CONFIGURATION MANAGEMENT OF EDF VERSION
# ======================================================================
# COPYRIGHT (C) 1991 - 2001  EDF R&D                  WWW.CODE-ASTER.ORG
# THIS PROGRAM IS FREE SOFTWARE; YOU CAN REDISTRIBUTE IT AND/OR MODIFY
# IT UNDER THE TERMS OF THE GNU GENERAL PUBLIC LICENSE AS PUBLISHED BY
# THE FREE SOFTWARE FOUNDATION; EITHER VERSION 2 OF THE LICENSE, OR   
# (AT YOUR OPTION) ANY LATER VERSION.                                 
#
# THIS PROGRAM IS DISTRIBUTED IN THE HOPE THAT IT WILL BE USEFUL, BUT 
# WITHOUT ANY WARRANTY; WITHOUT EVEN THE IMPLIED WARRANTY OF          
# MERCHANTABILITY OR FITNESS FOR A PARTICULAR PURPOSE. SEE THE GNU    
# GENERAL PUBLIC LICENSE FOR MORE DETAILS.                            
#
# YOU SHOULD HAVE RECEIVED A COPY OF THE GNU GENERAL PUBLIC LICENSE   
# ALONG WITH THIS PROGRAM; IF NOT, WRITE TO EDF R&D CODE_ASTER,       
#    1 AVENUE DU GENERAL DE GAULLE, 92141 CLAMART CEDEX, FRANCE.      
# ======================================================================
MODI_BASE_MODALE=OPER(nom="MODI_BASE_MODALE",op= 149,sd_prod=mode_meca,
                      reentrant='f',
            fr="Définir la base modale d'une structure sous écoulement",
            UIinfo={"groupes":("Matrices/vecteurs",)},
#  la commande modi_base _modale : reentrant = f ou o                      
         regles=(EXCLUS('AMOR_UNIF','AMOR_REDUIT', ),),
         BASE            =SIMP(statut='o',typ=mode_meca ),
         BASE_ELAS_FLUI  =SIMP(statut='o',typ=melasflu_sdaster ),
         NUME_VITE_FLUI  =SIMP(statut='o',typ='I' ),
         NUME_ORDRE      =SIMP(statut='f',typ='I',validators=NoRepeat(),max='**'),
         AMOR_REDUIT     =SIMP(statut='f',typ='R',max='**'),
         AMOR_UNIF       =SIMP(statut='f',typ='R' ),
         INFO            =SIMP(statut='f',typ='I',defaut= 1,into=(1,2) ),
         TITRE           =SIMP(statut='f',typ='TXM',max='**'),
)  ;
#& MODIF COMMANDE  DATE 10/07/2006   AUTEUR LEBOUVIE F.LEBOUVIER 
#            CONFIGURATION MANAGEMENT OF EDF VERSION
# ======================================================================
# COPYRIGHT (C) 1991 - 2001  EDF R&D                  WWW.CODE-ASTER.ORG
# THIS PROGRAM IS FREE SOFTWARE; YOU CAN REDISTRIBUTE IT AND/OR MODIFY
# IT UNDER THE TERMS OF THE GNU GENERAL PUBLIC LICENSE AS PUBLISHED BY
# THE FREE SOFTWARE FOUNDATION; EITHER VERSION 2 OF THE LICENSE, OR   
# (AT YOUR OPTION) ANY LATER VERSION.                                 
#
# THIS PROGRAM IS DISTRIBUTED IN THE HOPE THAT IT WILL BE USEFUL, BUT 
# WITHOUT ANY WARRANTY; WITHOUT EVEN THE IMPLIED WARRANTY OF          
# MERCHANTABILITY OR FITNESS FOR A PARTICULAR PURPOSE. SEE THE GNU    
# GENERAL PUBLIC LICENSE FOR MORE DETAILS.                            
#
# YOU SHOULD HAVE RECEIVED A COPY OF THE GNU GENERAL PUBLIC LICENSE   
# ALONG WITH THIS PROGRAM; IF NOT, WRITE TO EDF R&D CODE_ASTER,       
#    1 AVENUE DU GENERAL DE GAULLE, 92141 CLAMART CEDEX, FRANCE.      
# ======================================================================
# RESPONSABLE G8BHHXD X.DESROCHES
MODI_MAILLAGE=OPER(nom="MODI_MAILLAGE",op= 154,sd_prod=maillage_sdaster,
                   fr="Effectuer des modifications sur un maillage existant: réorienter des mailles servant,"
                      +" à l'application d'une pression, à la modélisation du contact,...",
                   reentrant='o',
            UIinfo={"groupes":("Maillage",)},
      regles=(AU_MOINS_UN('ORIE_FISSURE','DEFORME','EQUE_PIQUA','ORIE_PEAU_2D',
                       'ORIE_PEAU_3D','ORIE_NORM_COQUE','PLAQ_TUBE','MODI_MAILLE',
                       'TRANSLATION','ROTATION','MODI_BASE','ECHELLE','ORIE_SHB8','SYMETRIE',
                       ),
              PRESENT_ABSENT('ORIE_FISSURE','DEFORME','EQUE_PIQUA','ORIE_PEAU_2D',
                       'ORIE_PEAU_3D','ORIE_NORM_COQUE','PLAQ_TUBE','MODI_MAILLE',),
              PRESENT_ABSENT('DEFORME','ORIE_FISSURE','EQUE_PIQUA','ORIE_PEAU_2D',
                       'ORIE_PEAU_3D','ORIE_NORM_COQUE','PLAQ_TUBE','MODI_MAILLE',),
              PRESENT_ABSENT('EQUE_PIQUA','ORIE_FISSURE','DEFORME','ORIE_PEAU_2D',
                       'ORIE_PEAU_3D','ORIE_NORM_COQUE','PLAQ_TUBE','MODI_MAILLE',),
              PRESENT_ABSENT('ORIE_PEAU_2D','ORIE_FISSURE','DEFORME','EQUE_PIQUA',
                       'ORIE_PEAU_3D','ORIE_NORM_COQUE','PLAQ_TUBE','MODI_MAILLE',),
              PRESENT_ABSENT('ORIE_PEAU_3D','ORIE_FISSURE','DEFORME','EQUE_PIQUA','ORIE_PEAU_2D',
                       'PLAQ_TUBE','MODI_MAILLE',),
              PRESENT_ABSENT('ORIE_NORM_COQUE','ORIE_FISSURE','DEFORME','EQUE_PIQUA','ORIE_PEAU_2D',
                       'PLAQ_TUBE','MODI_MAILLE',),
              PRESENT_ABSENT('PLAQ_TUBE','ORIE_FISSURE','DEFORME','EQUE_PIQUA','ORIE_PEAU_2D',
                       'ORIE_PEAU_3D','ORIE_NORM_COQUE','MODI_MAILLE',),
              PRESENT_ABSENT('MODI_MAILLE','ORIE_FISSURE','DEFORME','EQUE_PIQUA','ORIE_PEAU_2D',
                       'ORIE_PEAU_3D','ORIE_NORM_COQUE','PLAQ_TUBE',),
              EXCLUS('EQUE_PIQUA','PLAQ_TUBE'),
              EXCLUS('EQUE_PIQUA','TUBE_COUDE'),
              EXCLUS('ROTATION','MODI_BASE'),
              EXCLUS('SYMETRIE','ROTATION'),
              EXCLUS('SYMETRIE','TRANSLATION'),
              EXCLUS('SYMETRIE','MODI_BASE'),
              EXCLUS('SYMETRIE','ECHELLE'),
              ),
         MAILLAGE        =SIMP(statut='o',typ=maillage_sdaster ),

         ORIE_FISSURE    =FACT(statut='f',
           GROUP_MA        =SIMP(statut='o',typ=grma,validators=NoRepeat(),max='**'),
         ),

         DEFORME         =FACT(statut='f',
           OPTION          =SIMP(statut='o',typ='TXM',into=("TRAN","TRAN_APPUI") ),
           DEPL            =SIMP(statut='o',typ=cham_no_sdaster ),
        b_deform        =BLOC(condition = "OPTION=='TRAN_APPUI'", 
           GROUP_NO_APPUI = SIMP(statut='o',typ=grno,validators=NoRepeat(),max='**' ),
           GROUP_NO_STRU  = SIMP(statut='o',typ=grno,validators=NoRepeat(),max='**' ),),
         ),

         EQUE_PIQUA      =FACT(statut='f',
           GROUP_NO        =SIMP(statut='o',typ=grno),
           E_BASE          =SIMP(statut='o',typ='R' ),
           DEXT_BASE       =SIMP(statut='o',typ='R' ),
           L_BASE          =SIMP(statut='o',typ='R' ),
           L_CHANF         =SIMP(statut='o',typ='R' ),
           TYPE            =SIMP(statut='o',typ='TXM',into=("TYPE_1","TYPE_2")),
           H_SOUD          =SIMP(statut='o',typ='R' ),
           ANGL_SOUD       =SIMP(statut='o',typ='R' ),
           JEU_SOUD        =SIMP(statut='o',typ='R' ),
           E_CORP          =SIMP(statut='o',typ='R' ),
           DEXT_CORP       =SIMP(statut='o',typ='R' ),
           AZIMUT          =SIMP(statut='o',typ='R' ),
           RAFF_MAIL       =SIMP(statut='o',typ='TXM' ),
           X_MAX           =SIMP(statut='o',typ='R' ),
         ),
         ORIE_PEAU_2D    =FACT(statut='f',max='**',
           GROUP_MA        =SIMP(statut='o',typ=grma,validators=NoRepeat(),max='**'),
         ),
         ORIE_PEAU_3D    =FACT(statut='f',max='**',
           GROUP_MA        =SIMP(statut='o',typ=grma,validators=NoRepeat(),max='**'),
         ),
         ORIE_SHB8       =FACT(statut='f',max=1,
           GROUP_MA        =SIMP(statut='o',typ=grma,validators=NoRepeat(),max='**'),
         ),
         ORIE_NORM_COQUE =FACT(statut='f',max='**',
           regles=(EXCLUS('NOEUD','GROUP_NO'),
                   PRESENT_PRESENT('NOEUD','VECT_NORM'),
                   PRESENT_PRESENT('GROUP_NO','VECT_NORM'),),
           GROUP_MA        =SIMP(statut='o',typ=grma,validators=NoRepeat(),max='**'),
           VECT_NORM       =SIMP(statut='f',typ='R',max=3),
           NOEUD           =SIMP(statut='f',typ=no),
           GROUP_NO        =SIMP(statut='f',typ=grno),
         ),
         PLAQ_TUBE       =FACT(statut='f',
           DEXT            =SIMP(statut='o',typ='R' ),
           EPAIS           =SIMP(statut='o',typ='R' ),
           L_TUBE_P1       =SIMP(statut='o',typ='R' ),
           AZIMUT          =SIMP(statut='f',typ='R',defaut= 90. ),
           COUTURE         =SIMP(statut='f',typ='TXM',defaut="OUI",into=("OUI","NON",)  ),
         ),
         TUBE_COUDE      =FACT(statut='f',
           ANGLE           =SIMP(statut='o',typ='R' ),
           R_CINTR         =SIMP(statut='o',typ='R' ),
           L_TUBE_P1       =SIMP(statut='o',typ='R' ),
         ),
         MODI_MAILLE     =FACT(statut='f',max=1,
           regles=(AU_MOINS_UN('GROUP_MA_FOND','MAILLE_FOND','GROUP_NO_FOND','NOEUD_FOND'),),
           OPTION          =SIMP(statut='o',typ='TXM',into=("NOEUD_QUART",) ),
           GROUP_MA_FOND   =SIMP(statut='f',typ=grma,validators=NoRepeat(),max=1),
           MAILLE_FOND     =SIMP(statut='f',typ=ma  ,validators=NoRepeat(),max=1),
           GROUP_NO_FOND   =SIMP(statut='f',typ=grno,validators=NoRepeat(),max=1),
           NOEUD_FOND      =SIMP(statut='f',typ=no  ,validators=NoRepeat(),max=1),
         ),
         MODI_BASE       =FACT(statut='f',
           VECT_X          =SIMP(statut='o',typ='R',min=2,max=3),
           VECT_Y          =SIMP(statut='f',typ='R',min=2,max=3),
         ),
         ECHELLE         =SIMP(statut='f',typ='R',),        
         TRANSLATION     =SIMP(statut='f',typ='R',min=2,max=3),
         ROTATION        =FACT(statut='f',max='**',
           POIN_1           =SIMP(statut='o',typ='R',min=2,max=3),
           ANGL             =SIMP(statut='o',typ='R',defaut= 0.E+0 ),
           regles=(EXCLUS('DIR','POIN_2'),),
           POIN_2           =SIMP(statut='f',typ='R',min=2,max=3),
           DIR              =SIMP(statut='f',typ='R',min=2,max=3),
         ),
         SYMETRIE        =FACT(statut='f',max='**',
                          fr = "Symétrie du maillage par rapport à un plan en 3D ou à une droite en 2D.",
           POINT           =SIMP(statut='o',typ='R',min=2,max=3,
                            fr="Point appartenant à la droite ou au plan."),
           AXE_1           =SIMP(statut='o',typ='R',min=2,max=3,
                            fr="Vecteur directeur de la droite ou 1er vecteur appartenant au plan."),
           AXE_2           =SIMP(statut='f',typ='R',min=3,max=3,
                            fr="2nd vecteur appartenant du plan."),
         ),
         INFO            =SIMP(statut='f',typ='I',defaut= 1,into=( 1 , 2) ),
)  ;
#& MODIF COMMANDE  DATE 13/06/2006   AUTEUR GENIAUT S.GENIAUT 
#            CONFIGURATION MANAGEMENT OF EDF VERSION
# ======================================================================
# COPYRIGHT (C) 1991 - 2004  EDF R&D                  WWW.CODE-ASTER.ORG
# THIS PROGRAM IS FREE SOFTWARE; YOU CAN REDISTRIBUTE IT AND/OR MODIFY  
# IT UNDER THE TERMS OF THE GNU GENERAL PUBLIC LICENSE AS PUBLISHED BY  
# THE FREE SOFTWARE FOUNDATION; EITHER VERSION 2 OF THE LICENSE, OR     
# (AT YOUR OPTION) ANY LATER VERSION.                                                  
#                                                                       
# THIS PROGRAM IS DISTRIBUTED IN THE HOPE THAT IT WILL BE USEFUL, BUT   
# WITHOUT ANY WARRANTY; WITHOUT EVEN THE IMPLIED WARRANTY OF            
# MERCHANTABILITY OR FITNESS FOR A PARTICULAR PURPOSE. SEE THE GNU      
# GENERAL PUBLIC LICENSE FOR MORE DETAILS.                              
#                                                                       
# YOU SHOULD HAVE RECEIVED A COPY OF THE GNU GENERAL PUBLIC LICENSE     
# ALONG WITH THIS PROGRAM; IF NOT, WRITE TO EDF R&D CODE_ASTER,         
#    1 AVENUE DU GENERAL DE GAULLE, 92141 CLAMART CEDEX, FRANCE.        
# ======================================================================

MODI_MODELE_XFEM=OPER(nom="MODI_MODELE_XFEM",op= 113,sd_prod=modele_sdaster,docu="U4.44.12-e",reentrant='f',
            UIinfo={"groupes":("Modélisation",)},
               fr="Engendrer ou enrichir une structure de donnees en affectant les cham_gd associes",

    MODELE_IN       =SIMP(statut='o',typ=modele_sdaster,min=01,max=01,),
    FISSURE         =SIMP(statut='o',typ=fiss_xfem,min=01,max=01,),
    CRITERE         =SIMP(statut='f',typ='R',defaut=1.67E-8),
    INFO            =SIMP(statut='f',typ='I',defaut= 1,into=(1,2,)),

)  ;
#& MODIF COMMANDE  DATE 10/10/2006   AUTEUR MCOURTOI M.COURTOIS 
#            CONFIGURATION MANAGEMENT OF EDF VERSION
# ======================================================================
# COPYRIGHT (C) 1991 - 2001  EDF R&D                  WWW.CODE-ASTER.ORG
# THIS PROGRAM IS FREE SOFTWARE; YOU CAN REDISTRIBUTE IT AND/OR MODIFY
# IT UNDER THE TERMS OF THE GNU GENERAL PUBLIC LICENSE AS PUBLISHED BY
# THE FREE SOFTWARE FOUNDATION; EITHER VERSION 2 OF THE LICENSE, OR   
# (AT YOUR OPTION) ANY LATER VERSION.                                 
#
# THIS PROGRAM IS DISTRIBUTED IN THE HOPE THAT IT WILL BE USEFUL, BUT 
# WITHOUT ANY WARRANTY; WITHOUT EVEN THE IMPLIED WARRANTY OF          
# MERCHANTABILITY OR FITNESS FOR A PARTICULAR PURPOSE. SEE THE GNU    
# GENERAL PUBLIC LICENSE FOR MORE DETAILS.                            
#
# YOU SHOULD HAVE RECEIVED A COPY OF THE GNU GENERAL PUBLIC LICENSE   
# ALONG WITH THIS PROGRAM; IF NOT, WRITE TO EDF R&D CODE_ASTER,       
#    1 AVENUE DU GENERAL DE GAULLE, 92141 CLAMART CEDEX, FRANCE.      
# ======================================================================
MODI_OBSTACLE=OPER(nom="MODI_OBSTACLE",op=182,sd_prod=table_fonction,
            fr="Calculer les obstacles dans les systèmes guidage-tube après usure",
            reentrant='f',
            UIinfo={"groupes":("Modélisation",)},
      regles=(PRESENT_ABSENT('R_MOBILE','CRAYON'),
              PRESENT_PRESENT('V_USUR_TUBE','V_USUR_OBST'),),
         OBSTACLE        =SIMP(statut='f',typ=table_fonction),
         GUIDE           =SIMP(statut='o',typ=table_sdaster),
         CRAYON          =SIMP(statut='f',typ=table_sdaster),
         TABL_USURE      =SIMP(statut='f',typ=table_sdaster),
         INST            =SIMP(statut='f',typ='R'),  
         R_MOBILE        =SIMP(statut='f',typ='R'),  
         PERCEMENT       =SIMP(statut='f',typ='R',defaut=1),  
         V_USUR_TUBE     =SIMP(statut='f',typ='R',max='**'),
         V_USUR_OBST     =SIMP(statut='f',typ='R',max='**'),
         INFO            =SIMP(statut='f',typ='I',defaut=1,into=(1,2)),
)  ;
#& MODIF COMMANDE  DATE 12/09/2005   AUTEUR CIBHHLV L.VIVAN 
#            CONFIGURATION MANAGEMENT OF EDF VERSION
# ======================================================================
# COPYRIGHT (C) 1991 - 2001  EDF R&D                  WWW.CODE-ASTER.ORG
# THIS PROGRAM IS FREE SOFTWARE; YOU CAN REDISTRIBUTE IT AND/OR MODIFY
# IT UNDER THE TERMS OF THE GNU GENERAL PUBLIC LICENSE AS PUBLISHED BY
# THE FREE SOFTWARE FOUNDATION; EITHER VERSION 2 OF THE LICENSE, OR
# (AT YOUR OPTION) ANY LATER VERSION.
#
# THIS PROGRAM IS DISTRIBUTED IN THE HOPE THAT IT WILL BE USEFUL, BUT
# WITHOUT ANY WARRANTY; WITHOUT EVEN THE IMPLIED WARRANTY OF
# MERCHANTABILITY OR FITNESS FOR A PARTICULAR PURPOSE. SEE THE GNU
# GENERAL PUBLIC LICENSE FOR MORE DETAILS.
#
# YOU SHOULD HAVE RECEIVED A COPY OF THE GNU GENERAL PUBLIC LICENSE
# ALONG WITH THIS PROGRAM; IF NOT, WRITE TO EDF R&D CODE_ASTER,
#    1 AVENUE DU GENERAL DE GAULLE, 92141 CLAMART CEDEX, FRANCE.
# ======================================================================
# RESPONSABLE JMBHH01 J.M.PROIX
def modi_repere_prod(RESULTAT,**args):
  if AsType(RESULTAT) == evol_elas :    return evol_elas
  if AsType(RESULTAT) == evol_noli :    return evol_noli
  if AsType(RESULTAT) == evol_ther :    return evol_ther
  if AsType(RESULTAT) == dyna_trans :   return dyna_trans
  if AsType(RESULTAT) == dyna_harmo :   return dyna_harmo
  if AsType(RESULTAT) == mode_meca :    return mode_meca
  if AsType(RESULTAT) == mode_flamb :   return mode_flamb
  if AsType(RESULTAT) == mult_elas :    return mult_elas
  if AsType(RESULTAT) == base_modale  : return base_modale
  raise AsException("type de concept resultat non prevu")

MODI_REPERE=OPER(nom="MODI_REPERE",op=191,sd_prod=modi_repere_prod,reentrant='n',
            UIinfo={"groupes":("Résultats et champs",)},
                    fr="Calcule des résultats dans le repère cylindrique",
         RESULTAT        =SIMP(statut='o',typ=(evol_elas,dyna_trans,dyna_harmo,mode_meca,
                                               evol_noli,mult_elas,
                                               evol_ther,base_modale,mode_flamb) ),
         regles=(EXCLUS('TOUT_ORDRE','NUME_ORDRE','INST','FREQ','NUME_MODE',
                        'NOEUD_CMP','LIST_INST','LIST_FREQ','NOM_CAS'),),
         TOUT_ORDRE      =SIMP(statut='f',typ='TXM',into=("OUI",) ),
         NUME_ORDRE      =SIMP(statut='f',typ='I',validators=NoRepeat(),max='**'),
         NUME_MODE       =SIMP(statut='f',typ='I',validators=NoRepeat(),max='**'),
         NOEUD_CMP       =SIMP(statut='f',typ='TXM',validators=NoRepeat(),max='**'),
         NOM_CAS         =SIMP(statut='f',typ='TXM' ),

         INST            =SIMP(statut='f',typ='R',validators=NoRepeat(),max='**'),
         FREQ            =SIMP(statut='f',typ='R',validators=NoRepeat(),max='**'),
         LIST_INST       =SIMP(statut='f',typ=listr8_sdaster),
         LIST_FREQ       =SIMP(statut='f',typ=listr8_sdaster),

         PRECISION       =SIMP(statut='f',typ='R',defaut=1.0E-3 ),
         CRITERE         =SIMP(statut='f',typ='TXM',defaut="RELATIF",into=("RELATIF","ABSOLU",),),

         MODI_CHAM       =FACT(statut='o',max='**',
           GROUP_MA        =SIMP(statut='f',typ=grma,validators=NoRepeat(),max='**'),
           GROUP_NO        =SIMP(statut='f',typ=grno,validators=NoRepeat(),max='**'),
           MAILLE          =SIMP(statut='f',typ=ma  ,validators=NoRepeat(),max='**'),
           NOEUD           =SIMP(statut='f',typ=no  ,validators=NoRepeat(),max='**'),
           TYPE_CHAM       =SIMP(statut='o',typ='TXM',
                                 into=("VECT_2D","VECT_3D","TORS_3D","TENS_2D","TENS_3D"),),
           NOM_CHAM        =SIMP(statut='o',typ='TXM',into=C_NOM_CHAM_INTO()),
           b_vect_2d       =BLOC(condition = "TYPE_CHAM=='VECT_2D'",
              NOM_CMP         =SIMP(statut='o',typ='TXM',min=2,max=2 ),),
           b_vect_3d       =BLOC(condition = "TYPE_CHAM=='VECT_3D'",
              NOM_CMP         =SIMP(statut='o',typ='TXM',min=3,max=3 ),),
           b_tors_3d       =BLOC(condition = "TYPE_CHAM=='TORS_3D'",
              NOM_CMP         =SIMP(statut='o',typ='TXM',min=6,max=6 ),),
           b_tens_2d       =BLOC(condition = "TYPE_CHAM=='TENS_2D'",
              NOM_CMP         =SIMP(statut='o',typ='TXM',min=4,max=4 ),),
           b_tens_3d       =BLOC(condition = "TYPE_CHAM=='TENS_3D'",
              NOM_CMP         =SIMP(statut='o',typ='TXM',min=6,max=6 ),),
         ),
         DEFI_REPERE     =FACT(statut='o',
         regles=(UN_PARMI('ANGL_NAUT','ORIGINE'),),
           REPERE          =SIMP(statut='f',typ='TXM',defaut="UTILISATEUR",
                                 into=("UTILISATEUR","CYLINDRIQUE"),),
           ANGL_NAUT       =SIMP(statut='f',typ='R',max=3),
           ORIGINE         =SIMP(statut='f',typ='R',min=2,max=3),
           AXE_Z           =SIMP(statut='f',typ='R',min=3,max=3),
         ),
         TITRE           =SIMP(statut='f',typ='TXM',max='**'),
         INFO            =SIMP(statut='f',typ='I',defaut=1,into=(1,2)),
)  ;
#& MODIF COMMANDE  DATE 31/10/2006   AUTEUR A3BHHAE H.ANDRIAMBOLOLONA 
#            CONFIGURATION MANAGEMENT OF EDF VERSION
# ======================================================================
# COPYRIGHT (C) 1991 - 2001  EDF R&D                  WWW.CODE-ASTER.ORG
# THIS PROGRAM IS FREE SOFTWARE; YOU CAN REDISTRIBUTE IT AND/OR MODIFY
# IT UNDER THE TERMS OF THE GNU GENERAL PUBLIC LICENSE AS PUBLISHED BY
# THE FREE SOFTWARE FOUNDATION; EITHER VERSION 2 OF THE LICENSE, OR   
# (AT YOUR OPTION) ANY LATER VERSION.                                 
#
# THIS PROGRAM IS DISTRIBUTED IN THE HOPE THAT IT WILL BE USEFUL, BUT 
# WITHOUT ANY WARRANTY; WITHOUT EVEN THE IMPLIED WARRANTY OF          
# MERCHANTABILITY OR FITNESS FOR A PARTICULAR PURPOSE. SEE THE GNU    
# GENERAL PUBLIC LICENSE FOR MORE DETAILS.                            
#
# YOU SHOULD HAVE RECEIVED A COPY OF THE GNU GENERAL PUBLIC LICENSE   
# ALONG WITH THIS PROGRAM; IF NOT, WRITE TO EDF R&D CODE_ASTER,       
#    1 AVENUE DU GENERAL DE GAULLE, 92141 CLAMART CEDEX, FRANCE.      
# ======================================================================
def norm_mode_prod(MODE,**args ):
  if AsType(MODE) == mode_meca   : return mode_meca
  if AsType(MODE) == mode_meca_c : return mode_meca_c
  if AsType(MODE) == mode_flamb  : return mode_flamb
  if AsType(MODE) == base_modale : return base_modale
  raise AsException("type de concept resultat non prevu")

NORM_MODE=OPER(nom="NORM_MODE",op=  37,sd_prod=norm_mode_prod,
               fr="Normer des modes propres en fonction d'un critère choisi par l'utilisateur",
               reentrant='f',
            UIinfo={"groupes":("Résolution",)},
         regles=(UN_PARMI('NORME','NOEUD','AVEC_CMP','SANS_CMP'),
                 CONCEPT_SENSIBLE('SEPARE'),
                 DERIVABLE('MODE'),),
         MODE       =SIMP(statut='o',typ=(mode_meca,mode_flamb,base_modale) ),
         NORME      =SIMP(statut='f',typ='TXM',fr="Norme prédéfinie : masse généralisée, euclidienne,...",
                          into=("MASS_GENE","RIGI_GENE","EUCL","EUCL_TRAN","TRAN","TRAN_ROTA") ),
         NOEUD      =SIMP(statut='f',typ=no, fr="Composante donnée d un noeud spécifié égale à 1"),
         b_noeud    =BLOC(condition = "NOEUD != None",
           NOM_CMP    =SIMP(statut='o',typ='TXM' ),
         ),
         AVEC_CMP   =SIMP(statut='f',typ='TXM',validators=NoRepeat(),max='**'),
         SANS_CMP   =SIMP(statut='f',typ='TXM',validators=NoRepeat(),max='**'),
         MASS_INER  =SIMP(statut='f',typ=table_sdaster),
         MODE_SIGNE =FACT(statut='f',fr="Imposer un signe sur une des composantes des modes",
           NOEUD      =SIMP(statut='o',typ=no,fr="Noeud ou sera imposé le signe"),
           NOM_CMP    =SIMP(statut='o',typ='TXM',fr="Composante du noeud ou sera imposé le signe" ),
           SIGNE      =SIMP(statut='f',typ='TXM',defaut="POSITIF",into=("NEGATIF","POSITIF"),
                            fr="Choix du signe" ),
         ),
         SENSIBILITE     =SIMP(statut='f',typ=(para_sensi,theta_geom),validators=NoRepeat(),max='**',
                               fr="Liste des param\350tres de sensibilit\351.",
                               ang="List of sensitivity parameters",
         ),
         b_base    =BLOC(condition = "AsType(MODE) == base_modale",
              MASSE = SIMP(statut='o',typ=(matr_asse_depl_r,matr_asse_gene_r,matr_asse_pres_r ), ),
              RAIDE = SIMP(statut='o',typ=(matr_asse_depl_r,matr_asse_depl_c,matr_asse_gene_r,matr_asse_pres_r ), ),
              AMOR  = SIMP(statut='f',typ=(matr_asse_depl_r,matr_asse_gene_r) ),
         ),
         TITRE      =SIMP(statut='f',typ='TXM',max='**'),
         INFO       =SIMP(statut='f',typ='I',defaut= 1,into=( 1 , 2) ),
)  ;
#& MODIF COMMANDE  DATE 12/06/2006   AUTEUR BOITEAU O.BOITEAU 
#            CONFIGURATION MANAGEMENT OF EDF VERSION
# ======================================================================
# COPYRIGHT (C) 1991 - 2001  EDF R&D                  WWW.CODE-ASTER.ORG
# THIS PROGRAM IS FREE SOFTWARE; YOU CAN REDISTRIBUTE IT AND/OR MODIFY
# IT UNDER THE TERMS OF THE GNU GENERAL PUBLIC LICENSE AS PUBLISHED BY
# THE FREE SOFTWARE FOUNDATION; EITHER VERSION 2 OF THE LICENSE, OR
# (AT YOUR OPTION) ANY LATER VERSION.
#
# THIS PROGRAM IS DISTRIBUTED IN THE HOPE THAT IT WILL BE USEFUL, BUT
# WITHOUT ANY WARRANTY; WITHOUT EVEN THE IMPLIED WARRANTY OF
# MERCHANTABILITY OR FITNESS FOR A PARTICULAR PURPOSE. SEE THE GNU
# GENERAL PUBLIC LICENSE FOR MORE DETAILS.
#
# YOU SHOULD HAVE RECEIVED A COPY OF THE GNU GENERAL PUBLIC LICENSE
# ALONG WITH THIS PROGRAM; IF NOT, WRITE TO EDF R&D CODE_ASTER,
#    1 AVENUE DU GENERAL DE GAULLE, 92141 CLAMART CEDEX, FRANCE.
# ======================================================================
# RESPONSABLE VABHHTS J.PELLET
NUME_DDL=OPER(nom="NUME_DDL",op=11,sd_prod=nume_ddl_sdaster,reentrant='n',
            UIinfo={"groupes":("Matrices/vecteurs",)},
              fr="Etablissement de la numérotation des ddl avec ou sans renumérotation et du stockage de la matrice",
                  regles=(UN_PARMI('MATR_RIGI','MODELE'),),
         MATR_RIGI       =SIMP(statut='f',validators=NoRepeat(),max=100,
                               typ=(matr_elem_depl_r ,matr_elem_depl_c,matr_elem_temp_r ,matr_elem_pres_c) ),
         MODELE          =SIMP(statut='f',typ=modele_sdaster ),
         b_modele        =BLOC(condition = "MODELE != None",
           CHARGE     =SIMP(statut='f',validators=NoRepeat(),max='**',typ=(char_meca,char_ther,char_acou, ),),
         ),
         METHODE         =SIMP(statut='f',typ='TXM',defaut="MULT_FRONT",into=("MULT_FRONT","LDLT","GCPC","MUMPS") ),
         b_mult_front    =BLOC(condition="METHODE=='MULT_FRONT'",fr="paramètres associés à la méthode multifrontale",
           RENUM           =SIMP(statut='f',typ='TXM',into=("MD","MDA","METIS"),defaut="METIS" ),
         ),
         b_ldlt          =BLOC(condition="METHODE=='LDLT'",fr="paramètres associés à la méthode LDLT",
           RENUM           =SIMP(statut='f',typ='TXM',into=("RCMK","SANS"),defaut="RCMK"  ),
         ),
         b_mumps        =BLOC(condition = "METHODE == 'MUMPS' ",fr="Paramètres de la méthode MUMPS",
           RENUM         =SIMP(statut='f',typ='TXM',defaut="AUTO",into=("AMD","AMF","PORD","METIS","QAMD","AUTO")),
         ),
         b_gcpc          =BLOC(condition="METHODE=='GCPC'",fr="paramètres associés à la méthode gradient conjugué",
           RENUM           =SIMP(statut='f',typ='TXM',into=("RCMK","SANS"),defaut="RCMK"  ),
         ),
         INFO            =SIMP(statut='f',typ='I',into=(1,2)),
)  ;
#& MODIF COMMANDE  DATE 22/06/2005   AUTEUR REZETTE C.REZETTE 
#            CONFIGURATION MANAGEMENT OF EDF VERSION
# ======================================================================
# COPYRIGHT (C) 1991 - 2001  EDF R&D                  WWW.CODE-ASTER.ORG
# THIS PROGRAM IS FREE SOFTWARE; YOU CAN REDISTRIBUTE IT AND/OR MODIFY
# IT UNDER THE TERMS OF THE GNU GENERAL PUBLIC LICENSE AS PUBLISHED BY
# THE FREE SOFTWARE FOUNDATION; EITHER VERSION 2 OF THE LICENSE, OR   
# (AT YOUR OPTION) ANY LATER VERSION.                                 
#
# THIS PROGRAM IS DISTRIBUTED IN THE HOPE THAT IT WILL BE USEFUL, BUT 
# WITHOUT ANY WARRANTY; WITHOUT EVEN THE IMPLIED WARRANTY OF          
# MERCHANTABILITY OR FITNESS FOR A PARTICULAR PURPOSE. SEE THE GNU    
# GENERAL PUBLIC LICENSE FOR MORE DETAILS.                            
#
# YOU SHOULD HAVE RECEIVED A COPY OF THE GNU GENERAL PUBLIC LICENSE   
# ALONG WITH THIS PROGRAM; IF NOT, WRITE TO EDF R&D CODE_ASTER,       
#    1 AVENUE DU GENERAL DE GAULLE, 92141 CLAMART CEDEX, FRANCE.      
# ======================================================================
NUME_DDL_GENE=OPER(nom="NUME_DDL_GENE",op= 127,sd_prod=nume_ddl_gene,
                   fr="Etablissement de la numérotation des ddl d'un modèle établi en coordonnées généralisées",
                    reentrant='n',
            UIinfo={"groupes":("Matrices/vecteurs",)},
         regles=UN_PARMI('MODELE_GENE','BASE'),
         MODELE_GENE     =SIMP(statut='f',typ=modele_gene ),
             b_modele_gene     =BLOC(condition = "MODELE_GENE != None",
               STOCKAGE     =SIMP(statut='f',typ='TXM',defaut="LIGN_CIEL",into=("LIGN_CIEL","PLEIN") ),
               METHODE            =SIMP(statut='f',typ='TXM',defaut="CLASSIQUE",into=("INITIAL","CLASSIQUE") ),
                                    ),
         BASE     =SIMP(statut='f',typ=(mode_meca,mode_stat,base_modale,mode_gene ) ),
             b_base     =BLOC(condition = "BASE != None",
               STOCKAGE     =SIMP(statut='f',typ='TXM',defaut="DIAG",into=("DIAG","PLEIN") ),
               NB_VECT     =SIMP(statut='f',typ='I',defaut= 9999 ),
                             ),
)  ;
#& MODIF COMMANDE  DATE 22/06/2005   AUTEUR REZETTE C.REZETTE 
#            CONFIGURATION MANAGEMENT OF EDF VERSION
# ======================================================================
# COPYRIGHT (C) 1991 - 2005  EDF R&D                  WWW.CODE-ASTER.ORG
# THIS PROGRAM IS FREE SOFTWARE; YOU CAN REDISTRIBUTE IT AND/OR MODIFY  
# IT UNDER THE TERMS OF THE GNU GENERAL PUBLIC LICENSE AS PUBLISHED BY  
# THE FREE SOFTWARE FOUNDATION; EITHER VERSION 2 OF THE LICENSE, OR     
# (AT YOUR OPTION) ANY LATER VERSION.                                                  
#                                                                       
# THIS PROGRAM IS DISTRIBUTED IN THE HOPE THAT IT WILL BE USEFUL, BUT   
# WITHOUT ANY WARRANTY; WITHOUT EVEN THE IMPLIED WARRANTY OF            
# MERCHANTABILITY OR FITNESS FOR A PARTICULAR PURPOSE. SEE THE GNU      
# GENERAL PUBLIC LICENSE FOR MORE DETAILS.                              
#                                                                       
# YOU SHOULD HAVE RECEIVED A COPY OF THE GNU GENERAL PUBLIC LICENSE     
# ALONG WITH THIS PROGRAM; IF NOT, WRITE TO EDF R&D CODE_ASTER,         
#    1 AVENUE DU GENERAL DE GAULLE, 92141 CLAMART CEDEX, FRANCE.        
# ======================================================================
POST_CHAM_XFEM=OPER(nom="POST_CHAM_XFEM",op= 196,sd_prod=resultat_sdaster,
                    reentrant='n',UIinfo={"groupes":("Post traitements",)},
            fr="Calcul des champs DEPL et SIEF_ELGA sur le maillage fissuré",
    MAILLAGE = SIMP(statut='o',typ=maillage_sdaster),
    MODELE   = SIMP(statut='o',typ=modele_sdaster,),
    RESULTAT = SIMP(statut='o',typ=resultat_sdaster),
    NOM_CHAM = SIMP(statut='o',typ='TXM',into=("DEPL","SIEF_ELGA"),)
);                     
#& MODIF COMMANDE  DATE 10/10/2006   AUTEUR MCOURTOI M.COURTOIS 
#            CONFIGURATION MANAGEMENT OF EDF VERSION
# ======================================================================
# COPYRIGHT (C) 1991 - 2001  EDF R&D                  WWW.CODE-ASTER.ORG
# THIS PROGRAM IS FREE SOFTWARE; YOU CAN REDISTRIBUTE IT AND/OR MODIFY
# IT UNDER THE TERMS OF THE GNU GENERAL PUBLIC LICENSE AS PUBLISHED BY
# THE FREE SOFTWARE FOUNDATION; EITHER VERSION 2 OF THE LICENSE, OR   
# (AT YOUR OPTION) ANY LATER VERSION.                                 
#
# THIS PROGRAM IS DISTRIBUTED IN THE HOPE THAT IT WILL BE USEFUL, BUT 
# WITHOUT ANY WARRANTY; WITHOUT EVEN THE IMPLIED WARRANTY OF          
# MERCHANTABILITY OR FITNESS FOR A PARTICULAR PURPOSE. SEE THE GNU    
# GENERAL PUBLIC LICENSE FOR MORE DETAILS.                            
#
# YOU SHOULD HAVE RECEIVED A COPY OF THE GNU GENERAL PUBLIC LICENSE   
# ALONG WITH THIS PROGRAM; IF NOT, WRITE TO EDF R&D CODE_ASTER,       
#    1 AVENUE DU GENERAL DE GAULLE, 92141 CLAMART CEDEX, FRANCE.      
# ======================================================================
from Macro.post_dyna_alea_ops import post_dyna_alea_ops

POST_DYNA_ALEA=MACRO(nom="POST_DYNA_ALEA",op= post_dyna_alea_ops,sd_prod=table_sdaster,
                    fr="Traitements statistiques de résultats de type interspectre et impression sur fichiers",
                    reentrant='n',
            UIinfo={"groupes":("Post traitements",)},
         regles=(UN_PARMI('NOEUD_I','NUME_ORDRE_I','OPTION'),),
         INTE_SPEC       =SIMP(statut='o',typ=table_fonction),
         NUME_VITE_FLUI  =SIMP(statut='f',typ='I' ),  
         TOUT_ORDRE      =SIMP(statut='f',typ='TXM',into=("OUI",) ),
         NUME_ORDRE_I    =SIMP(statut='f',typ='I',max='**' ),
         NOEUD_I         =SIMP(statut='f',typ=no,max='**'),         
         OPTION          =SIMP(statut='f',typ='TXM',into=("DIAG",) ),
         b_nume_ordre_i =BLOC(condition = "NUME_ORDRE_I != None",
           NUME_ORDRE_J    =SIMP(statut='o',typ='I',max='**' ),   
         ),  
         b_noeud_i      =BLOC(condition = "NOEUD_I != None",
           NOEUD_J         =SIMP(statut='o',typ=no,max='**'),
           NOM_CMP_I       =SIMP(statut='o',typ='TXM',max='**' ),  
           NOM_CMP_J       =SIMP(statut='o',typ='TXM',max='**' ),     
         ),  
         MOMENT          =SIMP(statut='f',typ='I',max='**',fr="Moments spectraux en complément des cinq premiers" ),  
         TITRE           =SIMP(statut='f',typ='TXM',max='**' ),  
         INFO            =SIMP(statut='f',typ='I',defaut= 1,into=(1,2) ),
)  ;
#& MODIF COMMANDE  DATE 03/01/2006   AUTEUR REZETTE C.REZETTE 
#            CONFIGURATION MANAGEMENT OF EDF VERSION
# ======================================================================
# COPYRIGHT (C) 1991 - 2001  EDF R&D                  WWW.CODE-ASTER.ORG
# THIS PROGRAM IS FREE SOFTWARE; YOU CAN REDISTRIBUTE IT AND/OR MODIFY
# IT UNDER THE TERMS OF THE GNU GENERAL PUBLIC LICENSE AS PUBLISHED BY
# THE FREE SOFTWARE FOUNDATION; EITHER VERSION 2 OF THE LICENSE, OR   
# (AT YOUR OPTION) ANY LATER VERSION.                                 
#
# THIS PROGRAM IS DISTRIBUTED IN THE HOPE THAT IT WILL BE USEFUL, BUT 
# WITHOUT ANY WARRANTY; WITHOUT EVEN THE IMPLIED WARRANTY OF          
# MERCHANTABILITY OR FITNESS FOR A PARTICULAR PURPOSE. SEE THE GNU    
# GENERAL PUBLIC LICENSE FOR MORE DETAILS.                            
#
# YOU SHOULD HAVE RECEIVED A COPY OF THE GNU GENERAL PUBLIC LICENSE   
# ALONG WITH THIS PROGRAM; IF NOT, WRITE TO EDF R&D CODE_ASTER,       
#    1 AVENUE DU GENERAL DE GAULLE, 92141 CLAMART CEDEX, FRANCE.      
# ======================================================================
POST_DYNA_MODA_T=OPER(nom="POST_DYNA_MODA_T",op= 130,sd_prod=table_sdaster,
                      fr="Post-traiter les résultats en coordonnées généralisées produit par DYNA_TRAN_MODAL",
                      reentrant='n',
            UIinfo={"groupes":("Post traitements",)},
        regles=(UN_PARMI('CHOC','RELA_EFFO_DEPL', ),),
         RESU_GENE       =SIMP(statut='o',typ=tran_gene ),
         CHOC            =FACT(statut='f',max='**',
                               fr="Analyse des non linéarités de choc",
           INST_INIT       =SIMP(statut='f',typ='R',defaut= -1. ),  
           INST_FIN        =SIMP(statut='f',typ='R',defaut= 999. ),  
           NB_BLOC         =SIMP(statut='f',typ='I',defaut= 1 ),  
           SEUIL_FORCE     =SIMP(statut='f',typ='R',defaut= 0.E+0 ),  
           DUREE_REPOS     =SIMP(statut='f',typ='R',defaut= 0.E+0 ),  
           OPTION          =SIMP(statut='f',typ='TXM',defaut="USURE",into=("IMPACT","USURE") ),
           NB_CLASSE       =SIMP(statut='f',typ='I',defaut= 10 ),  
         ),
         RELA_EFFO_DEPL  =FACT(statut='f',
                               fr="Analyse des relationsnon linéaires effort-déplacement",
           NOEUD           =SIMP(statut='o',typ=no),
           NOM_CMP         =SIMP(statut='o',typ='TXM' ),  
         ),
         INFO            =SIMP(statut='f',typ='I',defaut= 1,into=(1,2) ),
         TITRE           =SIMP(statut='f',typ='TXM',max='**' ),  
)  ;
#& MODIF COMMANDE  DATE 12/09/2006   AUTEUR REZETTE C.REZETTE 
#            CONFIGURATION MANAGEMENT OF EDF VERSION
# ======================================================================
# COPYRIGHT (C) 1991 - 2001  EDF R&D                  WWW.CODE-ASTER.ORG
# THIS PROGRAM IS FREE SOFTWARE; YOU CAN REDISTRIBUTE IT AND/OR MODIFY
# IT UNDER THE TERMS OF THE GNU GENERAL PUBLIC LICENSE AS PUBLISHED BY
# THE FREE SOFTWARE FOUNDATION; EITHER VERSION 2 OF THE LICENSE, OR   
# (AT YOUR OPTION) ANY LATER VERSION.                                 
#
# THIS PROGRAM IS DISTRIBUTED IN THE HOPE THAT IT WILL BE USEFUL, BUT 
# WITHOUT ANY WARRANTY; WITHOUT EVEN THE IMPLIED WARRANTY OF          
# MERCHANTABILITY OR FITNESS FOR A PARTICULAR PURPOSE. SEE THE GNU    
# GENERAL PUBLIC LICENSE FOR MORE DETAILS.                            
#
# YOU SHOULD HAVE RECEIVED A COPY OF THE GNU GENERAL PUBLIC LICENSE   
# ALONG WITH THIS PROGRAM; IF NOT, WRITE TO EDF R&D CODE_ASTER,       
#    1 AVENUE DU GENERAL DE GAULLE, 92141 CLAMART CEDEX, FRANCE.      
# ======================================================================
# RESPONSABLE G8BHHXD X.DESROCHES
POST_ELEM=OPER(nom="POST_ELEM",op=107,sd_prod=table_sdaster,reentrant='n',
            UIinfo={"groupes":("Post traitements",)},
               fr="Calcul de quantités globales (masse, inerties, énergie, ...) sur tout ou partie du modèle",

         regles=(UN_PARMI('MASS_INER', 'ENER_POT', 'ENER_CIN','TRAV_EXT',
                          'WEIBULL', 'RICE_TRACEY', 'CARA_GEOM','CHAR_LIMITE',
                          'CARA_POUTRE', 'INDIC_ENER', 'INDIC_SEUIL',
                          'AIRE_INTERNE','ENER_ELAS','ENER_TOTALE','INTEGRALE'),
                ),

         MASS_INER      = FACT(statut='f',max='**',
                               regles=(AU_MOINS_UN('TOUT','GROUP_MA','MAILLE'),),
                               TOUT         = SIMP(statut='f',typ='TXM',into=("OUI",) ),
                               MAILLE       = SIMP(statut='f',typ=ma  ,validators=NoRepeat(),max='**'),
                               GROUP_MA     = SIMP(statut='f',typ=grma,validators=NoRepeat(),max='**'),
                               ORIG_INER    = SIMP(statut='f',typ='R',min=3,max=3 ),
                              ),
         b_mass_iner = BLOC(condition = "( MASS_INER != None )",
                       fr="calcul de la masse, les inerties et le centre de gravité",
                       regles=(EXCLUS('CHAM_GD','RESULTAT'),
                               EXCLUS('TOUT_ORDRE','NUME_ORDRE','INST','FREQ','NUME_MODE',
                                      'NOEUD_CMP','LIST_ORDRE','LIST_INST','LIST_FREQ','NOM_CAS'),),
                       MODELE         = SIMP(statut='f',typ=modele_sdaster),
                       CHAM_MATER     = SIMP(statut='f',typ=cham_mater),
                       CARA_ELEM      = SIMP(statut='f',typ=cara_elem),
                       CHARGE         = SIMP(statut='f',typ=(char_meca,char_ther,char_acou),validators=NoRepeat(),max='**' ),
                       NUME_COUCHE    = SIMP(statut='f',typ='I',defaut=1),
                       NIVE_COUCHE    = SIMP(statut='f',typ='TXM',defaut="MOY",into=("INF","SUP","MOY"),),
                       MODE_FOURIER   = SIMP(statut='f',typ='I',defaut=0),
                       GEOMETRIE      = SIMP(statut='f',typ='TXM',defaut="INITIALE",into=("INITIALE","DEFORMEE")),
                       CHAM_GD        = SIMP(statut='f',typ=(cham_no_sdaster,cham_elem) ),
                       RESULTAT       = SIMP(statut='f',typ=(mode_meca,evol_elas,evol_noli,mult_elas,
                                                             fourier_elas,dyna_trans) ),
                       PRECISION      = SIMP(statut='f',typ='R',defaut= 1.0E-3),
                       CRITERE        = SIMP(statut='f',typ='TXM',defaut="RELATIF",into=("RELATIF","ABSOLU")),
                       TOUT_ORDRE     = SIMP(statut='f',typ='TXM',into=("OUI",) ),
                       NUME_ORDRE     = SIMP(statut='f',typ='I',),
                       LIST_ORDRE     = SIMP(statut='f',typ=listis_sdaster),
                       INST           = SIMP(statut='f',typ='R',),
                       LIST_INST      = SIMP(statut='f',typ=listr8_sdaster),
                       FREQ           = SIMP(statut='f',typ='R',),
                       LIST_FREQ      = SIMP(statut='f',typ=listr8_sdaster),
                       NUME_MODE      = SIMP(statut='f',typ='I',),
                       NOEUD_CMP      = SIMP(statut='f',typ='TXM',min=2,validators=NoRepeat(),max=2),
                       NOM_CAS        = SIMP(statut='f',typ='TXM',),
         ),

         ENER_POT       = FACT(statut='f',max='**',
                               regles=(AU_MOINS_UN('TOUT','GROUP_MA','MAILLE'),),
                               TOUT         = SIMP(statut='f',typ='TXM',into=("OUI",) ),
                               MAILLE       = SIMP(statut='f',typ=ma  ,validators=NoRepeat(),max='**'),
                               GROUP_MA     = SIMP(statut='f',typ=grma,validators=NoRepeat(),max='**'),
                              ),
         b_ener_pot = BLOC(condition = "( ENER_POT  != None )",
                       fr="calcul de l'énergie potentielle de déformation",
                       regles=(UN_PARMI('CHAM_GD','RESULTAT'),
                               EXCLUS('TOUT_ORDRE','NUME_ORDRE','INST','FREQ','NUME_MODE',
                                      'NOEUD_CMP','LIST_ORDRE','LIST_INST','LIST_FREQ','NOM_CAS'),),
                       MODELE         = SIMP(statut='f',typ=modele_sdaster),
                       CHAM_MATER     = SIMP(statut='f',typ=cham_mater),
                       CARA_ELEM      = SIMP(statut='f',typ=cara_elem),
                       CHARGE         = SIMP(statut='f',typ=(char_meca,char_ther,char_acou),validators=NoRepeat(),max='**' ),
                       NUME_COUCHE    = SIMP(statut='f',typ='I',defaut=1),
                       NIVE_COUCHE    = SIMP(statut='f',typ='TXM',defaut="MOY",into=("INF","SUP","MOY"),),
                       ANGLE          = SIMP(statut='f',typ='I',defaut=0),
                       MODE_FOURIER   = SIMP(statut='f',typ='I',defaut=0),
                       CHAM_GD        = SIMP(statut='f',typ=(cham_no_sdaster,cham_elem) ),
                       RESULTAT       = SIMP(statut='f',typ=(mode_meca,evol_elas,evol_ther,evol_noli,dyna_trans,mult_elas) ),
                       PRECISION      = SIMP(statut='f',typ='R',defaut= 1.0E-3),
                       CRITERE        = SIMP(statut='f',typ='TXM',defaut="RELATIF",into=("RELATIF","ABSOLU")),
                       TOUT_ORDRE     = SIMP(statut='f',typ='TXM',into=("OUI",) ),
                       NUME_ORDRE     = SIMP(statut='f',typ='I',validators=NoRepeat(),max='**'),
                       LIST_ORDRE     = SIMP(statut='f',typ=listis_sdaster),
                       INST           = SIMP(statut='f',typ='R',validators=NoRepeat(),max='**'),
                       LIST_INST      = SIMP(statut='f',typ=listr8_sdaster),
                       FREQ           = SIMP(statut='f',typ='R',validators=NoRepeat(),max='**'),
                       LIST_FREQ      = SIMP(statut='f',typ=listr8_sdaster),
                       NUME_MODE      = SIMP(statut='f',typ='I'  ,validators=NoRepeat(),max='**'),
                       NOEUD_CMP      = SIMP(statut='f',typ='TXM',validators=NoRepeat(),max='**'),
                       NOM_CAS        = SIMP(statut='f',typ='TXM',validators=NoRepeat(),max='**'),
         ),

         ENER_CIN       = FACT(statut='f',max='**',
                               regles=(AU_MOINS_UN('TOUT','GROUP_MA','MAILLE'),),
                               OPTION       = SIMP(statut='f',typ='TXM',
                                                   into=("MASS_MECA","MASS_MECA_DIAG"),
                                                   defaut="MASS_MECA" ),
                               TOUT         = SIMP(statut='f',typ='TXM',into=("OUI",) ),
                               MAILLE       = SIMP(statut='f',typ=ma  ,validators=NoRepeat(),max='**'),
                               GROUP_MA     = SIMP(statut='f',typ=grma,validators=NoRepeat(),max='**'),
                              ),
         b_ener_cin = BLOC(condition = "( ENER_CIN != None )",
                       fr="calcul de l'énergie cinétique",
                       regles=(UN_PARMI('CHAM_GD','RESULTAT'),
                               EXCLUS('TOUT_ORDRE','NUME_ORDRE','INST','FREQ','NUME_MODE',
                                      'NOEUD_CMP','LIST_ORDRE','LIST_INST','LIST_FREQ','NOM_CAS'),),
                       MODELE         = SIMP(statut='f',typ=modele_sdaster),
                       CHAM_MATER     = SIMP(statut='f',typ=cham_mater),
                       CARA_ELEM      = SIMP(statut='f',typ=cara_elem),
                       CHARGE         = SIMP(statut='f',typ=(char_meca,char_ther,char_acou),validators=NoRepeat(),max='**' ),
                       NUME_COUCHE    = SIMP(statut='f',typ='I',defaut=1),
                       NIVE_COUCHE    = SIMP(statut='f',typ='TXM',defaut="MOY",into=("INF","SUP","MOY"),),
                       ANGLE          = SIMP(statut='f',typ='I',defaut=0),
                       MODE_FOURIER   = SIMP(statut='f',typ='I',defaut=0),
                       CHAM_GD        = SIMP(statut='f',typ=(cham_no_sdaster,cham_elem) ),
                       RESULTAT       = SIMP(statut='f',typ=(mode_meca,evol_elas,evol_ther,evol_noli,dyna_trans) ),
                       PRECISION      = SIMP(statut='f',typ='R',defaut= 1.0E-3),
                       CRITERE        = SIMP(statut='f',typ='TXM',defaut="RELATIF",into=("RELATIF","ABSOLU")),
                       TOUT_ORDRE     = SIMP(statut='f',typ='TXM',into=("OUI",) ),
                       NUME_ORDRE     = SIMP(statut='f',typ='I',validators=NoRepeat(),max='**'),
                       LIST_ORDRE     = SIMP(statut='f',typ=listis_sdaster),
                       INST           = SIMP(statut='f',typ='R',validators=NoRepeat(),max='**'),
                       LIST_INST      = SIMP(statut='f',typ=listr8_sdaster),
                       FREQ           = SIMP(statut='f',typ='R',validators=NoRepeat(),max='**'),
                       LIST_FREQ      = SIMP(statut='f',typ=listr8_sdaster),
                       NUME_MODE      = SIMP(statut='f',typ='I',validators=NoRepeat(),max='**'),
                       NOEUD_CMP      = SIMP(statut='f',typ='TXM',validators=NoRepeat(),max='**'),
                       NOM_CAS        = SIMP(statut='f',typ='TXM',validators=NoRepeat(),max='**'),
         ),

         ENER_ELAS      = FACT(statut='f',max='**',
                               regles=(AU_MOINS_UN('TOUT','GROUP_MA','MAILLE'),),
                               TOUT         = SIMP(statut='f',typ='TXM',into=("OUI",) ),
                               MAILLE       = SIMP(statut='f',typ=ma  ,validators=NoRepeat(),max='**'),
                               GROUP_MA     = SIMP(statut='f',typ=grma,validators=NoRepeat(),max='**'),
                              ),
         b_ener_elas = BLOC(condition = "( ENER_ELAS != None )",
                       fr="calcul de l'énergie de déformation élastique",
                       MODELE         = SIMP(statut='f',typ=modele_sdaster),
                       CHAM_MATER     = SIMP(statut='f',typ=cham_mater),
                       CARA_ELEM      = SIMP(statut='f',typ=cara_elem),
                       CHARGE         = SIMP(statut='f',typ=(char_meca,char_ther,char_acou),validators=NoRepeat(),max='**' ),
                       NUME_COUCHE    = SIMP(statut='f',typ='I',defaut=1),
                       NIVE_COUCHE    = SIMP(statut='f',typ='TXM',defaut="MOY",into=("INF","SUP","MOY"),),
                       MODE_FOURIER   = SIMP(statut='f',typ='I',defaut=0),
                       RESULTAT       = SIMP(statut='o',typ=(evol_noli) ),
                       regles=(EXCLUS('TOUT_ORDRE','NUME_ORDRE','LIST_ORDRE','INST','LIST_INST'),),
                       PRECISION      = SIMP(statut='f',typ='R',defaut= 1.0E-3),
                       CRITERE        = SIMP(statut='f',typ='TXM',defaut="RELATIF",into=("RELATIF","ABSOLU")),
                       TOUT_ORDRE     = SIMP(statut='f',typ='TXM',into=("OUI",) ),
                       NUME_ORDRE     = SIMP(statut='f',typ='I',validators=NoRepeat(),max='**'),
                       LIST_ORDRE     = SIMP(statut='f',typ=listis_sdaster),
                       INST           = SIMP(statut='f',typ='R',validators=NoRepeat(),max='**'),
                       LIST_INST      = SIMP(statut='f',typ=listr8_sdaster),
         ),

         ENER_TOTALE    = FACT(statut='f',max='**',
                               regles=(AU_MOINS_UN('TOUT','GROUP_MA','MAILLE'),),
                               TOUT         = SIMP(statut='f',typ='TXM',into=("OUI",) ),
                               MAILLE       = SIMP(statut='f',typ=ma  ,validators=NoRepeat(),max='**'),
                               GROUP_MA     = SIMP(statut='f',typ=grma,validators=NoRepeat(),max='**'),
                              ),
         b_ener_totale = BLOC(condition = "( ENER_TOTALE != None )",
                       fr="calcul de l'énergie de déformation totale",
                       MODELE         = SIMP(statut='f',typ=modele_sdaster),
                       CHAM_MATER     = SIMP(statut='f',typ=cham_mater),
                       CARA_ELEM      = SIMP(statut='f',typ=cara_elem),
                       CHARGE         = SIMP(statut='f',typ=(char_meca,char_ther,char_acou),validators=NoRepeat(),max='**' ),
                       NUME_COUCHE    = SIMP(statut='f',typ='I',defaut=1),
                       NIVE_COUCHE    = SIMP(statut='f',typ='TXM',defaut="MOY",into=("INF","SUP","MOY"),),
                       MODE_FOURIER   = SIMP(statut='f',typ='I',defaut=0),
                       RESULTAT       = SIMP(statut='o',typ=(evol_noli) ),
                       regles=(EXCLUS('TOUT_ORDRE','NUME_ORDRE','LIST_ORDRE','INST','LIST_INST'),),
                       PRECISION      = SIMP(statut='f',typ='R',defaut= 1.0E-3),
                       CRITERE        = SIMP(statut='f',typ='TXM',defaut="RELATIF",into=("RELATIF","ABSOLU")),
                       TOUT_ORDRE     = SIMP(statut='f',typ='TXM',into=("OUI",) ),
                       NUME_ORDRE     = SIMP(statut='f',typ='I',validators=NoRepeat(),max='**'),
                       LIST_ORDRE     = SIMP(statut='f',typ=listis_sdaster),
                       INST           = SIMP(statut='f',typ='R',validators=NoRepeat(),max='**'),
                       LIST_INST      = SIMP(statut='f',typ=listr8_sdaster),
         ),

         INTEGRALE  = FACT(statut='f',max='**',
                               regles=(AU_MOINS_UN('TOUT','GROUP_MA','MAILLE'),),
                               TOUT         = SIMP(statut='f',typ='TXM',into=("OUI",) ),
                               MAILLE       = SIMP(statut='f',typ=ma  ,validators=NoRepeat(),max='**'),
                               GROUP_MA     = SIMP(statut='f',typ=grma,validators=NoRepeat(),max='**'),
                               NOM_CHAM       = SIMP(statut='o',typ='TXM',into=C_NOM_CHAM_INTO()),
                               NOM_CMP        = SIMP(statut='o',typ='TXM',validators=NoRepeat(),max='**'),
                              ),
         b_integrale = BLOC(condition = "( INTEGRALE != None )",
                       fr="calcul de la moyenne d'une composante",
                       regles=(EXCLUS('TOUT_ORDRE','NUME_ORDRE','LIST_ORDRE','INST','LIST_INST'),),
                       MODELE         = SIMP(statut='f',typ=modele_sdaster),
                       RESULTAT       = SIMP(statut='o',typ=(evol_noli,evol_ther,evol_elas) ),
                       PRECISION      = SIMP(statut='f',typ='R',defaut= 1.0E-3),
                       CRITERE        = SIMP(statut='f',typ='TXM',defaut="RELATIF",into=("RELATIF","ABSOLU")),
                       TOUT_ORDRE     = SIMP(statut='f',typ='TXM',into=("OUI",) ),
                       NUME_ORDRE     = SIMP(statut='f',typ='I',validators=NoRepeat(),max='**'),
                       LIST_ORDRE     = SIMP(statut='f',typ=listis_sdaster),
                       INST           = SIMP(statut='f',typ='R',validators=NoRepeat(),max='**'),
                       LIST_INST      = SIMP(statut='f',typ=listr8_sdaster),
         ),

         WEIBULL        = FACT(statut='f',max='**',
                               regles=(AU_MOINS_UN('TOUT','GROUP_MA','MAILLE'),),
                               TOUT         = SIMP(statut='f',typ='TXM',into=("OUI",) ),
                               MAILLE       = SIMP(statut='f',typ=ma  ,validators=NoRepeat(),max='**'),
                               GROUP_MA     = SIMP(statut='f',typ=grma,validators=NoRepeat(),max='**'),
                               OPTION       = SIMP(statut='f',typ='TXM',
                                                   into=("SIGM_ELGA","SIGM_ELMOY"),
                                                   defaut="SIGM_ELGA"),
                               CORR_PLAST   = SIMP(statut='f',typ='TXM',defaut="NON",into=("OUI","NON")),
                               COEF_MULT    = SIMP(statut='f',typ='R',defaut=1.),
                              ),
         b_weibull = BLOC(condition = "( WEIBULL != None )",
                       fr="calcul du champ élémentaire de la puissance m-ième de la contrainte de Weibull",
                       regles=(UN_PARMI('CHAM_GD','RESULTAT'),
                               EXCLUS('TOUT_ORDRE','NUME_ORDRE','LIST_ORDRE','INST','LIST_INST'),),
                       MODELE         = SIMP(statut='f',typ=modele_sdaster),
                       CHAM_MATER     = SIMP(statut='f',typ=cham_mater),
                       CARA_ELEM      = SIMP(statut='f',typ=cara_elem),
                       CHARGE         = SIMP(statut='f',typ=(char_meca,char_ther,char_acou),validators=NoRepeat(),max='**' ),
                       NUME_COUCHE    = SIMP(statut='f',typ='I',defaut=1),
                       NIVE_COUCHE    = SIMP(statut='f',typ='TXM',defaut="MOY",into=("INF","SUP","MOY"),),
                       MODE_FOURIER   = SIMP(statut='f',typ='I',defaut=0),
                       CHAM_GD        = SIMP(statut='f',typ=(cham_no_sdaster,cham_elem) ),
                       RESULTAT       = SIMP(statut='f',typ=(evol_noli) ),
                       PRECISION      = SIMP(statut='f',typ='R',defaut= 1.0E-3),
                       CRITERE        = SIMP(statut='f',typ='TXM',defaut="RELATIF",into=("RELATIF","ABSOLU")),
                       TOUT_ORDRE     = SIMP(statut='f',typ='TXM',into=("OUI",) ),
                       NUME_ORDRE     = SIMP(statut='f',typ='I',validators=NoRepeat(),max='**'),
                       LIST_ORDRE     = SIMP(statut='f',typ=listis_sdaster),
                       INST           = SIMP(statut='f',typ='R',validators=NoRepeat(),max='**'),
                       LIST_INST      = SIMP(statut='f',typ=listr8_sdaster),
         ),

         RICE_TRACEY    = FACT(statut='f',max='**',
                               regles=(AU_MOINS_UN('TOUT','GROUP_MA','MAILLE'),),
                               TOUT         = SIMP(statut='f',typ='TXM',into=("OUI",) ),
                               MAILLE       = SIMP(statut='f',typ=ma  ,validators=NoRepeat(),max='**'),
                               GROUP_MA     = SIMP(statut='f',typ=grma,validators=NoRepeat(),max='**'),
                               OPTION       = SIMP(statut='f',typ='TXM',
                                                   into=("SIGM_ELGA","SIGM_ELMOY"),
                                                   defaut="SIGM_ELGA"),
                               LOCAL        = SIMP(statut='f',typ='TXM',defaut="OUI",into=("OUI","NON")),
                              ),
         b_rice_tracey = BLOC(condition = "( RICE_TRACEY != None )",
                       fr="calcul du taux de croissance d'une cavité sphérique par rapport à un domaine",
                       regles=(UN_PARMI('CHAM_GD','RESULTAT'),
                               EXCLUS('TOUT_ORDRE','NUME_ORDRE','LIST_ORDRE','INST','LIST_INST'),),
                       MODELE         = SIMP(statut='f',typ=modele_sdaster),
                       CHAM_MATER     = SIMP(statut='f',typ=cham_mater),
                       CARA_ELEM      = SIMP(statut='f',typ=cara_elem),
                       CHARGE         = SIMP(statut='f',typ=(char_meca,char_ther,char_acou),validators=NoRepeat(),max='**' ),
                       NUME_COUCHE    = SIMP(statut='f',typ='I',defaut=1),
                       NIVE_COUCHE    = SIMP(statut='f',typ='TXM',defaut="MOY",into=("INF","SUP","MOY"),),
                       MODE_FOURIER   = SIMP(statut='f',typ='I',defaut=0),
                       CHAM_GD        = SIMP(statut='f',typ=(cham_no_sdaster,cham_elem) ),
                       RESULTAT       = SIMP(statut='f',typ=(evol_noli) ),
                       PRECISION      = SIMP(statut='f',typ='R',defaut= 1.0E-3),
                       CRITERE        = SIMP(statut='f',typ='TXM',defaut="RELATIF",into=("RELATIF","ABSOLU")),
                       TOUT_ORDRE     = SIMP(statut='f',typ='TXM',into=("OUI",) ),
                       NUME_ORDRE     = SIMP(statut='f',typ='I',validators=NoRepeat(),max='**'),
                       LIST_ORDRE     = SIMP(statut='f',typ=listis_sdaster),
                       INST           = SIMP(statut='f',typ='R',validators=NoRepeat(),max='**'),
                       LIST_INST      = SIMP(statut='f',typ=listr8_sdaster),
         ),

         INDIC_ENER     = FACT(statut='f',max='**',
                               regles=(AU_MOINS_UN('TOUT','GROUP_MA','MAILLE'),),
                               TOUT         = SIMP(statut='f',typ='TXM',into=("OUI",) ),
                               MAILLE       = SIMP(statut='f',typ=ma  ,validators=NoRepeat(),max='**'),
                               GROUP_MA     = SIMP(statut='f',typ=grma,validators=NoRepeat(),max='**'),
                              ),
         b_indic_ener = BLOC(condition = "( INDIC_ENER != None )",
                       fr="calcul un indicateur global de perte de proportionnalité du chargement",
                       MODELE         = SIMP(statut='f',typ=modele_sdaster),
                       CHAM_MATER     = SIMP(statut='f',typ=cham_mater),
                       CHARGE         = SIMP(statut='f',typ=(char_meca,char_ther,char_acou),validators=NoRepeat(),max='**' ),
                       MODE_FOURIER   = SIMP(statut='f',typ='I',defaut=0),
                       RESULTAT       = SIMP(statut='o',typ=(evol_noli) ),
                       regles=(EXCLUS('TOUT_ORDRE','NUME_ORDRE','LIST_ORDRE','INST','LIST_INST'),),
                       PRECISION      = SIMP(statut='f',typ='R',defaut= 1.0E-3),
                       CRITERE        = SIMP(statut='f',typ='TXM',defaut="RELATIF",into=("RELATIF","ABSOLU")),
                       TOUT_ORDRE     = SIMP(statut='f',typ='TXM',into=("OUI",) ),
                       NUME_ORDRE     = SIMP(statut='f',typ='I',validators=NoRepeat(),max='**'),
                       LIST_ORDRE     = SIMP(statut='f',typ=listis_sdaster),
                       INST           = SIMP(statut='f',typ='R',validators=NoRepeat(),max='**'),
                       LIST_INST      = SIMP(statut='f',typ=listr8_sdaster),
         ),

         INDIC_SEUIL    = FACT(statut='f',max='**',
                               regles=(AU_MOINS_UN('TOUT','GROUP_MA','MAILLE'),),
                               TOUT         = SIMP(statut='f',typ='TXM',into=("OUI",) ),
                               MAILLE       = SIMP(statut='f',typ=ma  ,validators=NoRepeat(),max='**'),
                               GROUP_MA     = SIMP(statut='f',typ=grma,validators=NoRepeat(),max='**'),
                              ),
         b_indic_seuil = BLOC(condition = "( INDIC_SEUIL != None )",
                       fr="calcul un indicateur global de perte de proportionnalité du chargement",
                       MODELE         = SIMP(statut='f',typ=modele_sdaster),
                       CHAM_MATER     = SIMP(statut='f',typ=cham_mater),
                       CHARGE         = SIMP(statut='f',typ=(char_meca,char_ther,char_acou),validators=NoRepeat(),max='**' ),
                       MODE_FOURIER   = SIMP(statut='f',typ='I',defaut=0),
                       RESULTAT       = SIMP(statut='o',typ=(evol_noli) ),
                       regles=(EXCLUS('TOUT_ORDRE','NUME_ORDRE','LIST_ORDRE','INST','LIST_INST'),),
                       PRECISION      = SIMP(statut='f',typ='R',defaut= 1.0E-3),
                       CRITERE        = SIMP(statut='f',typ='TXM',defaut="RELATIF",into=("RELATIF","ABSOLU")),
                       TOUT_ORDRE     = SIMP(statut='f',typ='TXM',into=("OUI",) ),
                       NUME_ORDRE     = SIMP(statut='f',typ='I',validators=NoRepeat(),max='**'),
                       LIST_ORDRE     = SIMP(statut='f',typ=listis_sdaster),
                       INST           = SIMP(statut='f',typ='R',validators=NoRepeat(),max='**'),
                       LIST_INST      = SIMP(statut='f',typ=listr8_sdaster),
         ),

         CHAR_LIMITE    = FACT(statut='f',min=0,
                               CHAR_CSTE = SIMP(statut='f',typ='TXM',into=("OUI","NON"),defaut="NON")
                              ),
         b_char_limite = BLOC(condition = "( CHAR_LIMITE != None )",
                       fr="post-traitement du calcul de la charge limite",
                       MODELE         = SIMP(statut='f',typ=modele_sdaster),
                       CHAM_MATER     = SIMP(statut='f',typ=cham_mater),
                       CARA_ELEM      = SIMP(statut='f',typ=cara_elem),
                       CHARGE         = SIMP(statut='f',typ=(char_meca,char_ther,char_acou),validators=NoRepeat(),max='**' ),
                       MODE_FOURIER   = SIMP(statut='f',typ='I',defaut=0),
                       RESULTAT       = SIMP(statut='o',typ=(evol_noli) ),
                       regles=(EXCLUS('TOUT_ORDRE','NUME_ORDRE','LIST_ORDRE','INST','LIST_INST'),),
                       PRECISION      = SIMP(statut='f',typ='R',defaut= 1.0E-3),
                       CRITERE        = SIMP(statut='f',typ='TXM',defaut="RELATIF",into=("RELATIF","ABSOLU")),
                       TOUT_ORDRE     = SIMP(statut='f',typ='TXM',into=("OUI",) ),
                       NUME_ORDRE     = SIMP(statut='f',typ='I',validators=NoRepeat(),max='**'),
                       LIST_ORDRE     = SIMP(statut='f',typ=listis_sdaster),
                       INST           = SIMP(statut='f',typ='R',validators=NoRepeat(),max='**'),
                       LIST_INST      = SIMP(statut='f',typ=listr8_sdaster),
         ),

         CARA_GEOM      = FACT(statut='f',max='**',
                               regles=(AU_MOINS_UN('TOUT','GROUP_MA','MAILLE'),),
                               TOUT         = SIMP(statut='f',typ='TXM',into=("OUI",) ),
                               MAILLE       = SIMP(statut='f',typ=ma  ,validators=NoRepeat(),max='**'),
                               GROUP_MA     = SIMP(statut='f',typ=grma,validators=NoRepeat(),max='**'),
                               SYME_X       = SIMP(statut='f',typ='TXM',defaut="NON",into=("OUI","NON") ),
                               SYME_Y       = SIMP(statut='f',typ='TXM',defaut="NON",into=("OUI","NON") ),
                               ORIG_INER    = SIMP(statut='f',typ='R',min=2,max=2),
                              ),
         b_cara_geom = BLOC(condition = "( CARA_GEOM != None )",
                       fr="calcul des caractéristiques géométriques d'un section de poutre",
                       MODELE         = SIMP(statut='f',typ=modele_sdaster),
                       CHAM_MATER     = SIMP(statut='f',typ=cham_mater),
                       CHARGE         = SIMP(statut='f',typ=(char_meca,char_ther,char_acou),validators=NoRepeat(),max='**' ),
                       MODE_FOURIER   = SIMP(statut='f',typ='I',defaut=0),
         ),

         CARA_POUTRE    = FACT(statut='f',max='**',
                               regles=(AU_MOINS_UN('TOUT','GROUP_MA'),
                                       ENSEMBLE('LONGUEUR','LIAISON','MATERIAU'),),
                               TOUT          = SIMP(statut='f',typ='TXM',into=("OUI",) ),
                               GROUP_MA      = SIMP(statut='f',typ=grma,validators=NoRepeat(),max='**'),
                               GROUP_MA_INTE = SIMP(statut='f',typ=grma,validators=NoRepeat(),max='**'),
                               CARA_GEOM     = SIMP(statut='o',typ=table_sdaster),
                               RT            = SIMP(statut='f',typ='R'),
                               LAPL_PHI      = SIMP(statut='f',typ=evol_ther),
                               LAPL_PHI_Y    = SIMP(statut='f',typ=evol_ther),
                               LAPL_PHI_Z    = SIMP(statut='f',typ=evol_ther),
                               LIAISON       = SIMP(statut='f',typ='TXM',into=("ROTULE","ENCASTREMENT")),
                               LONGUEUR      = SIMP(statut='f',typ='R'),
                               MATERIAU      = SIMP(statut='f',typ=mater_sdaster),
                               OPTION        = SIMP(statut='f',typ='TXM',
                                                    into=("CARA_TORSION","CARA_CISAILLEMENT","CARA_GAUCHI") ),
                             ),
         b_cara_poutre = BLOC(condition = "( CARA_POUTRE != None )",
                       fr="calcul des caractéristiques mécaniques d'un section de poutre",
                       MODELE         = SIMP(statut='f',typ=modele_sdaster),
                       CHAM_MATER     = SIMP(statut='f',typ=cham_mater),
                       CHARGE         = SIMP(statut='f',typ=(char_meca,char_ther,char_acou),validators=NoRepeat(),max='**' ),
                       MODE_FOURIER   = SIMP(statut='f',typ='I',defaut=0),
         ),

          AIRE_INTERNE   = FACT(statut='f',max='**',
                                GROUP_MA_BORD  = SIMP(statut='o',typ=grma,validators=NoRepeat(),max='**'),
                               ),
         b_aire_interne = BLOC(condition = "( AIRE_INTERNE != None )",
                       fr="calcul de l'aire d'un trou dans un maillage 2D",
                       MODELE         = SIMP(statut='f',typ=modele_sdaster),
         ),

         TRAV_EXT       = FACT(statut='f',),
         b_trav_ext = BLOC(condition = "( TRAV_EXT != None )",
                       fr="calcul du travail des efforts extérieurs",
                       RESULTAT       = SIMP(statut='o',typ=(evol_elas,evol_noli,dyna_trans) ),
                       PRECISION      = SIMP(statut='f',typ='R',defaut= 1.0E-3),
                       CRITERE        = SIMP(statut='f',typ='TXM',defaut="RELATIF",into=("RELATIF","ABSOLU")),
                       TOUT_ORDRE     = SIMP(statut='f',typ='TXM',into=("OUI",) ),
         ),

         TITRE           =SIMP(statut='f',typ='TXM',max='**' ),
         INFO            =SIMP(statut='f',typ='I',defaut=1,into=(1,2)),

 )  ;
#& MODIF COMMANDE  DATE 03/01/2006   AUTEUR REZETTE C.REZETTE 
#            CONFIGURATION MANAGEMENT OF EDF VERSION
# ======================================================================
# COPYRIGHT (C) 1991 - 2001  EDF R&D                  WWW.CODE-ASTER.ORG
# THIS PROGRAM IS FREE SOFTWARE; YOU CAN REDISTRIBUTE IT AND/OR MODIFY
# IT UNDER THE TERMS OF THE GNU GENERAL PUBLIC LICENSE AS PUBLISHED BY
# THE FREE SOFTWARE FOUNDATION; EITHER VERSION 2 OF THE LICENSE, OR   
# (AT YOUR OPTION) ANY LATER VERSION.                                 
#
# THIS PROGRAM IS DISTRIBUTED IN THE HOPE THAT IT WILL BE USEFUL, BUT 
# WITHOUT ANY WARRANTY; WITHOUT EVEN THE IMPLIED WARRANTY OF          
# MERCHANTABILITY OR FITNESS FOR A PARTICULAR PURPOSE. SEE THE GNU    
# GENERAL PUBLIC LICENSE FOR MORE DETAILS.                            
#
# YOU SHOULD HAVE RECEIVED A COPY OF THE GNU GENERAL PUBLIC LICENSE   
# ALONG WITH THIS PROGRAM; IF NOT, WRITE TO EDF R&D CODE_ASTER,       
#    1 AVENUE DU GENERAL DE GAULLE, 92141 CLAMART CEDEX, FRANCE.      
# ======================================================================
POST_FATI_ALEA=OPER(nom="POST_FATI_ALEA",op=170,sd_prod=table_sdaster,reentrant='n',
            UIinfo={"groupes":("Post traitements",)},
                    fr="Calculer le dommage de fatigue subi par une structure soumise à une sollicitation de type aléatoire",
         regles=(ENSEMBLE('MOMENT_SPEC_0','MOMENT_SPEC_2'),
                 PRESENT_PRESENT( 'MOMENT_SPEC_4','MOMENT_SPEC_0'),
                 UN_PARMI('TABL_POST_ALEA','MOMENT_SPEC_0'), ),
         MOMENT_SPEC_0   =SIMP(statut='f',typ='R'),  
         MOMENT_SPEC_2   =SIMP(statut='f',typ='R'),  
         MOMENT_SPEC_4   =SIMP(statut='f',typ='R'),  
         TABL_POST_ALEA  =SIMP(statut='f',typ=table_sdaster),
         COMPTAGE        =SIMP(statut='o',typ='TXM',into=("PIC","NIVEAU")),
         DUREE           =SIMP(statut='f',typ='R',defaut= 1.),  
         CORR_KE         =SIMP(statut='f',typ='TXM',into=("RCCM",)),
         DOMMAGE         =SIMP(statut='o',typ='TXM',into=("WOHLER",)),
         MATER           =SIMP(statut='o',typ=mater_sdaster),
         TITRE           =SIMP(statut='f',typ='TXM',max='**'),  
)  ;
#& MODIF COMMANDE  DATE 03/01/2006   AUTEUR REZETTE C.REZETTE 
#            CONFIGURATION MANAGEMENT OF EDF VERSION
# ======================================================================
# COPYRIGHT (C) 1991 - 2001  EDF R&D                  WWW.CODE-ASTER.ORG
# THIS PROGRAM IS FREE SOFTWARE; YOU CAN REDISTRIBUTE IT AND/OR MODIFY
# IT UNDER THE TERMS OF THE GNU GENERAL PUBLIC LICENSE AS PUBLISHED BY
# THE FREE SOFTWARE FOUNDATION; EITHER VERSION 2 OF THE LICENSE, OR
# (AT YOUR OPTION) ANY LATER VERSION.
#
# THIS PROGRAM IS DISTRIBUTED IN THE HOPE THAT IT WILL BE USEFUL, BUT
# WITHOUT ANY WARRANTY; WITHOUT EVEN THE IMPLIED WARRANTY OF
# MERCHANTABILITY OR FITNESS FOR A PARTICULAR PURPOSE. SEE THE GNU
# GENERAL PUBLIC LICENSE FOR MORE DETAILS.
#
# YOU SHOULD HAVE RECEIVED A COPY OF THE GNU GENERAL PUBLIC LICENSE
# ALONG WITH THIS PROGRAM; IF NOT, WRITE TO EDF R&D CODE_ASTER,
#    1 AVENUE DU GENERAL DE GAULLE, 92141 CLAMART CEDEX, FRANCE.
# ======================================================================
POST_FATIGUE=OPER(nom="POST_FATIGUE",op=136,sd_prod=table_sdaster,reentrant='n',
            UIinfo={"groupes":("Post traitements",)},
                  fr="Calculer en un point, le dommage de fatigue subi par une structure soumise à une histoire de chargement",

         CHARGEMENT = SIMP(statut='o',typ='TXM',into=("UNIAXIAL","PERIODIQUE","QUELCONQUE")),

         b_uniaxial = BLOC( condition = "CHARGEMENT=='UNIAXIAL'",
                      regles=(PRESENT_PRESENT('CORR_KE','MATER'),
                              PRESENT_PRESENT('CORR_SIGM_MOYE','MATER'),
                              PRESENT_PRESENT('DOMMAGE','MATER'),),
             HISTOIRE       = FACT(statut='o',
                                 regles=(UN_PARMI('SIGM','EPSI'),),
                                 SIGM  = SIMP(statut='f',typ=(fonction_sdaster,nappe_sdaster,formule)),
                                 EPSI  = SIMP(statut='f',typ=(fonction_sdaster,nappe_sdaster,formule)),),
             COMPTAGE       = SIMP(statut='o',typ='TXM',into=("RAINFLOW","RCCM","NATUREL")),
             DELTA_OSCI     = SIMP(statut='f',typ='R',defaut= 0.0E+0),
             COEF_MULT      = FACT(statut='f',
                                 KT    = SIMP(statut='o',typ='R'),),
             CORR_KE        = SIMP(statut='f',typ='TXM',into=("RCCM",)),
             DOMMAGE        = SIMP(statut='f',typ='TXM',into=("WOHLER","MANSON_COFFIN",
                                                              "TAHERI_MANSON","TAHERI_MIXTE")),
             MATER          = SIMP(statut='f',typ=mater_sdaster),
             CORR_SIGM_MOYE = SIMP(statut='f',typ='TXM',into=("GOODMAN","GERBER")),
             TAHERI_NAPPE   = SIMP(statut='f',typ=(nappe_sdaster,formule)),
             TAHERI_FONC    = SIMP(statut='f',typ=(fonction_sdaster,nappe_sdaster,formule)),
             CUMUL          = SIMP(statut='f',typ='TXM',into=("LINEAIRE",)),
         ),

         b_periodique = BLOC( condition = "CHARGEMENT=='PERIODIQUE'",
             HISTOIRE       = FACT(statut='o',
                                 SIGM_XX  = SIMP(statut='o',typ=(fonction_sdaster,nappe_sdaster,formule)),
                                 SIGM_YY  = SIMP(statut='o',typ=(fonction_sdaster,nappe_sdaster,formule)),
                                 SIGM_ZZ  = SIMP(statut='o',typ=(fonction_sdaster,nappe_sdaster,formule)),
                                 SIGM_XY  = SIMP(statut='o',typ=(fonction_sdaster,nappe_sdaster,formule)),
                                 SIGM_XZ  = SIMP(statut='f',typ=(fonction_sdaster,nappe_sdaster,formule)),
                                 SIGM_YZ  = SIMP(statut='f',typ=(fonction_sdaster,nappe_sdaster,formule)),),
             CRITERE        = SIMP(statut='o',typ='TXM',into=("CROSSLAND","PAPADOPOULOS")),
             DOMMAGE        = SIMP(statut='f',typ='TXM',into=("WOHLER",)),
             MATER          = SIMP(statut='o',typ=mater_sdaster),
             COEF_CORR      = SIMP(statut='f',typ='R'),
         ),

         b_quelconque = BLOC( condition = "CHARGEMENT=='QUELCONQUE'",
             HISTOIRE       = FACT(statut='o',
                                 SIGM_XX  = SIMP(statut='o',typ=(fonction_sdaster,nappe_sdaster,formule)),
                                 SIGM_YY  = SIMP(statut='o',typ=(fonction_sdaster,nappe_sdaster,formule)),
                                 SIGM_ZZ  = SIMP(statut='o',typ=(fonction_sdaster,nappe_sdaster,formule)),
                                 SIGM_XY  = SIMP(statut='o',typ=(fonction_sdaster,nappe_sdaster,formule)),
                                 SIGM_XZ  = SIMP(statut='f',typ=(fonction_sdaster,nappe_sdaster,formule)),
                                 SIGM_YZ  = SIMP(statut='f',typ=(fonction_sdaster,nappe_sdaster,formule)),
                                 EPSP     = SIMP(statut='o',typ=(fonction_sdaster,nappe_sdaster,formule)),
                                 TEMP     = SIMP(statut='o',typ=(fonction_sdaster,nappe_sdaster,formule)),),
             DOMMAGE        = SIMP(statut='f',typ='TXM',into=("LEMAITRE",),),
             MATER          = SIMP(statut='o',typ=mater_sdaster),
             CUMUL          = SIMP(statut='f',typ='TXM',into=("LINEAIRE",)),
         ),

         INFO            =SIMP(statut='f',typ='I',defaut=1,into=(1,2)),
         TITRE           =SIMP(statut='f',typ='TXM',max='**'),
)  ;
#& MODIF COMMANDE  DATE 31/10/2006   AUTEUR REZETTE C.REZETTE 
#            CONFIGURATION MANAGEMENT OF EDF VERSION
# ======================================================================
# COPYRIGHT (C) 1991 - 2006  EDF R&D                  WWW.CODE-ASTER.ORG
# THIS PROGRAM IS FREE SOFTWARE; YOU CAN REDISTRIBUTE IT AND/OR MODIFY  
# IT UNDER THE TERMS OF THE GNU GENERAL PUBLIC LICENSE AS PUBLISHED BY  
# THE FREE SOFTWARE FOUNDATION; EITHER VERSION 2 OF THE LICENSE, OR     
# (AT YOUR OPTION) ANY LATER VERSION.                                                  
#                                                                       
# THIS PROGRAM IS DISTRIBUTED IN THE HOPE THAT IT WILL BE USEFUL, BUT   
# WITHOUT ANY WARRANTY; WITHOUT EVEN THE IMPLIED WARRANTY OF            
# MERCHANTABILITY OR FITNESS FOR A PARTICULAR PURPOSE. SEE THE GNU      
# GENERAL PUBLIC LICENSE FOR MORE DETAILS.                              
#                                                                       
# YOU SHOULD HAVE RECEIVED A COPY OF THE GNU GENERAL PUBLIC LICENSE     
# ALONG WITH THIS PROGRAM; IF NOT, WRITE TO EDF R&D CODE_ASTER,         
#    1 AVENUE DU GENERAL DE GAULLE, 92141 CLAMART CEDEX, FRANCE.        
# ======================================================================

from Macro.post_gp_ops import post_gp_ops
def post_gp_prod(self, TABL_RESU, **kargs):
   """Typage des sd_prod
   """
   if TABL_RESU != None:
      self.type_sdprod(TABL_RESU, table_sdaster)
   return table_sdaster

POST_GP=MACRO(nom="POST_GP", op=post_gp_ops, sd_prod=post_gp_prod,
              fr="Calcul du critère énergétique Gp suite à un calcul thermo-mécanique",
              reentrant='n',
              UIinfo={"groupes":("Post traitements",)},
              regles=(AU_MOINS_UN('IDENTIFICATION', 'PREDICTION'),),
      
      # Résultat, modèle, comportement, chargement
      RESULTAT     = SIMP(statut='o',typ=(evol_elas,evol_noli,dyna_trans,mode_meca),),
      RESU_THER    = SIMP(statut='f',typ=evol_ther,),
      MODELE       = SIMP(statut='o',typ=modele_sdaster),
      MATER        = SIMP(statut='o',typ=mater_sdaster),
      
      COMP_ELAS    = FACT(statut='o',
            RELATION    = SIMP(statut='f',typ='TXM',defaut="ELAS",
                            into=("ELAS","ELAS_VMIS_LINE","ELAS_VMIS_TRAC"),),
            DEFORMATION = SIMP(statut='f',typ='TXM',defaut="PETIT",into=("PETIT","GREEN"),),
      ),
      
      EXCIT        = FACT(statut='f', max='**',
            CHARGE      = SIMP(statut='o', typ=(char_meca,char_cine_meca)),
            FONC_MULT   = SIMP(statut='f', typ=(fonction_sdaster,nappe_sdaster,formule)),
            TYPE_CHARGE = SIMP(statut='f', typ='TXM', defaut="FIXE", into=("FIXE",)),
      ),
      SYME_CHAR    = SIMP(statut='f',typ='TXM',defaut="SANS",into=("SYME","ANTI","SANS")),
      
      DIRECTION    = SIMP(statut='o', typ='R', max=3),
      THETA_2D     = FACT(statut='o', max='**',
                          fr="paramètres de définition des champs theta",
            GROUP_NO    = SIMP(statut='o', typ=grno, validators=NoRepeat(), max='**'),
            R_INF       = SIMP(statut='o', typ='R'),
            R_SUP       = SIMP(statut='o', typ='R'),
      ),
      
      # copeaux
      GROUP_MA     = SIMP(statut='o', typ=grma, validators=NoRepeat(), max='**'),
      PAS_ENTAILLE = SIMP(statut='o', typ='R', val_min=0.),
      
      # critère sur Gp
      CRIT_MAXI_GP = SIMP(statut='f', typ='TXM', defaut="ABSOLU",
                          into=("RELATIF","ABSOLU")),
      
      # correction axisymétrie
      RAYON_AXIS   = SIMP(statut='f', typ='R', val_min=0., defaut=1.),
      
      # identification
      IDENTIFICATION = FACT(statut='f', max=1,
            KJ_CRIT     = SIMP(statut='o', typ='R', val_min=0., max='**'),
            TEMP        = SIMP(statut='o', typ='R', val_min=0., max='**'),
      ),
      
      # prédiction
      PREDICTION   = FACT(statut='f', max=1,
            GP_CRIT     = SIMP(statut='o', typ='R', val_min=0., max='**'),
            TEMP        = SIMP(statut='o', typ='R', val_min=0., max='**'),
      ),
      
      # table résultat
      TABL_RESU    = SIMP(statut='o', typ=CO,),
      
      INFO         = SIMP(statut='f', typ='I', defaut=1, into=(1, 2),),
)
#& MODIF COMMANDE  DATE 09/05/2006   AUTEUR GALENNE E.GALENNE 
#            CONFIGURATION MANAGEMENT OF EDF VERSION
# ======================================================================
# COPYRIGHT (C) 1991 - 2001  EDF R&D                  WWW.CODE-ASTER.ORG
# THIS PROGRAM IS FREE SOFTWARE; YOU CAN REDISTRIBUTE IT AND/OR MODIFY
# IT UNDER THE TERMS OF THE GNU GENERAL PUBLIC LICENSE AS PUBLISHED BY
# THE FREE SOFTWARE FOUNDATION; EITHER VERSION 2 OF THE LICENSE, OR   
# (AT YOUR OPTION) ANY LATER VERSION.                                 
#
# THIS PROGRAM IS DISTRIBUTED IN THE HOPE THAT IT WILL BE USEFUL, BUT 
# WITHOUT ANY WARRANTY; WITHOUT EVEN THE IMPLIED WARRANTY OF          
# MERCHANTABILITY OR FITNESS FOR A PARTICULAR PURPOSE. SEE THE GNU    
# GENERAL PUBLIC LICENSE FOR MORE DETAILS.                            
#
# YOU SHOULD HAVE RECEIVED A COPY OF THE GNU GENERAL PUBLIC LICENSE   
# ALONG WITH THIS PROGRAM; IF NOT, WRITE TO EDF R&D CODE_ASTER,       
#    1 AVENUE DU GENERAL DE GAULLE, 92141 CLAMART CEDEX, FRANCE.      
# ======================================================================
# RESPONSABLE GALENNE E.GALENNE
from Macro.post_k1_k2_k3_ops import post_k1_k2_k3_ops
POST_K1_K2_K3=MACRO(nom="POST_K1_K2_K3",op=post_k1_k2_k3_ops,sd_prod=table_sdaster,
                   fr="Calcul des facteurs d'intensité de contraintes en 2D et en 3D par extrapolation des sauts de déplacements"
                     +" sur les lèvres de la fissure",
                   reentrant='n',
            UIinfo={"groupes":("Post traitements",)},

           regles=(UN_PARMI('RESULTAT','TABL_DEPL_SUP'),
                   PRESENT_PRESENT('RESULTAT','FOND_FISS'),),

         MODELISATION  =SIMP(statut='o',typ='TXM',
                             into=("3D","AXIS","D_PLAN","C_PLAN"),
                             fr="Modélisation cohérente avec celle utilisée pour le calcul des déplacements"),
         FOND_FISS     =SIMP(statut='f',typ=fond_fiss),
         b_fond_fiss   =BLOC (condition="(FOND_FISS!= None)",
                         MAILLAGE      = SIMP(statut='o',typ=maillage_sdaster),
                         TYPE_MAILLAGE = SIMP(statut='f',typ='TXM',into=("LIBRE","REGLE"),defaut="REGLE"),
                         NB_NOEUD_COUPE= SIMP(statut='f',typ='I' ,defaut=5 ),
                         NOEUD         = SIMP(statut='f',typ=no  ,validators=NoRepeat(),max='**'),
                         GROUP_NO      = SIMP(statut='f',typ=grno,validators=NoRepeat(),max='**'),
                         SANS_NOEUD    = SIMP(statut='f',typ=no  ,validators=NoRepeat(),max='**'),
                         SANS_GROUP_NO = SIMP(statut='f',typ=grno,validators=NoRepeat(),max='**'),
                         TOUT          = SIMP(statut='f',typ='TXM',into=("OUI",) )
                         ),
         MATER         =SIMP(statut='o',typ=mater_sdaster,
                             fr="Matériau homogène et isotrope cohérent avec celui utilisé pour le calcul des déplacements"),
         RESULTAT      =SIMP(statut='f',typ=(evol_elas,evol_noli),
                             fr="Table déplacement des noeuds de la lèvre supérieure et inférieure"),
         TABL_DEPL_SUP =SIMP(statut='f',typ=table_sdaster,
                             fr="Table issue de post_releve_t sur les noeuds de la lèvre supérieure"),
         TABL_DEPL_INF =SIMP(statut='f',typ=table_sdaster,
                             fr="Table issue de post_releve_t sur les noeuds de la lèvre inférieure"),
         ABSC_CURV_MAXI=SIMP(statut='f',typ='R',
                             fr="distance maximum à partir du fond de fissure à utiliser pour le calcul"),  
         PREC_VIS_A_VIS= SIMP(statut='f',typ='R',defaut=0.1),
         TOUT_ORDRE    =SIMP(statut='f',typ='TXM',into=("OUI",) ),
         NUME_ORDRE    =SIMP(statut='f',typ='I',validators=NoRepeat(),max='**'),
         LIST_ORDRE    =SIMP(statut='f',typ=listis_sdaster),
         INST          =SIMP(statut='f',typ='R',validators=NoRepeat(),max='**'),
         LIST_INST     =SIMP(statut='f',typ=listr8_sdaster),
             b_acce_reel     =BLOC(condition="(INST != None)or(LIST_INST != None)",
               PRECISION       =SIMP(statut='f',typ='R',defaut=1.0E-6),
               CRITERE         =SIMP(statut='f',typ='TXM',defaut="RELATIF",into=("RELATIF","ABSOLU") ),
             ),
         SYME_CHAR       =SIMP(statut='f',typ='TXM',defaut="SANS",into=("SYME","SANS") ),
         INFO          =SIMP(statut='f',typ='I',defaut=1,into=(1,2)),
         VECT_K1       =SIMP(statut='o',typ='R',max=3,
                             fr="Vecteur normal au plan de fissure, orienté de la lèvre inférieure vers la lèvre supérieure"),  
         TITRE         =SIMP(statut='f',typ='TXM',max='**'),  
)  ;
#& MODIF COMMANDE  DATE 03/01/2006   AUTEUR REZETTE C.REZETTE 
#            CONFIGURATION MANAGEMENT OF EDF VERSION
# ======================================================================
# COPYRIGHT (C) 1991 - 2002  EDF R&D                  WWW.CODE-ASTER.ORG
# THIS PROGRAM IS FREE SOFTWARE; YOU CAN REDISTRIBUTE IT AND/OR MODIFY
# IT UNDER THE TERMS OF THE GNU GENERAL PUBLIC LICENSE AS PUBLISHED BY
# THE FREE SOFTWARE FOUNDATION; EITHER VERSION 2 OF THE LICENSE, OR   
# (AT YOUR OPTION) ANY LATER VERSION.                                 
#
# THIS PROGRAM IS DISTRIBUTED IN THE HOPE THAT IT WILL BE USEFUL, BUT 
# WITHOUT ANY WARRANTY; WITHOUT EVEN THE IMPLIED WARRANTY OF          
# MERCHANTABILITY OR FITNESS FOR A PARTICULAR PURPOSE. SEE THE GNU    
# GENERAL PUBLIC LICENSE FOR MORE DETAILS.                            
#
# YOU SHOULD HAVE RECEIVED A COPY OF THE GNU GENERAL PUBLIC LICENSE   
# ALONG WITH THIS PROGRAM; IF NOT, WRITE TO EDF R&D CODE_ASTER,       
#    1 AVENUE DU GENERAL DE GAULLE, 92141 CLAMART CEDEX, FRANCE.      
#                                                                       
#                                                                       
# ======================================================================
#
POST_K_BETA=OPER(nom="POST_K_BETA",op=198,sd_prod=table_sdaster,
                   fr="Calcul des facteurs d'intensité de contraintes par la méthode K_BETA",
                   reentrant='n',
            UIinfo={"groupes":("Post traitements",)},
         MAILLAGE      = SIMP(statut='o',typ=maillage_sdaster),
         MATER_REV     = SIMP(statut='o',typ=mater_sdaster),
         EPAIS_REV     = SIMP(statut='o',typ='R'),
         FISSURE       = FACT(statut='o',
            DECALAGE       = SIMP(statut='f',typ='R',defaut=-2.e-04),
            PROFONDEUR     = SIMP(statut='o',typ='R'),
            LONGUEUR       = SIMP(statut='o',typ='R'),
            ORIENTATION    = SIMP(statut='o',typ='TXM',
                                 into=("CIRC","LONGI"),),
         ),
         K1D           = FACT(statut='o',max='**',
            TABL_MECA_REV  = SIMP(statut='o',typ=(table_sdaster)),
            TABL_MECA_MDB  = SIMP(statut='o',typ=(table_sdaster)),
            TABL_THER      = SIMP(statut='o',typ=(table_sdaster)),
            INTITULE       = SIMP(statut='o',typ='TXM' ), 
         ),
         TITRE         = SIMP(statut='f',typ='TXM',max='**'),  
);
#& MODIF COMMANDE  DATE 31/10/2006   AUTEUR REZETTE C.REZETTE 
#            CONFIGURATION MANAGEMENT OF EDF VERSION
# ======================================================================
# COPYRIGHT (C) 1991 - 2006  EDF R&D                  WWW.CODE-ASTER.ORG
# THIS PROGRAM IS FREE SOFTWARE; YOU CAN REDISTRIBUTE IT AND/OR MODIFY  
# IT UNDER THE TERMS OF THE GNU GENERAL PUBLIC LICENSE AS PUBLISHED BY  
# THE FREE SOFTWARE FOUNDATION; EITHER VERSION 2 OF THE LICENSE, OR     
# (AT YOUR OPTION) ANY LATER VERSION.                                                  
#                                                                       
# THIS PROGRAM IS DISTRIBUTED IN THE HOPE THAT IT WILL BE USEFUL, BUT   
# WITHOUT ANY WARRANTY; WITHOUT EVEN THE IMPLIED WARRANTY OF            
# MERCHANTABILITY OR FITNESS FOR A PARTICULAR PURPOSE. SEE THE GNU      
# GENERAL PUBLIC LICENSE FOR MORE DETAILS.                              
#                                                                       
# YOU SHOULD HAVE RECEIVED A COPY OF THE GNU GENERAL PUBLIC LICENSE     
# ALONG WITH THIS PROGRAM; IF NOT, WRITE TO EDF R&D CODE_ASTER,         
#    1 AVENUE DU GENERAL DE GAULLE, 92141 CLAMART CEDEX, FRANCE.        
# ======================================================================

from Macro.post_k_trans_ops import post_k_trans_ops

POST_K_TRANS=MACRO(nom="POST_K_TRANS",op=post_k_trans_ops,sd_prod=table_sdaster,
            fr="Calcul des facteurs d intensite des contrainte par recombinaison modale",reentrant='n',
            UIinfo={"groupes":("Post traitements",)},
        RESU_TRANS      =SIMP(statut='o',typ=tran_gene), 
        K_MODAL         =FACT(statut='o',
           TABL_K_MODA     =SIMP(statut='f',typ=table_sdaster,),
           RESU_MODA       =SIMP(statut='f',typ=mode_meca,),
           FOND_FISS       =SIMP(statut='f',typ=fond_fiss,),
           FISSURE         =SIMP(statut='f',typ=fiss_xfem,),
           THETA           =SIMP(statut='f',typ=(theta_geom,cham_no_sdaster)),
           R_INF           =SIMP(statut='f',typ='R'),
           R_SUP           =SIMP(statut='f',typ='R'),
           MODULE          =SIMP(statut='f',typ='R'),
           DIRE_THETA      =SIMP(statut='f',typ=cham_no_sdaster ),
           DIRECTION       =SIMP(statut='f',typ='R',max='**'),
           R_INF_FO        =SIMP(statut='f',typ=(fonction_sdaster,nappe_sdaster,formule)),
           R_SUP_FO        =SIMP(statut='f',typ=(fonction_sdaster,nappe_sdaster,formule)),             
           MODULE_FO       =SIMP(statut='f',typ=(fonction_sdaster,nappe_sdaster,formule)),
           DEGRE           =SIMP(statut='f',typ='I',into=(0,1,2,3,4,5,6,7) ),
           LISSAGE_THETA   =SIMP(statut='f',typ='TXM',into=("LEGENDRE","LAGRANGE","LAGRANGE_REGU"),),
           LISSAGE_G       =SIMP(statut='f',typ='TXM',into=("LEGENDRE","LAGRANGE","LAGRANGE_NO_NO","LAGRANGE_REGU"),),


           regles=(UN_PARMI('TABL_K_MODA','RESU_MODA'),
                   UN_PARMI('FISSURE','FOND_FISS'),
                   EXCLUS('MODULE','MODULE_FO'),
                   PRESENT_PRESENT('R_INF','R_SUP'),
                   PRESENT_PRESENT('R_INF_FO','R_SUP_FO'), ),
         ),
        regles=(EXCLUS('TOUT_ORDRE','NUME_ORDRE','INST','LIST_INST','LIST_ORDRE'),),
        TOUT_ORDRE      =SIMP(statut='f',typ='TXM',into=("OUI",) ),
        NUME_ORDRE      =SIMP(statut='f',typ='I',validators=NoRepeat(),max='**'),
        LIST_ORDRE      =SIMP(statut='f',typ=listis_sdaster),
        INST            =SIMP(statut='f',typ='R',validators=NoRepeat(),max='**'),
        LIST_INST       =SIMP(statut='f',typ=listr8_sdaster),
        PRECISION       =SIMP(statut='f',typ='R',defaut= 1.0E-3),
        CRITERE         =SIMP(statut='f',typ='TXM',defaut="RELATIF",into=("RELATIF","ABSOLU",) ),

        INFO            =SIMP(statut='f',typ='I',defaut=1,into=(1,2)),
        TITRE           =SIMP(statut='f',typ='TXM'),
)

#& MODIF COMMANDE  DATE 22/06/2005   AUTEUR REZETTE C.REZETTE 
#            CONFIGURATION MANAGEMENT OF EDF VERSION
# ======================================================================
# COPYRIGHT (C) 1991 - 2005  EDF R&D                  WWW.CODE-ASTER.ORG
# THIS PROGRAM IS FREE SOFTWARE; YOU CAN REDISTRIBUTE IT AND/OR MODIFY  
# IT UNDER THE TERMS OF THE GNU GENERAL PUBLIC LICENSE AS PUBLISHED BY  
# THE FREE SOFTWARE FOUNDATION; EITHER VERSION 2 OF THE LICENSE, OR     
# (AT YOUR OPTION) ANY LATER VERSION.                                                  
#                                                                       
# THIS PROGRAM IS DISTRIBUTED IN THE HOPE THAT IT WILL BE USEFUL, BUT   
# WITHOUT ANY WARRANTY; WITHOUT EVEN THE IMPLIED WARRANTY OF            
# MERCHANTABILITY OR FITNESS FOR A PARTICULAR PURPOSE. SEE THE GNU      
# GENERAL PUBLIC LICENSE FOR MORE DETAILS.                              
#                                                                       
# YOU SHOULD HAVE RECEIVED A COPY OF THE GNU GENERAL PUBLIC LICENSE     
# ALONG WITH THIS PROGRAM; IF NOT, WRITE TO EDF R&D CODE_ASTER,         
#    1 AVENUE DU GENERAL DE GAULLE, 92141 CLAMART CEDEX, FRANCE.        
# ======================================================================
POST_MAIL_XFEM=OPER(nom="POST_MAIL_XFEM",op= 187,sd_prod=maillage_sdaster,
                    reentrant='n',UIinfo={"groupes":("Maillage",)},
            fr="Crée un maillage se conformant à la fissure pour le post-traitement des éléments XFEM",
    MODELE  = SIMP(statut='o',typ=modele_sdaster),
    TITRE   = SIMP(statut='f',typ='TXM',max='**'),
);                     
#& MODIF COMMANDE  DATE 03/10/2006   AUTEUR CIBHHLV L.VIVAN 
#            CONFIGURATION MANAGEMENT OF EDF VERSION
# ======================================================================
# COPYRIGHT (C) 1991 - 2001  EDF R&D                  WWW.CODE-ASTER.ORG
# THIS PROGRAM IS FREE SOFTWARE; YOU CAN REDISTRIBUTE IT AND/OR MODIFY
# IT UNDER THE TERMS OF THE GNU GENERAL PUBLIC LICENSE AS PUBLISHED BY
# THE FREE SOFTWARE FOUNDATION; EITHER VERSION 2 OF THE LICENSE, OR   
# (AT YOUR OPTION) ANY LATER VERSION.                                 
#
# THIS PROGRAM IS DISTRIBUTED IN THE HOPE THAT IT WILL BE USEFUL, BUT 
# WITHOUT ANY WARRANTY; WITHOUT EVEN THE IMPLIED WARRANTY OF          
# MERCHANTABILITY OR FITNESS FOR A PARTIC               
#
# YOU SHOULD HAVE RECEIVED A COPY OF THE GNU GENERAL PUBLIC LICENSE   
# ALONG WITH THIS PROGRAM; IF NOT, WRITE TO EDF R&D CODE_ASTER,       
#    1 AVENUE DU GENERAL DE GAULLE, 92141 CLAMART CEDEX, FRANCE.      
# ======================================================================
# RESPONSABLE JMBHH01 J.M.PROIX
POST_RCCM=OPER(nom="POST_RCCM",op= 165,sd_prod=table_sdaster,
               fr="Vérification des critères de niveau 0 et certains critères de niveau A du RCC-M-B3200 (Edition 1991)",
               reentrant='n',
            UIinfo={"groupes":("Post traitements",)},
         TYPE_RESU       =SIMP(statut='f',typ='TXM',defaut="VALE_MAX",into=("VALE_MAX","DETAILS") ),
         INFO            =SIMP(statut='f',typ='I',into=(1,2) ),
         TITRE           =SIMP(statut='f',typ='TXM',max='**'),
         TYPE_RESU_MECA  =SIMP(statut='o',typ='TXM',into=("EVOLUTION","UNITAIRE","TUYAUTERIE") ),

# ======================================================================
     b_evolution  =BLOC(condition="(TYPE_RESU_MECA == 'EVOLUTION')",

         OPTION          =SIMP(statut='o',typ='TXM',validators=NoRepeat(),max='**',
                               into=("PM_PB","SN","FATIGUE_ZH210") ),
         MATER           =SIMP(statut='o',typ=mater_sdaster ),
         SY_MAX          =SIMP(statut='f',typ='R',
                               fr="limite élastique utilisée pourle calcul du rochet thermique" ),

         TRANSITOIRE     =FACT(statut='o',max='**',fr="transitoire à dépouiller",
           regles=(EXCLUS('TOUT_ORDRE','INST','LIST_INST'),),
           NB_OCCUR        =SIMP(statut='f',typ='I',defaut= 1,
                                 fr="nombre d occurences réelles de ce transitoire" ),
           TABL_RESU_MECA  =SIMP(statut='o',typ=table_sdaster,
                                 fr="relevé des contraintes sur le chemin"),
           TABL_SIGM_THER  =SIMP(statut='f',typ=table_sdaster,
                                 fr="résultat sous chargement thermique seul" ),
           TABL_RESU_PRES  =SIMP(statut='f',typ=table_sdaster,
                                 fr="table relevé des contraintes sous chargement de pression" ),
           TOUT_ORDRE      =SIMP(statut='f',typ='TXM',into=("OUI",) ),
           INST            =SIMP(statut='f',typ='R',validators=NoRepeat(),max='**'),
           LIST_INST       =SIMP(statut='f',typ=listr8_sdaster ),
           b_inst          =BLOC(condition = "(INST != None) or (LIST_INST != None)" ,
             PRECISION       =SIMP(statut='f',typ='R',defaut= 1.E-6 ),
             CRITERE         =SIMP(statut='f',typ='TXM',defaut="RELATIF",into=("ABSOLU","RELATIF") ),
                                 ), 
                             ),
         ),

# ======================================================================
     b_unitaire  =BLOC(condition="(TYPE_RESU_MECA == 'UNITAIRE')",

         OPTION          =SIMP(statut='o',typ='TXM',validators=NoRepeat(),max='**',
                               into=("PM_PB","SN","FATIGUE") ),
         MATER           =SIMP(statut='o',typ=mater_sdaster ),
         SY_MAX          =SIMP(statut='f',typ='R',
                               fr="limite élastique utilisée pourle calcul du rochet thermique" ),
         TYPE_KE         =SIMP(statut='f',typ='TXM',defaut="KE_MECA",into=("KE_MECA","KE_MIXTE"),
                               fr="Ke meca seul ou partition mecanique + thermique" ),
         CHAR_MECA   =FACT(statut='o',max='**',fr="Chargements mécaniques",
                           regles=(UN_PARMI('MX','MX_TUBU'),),
           NUME_CHAR     =SIMP(statut='o',typ='I',fr="numéro du chargement" ),
           NOM_CHAR      =SIMP(statut='f',typ='TXM',fr="nom du chargement" ),
           TYPE_CHAR     =SIMP(statut='f',typ='TXM',fr="nature du chargement",into=( "SEISME","AUTRE"),defaut="AUTRE",),
           MX            =SIMP(statut='f',typ='R',fr="moment suivant x", ),
           MX_TUBU       =SIMP(statut='f',typ='R',fr="moment suivant x, tubulure", ),
           b_1_tenseur     =BLOC( condition = "MX != None",
             FX            =SIMP(statut='f',typ='R',fr="effort suivant x", ),
             FY            =SIMP(statut='f',typ='R',fr="effort suivant y", ),
             FZ            =SIMP(statut='f',typ='R',fr="effort suivant z", ),
             MY            =SIMP(statut='o',typ='R',fr="moment suivant y", ),
             MZ            =SIMP(statut='o',typ='R',fr="moment suivant z", ),
           ),
           b_2_tenseurs    =BLOC( condition = "MX_TUBU != None",
             FX_TUBU       =SIMP(statut='f',typ='R',fr="effort suivant x, tubulure", ),
             FY_TUBU       =SIMP(statut='f',typ='R',fr="effort suivant y, tubulure", ),
             FZ_TUBU       =SIMP(statut='f',typ='R',fr="effort suivant z, tubulure", ),
             MY_TUBU       =SIMP(statut='o',typ='R',fr="moment suivant y, tubulure", ),
             MZ_TUBU       =SIMP(statut='o',typ='R',fr="moment suivant z, tubulure", ),
             FX_CORP       =SIMP(statut='f',typ='R',fr="effort suivant x, corps du piquage", ),
             FY_CORP       =SIMP(statut='f',typ='R',fr="effort suivant y, corps du piquage", ),
             FZ_CORP       =SIMP(statut='f',typ='R',fr="effort suivant z, corps du piquage", ),
             MX_CORP       =SIMP(statut='o',typ='R',fr="moment suivant x, corps du piquage", ),
             MY_CORP       =SIMP(statut='o',typ='R',fr="moment suivant y, corps du piquage", ),
             MZ_CORP       =SIMP(statut='o',typ='R',fr="moment suivant z, corps du piquage", ),
           ),

                         ),
         RESU_MECA_UNIT =FACT(statut='o',fr="resultats mécaniques unitaires",
                              regles=(UN_PARMI('TABL_MX','TABL_MX_TUBU'),),
           TABL_MX       =SIMP(statut='f',typ=table_sdaster,
                               fr="table relevé des contraintes pour chargement unitaire MX"),
           TABL_MX_TUBU  =SIMP(statut='f',typ=table_sdaster,
                               fr="table relevé des contraintes pour chargement unitaire MX_TUBU"),
           b_1_tenseur     =BLOC( condition = "TABL_MX != None",
             TABL_FX       =SIMP(statut='f',typ=table_sdaster,
                                 fr="table relevé des contraintes pour chargement unitaire FX"),
             TABL_FY       =SIMP(statut='f',typ=table_sdaster,
                                 fr="table relevé des contraintes pour chargement unitaire FY"),
             TABL_FZ       =SIMP(statut='f',typ=table_sdaster,
                                 fr="table relevé des contraintes pour chargement unitaire FZ"),
             TABL_MY       =SIMP(statut='o',typ=table_sdaster,
                                 fr="table relevé des contraintes pour chargement unitaire MY"),
             TABL_MZ       =SIMP(statut='o',typ=table_sdaster,
                                 fr="table relevé des contraintes pour chargement unitaire MZ"),
           ),
           b_2_tenseurs    =BLOC( condition = "TABL_MX_TUBU != None",
             TABL_FX_TUBU  =SIMP(statut='f',typ=table_sdaster,
                                 fr="table relevé des contraintes pour chargement unitaire FX_TUBU"),
             TABL_FY_TUBU  =SIMP(statut='f',typ=table_sdaster,
                                 fr="table relevé des contraintes pour chargement unitaire FY_TUBU"),
             TABL_FZ_TUBU  =SIMP(statut='f',typ=table_sdaster,
                                 fr="table relevé des contraintes pour chargement unitaire FZ_TUBU"),
             TABL_MY_TUBU  =SIMP(statut='o',typ=table_sdaster,
                                 fr="table relevé des contraintes pour chargement unitaire MY_TUBU"),
             TABL_MZ_TUBU  =SIMP(statut='o',typ=table_sdaster,
                                 fr="table relevé des contraintes pour chargement unitaire MZ_TUBU"),
             TABL_FX_CORP  =SIMP(statut='f',typ=table_sdaster,
                                 fr="table relevé des contraintes pour chargement unitaire FX_CORP"),
             TABL_FY_CORP  =SIMP(statut='f',typ=table_sdaster,
                                 fr="table relevé des contraintes pour chargement unitaire FY_CORP"),
             TABL_FZ_CORP  =SIMP(statut='f',typ=table_sdaster,
                                 fr="table relevé des contraintes pour chargement unitaire FZ_CORP"),
             TABL_MX_CORP  =SIMP(statut='o',typ=table_sdaster,
                                 fr="table relevé des contraintes pour chargement unitaire MX_CORP"),
             TABL_MY_CORP  =SIMP(statut='o',typ=table_sdaster,
                                 fr="table relevé des contraintes pour chargement unitaire MY_CORP"),
             TABL_MZ_CORP  =SIMP(statut='o',typ=table_sdaster,
                                 fr="table relevé des contraintes pour chargement unitaire MZ_CORP"),
           ),
           TABL_PRES     =SIMP(statut='o',typ=table_sdaster,
                               fr="table relevé des contraintes pour chargement unitaire de pression"),
                         ),

          RESU_THER   =FACT(statut='f',max='**',fr="resultats thermiques",
           NUME_RESU_THER =SIMP(statut='o',typ='I',fr="numéro de la table de résultat thermique" ),
           TABL_RESU_THER =SIMP(statut='o',typ=table_sdaster,
                              fr="table relevé des contraintes sous chargement thermique seul" ),
                           ),
         SITUATION         =FACT(statut='o',max='**',fr="Situation",ang="situation_ang",
              NB_OCCUR         =SIMP(statut='o',typ='I',fr="nombre d'occurences de la situation" ),
              NB_CYCL_SEISME   =SIMP(statut='f',typ='I',fr="nombre de cycles associé au séisme" ),
              NUME_SITU        =SIMP(statut='o',typ='I',fr="numéro de la situation" ),
              NOM_SITU         =SIMP(statut='f',typ='TXM',fr="nom de la situation" ),
              COMBINABLE       =SIMP(statut='f',typ='TXM',defaut= "OUI",into=("OUI","NON"),fr="non = sous-cycle" ),
              NUME_GROUPE      =SIMP(statut='o',typ='I',fr="numéro du groupe de la situation" ),
              NUME_PASSAGE     =SIMP(statut='f',typ='I',max=2,fr="numéro des deux groupes en relation" ),
              NUME_RESU_THER   =SIMP(statut='f',typ='I',max='**',fr="numeros de transitoires thermiques" ),
              CHAR_ETAT_A      =SIMP(statut='o',typ='I',max='**',fr="numeros de chargements etat A" ),
              CHAR_ETAT_B      =SIMP(statut='o',typ='I',max='**',fr="numeros de chargements etat B" ),
              PRES_A           =SIMP(statut='o',typ='R',fr="pression etat A"),
              PRES_B           =SIMP(statut='o',typ='R',fr="pression etat B"),
              TEMP_REF_A       =SIMP(statut='f',typ='R',fr="temperature référence etat A"),
              TEMP_REF_B       =SIMP(statut='f',typ='R',fr="temperature référence etat B"),
                               ),
                      ),
# ======================================================================
     b_tuyauterie  =BLOC(condition="(TYPE_RESU_MECA == 'TUYAUTERIE')",

         OPTION          =SIMP(statut='o',typ='TXM',into=("FATIGUE",) ),
         CHAM_MATER      =SIMP(statut='o',typ=cham_mater ),
         TYPE_KE         =SIMP(statut='f',typ='TXM',defaut="KE_MECA",into=("KE_MECA","KE_MIXTE"),
                               fr="Ke meca seul ou partition mecanique + thermique" ),
         MODELE          =SIMP(statut='o',typ=modele_sdaster),
         CARA_ELEM       =SIMP(statut='o',typ=cara_elem),
         ZONE_ANALYSE =FACT(statut='o',fr="liste des mailles ou des noeuds analysés",
            regles=(PRESENT_ABSENT('TOUT','GROUP_MA','MAILLE'),AU_MOINS_UN('TOUT','GROUP_MA','MAILLE'),),
            TOUT            =SIMP(statut='f',typ='TXM',into=("OUI",) ),
            GROUP_MA        =SIMP(statut='f',typ=grma,validators=NoRepeat(),max='**'),
            MAILLE          =SIMP(statut='f',typ=ma  ,validators=NoRepeat(),max='**'),
            ),
         RESU_MECA   =FACT(statut='o',max='**',fr="Chargements mécaniques",
           regles=(UN_PARMI('CHAM_GD','RESULTAT'),),
           NUME_CHAR     =SIMP(statut='o',typ='I',fr="numéro du chargement" ),
           NOM_CHAR      =SIMP(statut='f',typ='TXM',fr="nom du chargement" ),
           TYPE_CHAR     =SIMP(statut='f',typ='TXM',fr="nature du chargement",into=( "SEISME","AUTRE"),defaut="AUTRE",),
           CHAM_GD         =SIMP(statut='f',typ=cham_gd_sdaster),
           RESULTAT        =SIMP(statut='f',typ=resultat_sdaster),
           b_extrac        =BLOC(condition="RESULTAT != None",
                                 fr="extraction d un champ de grandeur",
             regles=(UN_PARMI('TOUT_ORDRE','NUME_ORDRE','INST','NOEUD_CMP'),),
             NOM_CHAM        =SIMP(statut='o',typ='TXM',into=("EFGE_ELNO_DEPL","SIEF_ELNO_ELGA"),),
             TOUT_ORDRE      =SIMP(statut='f',typ='TXM',into=("OUI",) ),
             NUME_ORDRE      =SIMP(statut='f',typ='I',),
             INST            =SIMP(statut='f',typ='R',),
             NOEUD_CMP       =SIMP(statut='f',typ='TXM',validators=NoRepeat(),max='**'),
             b_acce_reel     =BLOC(condition="(INST != None)",
               PRECISION       =SIMP(statut='f',typ='R',defaut=1.0E-3),
               CRITERE         =SIMP(statut='f',typ='TXM',defaut="RELATIF",into=("RELATIF","ABSOLU"), ),
             ),
           ),
                          ),
         INDI_SIGM =FACT(statut='o',max='**',fr="indices de contraintes",
            regles=(PRESENT_ABSENT('TOUT','GROUP_MA','MAILLE'),AU_MOINS_UN('TOUT','GROUP_MA','MAILLE'),),
            C1              =SIMP(statut='f',typ='R',defaut=1.0,fr="indice de contraintes C1 du RCCM"),
            K1              =SIMP(statut='f',typ='R',defaut=1.0,fr="indice de contraintes K1 du RCCM"),
            C2              =SIMP(statut='f',typ='R',defaut=1.0,fr="indice de contraintes C2 du RCCM"),
            K2              =SIMP(statut='f',typ='R',defaut=1.0,fr="indice de contraintes K2 du RCCM"),
            C3              =SIMP(statut='f',typ='R',defaut=0.5,fr="indice de contraintes C3 du RCCM"),
            K3              =SIMP(statut='f',typ='R',defaut=1.0,fr="indice de contraintes K3 du RCCM"),
            TOUT            =SIMP(statut='f',typ='TXM',into=("OUI",),),
            GROUP_MA        =SIMP(statut='f',typ=grma,validators=NoRepeat(),max='**',
                             fr="groupe(s) de mailles ou sont affectés les indices de contraintes"),
            MAILLE          =SIMP(statut='f',typ=ma,validators=NoRepeat(),max='**',
                             fr="liste des mailles ou sont affectés les indices de contraintes"),
            b_grma     =BLOC(condition="(GROUP_MA != None)or(MAILLE != None)",
               GROUP_NO        =SIMP(statut='f',typ=grno,validators=NoRepeat(),max='**'),
               NOEUD           =SIMP(statut='f',typ=no  ,validators=NoRepeat(),max='**'),
            ),
            TYPE_ELEM_STANDARD =SIMP(statut='f',typ='TXM',into=("DRO","COU","TRN","TEE"),
                              fr="type d'élément de tuyauterie ou sont affectés les indices de contraintes"),
                         ),
          RESU_THER   =FACT(statut='f',max='**',fr="resultats thermiques",
            regles=(PRESENT_ABSENT('TOUT','GROUP_MA','MAILLE'),AU_MOINS_UN('TOUT','GROUP_MA','MAILLE'),),
            NUME_RESU_THER =SIMP(statut='o',typ='I',fr="numéro de la table de résultat thermique" ),
            TABL_RESU_THER =SIMP(statut='o',typ=table_sdaster,
                              fr="table relevé des températures sur la section"),
            TABL_MOYE_THER =SIMP(statut='o',typ=table_sdaster,
                              fr="table relevé des moyennes sur la section"),
            TOUT            =SIMP(statut='f',typ='TXM',into=("OUI",) ),
            GROUP_MA        =SIMP(statut='f',typ=grma,validators=NoRepeat(),max='**'),
            MAILLE          =SIMP(statut='f',typ=ma  ,validators=NoRepeat(),max='**'),
            b_grma     =BLOC(condition="(GROUP_MA != None)or(MAILLE != None)",
               GROUP_NO        =SIMP(statut='f',typ=grno,validators=NoRepeat(),max='**'),
               NOEUD           =SIMP(statut='f',typ=no  ,validators=NoRepeat(),max='**'),
            ),
                           ),
         SITUATION         =FACT(statut='o',max='**',fr="Situation",ang="situation_ang",
              NB_OCCUR         =SIMP(statut='o',typ='I',fr="nombre d'occurences de la situation" ),
              NB_CYCL_SEISME   =SIMP(statut='f',typ='I',fr="nombre de cycles associé au séisme" ),
              NUME_SITU        =SIMP(statut='o',typ='I',fr="numéro de la situation" ),
              NOM_SITU         =SIMP(statut='f',typ='TXM',fr="nom de la situation" ),
              COMBINABLE       =SIMP(statut='f',typ='TXM',defaut= "OUI",into=("OUI","NON"),fr="non = sous-cycle" ),
              NUME_GROUPE      =SIMP(statut='o',typ='I',fr="numéro du groupe de la situation" ),
              NUME_PASSAGE     =SIMP(statut='f',typ='I',max=2,fr="numéro des deux groupes en relation" ),
              NUME_RESU_THER   =SIMP(statut='f',typ='I',max='**',fr="numeros de transitoires thermiques" ),
              CHAR_ETAT_A      =SIMP(statut='o',typ='I',max='**',fr="numeros de chargements etat A" ),
              CHAR_ETAT_B      =SIMP(statut='o',typ='I',max='**',fr="numeros de chargements etat B" ),
              PRES_A           =SIMP(statut='o',typ='R',fr="pression etat A"),
              PRES_B           =SIMP(statut='o',typ='R',fr="pression etat B"),
              TEMP_REF_A       =SIMP(statut='f',typ='R',fr="temperature référence etat A"),
              TEMP_REF_B       =SIMP(statut='f',typ='R',fr="temperature référence etat B"),
                               ),
               ),
)  ;
#& MODIF COMMANDE  DATE 27/11/2006   AUTEUR GNICOLAS G.NICOLAS 
# ======================================================================
#            CONFIGURATION MANAGEMENT OF EDF VERSION
# COPYRIGHT (C) 1991 - 2001  EDF R&D                  WWW.CODE-ASTER.ORG
# THIS PROGRAM IS FREE SOFTWARE; YOU CAN REDISTRIBUTE IT AND/OR MODIFY
# IT UNDER THE TERMS OF THE GNU GENERAL PUBLIC LICENSE AS PUBLISHED BY
# THE FREE SOFTWARE FOUNDATION; EITHER VERSION 2 OF THE LICENSE, OR   
# (AT YOUR OPTION) ANY LATER VERSION.                                 
#
# THIS PROGRAM IS DISTRIBUTED IN THE HOPE THAT IT WILL BE USEFUL, BUT 
# WITHOUT ANY WARRANTY; WITHOUT EVEN THE IMPLIED WARRANTY OF          
# MERCHANTABILITY OR FITNESS FOR A PARTICULAR PURPOSE. SEE THE GNU    
# GENERAL PUBLIC LICENSE FOR MORE DETAILS.                            
#
# YOU SHOULD HAVE RECEIVED A COPY OF THE GNU GENERAL PUBLIC LICENSE   
# ALONG WITH THIS PROGRAM; IF NOT, WRITE TO EDF R&D CODE_ASTER,       
#    1 AVENUE DU GENERAL DE GAULLE, 92141 CLAMART CEDEX, FRANCE.      
# ======================================================================
# RESPONSABLE G8BHHXD X.DESROCHES
POST_RELEVE_T=OPER(nom="POST_RELEVE_T",op=51,sd_prod=table_sdaster,reentrant='f',
            fr="Extraire des valeurs de composantes de champs de grandeurs pour y effectuer des calculs (moyenne,invariants,..)"
               +" ou pour les exprimer dans d'autres repères",
            docu="U4.81.21",UIinfo={"groupes":("Post traitements",)},

         ACTION          =FACT(statut='o',max='**',
                               regles=(UN_PARMI('RESULTAT','CHAM_GD'),), 

           OPERATION       =SIMP(statut='o',typ='TXM',into=("EXTRACTION","MOYENNE","EXTREMA"),validators=NoRepeat(),max=2),
           INTITULE        =SIMP(statut='o',typ='TXM'),  

           CHAM_GD         =SIMP(statut='f',typ=(cham_no_sdaster,
                                                 cham_elem,),),
           RESULTAT        =SIMP(statut='f',typ=(evol_elas,evol_ther,evol_noli,dyna_trans,
                                                 mode_meca,mode_flamb,mode_acou,base_modale,mode_stat,
                                                 mult_elas,fourier_elas,fourier_ther,dyna_harmo,acou_harmo)),
#
#  1. Sensibilité
#  1.1. Cas d'un résultat réel
#       Cas d'un résultat harmonique dont on veut partie réelle ou imaginaire
#
           b_sensibilite   =BLOC(condition=" (RESULTAT != None) and \
                                      (   AsType(RESULTAT) in (evol_elas,evol_ther,evol_noli,dyna_trans, \
                                                               mode_meca,mode_flamb,mode_acou,base_modale,mode_stat, \
                                                               mult_elas,fourier_elas,fourier_ther) or \
                                        ( AsType(RESULTAT) in (dyna_harmo,acou_harmo) and FORMAT_C != 'MODULE' ) )",
                                 fr="Définition des paramètres de sensibilité",
                                 ang="Definition of sensitivity parameters",
             regles=(CONCEPT_SENSIBLE("SEPARE"), REUSE_SENSIBLE(),
                     DERIVABLE('RESULTAT'),),
             SENSIBILITE     =SIMP(statut='f',typ=(para_sensi,theta_geom),validators=NoRepeat(),max='**',
                                   fr="Liste des paramètres de sensibilité.",
                                   ang="List of sensitivity parameters"),

           ),
#
#  1.2. Cas d'un résultat harmonique dont on veut le module
#
           b_sensibilite_harmo =BLOC(condition=" (RESULTAT != None) and \
                                      ( AsType(RESULTAT) in (dyna_harmo,acou_harmo) and FORMAT_C == 'MODULE' )",
                                     fr="Définition des paramètres de sensibilité",
                                     ang="Definition of sensitivity parameters",
             regles=(CONCEPT_SENSIBLE("SEPARE"), REUSE_SENSIBLE(),
                     DERIVABLE('RESULTAT'),),
             SENSIBILITE     =SIMP(statut='f',typ=(para_sensi,theta_geom),validators=NoRepeat(),max='**',
                                   fr="Liste des paramètres de sensibilité.",
                                   ang="List of sensitivity parameters"),
               b_sensibilite_harmo =BLOC(condition=" SENSIBILITE != None",
                                         fr="Option pour la sensibilite",
                                         ang="Option for sensitivity",
               SENSIBILITE_OPTION =SIMP(statut='o',typ='TXM',into=("MODULE_SENSIBILITE","SENSIBILITE_MODULE",),
                                        fr="Option : module de la dérivée ou dérivée du module",
                                        ang="Option : modulus of derivative or derivative of modulus"),
               ),
           ),

           b_extrac        =BLOC(condition = "RESULTAT != None",fr="extraction des résultats",
                                 regles=(EXCLUS('TOUT_ORDRE','NUME_ORDRE','LIST_ORDRE','NUME_MODE','LIST_MODE',         
                                                'INST','LIST_INST','FREQ','LIST_FREQ','NOEUD_CMP','NOM_CAS'), ),           
             NOM_CHAM        =SIMP(statut='o',typ='TXM' ),  
             TOUT_ORDRE      =SIMP(statut='f',typ='TXM',into=("OUI",) ),
             NUME_ORDRE      =SIMP(statut='f',typ='I',validators=NoRepeat(),max='**'),  
             LIST_ORDRE      =SIMP(statut='f',typ=listis_sdaster),
             NUME_MODE       =SIMP(statut='f',typ='I',validators=NoRepeat(),max='**'),  
             LIST_MODE       =SIMP(statut='f',typ=listis_sdaster),
             NOEUD_CMP       =SIMP(statut='f',typ='TXM',validators=NoRepeat(),max='**'),
             NOM_CAS         =SIMP(statut='f',typ='TXM',validators=NoRepeat(),max='**'),  
             FREQ            =SIMP(statut='f',typ='R',validators=NoRepeat(),max='**'),  
             LIST_FREQ       =SIMP(statut='f',typ=listr8_sdaster),
             INST            =SIMP(statut='f',typ='R',validators=NoRepeat(),max='**'),  
             LIST_INST       =SIMP(statut='f',typ=listr8_sdaster),
             PRECISION       =SIMP(statut='f',typ='R',defaut=1.0E-6),  
             CRITERE         =SIMP(statut='f',typ='TXM',defaut="RELATIF",into=("RELATIF","ABSOLU")),
           ),

           b_extrema   =BLOC(condition="OPERATION == 'EXTREMA'",
                             fr="recherche de MIN MAX",
                             regles=(EXCLUS('TOUT_CMP','NOM_CMP'),),
              TOUT            =SIMP(statut='f',typ='TXM',into=("OUI",) ),
              GROUP_MA        =SIMP(statut='f',typ=grma,validators=NoRepeat(),max='**'),
              MAILLE          =SIMP(statut='f',typ=ma  ,validators=NoRepeat(),max='**'),
              GROUP_NO        =SIMP(statut='f',typ=grno,validators=NoRepeat(),max='**'),
              NOEUD           =SIMP(statut='f',typ=no  ,validators=NoRepeat(),max='**'),
              TOUT_CMP        =SIMP(statut='f',typ='TXM',into=("OUI",)),
              NOM_CMP         =SIMP(statut='f',typ='TXM',max='**'),  
           ),

           b_autre   =BLOC(condition="OPERATION != 'EXTREMA'",
                           fr="extraction et moyenne",
                           regles=(AU_MOINS_UN('CHEMIN','GROUP_NO','NOEUD'),
                                   EXCLUS('CHEMIN','GROUP_NO'),
                                   EXCLUS('CHEMIN','NOEUD'),
                                   PRESENT_ABSENT('CHEMIN','GROUP_MA','MAILLE'),
                                   UN_PARMI('TOUT_CMP','NOM_CMP','INVARIANT','ELEM_PRINCIPAUX','RESULTANTE'),
                                   PRESENT_PRESENT('TRAC_DIR','DIRECTION'),          
                                   ENSEMBLE('MOMENT','POINT'),
                                   PRESENT_PRESENT('MOMENT','RESULTANTE'),
                                   PRESENT_ABSENT('TOUT_CMP','TRAC_DIR','TRAC_NOR'),
                                   EXCLUS('TRAC_DIR','TRAC_NOR'),
                                   PRESENT_PRESENT('ORIGINE','AXE_Z'),),
                   
              CHEMIN          =SIMP(statut='f',typ=(courbe_sdaster,surface_sdaster) ),
              TOUT            =SIMP(statut='f',typ='TXM',into=("OUI",) ),
              GROUP_MA        =SIMP(statut='f',typ=grma,validators=NoRepeat(),max='**'),
              MAILLE          =SIMP(statut='f',typ=ma  ,validators=NoRepeat(),max='**'),
              GROUP_NO        =SIMP(statut='f',typ=grno,validators=NoRepeat(),max='**'),
              NOEUD           =SIMP(statut='f',typ=no  ,validators=NoRepeat(),max='**'),

              TOUT_CMP        =SIMP(statut='f',typ='TXM',into=("OUI",)),
              NOM_CMP         =SIMP(statut='f',typ='TXM',max='**'),  
              INVARIANT       =SIMP(statut='f',typ='TXM',into=("OUI",)),
              ELEM_PRINCIPAUX =SIMP(statut='f',typ='TXM',into=("OUI",) ),
              RESULTANTE      =SIMP(statut='f',typ='TXM',max='**'),  

              MOMENT          =SIMP(statut='f',typ='TXM',max='**'),  
              POINT           =SIMP(statut='f',typ='R',max='**'),  

              REPERE          =SIMP(statut='f',typ='TXM',defaut="GLOBAL",
                                 into=("GLOBAL","LOCAL","POLAIRE","UTILISATEUR","CYLINDRIQUE"),),
              ANGL_NAUT       =SIMP(statut='f',typ='R',min=3,max=3),  
              ORIGINE         =SIMP(statut='f',typ='R',min=3,max=3),  
              AXE_Z           =SIMP(statut='f',typ='R',min=3,max=3),  

              TRAC_NOR        =SIMP(statut='f',typ='TXM',into=("OUI",)),
              TRAC_DIR        =SIMP(statut='f',typ='TXM',into=("OUI",)),
              DIRECTION       =SIMP(statut='f',typ='R',max='**'),  
 
              VECT_Y          =SIMP(statut='f',typ='R',max='**'),  
              MOYE_NOEUD      =SIMP(statut='f',typ='TXM',defaut="OUI",into=("OUI","NON")),
           ),

           FORMAT_C        =SIMP(statut='f',typ='TXM',defaut="MODULE",into=("MODULE","REEL","IMAG")),

         ),
         INFO            =SIMP(statut='f',typ='I',defaut=1,into=(1,2)),
         TITRE           =SIMP(statut='f',typ='TXM',max='**'),  
)  ;
#& MODIF COMMANDE  DATE 03/01/2006   AUTEUR REZETTE C.REZETTE 
#            CONFIGURATION MANAGEMENT OF EDF VERSION
# ======================================================================
# COPYRIGHT (C) 1991 - 2001  EDF R&D                  WWW.CODE-ASTER.ORG
# THIS PROGRAM IS FREE SOFTWARE; YOU CAN REDISTRIBUTE IT AND/OR MODIFY
# IT UNDER THE TERMS OF THE GNU GENERAL PUBLIC LICENSE AS PUBLISHED BY
# THE FREE SOFTWARE FOUNDATION; EITHER VERSION 2 OF THE LICENSE, OR   
# (AT YOUR OPTION) ANY LATER VERSION.                                 
#
# THIS PROGRAM IS DISTRIBUTED IN THE HOPE THAT IT WILL BE USEFUL, BUT 
# WITHOUT ANY WARRANTY; WITHOUT EVEN THE IMPLIED WARRANTY OF          
# MERCHANTABILITY OR FITNESS FOR A PARTICULAR PURPOSE. SEE THE GNU    
# GENERAL PUBLIC LICENSE FOR MORE DETAILS.                            
#
# YOU SHOULD HAVE RECEIVED A COPY OF THE GNU GENERAL PUBLIC LICENSE   
# ALONG WITH THIS PROGRAM; IF NOT, WRITE TO EDF R&D CODE_ASTER,       
#    1 AVENUE DU GENERAL DE GAULLE, 92141 CLAMART CEDEX, FRANCE.      
# ======================================================================
POST_USURE=OPER(nom="POST_USURE",op=153,sd_prod=table_sdaster,reentrant='f',
            UIinfo={"groupes":("Post traitements",)},
                fr="Calcul des volumes d'usure et des profondeurs d'usure d'après la puissance d'usure",
         regles=(UN_PARMI('TUBE_NEUF','RESU_GENE','PUIS_USURE'),
                 PRESENT_PRESENT('RESU_GENE','NOEUD','LOI_USURE'),
                 PRESENT_PRESENT('PUIS_USURE','LOI_USURE'),),
         TUBE_NEUF       =SIMP(statut='f',typ='TXM',into=("OUI",) ),
         ETAT_INIT       =FACT(statut='f',
           TABL_USURE      =SIMP(statut='f',typ=table_sdaster),
           INST_INIT       =SIMP(statut='f',typ='R'),  
                         ),
         RESU_GENE       =SIMP(statut='f',typ=tran_gene),
         NOEUD           =SIMP(statut='f',typ=no,),
         INST_INIT       =SIMP(statut='f',typ='R',defaut=-1.0E+0),  
         INST_FIN        =SIMP(statut='f',typ='R'),  
         NB_BLOC         =SIMP(statut='f',typ='I',defaut= 1 ),  
         PUIS_USURE      =SIMP(statut='f',typ='R'),  
         LOI_USURE       =SIMP(statut='f',typ='TXM',into=("ARCHARD","KWU_EPRI","EDF_MZ")),
         b_archard       =BLOC(condition = "LOI_USURE == 'ARCHARD'",
           regles=(UN_PARMI('MOBILE','MATER_USURE','SECTEUR'), 
                   EXCLUS('MATER_USURE','OBSTACLE'),
                   EXCLUS('MOBILE','USURE_OBST'),),
           MOBILE          =FACT(statut='f',
             COEF_USURE      =SIMP(statut='o',typ='R'), 
           ),   
           OBSTACLE        =FACT(statut='f',
             COEF_USURE      =SIMP(statut='o',typ='R'), 
           ),
           SECTEUR         =FACT(statut='f',max='**',
             CONTACT         =SIMP(statut='f',typ='TXM',into=("TUBE_BAV","TUBE_ALESAGE","TUBE_4_ENCO",  
                                                              "GRAPPE_ALESAGE","TUBE_3_ENCO","TUBE_TUBE", 
                                                              "GRAPPE_1_ENCO","GRAPPE_2_ENCO")),
             COEF_USUR_MOBILE=SIMP(statut='f',typ='R'),  
             COEF_USUR_OBST  =SIMP(statut='f',typ='R'),  
             ANGL_INIT       =SIMP(statut='f',typ='R'),  
             ANGL_FIN        =SIMP(statut='f',typ='R'),  
           ),
           MATER_USURE     =SIMP(statut='f',typ='TXM'),  
           USURE_OBST      =SIMP(statut='f',typ='TXM',into=("OUI",)),
         ),
         b_kwu_epri        =BLOC(condition = "LOI_USURE == 'KWU_EPRI'",
           regles=(UN_PARMI('MOBILE','MATER_USURE'), 
                   EXCLUS('MATER_USURE','OBSTACLE'),
                   EXCLUS('MOBILE','USURE_OBST'),),
           MOBILE          =FACT(statut='f',
             COEF_FNOR       =SIMP(statut='f',typ='R'),  
             COEF_VTAN       =SIMP(statut='f',typ='R'),  
             COEF_USURE      =SIMP(statut='f',typ='R'),  
             COEF_K          =SIMP(statut='f',typ='R',defaut=5.0E+0),  
             COEF_C          =SIMP(statut='f',typ='R',defaut=10.0E+0),  
           ),   
           OBSTACLE        =FACT(statut='f',
             COEF_FNOR       =SIMP(statut='f',typ='R' ),  
             COEF_VTAN       =SIMP(statut='f',typ='R' ),  
             COEF_USURE      =SIMP(statut='o',typ='R'), 
             COEF_K          =SIMP(statut='f',typ='R',defaut=5.0E+0),  
             COEF_C          =SIMP(statut='f',typ='R',defaut=10.0E+0),  
           ),   
           MATER_USURE     =SIMP(statut='f',typ='TXM'),  
           USURE_OBST      =SIMP(statut='f',typ='TXM',into=("OUI",)),
           FNOR_MAXI       =SIMP(statut='f',typ='R' ),  
           VTAN_MAXI       =SIMP(statut='f',typ='R' ),  
         ),
         b_edf_mz          =BLOC(condition = "LOI_USURE == 'EDF_MZ'",
           regles=(UN_PARMI('MOBILE','MATER_USURE'), 
                   EXCLUS('MATER_USURE','OBSTACLE'),
                   EXCLUS('MOBILE','USURE_OBST'),),
           MOBILE          =FACT(statut='f',
             COEF_USURE      =SIMP(statut='f',typ='R',defaut=1.0E-13),  
             COEF_B          =SIMP(statut='f',typ='R',defaut=1.2E+0),  
             COEF_N          =SIMP(statut='f',typ='R',defaut=2.44E-8),  
             COEF_S          =SIMP(statut='f',typ='R',defaut=1.14E-16),  
           ),   
           OBSTACLE        =FACT(statut='f',
             COEF_USURE      =SIMP(statut='o',typ='R',defaut=1.0E-13), 
             COEF_B          =SIMP(statut='f',typ='R',defaut=1.2E+0),  
             COEF_N          =SIMP(statut='f',typ='R',defaut=2.44E-8),  
             COEF_S          =SIMP(statut='f',typ='R',defaut=1.14E-16),  
           ),   
           MATER_USURE     =SIMP(statut='f',typ='TXM'),  
           USURE_OBST      =SIMP(statut='f',typ='TXM',into=("OUI",)),
         ),
         b_tube_neuf       =BLOC(condition = "TUBE_NEUF == 'OUI'",
            TABL_USURE      =SIMP(statut='o',typ=table_sdaster),
            INST            =SIMP(statut='f',typ='R'),
         ),
         CONTACT         =SIMP(statut='f',typ='TXM',into=("TUBE_BAV","TUBE_ALESAGE","TUBE_4_ENCO",    
                                                          "GRAPPE_ALESAGE","TUBE_3_ENCO","TUBE_TUBE",        
                                                          "GRAPPE_1_ENCO","GRAPPE_2_ENCO")),
         RAYON_MOBILE    =SIMP(statut='f',typ='R'),  
         RAYON_OBST      =SIMP(statut='f',typ='R'),  
         LARGEUR_OBST    =SIMP(statut='f',typ='R'),  
         ANGL_INCLI      =SIMP(statut='f',typ='R'),  
         ANGL_ISTHME     =SIMP(statut='f',typ='R'),  
         ANGL_IMPACT     =SIMP(statut='f',typ='R'),  
         INST            =SIMP(statut='f',typ='R',validators=NoRepeat(),max='**'),  
         LIST_INST       =SIMP(statut='f',typ=listr8_sdaster),
         COEF_INST       =SIMP(statut='f',typ='R',defaut=1.0E+0),  
         INFO            =SIMP(statut='f',typ='I',defaut=1,into=(1,2)),
         TITRE           =SIMP(statut='f',typ='TXM',max='**' ),  
)  ;
#& MODIF COMMANDE  DATE 22/06/2005   AUTEUR REZETTE C.REZETTE 
#            CONFIGURATION MANAGEMENT OF EDF VERSION
# ======================================================================
# COPYRIGHT (C) 1991 - 2001  EDF R&D                  WWW.CODE-ASTER.ORG
# THIS PROGRAM IS FREE SOFTWARE; YOU CAN REDISTRIBUTE IT AND/OR MODIFY
# IT UNDER THE TERMS OF THE GNU GENERAL PUBLIC LICENSE AS PUBLISHED BY
# THE FREE SOFTWARE FOUNDATION; EITHER VERSION 2 OF THE LICENSE, OR   
# (AT YOUR OPTION) ANY LATER VERSION.                                 
#
# THIS PROGRAM IS DISTRIBUTED IN THE HOPE THAT IT WILL BE USEFUL, BUT 
# WITHOUT ANY WARRANTY; WITHOUT EVEN THE IMPLIED WARRANTY OF          
# MERCHANTABILITY OR FITNESS FOR A PARTICULAR PURPOSE. SEE THE GNU    
# GENERAL PUBLIC LICENSE FOR MORE DETAILS.                            
#
# YOU SHOULD HAVE RECEIVED A COPY OF THE GNU GENERAL PUBLIC LICENSE   
# ALONG WITH THIS PROGRAM; IF NOT, WRITE TO EDF R&D CODE_ASTER,       
#    1 AVENUE DU GENERAL DE GAULLE, 92141 CLAMART CEDEX, FRANCE.      
# ======================================================================
POST_ZAC=OPER(nom="POST_ZAC",op= 175,sd_prod=mult_elas,reentrant='n',
            UIinfo={"groupes":("Post traitements",)},
              fr="Déterminer l'état adapté ou accommodé par la méthode de Zarka-Casier d'une structure sous"
                +" chargement cyclique élastique affine ou non",
         MODELE          =SIMP(statut='o',typ=modele_sdaster),
         CHAM_MATER      =SIMP(statut='o',typ=cham_mater),
         EXCIT           =FACT(statut='o',max='**',
           CHARGE          =SIMP(statut='o',typ=char_meca),
           FONC_MULT       =SIMP(statut='f',typ=(fonction_sdaster,nappe_sdaster,formule)),
           TYPE_CHARGE     =SIMP(statut='f',typ='TXM',defaut="FIXE_CSTE",into=("FIXE_CSTE",)),
         ),
         EVOL_ELAS       =SIMP(statut='o',typ=evol_elas),
         b_evol_elas     =BLOC(condition="EVOL_ELAS != None",
           regles=(UN_PARMI('NUME_ORDRE','LIST_INST','INST'),),
           NUME_ORDRE      =SIMP(statut='f',typ='I',validators=NoRepeat(),max='**'),  
           LIST_INST       =SIMP(statut='f',typ=listr8_sdaster),
           INST            =SIMP(statut='f',typ='R',validators=NoRepeat(),max='**'),  
         ),
         TEMP_ZAC        =SIMP(statut='f',typ='R',defaut=0.0E+0),  
         EVOL_NOLI       =SIMP(statut='f',typ=evol_noli),
         b_evol_noli     =BLOC(condition="EVOL_NOLI != None",
           INST_MAX        =SIMP(statut='o',typ='R'),  
         ),
         PRECISION       =SIMP(statut='f',typ='R',defaut= 1.0E-3),  
         CRITERE         =SIMP(statut='f',typ='TXM',defaut="RELATIF",into=("RELATIF","ABSOLU")),

)  ;
#& MODIF COMMANDE  DATE 19/06/2006   AUTEUR VABHHTS J.PELLET 
#            CONFIGURATION MANAGEMENT OF EDF VERSION
# ======================================================================
# COPYRIGHT (C) 1991 - 2001  EDF R&D                  WWW.CODE-ASTER.ORG
# THIS PROGRAM IS FREE SOFTWARE; YOU CAN REDISTRIBUTE IT AND/OR MODIFY
# IT UNDER THE TERMS OF THE GNU GENERAL PUBLIC LICENSE AS PUBLISHED BY
# THE FREE SOFTWARE FOUNDATION; EITHER VERSION 2 OF THE LICENSE, OR
# (AT YOUR OPTION) ANY LATER VERSION.
#
# THIS PROGRAM IS DISTRIBUTED IN THE HOPE THAT IT WILL BE USEFUL, BUT
# WITHOUT ANY WARRANTY; WITHOUT EVEN THE IMPLIED WARRANTY OF
# MERCHANTABILITY OR FITNESS FOR A PARTICULAR PURPOSE. SEE THE GNU
# GENERAL PUBLIC LICENSE FOR MORE DETAILS.
#
# YOU SHOULD HAVE RECEIVED A COPY OF THE GNU GENERAL PUBLIC LICENSE
# ALONG WITH THIS PROGRAM; IF NOT, WRITE TO EDF R&D CODE_ASTER,
#    1 AVENUE DU GENERAL DE GAULLE, 92141 CLAMART CEDEX, FRANCE.
# ======================================================================
POURSUITE=MACRO(nom="POURSUITE",op=ops.build_poursuite,repetable='n',
                fr="Poursuite d'une étude à partir de la sauvegarde au format JEVEUX ou HDF de sa base globale",
                sd_prod = ops.POURSUITE,
            UIinfo={"groupes":("Gestion du travail",)},
                op_init = ops.POURSUITE_context,fichier_ini = 1,
         FORMAT_HDF      =SIMP(fr="sauvegarde de la base GLOBALE au format HDF",statut='f',
                               typ='TXM',defaut="NON",into=("OUI","NON",) ),
         PAR_LOT         =SIMP(fr="mode de traitement des commandes",statut='f',typ='TXM',
                           into=("OUI","NON"),defaut="OUI"),
         IMPR_MACRO      =SIMP(fr="affichage des sous-commandes produites par les macros dans le fichier mess",
                           statut='f',typ='TXM',into=("OUI","NON"),defaut="NON"),
         BASE            =FACT(fr="définition des paramètres associés aux bases JEVEUX",
                               statut='f',min=1,max=2,
           FICHIER         =SIMP(fr="nom de la base",statut='o',typ='TXM'),
           TITRE           =SIMP(statut='f',typ='TXM'),
           CAS             =SIMP(statut='f',typ='TXM'),
           NMAX_ENRE       =SIMP(fr="nombre maximum d enregistrements",statut='f',typ='I'),
           LONG_ENRE       =SIMP(fr="longueur des enregistrements",statut='f',typ='I'),
           LONG_REPE       =SIMP(fr="longueur du répertoire",statut='f',typ='I'),
         ),
         IMPRESSION      =FACT(statut='f',min=1,max=3,
           FICHIER         =SIMP(statut='o',typ='TXM'),
           UNITE           =SIMP(statut='o',typ='I'),
         ),
         CATALOGUE       =FACT(statut='f',min=1,max=10,
           FICHIER         =SIMP(statut='o',typ='TXM'),
           TITRE           =SIMP(statut='f',typ='TXM'),
           UNITE           =SIMP(statut='f',typ='I'),
         ),
         ERREUR          =FACT(fr="comportement en cas d'erreur",statut='f',min=1,max=1,
           ERREUR_F        =SIMP(statut='f',typ='TXM',into=('ABORT','EXCEPTION'),defaut='ABORT'),
         ),
         DEBUG           =FACT(fr="option de déboggage reservée aux développeurs",
                               statut='f',min=1,max=1,
           JXVERI          =SIMP(fr="vérifie l intégrité de la segmentation mémoire",
                                 statut='f',typ='TXM',into=('OUI','NON'),defaut='NON'),
           SDVERI          =SIMP(fr="vérifie la conformité des SD produites par les commandes",
                                 statut='f',typ='TXM',into=('OUI','NON'),defaut='NON'),
           JEVEUX          =SIMP(fr="force les déchargement sur disque",
                                 statut='f',typ='TXM',into=('OUI','NON'),defaut='NON'),
           ENVIMA          =SIMP(fr="imprime les valeurs définies dans ENVIMA",
                                 statut='f',typ='TXM',into=('TEST',)),
         ),
         MEMOIRE         =FACT(fr="mode de gestion mémoire utilisé",statut='f',min=1,max=1,
           GESTION         =SIMP(statut='f',typ='TXM',into=('COMPACTE','RAPIDE'),defaut='RAPIDE'),
           TYPE_ALLOCATION =SIMP(statut='f',typ='I',into=(1,2,3,4),defaut=1),
           TAILLE          =SIMP(statut='f',typ='I'),
           TAILLE_BLOC     =SIMP(statut='f',typ='R',defaut=800.),
           PARTITION       =SIMP(statut='f',typ='R' ),
         ),
         RESERVE_CPU     =FACT(fr="reserve de temps pour terminer une execution",statut='f',max=1,
           regles=(EXCLUS('VALE','POURCENTAGE'),),
           VALE            =SIMP(statut='f',typ='I',val_min=0),
           POURCENTAGE     =SIMP(statut='f',typ='R',val_min=0.,val_max=1.0),
#          valeur en pourcentage du temps maximum bornée à 180 secondes
           BORNE           =SIMP(statut='f',typ='I',val_min=0,defaut=180)
         ),
         CODE            =FACT("définition d un nom pour l'esemble d'une étude",
                               statut='f',min=1,max=1,
           NOM             =SIMP(statut='o',typ='TXM'),
           UNITE           =SIMP(statut='f',typ='I',defaut=15),
         ),
)  ;
#& MODIF COMMANDE  DATE 22/06/2005   AUTEUR REZETTE C.REZETTE 
#            CONFIGURATION MANAGEMENT OF EDF VERSION
# ======================================================================
# COPYRIGHT (C) 1991 - 2001  EDF R&D                  WWW.CODE-ASTER.ORG
# THIS PROGRAM IS FREE SOFTWARE; YOU CAN REDISTRIBUTE IT AND/OR MODIFY
# IT UNDER THE TERMS OF THE GNU GENERAL PUBLIC LICENSE AS PUBLISHED BY
# THE FREE SOFTWARE FOUNDATION; EITHER VERSION 2 OF THE LICENSE, OR   
# (AT YOUR OPTION) ANY LATER VERSION.                                 
#
# THIS PROGRAM IS DISTRIBUTED IN THE HOPE THAT IT WILL BE USEFUL, BUT 
# WITHOUT ANY WARRANTY; WITHOUT EVEN THE IMPLIED WARRANTY OF          
# MERCHANTABILITY OR FITNESS FOR A PARTICULAR PURPOSE. SEE THE GNU    
# GENERAL PUBLIC LICENSE FOR MORE DETAILS.                            
#
# YOU SHOULD HAVE RECEIVED A COPY OF THE GNU GENERAL PUBLIC LICENSE   
# ALONG WITH THIS PROGRAM; IF NOT, WRITE TO EDF R&D CODE_ASTER,       
#    1 AVENUE DU GENERAL DE GAULLE, 92141 CLAMART CEDEX, FRANCE.      
# ======================================================================
PRE_GIBI=PROC(nom="PRE_GIBI",op=49,
            UIinfo={"groupes":("Gestion du travail",)},
              fr="Conversion d'un fichier de maillage GIBI au format Aster",
         UNITE_GIBI      =SIMP(statut='f',typ='I',defaut=19),  
         UNITE_MAILLAGE  =SIMP(statut='f',typ='I',defaut=20),  
)  ;
#& MODIF COMMANDE  DATE 22/06/2005   AUTEUR REZETTE C.REZETTE 
#            CONFIGURATION MANAGEMENT OF EDF VERSION
# ======================================================================
# COPYRIGHT (C) 1991 - 2001  EDF R&D                  WWW.CODE-ASTER.ORG
# THIS PROGRAM IS FREE SOFTWARE; YOU CAN REDISTRIBUTE IT AND/OR MODIFY
# IT UNDER THE TERMS OF THE GNU GENERAL PUBLIC LICENSE AS PUBLISHED BY
# THE FREE SOFTWARE FOUNDATION; EITHER VERSION 2 OF THE LICENSE, OR   
# (AT YOUR OPTION) ANY LATER VERSION.                                 
#
# THIS PROGRAM IS DISTRIBUTED IN THE HOPE THAT IT WILL BE USEFUL, BUT 
# WITHOUT ANY WARRANTY; WITHOUT EVEN THE IMPLIED WARRANTY OF          
# MERCHANTABILITY OR FITNESS FOR A PARTICULAR PURPOSE. SEE THE GNU    
# GENERAL PUBLIC LICENSE FOR MORE DETAILS.                            
#
# YOU SHOULD HAVE RECEIVED A COPY OF THE GNU GENERAL PUBLIC LICENSE   
# ALONG WITH THIS PROGRAM; IF NOT, WRITE TO EDF R&D CODE_ASTER,       
#    1 AVENUE DU GENERAL DE GAULLE, 92141 CLAMART CEDEX, FRANCE.      
# ======================================================================

PRE_GMSH=PROC(nom="PRE_GMSH",op=47,
            UIinfo={"groupes":("Gestion du travail",)},
               fr="Conversion d'un fichier de maillage GMSH au format Aster",
         UNITE_GMSH      =SIMP(statut='f',typ='I',defaut=19),  
         UNITE_MAILLAGE  =SIMP(statut='f',typ='I',defaut=20),  
)  ;
#& MODIF COMMANDE  DATE 22/06/2005   AUTEUR REZETTE C.REZETTE 
#            CONFIGURATION MANAGEMENT OF EDF VERSION
# ======================================================================
# COPYRIGHT (C) 1991 - 2001  EDF R&D                  WWW.CODE-ASTER.ORG
# THIS PROGRAM IS FREE SOFTWARE; YOU CAN REDISTRIBUTE IT AND/OR MODIFY
# IT UNDER THE TERMS OF THE GNU GENERAL PUBLIC LICENSE AS PUBLISHED BY
# THE FREE SOFTWARE FOUNDATION; EITHER VERSION 2 OF THE LICENSE, OR   
# (AT YOUR OPTION) ANY LATER VERSION.                                 
#
# THIS PROGRAM IS DISTRIBUTED IN THE HOPE THAT IT WILL BE USEFUL, BUT 
# WITHOUT ANY WARRANTY; WITHOUT EVEN THE IMPLIED WARRANTY OF          
# MERCHANTABILITY OR FITNESS FOR A PARTICULAR PURPOSE. SEE THE GNU    
# GENERAL PUBLIC LICENSE FOR MORE DETAILS.                            
#
# YOU SHOULD HAVE RECEIVED A COPY OF THE GNU GENERAL PUBLIC LICENSE   
# ALONG WITH THIS PROGRAM; IF NOT, WRITE TO EDF R&D CODE_ASTER,       
#    1 AVENUE DU GENERAL DE GAULLE, 92141 CLAMART CEDEX, FRANCE.      
# ======================================================================
PRE_IDEAS=PROC(nom="PRE_IDEAS",op=47,
            UIinfo={"groupes":("Gestion du travail",)},
               fr="Conversion d'un fichier universel IDEAS-SUPERTAB au format Aster",
         UNITE_IDEAS     =SIMP(statut='f',typ='I',defaut=19),  
         UNITE_MAILLAGE  =SIMP(statut='f',typ='I',defaut=20),  
         CREA_GROUP_COUL =SIMP(statut='f',typ='TXM',defaut="NON",into=("OUI","NON") ),
)  ;
#& MODIF COMMANDE  DATE 21/02/2006   AUTEUR REZETTE C.REZETTE 
#            CONFIGURATION MANAGEMENT OF EDF VERSION
# ======================================================================
# COPYRIGHT (C) 1991 - 2001  EDF R&D                  WWW.CODE-ASTER.ORG
# THIS PROGRAM IS FREE SOFTWARE; YOU CAN REDISTRIBUTE IT AND/OR MODIFY
# IT UNDER THE TERMS OF THE GNU GENERAL PUBLIC LICENSE AS PUBLISHED BY
# THE FREE SOFTWARE FOUNDATION; EITHER VERSION 2 OF THE LICENSE, OR   
# (AT YOUR OPTION) ANY LATER VERSION.                                 
#
# THIS PROGRAM IS DISTRIBUTED IN THE HOPE THAT IT WILL BE USEFUL, BUT 
# WITHOUT ANY WARRANTY; WITHOUT EVEN THE IMPLIED WARRANTY OF          
# MERCHANTABILITY OR FITNESS FOR A PARTICULAR PURPOSE. SEE THE GNU    
# GENERAL PUBLIC LICENSE FOR MORE DETAILS.                            
#
# YOU SHOULD HAVE RECEIVED A COPY OF THE GNU GENERAL PUBLIC LICENSE   
# ALONG WITH THIS PROGRAM; IF NOT, WRITE TO EDF R&D CODE_ASTER,       
#    1 AVENUE DU GENERAL DE GAULLE, 92141 CLAMART CEDEX, FRANCE.      
# ======================================================================

PROD_MATR_CHAM=OPER(nom="PROD_MATR_CHAM",op= 156,sd_prod=cham_no_sdaster,
                    fr="Effectuer le produit d'une matrice par un vecteur",
                    reentrant='n',
            UIinfo={"groupes":("Résultats et champs",)},
         MATR_ASSE       =SIMP(statut='o',typ=(matr_asse_depl_r,matr_asse_depl_c,matr_asse_temp_r,matr_asse_pres_c ) ),
         CHAM_NO         =SIMP(statut='o',typ=cham_no_sdaster),
         TITRE           =SIMP(statut='f',typ='TXM',max='**'),
)  ;
#& MODIF COMMANDE  DATE 12/09/2006   AUTEUR VABHHTS J.PELLET 
#            CONFIGURATION MANAGEMENT OF EDF VERSION
# ======================================================================
# COPYRIGHT (C) 1991 - 2001  EDF R&D                  WWW.CODE-ASTER.ORG
# THIS PROGRAM IS FREE SOFTWARE; YOU CAN REDISTRIBUTE IT AND/OR MODIFY
# IT UNDER THE TERMS OF THE GNU GENERAL PUBLIC LICENSE AS PUBLISHED BY
# THE FREE SOFTWARE FOUNDATION; EITHER VERSION 2 OF THE LICENSE, OR
# (AT YOUR OPTION) ANY LATER VERSION.
#
# THIS PROGRAM IS DISTRIBUTED IN THE HOPE THAT IT WILL BE USEFUL, BUT
# WITHOUT ANY WARRANTY; WITHOUT EVEN THE IMPLIED WARRANTY OF
# MERCHANTABILITY OR FITNESS FOR A PARTICULAR PURPOSE. SEE THE GNU
# GENERAL PUBLIC LICENSE FOR MORE DETAILS.
#
# YOU SHOULD HAVE RECEIVED A COPY OF THE GNU GENERAL PUBLIC LICENSE
# ALONG WITH THIS PROGRAM; IF NOT, WRITE TO EDF R&D CODE_ASTER,
#    1 AVENUE DU GENERAL DE GAULLE, 92141 CLAMART CEDEX, FRANCE.
# ======================================================================
# RESPONSABLE VABHHTS J.PELLET
def proj_champ_prod(RESULTAT=None,CHAM_NO_REFE=None,**args ):
    if AsType(RESULTAT)     == evol_ther      : return evol_ther
    if AsType(RESULTAT)     == evol_elas      : return evol_elas
    if AsType(RESULTAT)     == evol_noli      : return evol_noli
    if AsType(RESULTAT)     == evol_char      : return evol_char
    if AsType(RESULTAT)     == dyna_trans     : return dyna_trans
    if AsType(RESULTAT)     == dyna_harmo     : return dyna_harmo
    if AsType(RESULTAT)     == mode_meca      : return mode_meca
    if AsType(RESULTAT)     == mode_stat_depl : return mode_stat_depl
    if AsType(RESULTAT)     == base_modale    : return base_modale
    if CHAM_NO_REFE         != None           : return cham_no_sdaster
    raise AsException("type de concept resultat non prevu")

PROJ_CHAMP=OPER(nom="PROJ_CHAMP",op= 166,sd_prod=proj_champ_prod,reentrant='f',
            UIinfo={"groupes":("Résultats et champs",)},
                fr="Projeter les champs aux noeuds d'une SD résultat de type evol_xxx sur un autre maillage",
#
         METHODE         =SIMP(statut='f',typ='TXM',defaut="ELEM",
                               into=("NUAGE_DEG_0","NUAGE_DEG_1","ELEM",) ),
         b_nuage         =BLOC(condition="(METHODE=='NUAGE_DEG_1') or (METHODE=='NUAGE_DEG_0')",
                               fr="Lissage d'un nuage de points",
           CHAM_NO         =SIMP(statut='o',typ=cham_no_sdaster),
           CHAM_NO_REFE    =SIMP(statut='o',typ=cham_no_sdaster),
         ),
         b_elem          =BLOC(condition="METHODE=='ELEM'",
                              fr="Utilisation des fonctions de forme du maillage initial",
           regles=(EXCLUS('TOUT_ORDRE','NUME_ORDRE','INST','FREQ','LIST_INST','LIST_FREQ','LIST_ORDRE'),
                   EXCLUS('TOUT_CHAM','NOM_CHAM',),
                   CONCEPT_SENSIBLE('SEPARE'),
                   REUSE_SENSIBLE(),
                   DERIVABLE('RESULTAT'),),
           RESULTAT        =SIMP(statut='o',typ=(evol_ther,evol_elas,evol_noli,dyna_trans,evol_char,dyna_harmo,
                                                 mode_meca,mode_stat_depl,base_modale) ),
           SENSIBILITE     =SIMP(statut='f',typ=(para_sensi,theta_geom),validators=NoRepeat(),max='**',
                               fr="Liste des paramètres de sensibilité.",
                               ang="List of sensitivity parameters",),
           MODELE_1        =SIMP(statut='o',typ=modele_sdaster),
           MODELE_2        =SIMP(statut='o',typ=modele_sdaster),

           NOM_PARA        =SIMP(statut='f',typ='TXM', max='**'),
           TOUT_CHAM       =SIMP(statut='f',typ='TXM',into=("OUI",) ),
           NOM_CHAM        =SIMP(statut='f',typ='TXM',validators=NoRepeat(),max='**'),

#          POUR IMPOSER LA NUMEROTATION DES DDLS :
#          ------------------------------------------------------------------
           NUME_DDL        =SIMP(statut='f',typ=(nume_ddl_sdaster) ),


           TOUT_ORDRE      =SIMP(statut='f',typ='TXM',into=("OUI",) ),
           NUME_ORDRE      =SIMP(statut='f',typ='I',validators=NoRepeat(),max='**' ),
           LIST_ORDRE      =SIMP(statut='f',typ=listis_sdaster),
           INST            =SIMP(statut='f',typ='R',validators=NoRepeat(),max='**' ),
           LIST_INST       =SIMP(statut='f',typ=listr8_sdaster),
           FREQ            =SIMP(statut='f',typ='R',validators=NoRepeat(),max='**' ),
           LIST_FREQ       =SIMP(statut='f',typ=listr8_sdaster),
           NUME_MODE       =SIMP(statut='f',typ='I',validators=NoRepeat(),max='**' ),
           NOEUD_CMP       =SIMP(statut='f',typ='TXM',validators=NoRepeat(),max='**'),


           CAS_FIGURE      =SIMP(statut='f',typ='TXM',into=("2D","3D","2.5D","1.5D",) ),
           DISTANCE_MAX    =SIMP(statut='f',typ='R',
                fr="Distance maximale entre le noeud et l'élément le plus proche, lorsque le noeud n'est dans aucun élément."),
           TRANSF_GEOM_2   =SIMP(statut='f',typ=(fonction_sdaster,nappe_sdaster,formule),min=2,max=3,
                fr="2 (ou 3) fonctions fx,fy,fz définissant la transformation géométrique à appliquer"+
                   " aux noeuds du MODELE_2 avant la projection."),

           ALARME          =SIMP(statut='f',typ='TXM',defaut="OUI",into=("OUI","NON") ),

           TYPE_CHAM       =SIMP(statut='f',typ='TXM',into=("NOEU",),
                fr="Pour forcer le type des champs projetés. NOEU -> cham_no"),

           PROL_ZERO       =SIMP(statut='f',typ='TXM',into=("OUI","NON"),defaut="NON",
                fr="Si le résultat est un mode_xxx ou une base_xxx, on peut prolonger"
                   +" les champs par zéro la ou la projection ne donne pas de valeurs."),

         ),

         VIS_A_VIS       =FACT(statut='f',max='**',
           regles=(AU_MOINS_UN('TOUT_1','GROUP_MA_1','MAILLE_1','GROUP_NO_1','NOEUD_1'),
                   AU_MOINS_UN('TOUT_2','GROUP_MA_2','MAILLE_2','GROUP_NO_2','NOEUD_2'),),
           TOUT_1          =SIMP(statut='f',typ='TXM',into=("OUI",) ),
           GROUP_MA_1      =SIMP(statut='f',typ=grma,validators=NoRepeat(),max='**'),
           MAILLE_1        =SIMP(statut='f',typ=ma  ,validators=NoRepeat(),max='**'),
           GROUP_NO_1      =SIMP(statut='f',typ=grno,validators=NoRepeat(),max='**'),
           NOEUD_1         =SIMP(statut='f',typ=no  ,validators=NoRepeat(),max='**'),
           TOUT_2          =SIMP(statut='f',typ='TXM',into=("OUI",) ),
           GROUP_MA_2      =SIMP(statut='f',typ=grma,validators=NoRepeat(),max='**'),
           MAILLE_2        =SIMP(statut='f',typ=ma  ,validators=NoRepeat(),max='**'),
           GROUP_NO_2      =SIMP(statut='f',typ=grno,validators=NoRepeat(),max='**'),
           NOEUD_2         =SIMP(statut='f',typ=no  ,validators=NoRepeat(),max='**'),
           CAS_FIGURE      =SIMP(statut='f',typ='TXM',into=("2D","3D","2.5D","1.5D",) ),
           TRANSF_GEOM_2   =SIMP(statut='f',typ=(fonction_sdaster,nappe_sdaster,formule),min=2,max=3,
                fr="2 (ou 3) fonctions fx,fy,fz définissant la transformation géométrique à appliquer"+
                   " aux noeuds du MODELE_2 avant la projection."),
         ),

         TITRE           =SIMP(statut='f',typ='TXM',max='**' ),
         INFO            =SIMP(statut='f',typ='I',defaut=1,into=(1,2)),
)  ;
#& MODIF COMMANDE  DATE 22/06/2005   AUTEUR REZETTE C.REZETTE 
#            CONFIGURATION MANAGEMENT OF EDF VERSION
# ======================================================================
# COPYRIGHT (C) 1991 - 2001  EDF R&D                  WWW.CODE-ASTER.ORG
# THIS PROGRAM IS FREE SOFTWARE; YOU CAN REDISTRIBUTE IT AND/OR MODIFY
# IT UNDER THE TERMS OF THE GNU GENERAL PUBLIC LICENSE AS PUBLISHED BY
# THE FREE SOFTWARE FOUNDATION; EITHER VERSION 2 OF THE LICENSE, OR   
# (AT YOUR OPTION) ANY LATER VERSION.                                 
#
# THIS PROGRAM IS DISTRIBUTED IN THE HOPE THAT IT WILL BE USEFUL, BUT 
# WITHOUT ANY WARRANTY; WITHOUT EVEN THE IMPLIED WARRANTY OF          
# MERCHANTABILITY OR FITNESS FOR A PARTICULAR PURPOSE. SEE THE GNU    
# GENERAL PUBLIC LICENSE FOR MORE DETAILS.                            
#
# YOU SHOULD HAVE RECEIVED A COPY OF THE GNU GENERAL PUBLIC LICENSE   
# ALONG WITH THIS PROGRAM; IF NOT, WRITE TO EDF R&D CODE_ASTER,       
#    1 AVENUE DU GENERAL DE GAULLE, 92141 CLAMART CEDEX, FRANCE.      
# ======================================================================
def matr_asse_gene_prod(MATR_ASSE,MATR_ASSE_GENE,**args):
  if AsType(MATR_ASSE) == matr_asse_depl_r  : return matr_asse_gene_r
  if AsType(MATR_ASSE_GENE) == matr_asse_gene_r  : return matr_asse_gene_r
  if AsType(MATR_ASSE) == matr_asse_depl_c  : return matr_asse_gene_c
  if AsType(MATR_ASSE_GENE) == matr_asse_gene_c  : return matr_asse_gene_c
  raise AsException("type de concept resultat non prevu")

PROJ_MATR_BASE=OPER(nom="PROJ_MATR_BASE",op=  71,sd_prod=matr_asse_gene_prod,
                    fr="Projection d'une matrice assemblée sur une base (modale ou de RITZ)",
                    reentrant='n',
            UIinfo={"groupes":("Matrices/vecteurs",)},
         regles=(UN_PARMI('MATR_ASSE','MATR_ASSE_GENE'),),            
         BASE            =SIMP(statut='o',typ=(mode_meca,base_modale,mode_gene,mode_stat ) ),
         NUME_DDL_GENE   =SIMP(statut='o',typ=nume_ddl_gene ),
         MATR_ASSE       =SIMP(statut='f',typ=(matr_asse_depl_r,matr_asse_depl_c) ),
         MATR_ASSE_GENE  =SIMP(statut='f',typ=(matr_asse_gene_r,matr_asse_gene_c) ),
)  ;

#& MODIF COMMANDE  DATE 19/06/2006   AUTEUR VABHHTS J.PELLET 
#            CONFIGURATION MANAGEMENT OF EDF VERSION
# ======================================================================
# COPYRIGHT (C) 1991 - 2001  EDF R&D                  WWW.CODE-ASTER.ORG
# THIS PROGRAM IS FREE SOFTWARE; YOU CAN REDISTRIBUTE IT AND/OR MODIFY
# IT UNDER THE TERMS OF THE GNU GENERAL PUBLIC LICENSE AS PUBLISHED BY
# THE FREE SOFTWARE FOUNDATION; EITHER VERSION 2 OF THE LICENSE, OR   
# (AT YOUR OPTION) ANY LATER VERSION.                                 
#
# THIS PROGRAM IS DISTRIBUTED IN THE HOPE THAT IT WILL BE USEFUL, BUT 
# WITHOUT ANY WARRANTY; WITHOUT EVEN THE IMPLIED WARRANTY OF          
# MERCHANTABILITY OR FITNESS FOR A PARTICULAR PURPOSE. SEE THE GNU    
# GENERAL PUBLIC LICENSE FOR MORE DETAILS.                            
#
# YOU SHOULD HAVE RECEIVED A COPY OF THE GNU GENERAL PUBLIC LICENSE   
# ALONG WITH THIS PROGRAM; IF NOT, WRITE TO EDF R&D CODE_ASTER,       
#    1 AVENUE DU GENERAL DE GAULLE, 92141 CLAMART CEDEX, FRANCE.      
# ======================================================================
def proj_mesu_modal_prod(MODELE_MESURE,**args):
     vale=MODELE_MESURE['MESURE']
     if  AsType(vale) == dyna_trans   : return tran_gene
     if  AsType(vale) == dyna_harmo   : return harm_gene
     if  AsType(vale) == mode_meca    : return mode_gene
#     if  AsType(vale) == mode_meca_c  : return mode_gene_c
     if  AsType(vale) == base_modale  : return mode_gene
     raise AsException("type de concept resultat non prevu")

PROJ_MESU_MODAL=OPER(nom="PROJ_MESU_MODAL",op= 193,
                     sd_prod=proj_mesu_modal_prod,
                     reentrant='n',
            UIinfo={"groupes":("Résultats et champs",)},
                     fr="Calcul des coordonnees généralisees de mesure experimentale relatives a une base de projection",

         MODELE_CALCUL   =FACT(statut='o',
           MODELE          =SIMP(statut='o',typ=(modele_sdaster) ),
           BASE            =SIMP(statut='o',typ=(mode_meca,base_modale,) ),
                         ),
         MODELE_MESURE   =FACT(statut='o',
           MODELE          =SIMP(statut='o',typ=(modele_sdaster) ),
           MESURE          =SIMP(statut='o',typ=(dyna_trans,dyna_harmo,base_modale,mode_meca,mode_meca_c,) ),
           NOM_CHAM        =SIMP(statut='f',typ='TXM',defaut="DEPL",into=("DEPL","VITE","ACCE","SIEF_NOEU","EPSI_NOEU_DEPL",) ),
                         ),
         CORR_MANU       =FACT(statut='f',max='**',
           regles=(PRESENT_PRESENT('NOEU_CALCUL','NOEU_MESURE'),),
           NOEU_CALCUL     =SIMP(statut='f',typ=no),
           NOEU_MESURE     =SIMP(statut='f',typ=no),
                         ),
         NOM_PARA        =SIMP(statut='f',typ='TXM',max='**'),
         RESOLUTION      =FACT(statut='f',
           METHODE         =SIMP(statut='f',typ='TXM',defaut="LU",into=("LU","SVD",) ),
           b_svd =BLOC(condition="METHODE=='SVD'",
                       EPS=SIMP(statut='f',typ='R',defaut=0. ),
                      ),
           REGUL           =SIMP(statut='f',typ='TXM',defaut="NON",into=("NON","NORM_MIN","TIK_RELA",) ),
           b_regul =BLOC(condition="REGUL!='NON'",
                         regles=(PRESENT_ABSENT('COEF_PONDER','COEF_PONDER_F', ),),
                         COEF_PONDER   =SIMP(statut='f',typ='R',defaut=0.     ,max='**' ),  
                         COEF_PONDER_F =SIMP(statut='f',typ=(fonction_sdaster,nappe_sdaster,formule),max='**' ),
                        ),
             ),

          ); 
#& MODIF COMMANDE  DATE 10/10/2006   AUTEUR MCOURTOI M.COURTOIS 
#            CONFIGURATION MANAGEMENT OF EDF VERSION
# ======================================================================
# COPYRIGHT (C) 1991 - 2001  EDF R&D                  WWW.CODE-ASTER.ORG
# THIS PROGRAM IS FREE SOFTWARE; YOU CAN REDISTRIBUTE IT AND/OR MODIFY
# IT UNDER THE TERMS OF THE GNU GENERAL PUBLIC LICENSE AS PUBLISHED BY
# THE FREE SOFTWARE FOUNDATION; EITHER VERSION 2 OF THE LICENSE, OR   
# (AT YOUR OPTION) ANY LATER VERSION.                                 
#
# THIS PROGRAM IS DISTRIBUTED IN THE HOPE THAT IT WILL BE USEFUL, BUT 
# WITHOUT ANY WARRANTY; WITHOUT EVEN THE IMPLIED WARRANTY OF          
# MERCHANTABILITY OR FITNESS FOR A PARTICULAR PURPOSE. SEE THE GNU    
# GENERAL PUBLIC LICENSE FOR MORE DETAILS.                            
#
# YOU SHOULD HAVE RECEIVED A COPY OF THE GNU GENERAL PUBLIC LICENSE   
# ALONG WITH THIS PROGRAM; IF NOT, WRITE TO EDF R&D CODE_ASTER,       
#    1 AVENUE DU GENERAL DE GAULLE, 92141 CLAMART CEDEX, FRANCE.      
# ======================================================================
PROJ_SPEC_BASE=OPER(nom="PROJ_SPEC_BASE",op= 146,sd_prod=table_fonction,reentrant='n',
            UIinfo={"groupes":("Matrices/vecteurs",)},
            fr="Projecter un ou plusieurs spectres de turbulence sur une (ou plusieurs) base(s) modale(s) ",
      regles=(UN_PARMI('BASE_ELAS_FLUI','MODE_MECA','CHAM_NO'),
              ENSEMBLE('FREQ_INIT','FREQ_FIN','NB_POIN'),),
         SPEC_TURB       =SIMP(statut='o',typ=spectre_sdaster,validators=NoRepeat(),max='**' ),
         TOUT_CMP        =SIMP(statut='f',typ='TXM',defaut="OUI",into=("OUI","NON")),
         BASE_ELAS_FLUI  =SIMP(statut='f',typ=melasflu_sdaster ),
         MODE_MECA       =SIMP(statut='f',typ=mode_meca ),
         CHAM_NO         =SIMP(statut='f',typ=cham_no_sdaster),
         FREQ_INIT       =SIMP(statut='f',typ='R',val_min=0.E+0 ),  
         FREQ_FIN        =SIMP(statut='f',typ='R',val_min=0.E+0 ),  
         NB_POIN         =SIMP(statut='f',typ='I' ),  
         OPTION          =SIMP(statut='f',typ='TXM',defaut="TOUT",into=("TOUT","DIAG")),
         GROUP_MA        =SIMP(statut='f',typ=grma),
#  Quel est le type attendu derriere  MODELE_INTERFACE         
         MODELE_INTERFACE=SIMP(statut='f',typ=modele_sdaster),
         VECT_X          =SIMP(statut='f',typ='R',min=3,max=3 ),  
         VECT_Y          =SIMP(statut='f',typ='R',min=3,max=3 ),  
         ORIG_AXE        =SIMP(statut='f',typ='R',min=3,max=3 ),  
         TITRE           =SIMP(statut='f',typ='TXM',max='**' ),  
)  ;
#& MODIF COMMANDE  DATE 21/02/2006   AUTEUR REZETTE C.REZETTE 
#            CONFIGURATION MANAGEMENT OF EDF VERSION
# ======================================================================
# COPYRIGHT (C) 1991 - 2001  EDF R&D                  WWW.CODE-ASTER.ORG
# THIS PROGRAM IS FREE SOFTWARE; YOU CAN REDISTRIBUTE IT AND/OR MODIFY
# IT UNDER THE TERMS OF THE GNU GENERAL PUBLIC LICENSE AS PUBLISHED BY
# THE FREE SOFTWARE FOUNDATION; EITHER VERSION 2 OF THE LICENSE, OR   
# (AT YOUR OPTION) ANY LATER VERSION.                                 
#
# THIS PROGRAM IS DISTRIBUTED IN THE HOPE THAT IT WILL BE USEFUL, BUT 
# WITHOUT ANY WARRANTY; WITHOUT EVEN THE IMPLIED WARRANTY OF          
# MERCHANTABILITY OR FITNESS FOR A PARTICULAR PURPOSE. SEE THE GNU    
# GENERAL PUBLIC LICENSE FOR MORE DETAILS.                            
#
# YOU SHOULD HAVE RECEIVED A COPY OF THE GNU GENERAL PUBLIC LICENSE   
# ALONG WITH THIS PROGRAM; IF NOT, WRITE TO EDF R&D CODE_ASTER,       
#    1 AVENUE DU GENERAL DE GAULLE, 92141 CLAMART CEDEX, FRANCE.      
# ======================================================================

PROJ_VECT_BASE=OPER(nom="PROJ_VECT_BASE",op=  72,sd_prod=vect_asse_gene,
                    fr="Projection d'un vecteur assemblé sur une base (modale ou de RITZ)",
                    reentrant='n',
            UIinfo={"groupes":("Matrices/vecteurs",)},
         regles=(UN_PARMI('VECT_ASSE','VECT_ASSE_GENE'),),              
         BASE            =SIMP(statut='o',typ=(mode_meca,base_modale,mode_gene,mode_stat ) ),
         NUME_DDL_GENE   =SIMP(statut='o',typ=nume_ddl_gene ),
         TYPE_VECT       =SIMP(statut='f',typ='TXM',defaut="FORC"),
         VECT_ASSE       =SIMP(statut='f',typ=cham_no_sdaster),
         VECT_ASSE_GENE  =SIMP(statut='f',typ=vect_asse_gene ),
)  ;
#& MODIF COMMANDE  DATE 22/08/2006   AUTEUR MASSIN P.MASSIN 
#            CONFIGURATION MANAGEMENT OF EDF VERSION
# ======================================================================
# COPYRIGHT (C) 1991 - 2006  EDF R&D                  WWW.CODE-ASTER.ORG
# THIS PROGRAM IS FREE SOFTWARE; YOU CAN REDISTRIBUTE IT AND/OR MODIFY  
# IT UNDER THE TERMS OF THE GNU GENERAL PUBLIC LICENSE AS PUBLISHED BY  
# THE FREE SOFTWARE FOUNDATION; EITHER VERSION 2 OF THE LICENSE, OR     
# (AT YOUR OPTION) ANY LATER VERSION.                                                  
#                                                                       
# THIS PROGRAM IS DISTRIBUTED IN THE HOPE THAT IT WILL BE USEFUL, BUT   
# WITHOUT ANY WARRANTY; WITHOUT EVEN THE IMPLIED WARRANTY OF            
# MERCHANTABILITY OR FITNESS FOR A PARTICULAR PURPOSE. SEE THE GNU      
# GENERAL PUBLIC LICENSE FOR MORE DETAILS.                              
#                                                                       
# YOU SHOULD HAVE RECEIVED A COPY OF THE GNU GENERAL PUBLIC LICENSE     
# ALONG WITH THIS PROGRAM; IF NOT, WRITE TO EDF R&D CODE_ASTER,         
#    1 AVENUE DU GENERAL DE GAULLE, 92141 CLAMART CEDEX, FRANCE.        
# ======================================================================

PROPA_XFEM=OPER(nom="PROPA_XFEM",op=10,sd_prod=fiss_xfem,reentrant='n',
                UIinfo={"groupes":("Modélisation",)},
                fr="Propagation de fissure avec X-FEM",
    
    MODELE        =SIMP(statut='o',typ=modele_sdaster),
        
    TABLE         =SIMP(statut='o',typ=table_sdaster),

    LOI_PROPA     =FACT(statut='o',max=01,
      LOI            =SIMP(statut='o',typ='TXM',into=("PARIS",),defaut="PARIS"),
      b_paris        =BLOC( condition = "LOI=='PARIS'",
        C            =SIMP(statut='o',typ='R',),
        M            =SIMP(statut='o',typ='R',),),
            ),
            
    RAYON          =SIMP(statut='o',typ='R',),
          
    METHODE        =SIMP(statut='f',typ='TXM',into=("SIMPLEXE","UPWIND",),defaut="COEFF_POSITIF"),

#    RUNGE_KUTTA    =SIMP(statut='f',typ='I',into=("1","2",),defaut=1),

    INFO           =SIMP(statut='f',typ='I',defaut= 1,into=(1,2) ),
)  ;
#& MODIF COMMANDE  DATE 03/01/2006   AUTEUR REZETTE C.REZETTE 
#            CONFIGURATION MANAGEMENT OF EDF VERSION
# ======================================================================
# COPYRIGHT (C) 1991 - 2001  EDF R&D                  WWW.CODE-ASTER.ORG
# THIS PROGRAM IS FREE SOFTWARE; YOU CAN REDISTRIBUTE IT AND/OR MODIFY
# IT UNDER THE TERMS OF THE GNU GENERAL PUBLIC LICENSE AS PUBLISHED BY
# THE FREE SOFTWARE FOUNDATION; EITHER VERSION 2 OF THE LICENSE, OR   
# (AT YOUR OPTION) ANY LATER VERSION.                                 
#
# THIS PROGRAM IS DISTRIBUTED IN THE HOPE THAT IT WILL BE USEFUL, BUT 
# WITHOUT ANY WARRANTY; WITHOUT EVEN THE IMPLIED WARRANTY OF          
# MERCHANTABILITY OR FITNESS FOR A PARTICULAR PURPOSE. SEE THE GNU    
# GENERAL PUBLIC LICENSE FOR MORE DETAILS.                            
#
# YOU SHOULD HAVE RECEIVED A COPY OF THE GNU GENERAL PUBLIC LICENSE   
# ALONG WITH THIS PROGRAM; IF NOT, WRITE TO EDF R&D CODE_ASTER,       
#    1 AVENUE DU GENERAL DE GAULLE, 92141 CLAMART CEDEX, FRANCE.      
# ======================================================================
RECA_WEIBULL=OPER(nom="RECA_WEIBULL",op= 197,sd_prod=table_sdaster,
                     fr="Recaler les paramètres du modèle de WEIBULL sur des données expérimentales",reentrant='n',
            UIinfo={"groupes":("Post traitements",)},
         LIST_PARA       =SIMP(statut='o',typ='TXM',validators=NoRepeat(),max=2,into=("SIGM_REFE","M",) ),
         RESU            =FACT(statut='o',max='**',
           regles=(EXCLUS('TOUT_ORDRE','NUME_ORDRE','INST','LIST_INST',),
                   AU_MOINS_UN('TOUT','GROUP_MA','MAILLE', ),),
           EVOL_NOLI       =SIMP(statut='o',typ=(evol_noli) ),
           MODELE          =SIMP(statut='o',typ=(modele_sdaster) ),
           CHAM_MATER      =SIMP(statut='o',typ=(cham_mater) ),
           TEMPE           =SIMP(statut='f',typ='R' ),
           LIST_INST_RUPT  =SIMP(statut='o',typ='R',validators=NoRepeat(),max='**' ),
           TOUT_ORDRE      =SIMP(statut='f',typ='TXM',into=("OUI",) ),
           NUME_ORDRE      =SIMP(statut='f',typ='I',validators=NoRepeat(),max='**' ),
           INST            =SIMP(statut='f',typ='R',validators=NoRepeat(),max='**' ),
           LIST_INST       =SIMP(statut='f',typ=(listr8_sdaster) ),
           TOUT            =SIMP(statut='f',typ='TXM',into=("OUI",) ),
           GROUP_MA        =SIMP(statut='f',typ=grma,validators=NoRepeat(),max='**'),
           MAILLE          =SIMP(statut='f',typ=ma  ,validators=NoRepeat(),max='**'),
           COEF_MULT       =SIMP(statut='f',typ='R',defaut= 1.E0 ),
                         ),
         OPTION          =SIMP(statut='f',typ='TXM',defaut="SIGM_ELGA",into=("SIGM_ELGA","SIGM_ELMOY",) ),
         CORR_PLAST      =SIMP(statut='f',typ='TXM',defaut="NON",into=("OUI","NON",) ),
         METHODE         =SIMP(statut='f',typ='TXM',defaut="MAXI_VRAI",into=("MAXI_VRAI","REGR_LINE",) ),
         INCO_GLOB_RELA  =SIMP(statut='f',typ='R',defaut= 1.0E-3 ),
         ITER_GLOB_MAXI  =SIMP(statut='f',typ='I',defaut= 10 ),
         INFO            =SIMP(statut='f',typ='I',defaut= 1,into=( 1 , 2 ,) ),
                       )  ;
#& MODIF COMMANDE  DATE 07/11/2006   AUTEUR DURAND C.DURAND 
#            CONFIGURATION MANAGEMENT OF EDF VERSION
# ======================================================================
# COPYRIGHT (C) 1991 - 2001  EDF R&D                  WWW.CODE-ASTER.ORG
# THIS PROGRAM IS FREE SOFTWARE; YOU CAN REDISTRIBUTE IT AND/OR MODIFY
# IT UNDER THE TERMS OF THE GNU GENERAL PUBLIC LICENSE AS PUBLISHED BY
# THE FREE SOFTWARE FOUNDATION; EITHER VERSION 2 OF THE LICENSE, OR
# (AT YOUR OPTION) ANY LATER VERSION.
#
# THIS PROGRAM IS DISTRIBUTED IN THE HOPE THAT IT WILL BE USEFUL, BUT
# WITHOUT ANY WARRANTY; WITHOUT EVEN THE IMPLIED WARRANTY OF
# MERCHANTABILITY OR FITNESS FOR A PARTICULAR PURPOSE. SEE THE GNU
# GENERAL PUBLIC LICENSE FOR MORE DETAILS.
#
# YOU SHOULD HAVE RECEIVED A COPY OF THE GNU GENERAL PUBLIC LICENSE
# ALONG WITH THIS PROGRAM; IF NOT, WRITE TO EDF R&D CODE_ASTER,
#    1 AVENUE DU GENERAL DE GAULLE, 92141 CLAMART CEDEX, FRANCE.
# ======================================================================
# RESPONSABLE MCOURTOI M.COURTOIS
def recu_fonction_prod(RESULTAT=None,TABLE=None,RESU_GENE=None,
                       BASE_ELAS_FLUI=None,CHAM_GD=None,NAPPE=None,
                       NOM_PARA_TABL=None,**args):
   if AsType(RESULTAT)  == dyna_harmo or \
      AsType(RESU_GENE) == harm_gene or \
      (TABLE != None and NOM_PARA_TABL == "FONCTION_C"):
      return fonction_c
   else:
      return fonction_sdaster

RECU_FONCTION=OPER(nom="RECU_FONCTION",op=90,sd_prod=recu_fonction_prod,
                   fr="Extraire sous forme d'une fonction, l'évolution d'une grandeur en fonction d'une autre",
                   reentrant='f',
            UIinfo={"groupes":("Fonction",)},
         regles=(UN_PARMI('CHAM_GD','RESULTAT','RESU_GENE','TABLE','BASE_ELAS_FLUI','NAPPE'),),

         CHAM_GD         =SIMP(statut='f',typ=(cham_no_sdaster,
                                               cham_elem,),),
         RESULTAT        =SIMP(statut='f',typ=(evol_elas,dyna_trans,evol_noli,evol_ther,dyna_harmo ) ),
         RESU_GENE       =SIMP(statut='f',typ=(tran_gene, mode_gene, harm_gene)),
         TABLE           =SIMP(statut='f',typ=(table_sdaster,table_fonction)),
         BASE_ELAS_FLUI  =SIMP(statut='f',typ=melasflu_sdaster),
         NAPPE           =SIMP(statut='f',typ=nappe_sdaster),

# ======= SENSIBILITE =================================================
         b_sensibilite   =BLOC(condition="RESULTAT != None",
                                 fr="Définition des paramètres de sensibilité",
                                 ang="Definition of sensitivity parameters",
           regles=(CONCEPT_SENSIBLE('SEPARE'), REUSE_SENSIBLE(),
                   DERIVABLE('RESULTAT'),),
           SENSIBILITE     =SIMP(statut='f',typ=(para_sensi,theta_geom),validators=NoRepeat(),max='**',
                                   fr="Liste des paramètres de sensibilité.",
                                   ang="List of sensitivity parameters"),),
# ======= ACCES A LA SD RESULTAT =================================================
         b_acces = BLOC ( condition = "(RESULTAT != None) or (RESU_GENE != None)",
                          fr="acces a une SD résultat",
# on ne peut pas mettre de regles, le défaut TOUT_ORDRE est pris en compte dans le fortran
           TOUT_ORDRE      =SIMP(statut='f',typ='TXM',into=("OUI",) ),
           NUME_ORDRE      =SIMP(statut='f',typ='I',validators=NoRepeat(),max='**'),
           LIST_ORDRE      =SIMP(statut='f',typ=listis_sdaster ),
           TOUT_INST       =SIMP(statut='f',typ='TXM',into=("OUI",) ),
           INST            =SIMP(statut='f',typ='R',validators=NoRepeat(),max='**'),
           LIST_INST       =SIMP(statut='f',typ=listr8_sdaster ),
           FREQ            =SIMP(statut='f',typ='R',validators=NoRepeat(),max='**'),
           LIST_FREQ       =SIMP(statut='f',typ=listr8_sdaster ),
           NUME_MODE       =SIMP(statut='f',typ='I',validators=NoRepeat(),max='**'),
           b_prec = BLOC ( condition = "(INST != None) or (LIST_INST != None) or (FREQ != None) or (LIST_FREQ != None)",
             PRECISION       =SIMP(statut='f',typ='R',defaut= 1.E-3 ),
             CRITERE         =SIMP(statut='f',typ='TXM',defaut="RELATIF",into=("RELATIF","ABSOLU") ),
             INTERP_NUME     =SIMP(statut='f',typ='TXM',into=("NON","LIN") ),
           ),
         ),
# ======= BASE_ELAS_FLUI =================================================
         b_base_elas_flui = BLOC ( condition = "BASE_ELAS_FLUI != None",
                                   fr="Récupération de la fonction à partir d un concept melasflu",
           regles=(UN_PARMI('TOUT_ORDRE','NUME_ORDRE'),),
           TOUT_ORDRE      =SIMP(statut='f',typ='TXM',into=("OUI",) ),
           NUME_ORDRE      =SIMP(statut='f',typ='I',validators=NoRepeat(),max='**'),
           NUME_MODE       =SIMP(statut='o',typ='I' ),
           PARA_X          =SIMP(statut='o',typ='TXM',into=("VITE_FLU",) ),
           PARA_Y          =SIMP(statut='o',typ='TXM',into=("FREQ","AMOR") ),
         ),

# ======= TABLE =================================================
         b_table = BLOC ( condition = "TABLE != None",
                          fr="Récupération de la fonction à partir d un concept table",
                          regles=(UN_PARMI('PARA_X','NOM_PARA_TABL'),
                                  PRESENT_PRESENT('PARA_X','PARA_Y'),),
           PARA_X        = SIMP(statut='f',typ='TXM',
                                 fr="1ère colonne de la table qui définit la fonction à récupérer", ),
           PARA_Y        = SIMP(statut='f',typ='TXM',
                                 fr="2ème colonne de la table qui définit la fonction à récupérer", ),
           #b_tabl_fonc = BLOC(condition = "AsType(TABLE) == table_fonction",
           NOM_PARA_TABL = SIMP(statut='f',typ='TXM',into=("FONCTION","FONCTION_C"),
                                fr="Nom du paramètre de la table contenant la fonction" ),
           #),

           FILTRE        = FACT(statut='f',max='**',
              NOM_PARA        =SIMP(statut='o',typ='TXM' ),
              CRIT_COMP       =SIMP(statut='f',typ='TXM',defaut="EQ",
                                    into=("EQ","LT","GT","NE","LE","GE","VIDE",
                                          "NON_VIDE","MAXI","ABS_MAXI","MINI","ABS_MINI") ),
              b_vale          =BLOC(condition = "(CRIT_COMP in ('EQ','NE','GT','LT','GE','LE'))",
                 regles=(UN_PARMI('VALE','VALE_I','VALE_K','VALE_C',),),
                 VALE            =SIMP(statut='f',typ='R' ),
                 VALE_I          =SIMP(statut='f',typ='I' ),
                 VALE_C          =SIMP(statut='f',typ='C' ),
                 VALE_K          =SIMP(statut='f',typ='TXM' ),),

              CRITERE         =SIMP(statut='f',typ='TXM',defaut="RELATIF",into=("RELATIF","ABSOLU") ),
              PRECISION       =SIMP(statut='f',typ='R',defaut= 1.E-3 ),
           ),
         ),

# ======= RESULTAT =================================================
         b_resu = BLOC ( condition = "RESULTAT != None", fr="Opérandes en cas de RESULTAT",
                         regles=(UN_PARMI('NOM_CHAM','NOM_PARA_RESU'),),
           NOM_CHAM        =SIMP(statut='f',typ='TXM',into=C_NOM_CHAM_INTO()),
           NOM_PARA_RESU   =SIMP(statut='f',typ='TXM' ),
           b_cham = BLOC ( condition = "NOM_CHAM != None",
                           regles=(AU_MOINS_UN('MAILLE','GROUP_MA','GROUP_NO','NOEUD'),
                                   PRESENT_ABSENT('POINT','NOEUD','GROUP_NO'),
                                   PRESENT_ABSENT('SOUS_POINT','NOEUD','GROUP_NO'),
                                   EXCLUS('GROUP_MA','MAILLE'),
                                   EXCLUS('GROUP_NO','NOEUD'),),
             NOM_CMP         =SIMP(statut='o',typ='TXM' ),
             MAILLE          =SIMP(statut='f',typ=ma),
             GROUP_MA        =SIMP(statut='f',typ=grma),
             NOEUD           =SIMP(statut='f',typ=no),
             GROUP_NO        =SIMP(statut='f',typ=grno),
             POINT           =SIMP(statut='f',typ='I' ),
             SOUS_POINT      =SIMP(statut='f',typ='I' ),
           ),
         ),

# ======= RESU_GENE =================================================
         b_tran_gene = BLOC ( condition = "AsType(RESU_GENE) == tran_gene",
                              fr="Récupération d'une fonction à partir d un concept TRAN_GENE",
                              regles=(UN_PARMI('NOM_CHAM','NOEUD_CHOC','GROUP_NO_CHOC'),),
             NOM_CHAM        =SIMP(statut='f',typ='TXM',into=("DEPL","VITE","ACCE","PTEM") ),
             NOEUD_CHOC      =SIMP(statut='f',typ=no),
             GROUP_NO_CHOC   =SIMP(statut='f',typ=grno),
           b_cham = BLOC ( condition = "(NOM_CHAM=='DEPL') or (NOM_CHAM=='VITE') or (NOM_CHAM=='ACCE')",
                           regles=(UN_PARMI('GROUP_NO','NOEUD'),
                                   EXCLUS('MULT_APPUI','CORR_STAT'),),
             NOM_CMP         =SIMP(statut='o',typ='TXM' ),
             NOEUD           =SIMP(statut='f',typ=no),
             GROUP_NO        =SIMP(statut='f',typ=grno),
             MULT_APPUI      =SIMP(statut='f',typ='TXM',into=("OUI",) ),
             CORR_STAT       =SIMP(statut='f',typ='TXM',into=("OUI",) ),
             ACCE_MONO_APPUI =SIMP(statut='f',typ=(fonction_sdaster,formule)),
           ),
           b_choc = BLOC ( condition = "(NOEUD_CHOC != None) or (GROUP_NO_CHOC != None)",
                           regles=(PRESENT_PRESENT('SOUS_STRUC','INTITULE'),),
             PARA_X          =SIMP(statut='o',typ='TXM',
                              into=("INST","FN","FT1","FT2","VN","VT1","VT2","DXLOC","DYLOC","DZLOC") ),
             PARA_Y          =SIMP(statut='o',typ='TXM',
                              into=("INST","FN","FT1","FT2","VN","VT1","VT2","DXLOC","DYLOC","DZLOC") ),
             LIST_PARA       =SIMP(statut='f',typ=listr8_sdaster ),
             INTITULE        =SIMP(statut='f',typ='TXM' ),
             SOUS_STRUC      =SIMP(statut='f',typ='TXM' ),
           ),
         ),
         b_harm_gene = BLOC ( condition = "AsType(RESU_GENE)==harm_gene",
                              fr="Récupération d'une fonction à partir d un concept HARM_GENE",
                              regles=(UN_PARMI('NOM_CHAM','NOM_PARA_RESU'),),
             NOM_CHAM        =SIMP(statut='f',typ='TXM',into=C_NOM_CHAM_INTO()),
             NOM_PARA_RESU   =SIMP(statut='f',typ='TXM' ),
           b_cham = BLOC ( condition = "NOM_CHAM != None",
                           regles=(UN_PARMI('NUME_CMP_GENE','NOM_CMP'),),
             NUME_CMP_GENE   =SIMP(statut='f',typ='I' ),
             NOM_CMP         =SIMP(statut='f',typ='TXM' ),
             b_cmp = BLOC ( condition = "NOM_CMP != None",
                            regles=(UN_PARMI('NOEUD','GROUP_NO'),),
               NOEUD         =SIMP(statut='f',typ=no),
               GROUP_NO      =SIMP(statut='f',typ=grno),
             ),
           ),
         ),
         b_mode_gene = BLOC ( condition = "AsType(RESU_GENE)==mode_gene",
                              fr="Récupération d'une fonction à partir d un concept MODE_GENE",
                              regles=(UN_PARMI('NOM_CHAM','NOM_PARA_RESU'),),
             NOM_CHAM        =SIMP(statut='f',typ='TXM',into=C_NOM_CHAM_INTO()),
             NOM_PARA_RESU   =SIMP(statut='f',typ='TXM' ),
           b_cham = BLOC ( condition = "NOM_CHAM != None",
                           regles=(UN_PARMI('NUME_CMP_GENE','NOM_CMP'),),
             NUME_CMP_GENE   =SIMP(statut='f',typ='I' ),
             NOM_CMP         =SIMP(statut='f',typ='TXM' ),
             b_cmp = BLOC ( condition = "NOM_CMP != None",
                            regles=(UN_PARMI('NOEUD','GROUP_NO'),
                                    UN_PARMI('SQUELETTE','SOUS_STRUC'),),
               NOEUD         =SIMP(statut='f',typ=no),
               GROUP_NO      =SIMP(statut='f',typ=grno),
               SQUELETTE     =SIMP(statut='f',typ=squelette ),
               SOUS_STRUC    =SIMP(statut='f',typ='TXM' ),  
             ),
           ),
         ),

# ======= CHAM_GD =================================================
         b_cham_gd = BLOC ( condition = "(CHAM_GD != None)", fr="Opérandes en cas de CHAM_GD",
                            regles=(AU_MOINS_UN('MAILLE','GROUP_MA','GROUP_NO','NOEUD'),
                                    PRESENT_ABSENT('POINT','NOEUD','GROUP_NO'),
                                    PRESENT_ABSENT('SOUS_POINT','NOEUD','GROUP_NO'),
                                    EXCLUS('GROUP_MA','MAILLE'),
                                    EXCLUS('GROUP_NO','NOEUD'),),
           NOM_CMP         =SIMP(statut='o',typ='TXM' ),
           MAILLE          =SIMP(statut='f',typ=ma),
           GROUP_MA        =SIMP(statut='f',typ=grma),
           NOEUD           =SIMP(statut='f',typ=no),
           GROUP_NO        =SIMP(statut='f',typ=grno),
           POINT           =SIMP(statut='f',typ='I' ),
           SOUS_POINT      =SIMP(statut='f',typ='I' ),
         ),

# ======= NAPPE =================================================
         b_nappe = BLOC ( condition = "(NAPPE != None)", fr="Opérandes en cas de NAPPE",
         VALE_PARA_FONC  =SIMP(statut='o',typ='R' ),
         PRECISION       =SIMP(statut='f',typ='R',defaut= 1.E-3 ),
         CRITERE         =SIMP(statut='f',typ='TXM',defaut="RELATIF",into=("RELATIF","ABSOLU") ),
         ),

# ======= SURCHARGE DES ATTRIBUTS =================================================
         NOM_PARA        =SIMP(statut='f',typ='TXM', into=C_PARA_FONCTION() ),
         NOM_RESU        =SIMP(statut='f',typ='TXM' ),
         INTERPOL        =SIMP(statut='f',typ='TXM',max=2,into=("NON","LIN","LOG") ),
         PROL_DROITE     =SIMP(statut='f',typ='TXM',into=("CONSTANT","LINEAIRE","EXCLU") ),
         PROL_GAUCHE     =SIMP(statut='f',typ='TXM',into=("CONSTANT","LINEAIRE","EXCLU") ),

         TITRE           =SIMP(statut='f',typ='TXM',max='**'),
         INFO            =SIMP(statut='f',typ='I',defaut= 1,into=( 1 , 2 ) ),
)  ;
#& MODIF COMMANDE  DATE 21/02/2006   AUTEUR REZETTE C.REZETTE 
#            CONFIGURATION MANAGEMENT OF EDF VERSION
# ======================================================================
# COPYRIGHT (C) 1991 - 2001  EDF R&D                  WWW.CODE-ASTER.ORG
# THIS PROGRAM IS FREE SOFTWARE; YOU CAN REDISTRIBUTE IT AND/OR MODIFY
# IT UNDER THE TERMS OF THE GNU GENERAL PUBLIC LICENSE AS PUBLISHED BY
# THE FREE SOFTWARE FOUNDATION; EITHER VERSION 2 OF THE LICENSE, OR   
# (AT YOUR OPTION) ANY LATER VERSION.                                 
#
# THIS PROGRAM IS DISTRIBUTED IN THE HOPE THAT IT WILL BE USEFUL, BUT 
# WITHOUT ANY WARRANTY; WITHOUT EVEN THE IMPLIED WARRANTY OF          
# MERCHANTABILITY OR FITNESS FOR A PARTICULAR PURPOSE. SEE THE GNU    
# GENERAL PUBLIC LICENSE FOR MORE DETAILS.                            
#
# YOU SHOULD HAVE RECEIVED A COPY OF THE GNU GENERAL PUBLIC LICENSE   
# ALONG WITH THIS PROGRAM; IF NOT, WRITE TO EDF R&D CODE_ASTER,       
#    1 AVENUE DU GENERAL DE GAULLE, 92141 CLAMART CEDEX, FRANCE.      
# ======================================================================
RECU_GENE=OPER(nom="RECU_GENE",op=  76,sd_prod=vect_asse_gene,reentrant='n',
            UIinfo={"groupes":("Résultats et champs",)},
               fr="Extraire d'un champ de grandeur (déplacements, vitesses ou accélérations) à partir de résultats"
                  +" en coordonnées généralisées",
         RESU_GENE       =SIMP(statut='o',typ=tran_gene ),
         INST            =SIMP(statut='o',typ='R' ),
         NOM_CHAM        =SIMP(statut='f',typ='TXM',defaut="DEPL",into=("DEPL","VITE","ACCE") ),
         INTERPOL        =SIMP(statut='f',typ='TXM',defaut="NON",into=("NON","LIN") ),
         CRITERE         =SIMP(statut='f',typ='TXM',defaut="RELATIF" ,into=("ABSOLU","RELATIF") ),
         PRECISION       =SIMP(statut='f',typ='R',defaut= 1.E-3 ),
)  ;
#& MODIF COMMANDE  DATE 22/06/2005   AUTEUR REZETTE C.REZETTE 
#            CONFIGURATION MANAGEMENT OF EDF VERSION
# ======================================================================
# COPYRIGHT (C) 1991 - 2001  EDF R&D                  WWW.CODE-ASTER.ORG
# THIS PROGRAM IS FREE SOFTWARE; YOU CAN REDISTRIBUTE IT AND/OR MODIFY
# IT UNDER THE TERMS OF THE GNU GENERAL PUBLIC LICENSE AS PUBLISHED BY
# THE FREE SOFTWARE FOUNDATION; EITHER VERSION 2 OF THE LICENSE, OR   
# (AT YOUR OPTION) ANY LATER VERSION.                                 
#
# THIS PROGRAM IS DISTRIBUTED IN THE HOPE THAT IT WILL BE USEFUL, BUT 
# WITHOUT ANY WARRANTY; WITHOUT EVEN THE IMPLIED WARRANTY OF          
# MERCHANTABILITY OR FITNESS FOR A PARTICULAR PURPOSE. SEE THE GNU    
# GENERAL PUBLIC LICENSE FOR MORE DETAILS.                            
#
# YOU SHOULD HAVE RECEIVED A COPY OF THE GNU GENERAL PUBLIC LICENSE   
# ALONG WITH THIS PROGRAM; IF NOT, WRITE TO EDF R&D CODE_ASTER,       
#    1 AVENUE DU GENERAL DE GAULLE, 92141 CLAMART CEDEX, FRANCE.      
# ======================================================================
# RESPONSABLE VABHHTS J.PELLET
RECU_TABLE=OPER(nom="RECU_TABLE",op= 174,sd_prod=table_sdaster,
         fr="Récupérer dans une table les valeurs d'un paramètre d'une SD Résultat ou d'extraire une table contenue"
            +" dans une autre SD pour celles qui le permettent",
         UIinfo={"groupes":("Résultats et champs",)},reentrant='n',
         CO              =SIMP(statut='o',typ=assd),
         regles=(UN_PARMI('NOM_TABLE','NOM_PARA')),
         NOM_TABLE       =SIMP(statut='f',typ='TXM' ),
         NOM_PARA        =SIMP(statut='f',typ='TXM',max='**'),  
         TITRE           =SIMP(statut='f',typ='TXM',max='**'),  
)  ;
#& MODIF COMMANDE  DATE 21/02/2006   AUTEUR REZETTE C.REZETTE 
#            CONFIGURATION MANAGEMENT OF EDF VERSION
# ======================================================================
# COPYRIGHT (C) 1991 - 2001  EDF R&D                  WWW.CODE-ASTER.ORG
# THIS PROGRAM IS FREE SOFTWARE; YOU CAN REDISTRIBUTE IT AND/OR MODIFY
# IT UNDER THE TERMS OF THE GNU GENERAL PUBLIC LICENSE AS PUBLISHED BY
# THE FREE SOFTWARE FOUNDATION; EITHER VERSION 2 OF THE LICENSE, OR   
# (AT YOUR OPTION) ANY LATER VERSION.                                 
#
# THIS PROGRAM IS DISTRIBUTED IN THE HOPE THAT IT WILL BE USEFUL, BUT 
# WITHOUT ANY WARRANTY; WITHOUT EVEN THE IMPLIED WARRANTY OF          
# MERCHANTABILITY OR FITNESS FOR A PARTICULAR PURPOSE. SEE THE GNU    
# GENERAL PUBLIC LICENSE FOR MORE DETAILS.                            
#
# YOU SHOULD HAVE RECEIVED A COPY OF THE GNU GENERAL PUBLIC LICENSE   
# ALONG WITH THIS PROGRAM; IF NOT, WRITE TO EDF R&D CODE_ASTER,       
#    1 AVENUE DU GENERAL DE GAULLE, 92141 CLAMART CEDEX, FRANCE.      
# ======================================================================

RESO_GRAD=OPER(nom="RESO_GRAD",op=  84,sd_prod=cham_no_sdaster,
               fr="Résolution d'un système linéaire par la méthode du gradient conjugué préconditionné",
               reentrant='f',
            UIinfo={"groupes":("Résolution",)},
         MATR_ASSE       =SIMP(statut='o',typ=(matr_asse_depl_r,matr_asse_temp_r,matr_asse_pres_r ) ),
         CHAM_NO         =SIMP(statut='o',typ=cham_no_sdaster),
         CHAM_CINE       =SIMP(statut='f',typ=cham_no_sdaster),
         MATR_FACT       =SIMP(statut='f',typ=(matr_asse_depl_r,matr_asse_temp_r,matr_asse_pres_r ) ),
         NMAX_ITER       =SIMP(statut='f',typ='I',defaut= 0 ),  
         REPRISE         =SIMP(statut='f',typ='TXM',defaut="NON",into=("OUI","NON") ),
         RESI_RELA       =SIMP(statut='f',typ='R',defaut= 1E-6 ),  
         INFO            =SIMP(statut='f',typ='I',into=(1,2) ),
)  ;
#& MODIF COMMANDE  DATE 21/02/2006   AUTEUR REZETTE C.REZETTE 
#            CONFIGURATION MANAGEMENT OF EDF VERSION
# ======================================================================
# COPYRIGHT (C) 1991 - 2001  EDF R&D                  WWW.CODE-ASTER.ORG
# THIS PROGRAM IS FREE SOFTWARE; YOU CAN REDISTRIBUTE IT AND/OR MODIFY
# IT UNDER THE TERMS OF THE GNU GENERAL PUBLIC LICENSE AS PUBLISHED BY
# THE FREE SOFTWARE FOUNDATION; EITHER VERSION 2 OF THE LICENSE, OR
# (AT YOUR OPTION) ANY LATER VERSION.
#
# THIS PROGRAM IS DISTRIBUTED IN THE HOPE THAT IT WILL BE USEFUL, BUT
# WITHOUT ANY WARRANTY; WITHOUT EVEN THE IMPLIED WARRANTY OF
# MERCHANTABILITY OR FITNESS FOR A PARTICULAR PURPOSE. SEE THE GNU
# GENERAL PUBLIC LICENSE FOR MORE DETAILS.
#
# YOU SHOULD HAVE RECEIVED A COPY OF THE GNU GENERAL PUBLIC LICENSE
# ALONG WITH THIS PROGRAM; IF NOT, WRITE TO EDF R&D CODE_ASTER,
#    1 AVENUE DU GENERAL DE GAULLE, 92141 CLAMART CEDEX, FRANCE.
# ======================================================================
# RESPONSABLE VABHHTS J.PELLET

RESO_LDLT=OPER(nom="RESO_LDLT",op=15,sd_prod=cham_no_sdaster,reentrant='f',
               fr="Résoudre par méthode directe un système d'équations linéaires préalablement factorisé par FACT_LDLT",
            UIinfo={"groupes":("Résolution",)},
         MATR_FACT       =SIMP(statut='o',typ=(matr_asse_depl_r,matr_asse_depl_c,matr_asse_temp_r,
                                               matr_asse_temp_c,matr_asse_pres_r,matr_asse_pres_c) ),
         CHAM_NO         =SIMP(statut='o',typ=cham_no_sdaster),
         CHAM_CINE       =SIMP(statut='f',typ=cham_no_sdaster),
         # RESI_RELA : précision utilisée si SOLVEUR=MUMPS
         RESI_RELA       =SIMP(statut='f',typ='R',defaut=1.e-6),
         TITRE           =SIMP(statut='f',typ='TXM',max='**'),
         INFO            =SIMP(statut='f',typ='I',into=(1,2) ),
)  ;
#& MODIF COMMANDE  DATE 31/10/2006   AUTEUR CIBHHLV L.VIVAN 
#            CONFIGURATION MANAGEMENT OF EDF VERSION
# ======================================================================
# COPYRIGHT (C) 1991 - 2001  EDF R&D                  WWW.CODE-ASTER.ORG
# THIS PROGRAM IS FREE SOFTWARE; YOU CAN REDISTRIBUTE IT AND/OR MODIFY
# IT UNDER THE TERMS OF THE GNU GENERAL PUBLIC LICENSE AS PUBLISHED BY
# THE FREE SOFTWARE FOUNDATION; EITHER VERSION 2 OF THE LICENSE, OR   
# (AT YOUR OPTION) ANY LATER VERSION.                                 
#
# THIS PROGRAM IS DISTRIBUTED IN THE HOPE THAT IT WILL BE USEFUL, BUT 
# WITHOUT ANY WARRANTY; WITHOUT EVEN THE IMPLIED WARRANTY OF          
# MERCHANTABILITY OR FITNESS FOR A PARTICULAR PURPOSE. SEE THE GNU    
# GENERAL PUBLIC LICENSE FOR MORE DETAILS.                            
#
# YOU SHOULD HAVE RECEIVED A COPY OF THE GNU GENERAL PUBLIC LICENSE   
# ALONG WITH THIS PROGRAM; IF NOT, WRITE TO EDF R&D CODE_ASTER,       
#    1 AVENUE DU GENERAL DE GAULLE, 92141 CLAMART CEDEX, FRANCE.      
# ======================================================================
# RESPONSABLE BOYERE E.BOYERE
def rest_base_phys_prod(RESU_GENE,RESU_PHYS,RESULTAT,**args ):
  if AsType(RESU_GENE) == tran_gene : return dyna_trans
  if AsType(RESU_GENE) == mode_gene : return mode_meca
  if AsType(RESU_GENE) == mode_cycl : return mode_meca
  if AsType(RESU_GENE) == harm_gene : return dyna_harmo
  if AsType(RESU_PHYS) == evol_noli : return dyna_trans
  if AsType(RESULTAT)  == evol_elas      : return evol_elas
  if AsType(RESULTAT)  == evol_noli      : return evol_noli
  if AsType(RESULTAT)  == evol_char      : return evol_char
  if AsType(RESULTAT)  == dyna_trans     : return dyna_trans
  if AsType(RESULTAT)  == mode_meca      : return mode_meca
  if AsType(RESULTAT)  == mode_stat_depl : return mode_stat_depl
  if AsType(RESULTAT)  == base_modale    : return base_modale
  raise AsException("type de concept resultat non prevu")

REST_BASE_PHYS=OPER(nom="REST_BASE_PHYS",op=  75,sd_prod=rest_base_phys_prod,
                    fr="Restituer dans la base physique des résultats en coordonnées généralisées",
                    reentrant='n',
            UIinfo={"groupes":("Matrices/vecteurs",)},
        regles=(UN_PARMI('RESU_GENE','RESU_PHYS','RESULTAT'),
                EXCLUS('TOUT_ORDRE','NUME_ORDRE','INST','LIST_INST','TOUT_INST'),
                EXCLUS('TOUT_INST','NUME_ORDRE','INST','LIST_INST','TOUT_ORDRE'),
#  Doc U à revoir
                EXCLUS('MULT_APPUI','CORR_STAT'),
                EXCLUS('MULT_APPUI','NOEUD','GROUP_NO'),
                EXCLUS('CORR_STAT','NOEUD','GROUP_NO'),             
                EXCLUS('NOEUD','GROUP_NO'),
                PRESENT_PRESENT('RESU_PHYS','BASE_MODALE'),
                PRESENT_PRESENT('RESULTAT','SQUELETTE'),
                PRESENT_PRESENT('ACCE_MONO_APPUI','DIRECTION'),),
         RESULTAT        =SIMP(statut='f',typ=(evol_elas,evol_noli,dyna_trans,evol_char,
                                               mode_meca,mode_stat_depl,base_modale) ),
         
         RESU_GENE       =SIMP(statut='f',typ=(tran_gene,mode_gene,mode_cycl,harm_gene) ),
         RESU_PHYS       =SIMP(statut='f',typ=evol_noli ),
         BASE_MODALE     =SIMP(statut='f',typ=(base_modale,mode_meca) ),
         NUME_DDL        =SIMP(statut='f',typ=nume_ddl_sdaster ),
         MODE_MECA       =SIMP(statut='f',typ=mode_meca ),
         TOUT_ORDRE      =SIMP(statut='f',typ='TXM',into=("OUI",) ),
         NUME_ORDRE      =SIMP(statut='f',typ='I',validators=NoRepeat(),max='**' ),  
         NUME_MODE      =SIMP(statut='f',typ='I',validators=NoRepeat(),max='**' ),  
         TOUT_INST       =SIMP(statut='f',typ='TXM',into=("OUI",) ),
         INST            =SIMP(statut='f',typ='R',validators=NoRepeat(),max='**' ),  
         LIST_INST       =SIMP(statut='f',typ=listr8_sdaster ),
         FREQ            =SIMP(statut='f',typ='R',validators=NoRepeat(),max='**' ),  
         LIST_FREQ       =SIMP(statut='f',typ=listr8_sdaster ),
         CRITERE         =SIMP(statut='f',typ='TXM',defaut="RELATIF",into=("ABSOLU","RELATIF") ),
         PRECISION       =SIMP(statut='f',typ='R',defaut= 1.E-3 ),  
         INTERPOL        =SIMP(statut='f',typ='TXM',defaut="NON",into=("NON","LIN") ),
         MULT_APPUI      =SIMP(statut='f',typ='TXM',into=("OUI",) ),
         CORR_STAT       =SIMP(statut='f',typ='TXM',into=("OUI",) ),
         NOM_CHAM        =SIMP(statut='f',typ='TXM',validators=NoRepeat(),max=8,defaut="ACCE",   
                               into=("DEPL","VITE","ACCE","ACCE_ABSOLU","EFGE_ELNO_DEPL","SIPO_ELNO_DEPL",                 
                                     "SIGM_ELNO_DEPL","FORC_NODA",) ),
         TOUT_CHAM       =SIMP(statut='f',typ='TXM',into=("OUI",) ),
         GROUP_NO        =SIMP(statut='f',typ=grno,validators=NoRepeat(),max='**'),
         NOEUD           =SIMP(statut='f',typ=no  ,validators=NoRepeat(),max='**'),
         GROUP_MA        =SIMP(statut='f',typ=grma,validators=NoRepeat(),max='**'),
         MAILLE          =SIMP(statut='f',typ=ma  ,validators=NoRepeat(),max='**'),
 
         ACCE_MONO_APPUI =SIMP(statut='f',typ=(fonction_sdaster,nappe_sdaster,formule)),
         DIRECTION       =SIMP(statut='f',typ='R',min=3,max=3 ),

         CYCLIQUE    =FACT(statut='f',max='**',
           NB_SECTEUR      =SIMP(statut='f',typ='I',validators=NoRepeat(),max=1 ),
           NUME_DIAMETRE    =SIMP(statut='f',typ='I',validators=NoRepeat(),max=1 ),
           RESULTAT2       =SIMP(statut='f',typ=(evol_elas,evol_noli,dyna_trans,evol_char,
                                               mode_meca,mode_stat_depl,base_modale) ),
         ),

         SQUELETTE       =SIMP(statut='f',typ=squelette ),
         SOUS_STRUC      =SIMP(statut='f',typ='TXM' ),  
         SECTEUR         =SIMP(statut='f',typ='I',defaut= 1 ),  
         TITRE           =SIMP(statut='f',typ='TXM',max='**' ),  
)  ;
#& MODIF COMMANDE  DATE 10/10/2006   AUTEUR MCOURTOI M.COURTOIS 
#            CONFIGURATION MANAGEMENT OF EDF VERSION
# ======================================================================
# COPYRIGHT (C) 1991 - 2001  EDF R&D                  WWW.CODE-ASTER.ORG
# THIS PROGRAM IS FREE SOFTWARE; YOU CAN REDISTRIBUTE IT AND/OR MODIFY
# IT UNDER THE TERMS OF THE GNU GENERAL PUBLIC LICENSE AS PUBLISHED BY
# THE FREE SOFTWARE FOUNDATION; EITHER VERSION 2 OF THE LICENSE, OR   
# (AT YOUR OPTION) ANY LATER VERSION.                                 
#
# THIS PROGRAM IS DISTRIBUTED IN THE HOPE THAT IT WILL BE USEFUL, BUT 
# WITHOUT ANY WARRANTY; WITHOUT EVEN THE IMPLIED WARRANTY OF          
# MERCHANTABILITY OR FITNESS FOR A PARTICULAR PURPOSE. SEE THE GNU    
# GENERAL PUBLIC LICENSE FOR MORE DETAILS.                            
#
# YOU SHOULD HAVE RECEIVED A COPY OF THE GNU GENERAL PUBLIC LICENSE   
# ALONG WITH THIS PROGRAM; IF NOT, WRITE TO EDF R&D CODE_ASTER,       
#    1 AVENUE DU GENERAL DE GAULLE, 92141 CLAMART CEDEX, FRANCE.      
# ======================================================================
REST_SPEC_PHYS=OPER(nom="REST_SPEC_PHYS",op= 148,sd_prod=table_fonction,
                    reentrant='n',
            fr="Calculer la réponse d'une structure dans la base physique",
            UIinfo={"groupes":("Matrices/vecteurs",)},
         regles=(AU_MOINS_UN('BASE_ELAS_FLUI','MODE_MECA'),),
         BASE_ELAS_FLUI  =SIMP(statut='f',typ=melasflu_sdaster ),
         MODE_MECA       =SIMP(statut='f',typ=mode_meca ),
         BANDE           =SIMP(statut='f',typ='R',min=2,validators=NoRepeat(),max=2    ),  
         NUME_ORDRE      =SIMP(statut='f',typ='I'      ,validators=NoRepeat(),max='**' ),  
         INTE_SPEC_GENE  =SIMP(statut='o',typ=table_fonction),
         NOEUD           =SIMP(statut='o',typ=no   ,max='**'),
         MAILLE          =SIMP(statut='f',typ=ma   ,max='**'),
         NOM_CMP         =SIMP(statut='o',typ='TXM',max='**'),  
         NOM_CHAM        =SIMP(statut='o',typ='TXM',validators=NoRepeat(),max=7,    
                               into=("DEPL","VITE","ACCE","EFGE_ELNO_DEPL",
                                     "SIPO_ELNO_DEPL","SIGM_ELNO_DEPL","FORC_NODA") ),
         MODE_STAT       =SIMP(statut='f',typ=(mode_stat_depl,mode_stat_acce,mode_stat_forc), ),
         EXCIT           =FACT(statut='f',
           NOEUD           =SIMP(statut='o',typ=no   ,max='**'),
           NOM_CMP         =SIMP(statut='o',typ='TXM',max='**'),  
         ),
         MOUVEMENT       =SIMP(statut='f',typ='TXM',defaut="ABSOLU",into=("RELATIF","ABSOLU","DIFFERENTIEL") ),
         OPTION          =SIMP(statut='f',typ='TXM',defaut="DIAG_DIAG",    
                               into=("DIAG_TOUT","DIAG_DIAG","TOUT_TOUT","TOUT_DIAG") ),
         TITRE           =SIMP(statut='f',typ='TXM',max='**' ),  
)  ;
#& MODIF COMMANDE  DATE 10/10/2006   AUTEUR REZETTE C.REZETTE 
#            CONFIGURATION MANAGEMENT OF EDF VERSION
# ======================================================================
# COPYRIGHT (C) 1991 - 2006  EDF R&D                  WWW.CODE-ASTER.ORG
# THIS PROGRAM IS FREE SOFTWARE; YOU CAN REDISTRIBUTE IT AND/OR MODIFY  
# IT UNDER THE TERMS OF THE GNU GENERAL PUBLIC LICENSE AS PUBLISHED BY  
# THE FREE SOFTWARE FOUNDATION; EITHER VERSION 2 OF THE LICENSE, OR     
# (AT YOUR OPTION) ANY LATER VERSION.                                                  
#                                                                       
# THIS PROGRAM IS DISTRIBUTED IN THE HOPE THAT IT WILL BE USEFUL, BUT   
# WITHOUT ANY WARRANTY; WITHOUT EVEN THE IMPLIED WARRANTY OF            
# MERCHANTABILITY OR FITNESS FOR A PARTICULAR PURPOSE. SEE THE GNU      
# GENERAL PUBLIC LICENSE FOR MORE DETAILS.                              
#                                                                       
# YOU SHOULD HAVE RECEIVED A COPY OF THE GNU GENERAL PUBLIC LICENSE     
# ALONG WITH THIS PROGRAM; IF NOT, WRITE TO EDF R&D CODE_ASTER,         
#    1 AVENUE DU GENERAL DE GAULLE, 92141 CLAMART CEDEX, FRANCE.        
# ======================================================================
# -*- coding: iso-8859-1 -*-

from Macro.simu_point_mat_ops import simu_point_mat_ops

SIMU_POINT_MAT=MACRO(nom="SIMU_POINT_MAT", op=simu_point_mat_ops,sd_prod=table_sdaster,
                   UIinfo={"groupes":("Résolution",)},
                   fr="Calcul de l'évolution mécanique, en quasi-statique,"
                      +" d'un point matériel en non linéaire",
   COMP_INCR       =C_COMP_INCR(),
   MATER           =SIMP(statut='o',typ=mater_sdaster,max=30),
   INCREMENT       =FACT(statut='o',
           LIST_INST       =SIMP(statut='o',typ=listr8_sdaster),
           # DEBUT DE BLOC POUR LA SUBDIVISION DES PAS DE TEMPS
           SUBD_METHODE    =SIMP( statut='f',typ='TXM',
              into =("AUCUNE","UNIFORME","EXTRAPOLE"),
              defaut="AUCUNE",
              fr="Méthode de subdivision des pas de temps en cas de non-convergence"
           ),
           b_subd_unif=BLOC(condition = "SUBD_METHODE == 'UNIFORME'",
             regles=(AU_MOINS_UN('SUBD_NIVEAU','SUBD_PAS_MINI'),),
             SUBD_COEF_PAS_1=SIMP(statut='f',typ='R',defaut=1.0,val_min=0.0,
                fr="Coefficient multiplicateur de la 1ère subdivision"),
             SUBD_PAS       =SIMP(statut='f',typ='I',defaut=4,val_min=2,
                fr="Nombre de subdivision d'un pas de temps"),
             SUBD_NIVEAU=SIMP(statut='f',typ='I',val_min=2,
                fr="Nombre maximum de niveau de subdivision d'un pas de temps"),
             SUBD_PAS_MINI=SIMP(statut='f',typ='R',val_min=0.0,
                fr="Pas de temps en dessous duquel on ne subdivise plus"),
           ),
           b_subd_extr=BLOC(condition = "SUBD_METHODE == 'EXTRAPOLE'",
             regles=(AU_MOINS_UN('SUBD_NIVEAU','SUBD_PAS_MINI'),),
             SUBD_OPTION    =SIMP(statut='f',typ='TXM',
                into =("IGNORE_PREMIERES","GARDE_DERNIERES",), 
                defaut="IGNORE_PREMIERES",
                fr="Technique d'extrapolation : les 1ere itérations sont ignorées ou les dernières sont gardées"),
             SUBD_ITER_IGNO =SIMP(statut='c',typ='I',defaut=3,val_min=0,
                fr="Les n premières itérations sont ignorées pour l'extrapolation"),
             SUBD_ITER_FIN  =SIMP(statut='c',typ='I',defaut=8,val_min=3,
                fr="Seules les n dernières itérations sont prises pour l'extrapolation"),
             SUBD_PAS       =SIMP(statut='c',typ='I',defaut=4,val_min=2,
                fr="Nombre de subdivision d'un pas de temps en cas divergence"),
             SUBD_NIVEAU=SIMP(statut='f',typ='I',val_min=2,
                fr="Nombre maximum de niveau de subdivision d'un pas de temps"),
             SUBD_PAS_MINI=SIMP(statut='f',typ='R',val_min=0.0,
                fr="Pas de temps en dessous duquel on ne subdivise plus"),
             SUBD_ITER_PLUS =SIMP(statut='c',typ='I',defaut=50,val_min=20,
                fr="% itération autorisée en plus"),
           ),
           # FIN DE BLOC POUR LA SUBDIVISION DES PAS DE TEMPS 
         ),
   NEWTON          =FACT(statut='d',
           PREDICTION      =SIMP(statut='f',typ='TXM',into=("TANGENTE","ELASTIQUE","EXTRAPOL") ),
           MATRICE         =SIMP(statut='f',typ='TXM',defaut="TANGENTE",into=("TANGENTE","ELASTIQUE") ),
           PAS_MINI_ELAS   =SIMP(statut='f',typ='R',defaut=0.0E+0),
           REAC_ITER       =SIMP(statut='f',typ='I',defaut=1),
           REAC_ITER_ELAS  =SIMP(statut='f',typ='I',defaut=0),
         ),
   CONVERGENCE     =FACT(statut='d',
     regles=(PRESENT_ABSENT('RESI_REFE_RELA','RESI_GLOB_MAXI','RESI_GLOB_RELA'),),
     SIGM_REFE       =SIMP(statut='f',typ='R'),
     EPSI_REFE       =SIMP(statut='f',typ='R'),
     RESI_REFE_RELA  =SIMP(statut='f',typ='R'),
     RESI_GLOB_MAXI  =SIMP(statut='f',typ='R'),
     RESI_GLOB_RELA  =SIMP(statut='f',typ='R'),
     ITER_GLOB_MAXI  =SIMP(statut='f',typ='I',defaut=50),
     ITER_GLOB_ELAS  =SIMP(statut='f',typ='I',defaut=25),
     ARRET           =SIMP(statut='f',typ='TXM',defaut="OUI",into=("OUI","NON")),
   ),
   SUIVI_DDL      = FACT(statut='f',max=4,                                                                   
       NUME_SUIVI      =SIMP(statut='o',typ='I' ,min=1,max=4),                                               
       NOM_CHAM        =SIMP(statut='o',typ='TXM',validators=NoRepeat(),max=1,                               
                             into=("DEPL","SIEF_ELGA","VARI_ELGA",)),                                        
       NOM_CMP         =SIMP(statut='o',typ='TXM',max=1 ),                                                   
   ),                                                                                                        
   SIGM_IMPOSE=FACT(statut='f',
          SIXX = SIMP(statut='f',typ=(fonction_sdaster,nappe_sdaster,formule) ),
          SIYY = SIMP(statut='f',typ=(fonction_sdaster,nappe_sdaster,formule) ),
          SIZZ = SIMP(statut='f',typ=(fonction_sdaster,nappe_sdaster,formule) ),
          SIXY = SIMP(statut='f',typ=(fonction_sdaster,nappe_sdaster,formule) ),
          SIXZ = SIMP(statut='f',typ=(fonction_sdaster,nappe_sdaster,formule) ),
          SIYZ = SIMP(statut='f',typ=(fonction_sdaster,nappe_sdaster,formule) ),
                     ),
   EPSI_IMPOSE=FACT(statut='f',
          EPXX = SIMP(statut='f',typ=(fonction_sdaster,nappe_sdaster,formule) ),
          EPYY = SIMP(statut='f',typ=(fonction_sdaster,nappe_sdaster,formule) ),
          EPZZ = SIMP(statut='f',typ=(fonction_sdaster,nappe_sdaster,formule) ),
          EPXY = SIMP(statut='f',typ=(fonction_sdaster,nappe_sdaster,formule) ),
          EPXZ = SIMP(statut='f',typ=(fonction_sdaster,nappe_sdaster,formule) ),
          EPYZ = SIMP(statut='f',typ=(fonction_sdaster,nappe_sdaster,formule) ),
                     ),
         
         
   INFO            =SIMP(statut='f',typ='I',defaut=1,into=(1,2) ),
)
#& MODIF COMMANDE  DATE 15/05/2006   AUTEUR ASSIRE A.ASSIRE 
#            CONFIGURATION MANAGEMENT OF EDF VERSION
# ======================================================================
# COPYRIGHT (C) 1991 - 2004  EDF R&D                  WWW.CODE-ASTER.ORG
# THIS PROGRAM IS FREE SOFTWARE; YOU CAN REDISTRIBUTE IT AND/OR MODIFY  
# IT UNDER THE TERMS OF THE GNU GENERAL PUBLIC LICENSE AS PUBLISHED BY  
# THE FREE SOFTWARE FOUNDATION; EITHER VERSION 2 OF THE LICENSE, OR     
# (AT YOUR OPTION) ANY LATER VERSION.                                                  
#                                                                       
# THIS PROGRAM IS DISTRIBUTED IN THE HOPE THAT IT WILL BE USEFUL, BUT   
# WITHOUT ANY WARRANTY; WITHOUT EVEN THE IMPLIED WARRANTY OF            
# MERCHANTABILITY OR FITNESS FOR A PARTICULAR PURPOSE. SEE THE GNU      
# GENERAL PUBLIC LICENSE FOR MORE DETAILS.                              
#                                                                       
# YOU SHOULD HAVE RECEIVED A COPY OF THE GNU GENERAL PUBLIC LICENSE     
# ALONG WITH THIS PROGRAM; IF NOT, WRITE TO EDF R&D CODE_ASTER,         
#    1 AVENUE DU GENERAL DE GAULLE, 92141 CLAMART CEDEX, FRANCE.        
# ======================================================================

from Macro.stanley_ops import stanley_ops

STANLEY=MACRO(nom="STANLEY",op=stanley_ops,sd_prod=None,
                       reentrant='n',
              UIinfo={"groupes":("Outils métier",)},
                       fr="Outil de post-traitement interactif Stanley ",
         RESULTAT        =SIMP(statut='f',typ=(evol_elas,evol_noli,evol_ther,mode_meca,mode_stat,dyna_harmo,dyna_trans) ),
         MODELE          =SIMP(statut='f',typ=modele_sdaster),
         CHAM_MATER      =SIMP(statut='f',typ=cham_mater),
         CARA_ELEM       =SIMP(statut='f',typ=cara_elem),
         DISPLAY         =SIMP(statut='f',typ='TXM'),
         UNITE_VALIDATION=SIMP(statut='c',typ='I',val_min=10,val_max=90,
                               fr="Unité logique définissant le fichier (fort.N) dans lequel on écrit les md5"),

)  ;
#& MODIF COMMANDE  DATE 10/10/2006   AUTEUR REZETTE C.REZETTE 
#            CONFIGURATION MANAGEMENT OF EDF VERSION
# ======================================================================
# COPYRIGHT (C) 1991 - 2001  EDF R&D                  WWW.CODE-ASTER.ORG
# THIS PROGRAM IS FREE SOFTWARE; YOU CAN REDISTRIBUTE IT AND/OR MODIFY
# IT UNDER THE TERMS OF THE GNU GENERAL PUBLIC LICENSE AS PUBLISHED BY
# THE FREE SOFTWARE FOUNDATION; EITHER VERSION 2 OF THE LICENSE, OR
# (AT YOUR OPTION) ANY LATER VERSION.
#
# THIS PROGRAM IS DISTRIBUTED IN THE HOPE THAT IT WILL BE USEFUL, BUT
# WITHOUT ANY WARRANTY; WITHOUT EVEN THE IMPLIED WARRANTY OF
# MERCHANTABILITY OR FITNESS FOR A PARTICULAR PURPOSE. SEE THE GNU
# GENERAL PUBLIC LICENSE FOR MORE DETAILS.
#
# YOU SHOULD HAVE RECEIVED A COPY OF THE GNU GENERAL PUBLIC LICENSE
# ALONG WITH THIS PROGRAM; IF NOT, WRITE TO EDF R&D CODE_ASTER,
#    1 AVENUE DU GENERAL DE GAULLE, 92141 CLAMART CEDEX, FRANCE.
# ======================================================================
# RESPONSABLE MABBAS M.ABBAS
STAT_NON_LINE=OPER(nom="STAT_NON_LINE",op=70,sd_prod=evol_noli,
                   fr="Calcul de l'évolution mécanique ou thermo-hydro-mécanique couplée, en quasi-statique,"
                      +" d'une structure en non linéaire",
                   reentrant='f',
            UIinfo={"groupes":("Résolution",)},
         regles=(AU_MOINS_UN('COMP_INCR','COMP_ELAS'),
                 CONCEPT_SENSIBLE('ENSEMBLE'),),
         MODELE          =SIMP(statut='o',typ=modele_sdaster),
         CHAM_MATER      =SIMP(statut='o',typ=cham_mater),
         CARA_ELEM       =SIMP(statut='f',typ=cara_elem),
         EXCIT           =FACT(statut='o',max='**',
           CHARGE          =SIMP(statut='o',typ=(char_meca,char_cine_meca)),
           FONC_MULT       =SIMP(statut='f',typ=(fonction_sdaster,nappe_sdaster,formule)),
           TYPE_CHARGE     =SIMP(statut='f',typ='TXM',defaut="FIXE_CSTE",
                                 into=("FIXE_CSTE","FIXE_PILO","SUIV","DIDI")),
         ),
         SOUS_STRUC      =FACT(statut='f',min=01,max='**',
                regles=(UN_PARMI('TOUT','MAILLE'),),
                CAS_CHARGE  =SIMP(statut='o',typ='TXM' ),
                TOUT        =SIMP(statut='f',typ='TXM',into=("OUI",) ),
                MAILLE      =SIMP(statut='f',typ=ma,validators=NoRepeat(),max='**',),
              ),
         COMP_INCR       =C_COMP_INCR(),
         COMP_ELAS       =FACT(statut='f',max='**',
           RESI_INTE_RELA  =SIMP(statut='f',typ='R',defaut= 1.0E-6),
           ITER_INTE_MAXI  =SIMP(statut='f',typ='I',defaut= 10 ),
           ITER_INTE_PAS   =SIMP(statut='f',typ='I',defaut= 0 ),
           RESO_INTE       =SIMP(statut='f',typ='TXM',defaut="IMPLICITE",
                                 into=("RUNGE_KUTTA_2","RUNGE_KUTTA_4","IMPLICITE")),
           RELATION        =SIMP(statut='o',typ='TXM',defaut="ELAS",
                                 into=("ELAS","ELAS_VMIS_LINE","ELAS_VMIS_TRAC",
                                      "ELAS_POUTRE_GR","CABLE","ELAS_HYPER")),
           ELAS            =SIMP(statut='c',typ='I',defaut=1,into=(1,)),
           ELAS_VMIS_TRAC  =SIMP(statut='c',typ='I',defaut=1,into=(1,)),
           ELAS_VMIS_LINE  =SIMP(statut='c',typ='I',defaut=1,into=(1,)),
           ELAS_HYPER      =SIMP(statut='c',typ='I',defaut=1,into=(1,)),           
           ELAS_POUTRE_GR  =SIMP(statut='c',typ='I',defaut=3,into=(3,)),
           CABLE           =SIMP(statut='c',typ='I',defaut=1,into=(1,)),
           DEFORMATION     =SIMP(statut='f',typ='TXM',defaut="PETIT" ,into=("PETIT","GREEN","GREEN_GR",) ),
      regles=(PRESENT_ABSENT('TOUT','GROUP_MA','MAILLE'),),
           TOUT            =SIMP(statut='f',typ='TXM',into=("OUI",) ),
           GROUP_MA        =SIMP(statut='f',typ=grma,validators=NoRepeat(),max='**'),
           MAILLE          =SIMP(statut='f',typ=ma  ,validators=NoRepeat(),max='**'),
         ),
         b_reuse =BLOC(condition = "reuse",fr="en mode concept reentrant : ETAT_INIT obligatoire",
           ETAT_INIT       =FACT(statut='o',
             regles=(AU_MOINS_UN('EVOL_NOLI','DEPL','SIGM','VARI','VARI_NON_LOCAL',),
                     EXCLUS('EVOL_NOLI','DEPL',),
                     EXCLUS('EVOL_NOLI','SIGM',),
                     EXCLUS('EVOL_NOLI','VARI',),
                     EXCLUS('EVOL_NOLI','VARI_NON_LOCAL',),
                     EXCLUS('NUME_ORDRE','INST'), ),
             DEPL            =SIMP(statut='f',typ=cham_no_sdaster),
             SIGM            =SIMP(statut='f',typ=(cham_elem,carte_sdaster)),
             VARI            =SIMP(statut='f',typ=cham_elem),
             VARI_NON_LOCAL  =SIMP(statut='f',typ=cham_no_sdaster),
             EVOL_NOLI       =SIMP(statut='f',typ=evol_noli),
             NUME_ORDRE      =SIMP(statut='f',typ='I'),
             INST            =SIMP(statut='f',typ='R'),
             PRECISION       =SIMP(statut='f',typ='R',defaut= 1.0E-3 ),
             CRITERE         =SIMP(statut='f',typ='TXM',defaut="RELATIF",into=("RELATIF","ABSOLU") ),
             NUME_DIDI       =SIMP(statut='f',typ='I'),
             INST_ETAT_INIT  =SIMP(statut='f',typ='R'),
         ),),
         b_not_reuse =BLOC(condition = "not reuse",fr="en mode concept non reentrant : ETAT_INIT facultatif",
           ETAT_INIT       =FACT(statut='f',
             regles=(AU_MOINS_UN('EVOL_NOLI','DEPL','SIGM','VARI','VARI_NON_LOCAL',),
                     EXCLUS('EVOL_NOLI','DEPL',),
                     EXCLUS('EVOL_NOLI','SIGM',),
                     EXCLUS('EVOL_NOLI','VARI',),
                     EXCLUS('EVOL_NOLI','VARI_NON_LOCAL',),
                     EXCLUS('NUME_ORDRE','INST'), ),
             DEPL            =SIMP(statut='f',typ=cham_no_sdaster),
             SIGM            =SIMP(statut='f',typ=(cham_elem,carte_sdaster)),
             VARI            =SIMP(statut='f',typ=cham_elem),
             VARI_NON_LOCAL  =SIMP(statut='f',typ=cham_no_sdaster),
             EVOL_NOLI       =SIMP(statut='f',typ=evol_noli),
             NUME_ORDRE      =SIMP(statut='f',typ='I'),
             INST            =SIMP(statut='f',typ='R'),
             PRECISION       =SIMP(statut='f',typ='R',defaut= 1.0E-3 ),
             CRITERE         =SIMP(statut='f',typ='TXM',defaut="RELATIF",into=("RELATIF","ABSOLU") ),
             NUME_DIDI       =SIMP(statut='f',typ='I'),
             INST_ETAT_INIT  =SIMP(statut='f',typ='R'),
         ),),
         INCREMENT       =FACT(statut='o',
           regles=(EXCLUS('NUME_INST_INIT','INST_INIT'),
                   EXCLUS('NUME_INST_FIN','INST_FIN'),),
           LIST_INST       =SIMP(statut='o',typ=listr8_sdaster),
           EVOLUTION       =SIMP(statut='f',typ='TXM',defaut="CHRONOLOGIQUE",
                                 into=("CHRONOLOGIQUE","RETROGRADE","SANS",) ),
           NUME_INST_INIT  =SIMP(statut='f',typ='I'),
           INST_INIT       =SIMP(statut='f',typ='R'),
           NUME_INST_FIN   =SIMP(statut='f',typ='I'),
           INST_FIN        =SIMP(statut='f',typ='R'),
           PRECISION       =SIMP(statut='f',typ='R',defaut=1.0E-3 ),
           # DEBUT DE BLOC POUR LA SUBDIVISION DES PAS DE TEMPS
           SUBD_METHODE    =SIMP( statut='f',typ='TXM',
              into =("AUCUNE","UNIFORME","EXTRAPOLE"),
              defaut="AUCUNE",
              fr="Méthode de subdivision des pas de temps en cas de non-convergence"
           ),
           b_subd_unif=BLOC(condition = "SUBD_METHODE == 'UNIFORME'",
             regles=(AU_MOINS_UN('SUBD_NIVEAU','SUBD_PAS_MINI'),),
             SUBD_COEF_PAS_1=SIMP(statut='f',typ='R',defaut=1.0,val_min=0.0,
                fr="Coefficient multiplicateur de la 1ère subdivision"),
             SUBD_PAS       =SIMP(statut='f',typ='I',defaut=4,val_min=2,
                fr="Nombre de subdivision d'un pas de temps"),
             SUBD_NIVEAU=SIMP(statut='f',typ='I',val_min=2,
                fr="Nombre maximum de niveau de subdivision d'un pas de temps"),
             SUBD_PAS_MINI=SIMP(statut='f',typ='R',val_min=0.0,
                fr="Pas de temps en dessous duquel on ne subdivise plus"),
           ),
           b_subd_extr=BLOC(condition = "SUBD_METHODE == 'EXTRAPOLE'",
             regles=(AU_MOINS_UN('SUBD_NIVEAU','SUBD_PAS_MINI'),),
             SUBD_OPTION    =SIMP(statut='f',typ='TXM',
                into =("IGNORE_PREMIERES","GARDE_DERNIERES",), 
                defaut="IGNORE_PREMIERES",
                fr="Technique d'extrapolation : les 1ere itérations sont ignorées ou les dernières sont gardées"),
             SUBD_ITER_IGNO =SIMP(statut='c',typ='I',defaut=3,val_min=0,
                fr="Les n premières itérations sont ignorées pour l'extrapolation"),
             SUBD_ITER_FIN  =SIMP(statut='c',typ='I',defaut=8,val_min=3,
                fr="Seules les n dernières itérations sont prises pour l'extrapolation"),
             SUBD_PAS       =SIMP(statut='c',typ='I',defaut=4,val_min=2,
                fr="Nombre de subdivision d'un pas de temps en cas divergence"),
             SUBD_NIVEAU=SIMP(statut='f',typ='I',val_min=2,
                fr="Nombre maximum de niveau de subdivision d'un pas de temps"),
             SUBD_PAS_MINI=SIMP(statut='f',typ='R',val_min=0.0,
                fr="Pas de temps en dessous duquel on ne subdivise plus"),
             SUBD_ITER_PLUS =SIMP(statut='c',typ='I',defaut=50,val_min=20,
                fr="% itération autorisée en plus"),
           ),
           # FIN DE BLOC POUR LA SUBDIVISION DES PAS DE TEMPS 
           OPTI_LIST_INST  =SIMP(statut='f',typ='TXM',into=("INCR_MAXI",),),
           NOM_CHAM        =SIMP(statut='f',typ='TXM',),
           NOM_CMP         =SIMP(statut='f',typ='TXM',),
           VALE            =SIMP(statut='f',typ='R'),
         ),
         NEWTON          =FACT(statut='d',
           REAC_INCR       =SIMP(statut='f',typ='I',defaut= 1 ),
           PREDICTION      =SIMP(statut='f',typ='TXM',into=("DEPL_CALCULE","TANGENTE","ELASTIQUE","EXTRAPOL") ),
           MATRICE         =SIMP(statut='f',typ='TXM',defaut="TANGENTE",into=("TANGENTE","ELASTIQUE") ),
           PAS_MINI_ELAS   =SIMP(statut='f',typ='R',defaut=0.0E+0),
           REAC_ITER       =SIMP(statut='f',typ='I',defaut=0),
           REAC_ITER_ELAS  =SIMP(statut='f',typ='I',defaut=0),
           EVOL_NOLI       =SIMP(statut='f',typ=evol_noli),
         ),
         RECH_LINEAIRE   =FACT(statut='f',
           RESI_LINE_RELA  =SIMP(statut='f',typ='R',defaut= 1.0E-1 ),
           ITER_LINE_MAXI  =SIMP(statut='f',typ='I',defaut= 3),
           ITER_LINE_CRIT  =SIMP(statut='f',typ='I',defaut= 20),
           PAS_MINI_CRIT   =SIMP(statut='f',typ='R',defaut=0.0E+0),
           RHO_MIN         =SIMP(statut='f',typ='R',defaut=1.0E-2),
           RHO_MAX         =SIMP(statut='f',typ='R',defaut=1.0E+1),
           RHO_EXCL        =SIMP(statut='f',typ='R',defaut=0.9E-2,val_min=0.),
         ),
         PILOTAGE        =FACT(statut='f',
           regles=(EXCLUS('NOEUD','GROUP_NO'),PRESENT_ABSENT('TOUT','GROUP_MA','MAILLE'),),
           TYPE    =SIMP(statut='o',typ='TXM',into=("DDL_IMPO","LONG_ARC","PRED_ELAS","PRED_ELAS_INCR","DEFORMATION","ANA_LIM") ),
           COEF_MULT       =SIMP(statut='f',typ='R',defaut= 1.0E+0),
           ETA_PILO_MAX    =SIMP(statut='f',typ='R'),
           ETA_PILO_MIN    =SIMP(statut='f',typ='R'),
           ETA_PILO_R_MAX  =SIMP(statut='f',typ='R'),
           ETA_PILO_R_MIN  =SIMP(statut='f',typ='R'),
           PROJ_BORNES     =SIMP(statut='f',typ='TXM',defaut="OUI",into=("OUI","NON")),
           SELECTION       =SIMP(statut='f',typ='TXM',defaut="NORM_INCR_DEPL", into=("RESIDU","ANGL_INCR_DEPL","NORM_INCR_DEPL") ),
           TOUT            =SIMP(statut='f',typ='TXM',into=("OUI",) ),
           GROUP_MA        =SIMP(statut='f',typ=grma ,validators=NoRepeat(),max='**'),
           MAILLE          =SIMP(statut='f',typ=ma   ,validators=NoRepeat(),max='**'),
           NOEUD           =SIMP(statut='f',typ=no   ,validators=NoRepeat(),max='**'),
           GROUP_NO        =SIMP(statut='f',typ=grno ,validators=NoRepeat(),max='**'),
           NOM_CMP         =SIMP(statut='f',typ='TXM',max='**'),
                         ),
         CONVERGENCE     =FACT(statut='d',
           regles=(PRESENT_ABSENT('RESI_REFE_RELA','RESI_GLOB_MAXI','RESI_GLOB_RELA'),),
           SIGM_REFE       =SIMP(statut='f',typ='R'),
           EPSI_REFE       =SIMP(statut='f',typ='R'),
           FLUX_THER_REFE  =SIMP(statut='f',typ='R'),
           FLUX_HYD1_REFE  =SIMP(statut='f',typ='R'),
           FLUX_HYD2_REFE  =SIMP(statut='f',typ='R'),
           RESI_REFE_RELA  =SIMP(statut='f',typ='R'),
           RESI_GLOB_MAXI  =SIMP(statut='f',typ='R'),
           RESI_GLOB_RELA  =SIMP(statut='f',typ='R'),
           ITER_GLOB_MAXI  =SIMP(statut='f',typ='I',defaut=10),
           ITER_GLOB_ELAS  =SIMP(statut='f',typ='I',defaut=25),
           ARRET           =SIMP(statut='f',typ='TXM',defaut="OUI",into=("OUI","NON")),
         ),
         SOLVEUR         =FACT(statut='d',
           METHODE=SIMP(statut='f',typ='TXM',defaut="MULT_FRONT",into=("MULT_FRONT","LDLT","GCPC","MUMPS","FETI") ),
           b_mult_front    =BLOC(condition = "METHODE == 'MULT_FRONT' ",fr="Paramètres de la méthode multi frontale",
             RENUM           =SIMP(statut='f',typ='TXM',defaut="METIS",into=("MD","MDA","METIS") ),
           ),
           b_ldlt         =BLOC(condition = "METHODE == 'LDLT' ",fr="Paramètres de la méthode LDLT",
             RENUM           =SIMP(statut='f',typ='TXM',defaut="RCMK",into=("RCMK","SANS") ),
           ),
           b_ldlt_mult    =BLOC(condition = "METHODE == 'LDLT' or METHODE == 'MULT_FRONT' ",
                                   fr="Paramètres relatifs à la non inversibilité de la matrice à factorise",
             NPREC           =SIMP(statut='f',typ='I',defaut= 8 ),
             STOP_SINGULIER  =SIMP(statut='f',typ='TXM',defaut="OUI",into=("OUI","NON","DECOUPE") ),
           ),
           b_gcpc         =BLOC(condition = "METHODE == 'GCPC' ", fr="Paramètres de la méthode du gradient conjugué",
             PRE_COND        =SIMP(statut='f',typ='TXM',into=("LDLT_INC",),defaut="LDLT_INC" ),
             NIVE_REMPLISSAGE=SIMP(statut='f',typ='I',defaut= 0 ),
             RENUM           =SIMP(statut='f',typ='TXM',defaut="RCMK",into=("SANS","RCMK") ),
             RESI_RELA       =SIMP(statut='f',typ='R',defaut= 1.E-6 ),
             NMAX_ITER       =SIMP(statut='f',typ='I',defaut= 0 ),
           ),
           b_mumps        =BLOC(condition = "METHODE == 'MUMPS' ",fr="Paramètres de la méthode MUMPS",
             TYPE_RESOL      =SIMP(statut='f',typ='TXM',defaut="AUTO",into=("NONSYM","SYMGEN","SYMDEF","AUTO")),
             SCALING         =SIMP(statut='f',typ='TXM',defaut="AUTO",into=("SANS","AUTO")),
             RENUM           =SIMP(statut='f',typ='TXM',defaut="AUTO",into=("AMD","AMF","PORD","METIS","QAMD","AUTO")),
             PCENT_PIVOT     =SIMP(statut='f',typ='I',defaut=80,),
             RESI_RELA       =SIMP(statut='f',typ='R',defaut=-1.0,),
             ),
           b_feti          =BLOC(condition = "METHODE == 'FETI' ",fr="Paramètres de la méthode FETI 1",
             PARTITION       =SIMP(statut='o',typ=sd_feti_sdaster),
             RENUM           =SIMP(statut='f',typ='TXM',defaut="METIS",into=("MD","MDA","METIS") ),
             RESI_RELA       =SIMP(statut='f',typ='R',defaut=1.E-6,val_min=0.),
             NMAX_ITER       =SIMP(statut='f',typ='I',defaut=0,val_min=0),
             TYPE_REORTHO_DD =SIMP(statut='f',typ='TXM',defaut="GSM",into=("SANS","GS","GSM","IGSM") ),
             NB_REORTHO_DD   =SIMP(statut='f',typ='I',defaut=0,val_min=0),
             NB_REORTHO_INST =SIMP(statut='f',typ='I',defaut=0,val_min=0),
             PRE_COND        =SIMP(statut='f',typ='TXM',defaut="LUMPE",into=("LUMPE","SANS") ),
             SCALING         =SIMP(statut='f',typ='TXM',defaut="MULT",into=("SANS","MULT") ),
             VERIF_SDFETI    =SIMP(statut='f',typ='TXM',defaut="OUI",into=("OUI","NON") ),
             TEST_CONTINU    =SIMP(statut='f',typ='R',defaut=1.E-8,val_min=0.),
             INFO_FETI       =SIMP(statut='f',typ='TXM',defaut='FFFFFFFFFFFFFFFFFFFFFFFF'),
             STOCKAGE_GI     =SIMP(statut='f',typ='TXM',defaut="OUI",into=("OUI","NON","CAL") ),
             NB_SD_PROC0     =SIMP(statut='f',typ='I',defaut=0,val_min=0),
             ACCELERATION_SM =SIMP(statut='f',typ='TXM',defaut="OUI",into=("OUI","NON") ),
           ),
           SYME            =SIMP(statut='f',typ='TXM',defaut="NON",into=("OUI","NON") ),
         ),
         ARCHIVAGE       =FACT(statut='f',
           regles=(EXCLUS('PAS_ARCH','LIST_INST','INST'),
                   EXCLUS('ARCH_ETAT_INIT','NUME_INIT'), ),
           LIST_INST       =SIMP(statut='f',typ=(listr8_sdaster) ),
           INST            =SIMP(statut='f',typ='R',validators=NoRepeat(),max='**' ),
           PAS_ARCH        =SIMP(statut='f',typ='I' ),
           PRECISION       =SIMP(statut='f',typ='R',defaut= 1.0E-3),
           ARCH_ETAT_INIT  =SIMP(statut='f',typ='TXM',into=("OUI",)),
           NUME_INIT       =SIMP(statut='f',typ='I'),
           DETR_NUME_SUIV  =SIMP(statut='f',typ='TXM',into=("OUI",)),
           CHAM_EXCLU      =SIMP(statut='f',typ='TXM',validators=NoRepeat(),max='**',into=("DEPL","SIEF_ELGA","VARI_ELGA",
                                                                     "VARI_NON_LOCAL","LANL_ELGA")),
         ),
         OBSERVATION     =FACT(statut='f',max='**',
           regles=(UN_PARMI('NOEUD','GROUP_NO','MAILLE'),
                   PRESENT_PRESENT('MAILLE','POINT'),),
           NOM_CHAM        =SIMP(statut='o',typ='TXM',validators=NoRepeat(),max='**',into=("DEPL","VITE","ACCE","SIEF_ELGA",
                                              "VARI_ELGA","DEPL_ABSOLU","VITE_ABSOLU","ACCE_ABSOLU","VALE_CONT")),
           NOM_CMP         =SIMP(statut='o',typ='TXM',max='**' ),
           LIST_ARCH       =SIMP(statut='f',typ=listis_sdaster),
           LIST_INST       =SIMP(statut='f',typ=listr8_sdaster),
           INST            =SIMP(statut='f',typ='R',validators=NoRepeat(),max='**' ),
           PRECISION       =SIMP(statut='f',typ='R',defaut= 1.0E-3 ),
           CRITERE         =SIMP(statut='f',typ='TXM',defaut="RELATIF",into=("RELATIF","ABSOLU") ),
           PAS_OBSE        =SIMP(statut='f',typ='I'),
           NOEUD           =SIMP(statut='f',typ=no  ,validators=NoRepeat(),max='**'),
           GROUP_NO        =SIMP(statut='f',typ=grno,validators=NoRepeat(),max='**'),
           MAILLE          =SIMP(statut='f',typ=ma  ,validators=NoRepeat(),max='**'),
           POINT           =SIMP(statut='f',typ='I' ,validators=NoRepeat(),max='**'),
         ),

         SUIVI_DDL      = FACT(statut='f',max=4,
                               regles=(UN_PARMI('NOEUD','MAILLE','GROUP_NO','GROUP_MA','VALE_MIN','VALE_MAX'),
                                       PRESENT_PRESENT('MAILLE','POINT'),),
             NUME_SUIVI      =SIMP(statut='o',typ='I' ,min=1,max=4),
             NOM_CHAM        =SIMP(statut='o',typ='TXM',validators=NoRepeat(),max=1,
                                   into=("DEPL","VITE","ACCE","SIEF_ELGA",
                                         "VARI_ELGA","FORC_NODA","DEPL_ABSOLU","VITE_ABSOLU","ACCE_ABSOLU",)),
             NOM_CMP         =SIMP(statut='o',typ='TXM',max=1 ),
             NOEUD           =SIMP(statut='f',typ=no  ,validators=NoRepeat(),max='**'),
             GROUP_NO        =SIMP(statut='f',typ=grno,validators=NoRepeat(),max='**'),
             MAILLE          =SIMP(statut='f',typ=ma  ,validators=NoRepeat(),max='**'),
             GROUP_MA        =SIMP(statut='f',typ=grma,validators=NoRepeat(),max='**'),
             POINT           =SIMP(statut='f',typ='I' ,validators=NoRepeat(),max='**'),
             VALE_MAX        =SIMP(statut='f',typ='TXM',validators=NoRepeat(),max=1,into=("OUI",) ),
             VALE_MIN        =SIMP(statut='f',typ='TXM',validators=NoRepeat(),max=1,into=("OUI",) ),
         ),

         AFFICHAGE      = FACT(statut='f',max=16,

            UNITE       = SIMP(statut='f',typ='I',val_min=1),

            LONG_R      = SIMP(statut='f',typ='I',defaut=12,val_min=1,val_max=12),
            PREC_R      = SIMP(statut='f',typ='I',defaut=5, val_min=1,val_max=8),
            LONG_I      = SIMP(statut='f',typ='I',defaut=6, val_min=1,val_max=12),
            
            NOM_COLONNE = SIMP(statut='o',typ='TXM',defaut="STANDARD",
                                into=("STANDARD","MINIMUM",
                                      "ITER_NEWT",
                                      "INCR_TPS",
                                      "RESI_RELA","RELA_NOEU",
                                      "RESI_MAXI","MAXI_NOEU",
                                      "RESI_REFE","REFE_NOEU",
                                      "RELI_ITER","RELI_COEF",
                                      "PILO_PARA",
                                      "LAGR_ECAR","LAGR_INCR","LAGR_ITER",
                                      "MATR_ASSE",
                                      "ITER_DEBO",
                                      "CTCD_ITER","CTCD_INFO","CTCD_GEOM","CTCD_NOEU",
                                      "CTCC_GEOM","CTCC_FROT","CTCC_CONT",
                                      "SUIV_1","SUIV_2","SUIV_3","SUIV_4","ITER_FETI",
                                     ),
                               ),
            b_residu    = BLOC(condition = " NOM_COLONNE == 'RESI_RELA' or \
                    NOM_COLONNE == 'RESI_MAXI' or\
                    NOM_COLONNE == 'RESI_REFE' or\
                    NOM_COLONNE == 'CTCD_GEOM' or\
                    NOM_COLONNE == 'STANDARD' ",
                            INFO_RESIDU = SIMP(statut='f',typ='TXM',defaut="NON",into=("OUI","NON")),   
                          ),
         ),



         CRIT_FLAMB     =FACT(statut='f',min=1,max=1,
           NB_FREQ         =SIMP(statut='f',typ='I',max=1,defaut=3),
           CHAR_CRIT       =SIMP(statut='f',typ='R',min=2,max=2,defaut=(-10.0,10),
                            fr="Valeur des deux charges critiques délimitant la bande de recherche en HPP"),
         ),
           SENSIBILITE     =SIMP(statut='f',typ=(para_sensi,theta_geom),validators=NoRepeat(),max='**',
                               fr="Liste des paramètres de sensibilité",
                               ang="List of sensitivity parameters"),
           SOLV_NON_LOCAL  =FACT(statut='f',
             METHODE         =SIMP(statut='f',typ='TXM',defaut="MULT_FRONT",into=("MULT_FRONT","LDLT","GCPC","MUMPS") ),
             b_mult_front    =BLOC(condition = "METHODE == 'MULT_FRONT' ",fr="Paramètres de la méthode multi frontale",
               RENUM           =SIMP(statut='f',typ='TXM',defaut="METIS",into=("MD","MDA","METIS") ),
             ),
             b_ldlt         =BLOC(condition = "METHODE == 'LDLT' ",fr="Paramètres de la méthode LDLT",
               RENUM           =SIMP(statut='f',typ='TXM',defaut="RCMK",into=("RCMK","SANS") ),
             ),
             b_ldlt_mult    =BLOC(condition = "METHODE == 'LDLT' or METHODE == 'MULT_FRONT' ",
                                    fr="Paramètres relatifs à la non inversibilité de la matrice à factorise",
               NPREC           =SIMP(statut='f',typ='I',defaut= 8 ),
               STOP_SINGULIER  =SIMP(statut='f',typ='TXM',defaut="OUI",into=("OUI","NON") ),
             ),
             b_mumps        =BLOC(condition = "METHODE == 'MUMPS' ",fr="Paramètres de la méthode MUMPS",
               TYPE_RESOL      =SIMP(statut='f',typ='TXM',defaut="AUTO",into=("NONSYM","SYMGEN","SYMDEF","AUTO")),
               SCALING         =SIMP(statut='f',typ='TXM',defaut="AUTO",into=("SANS","AUTO")),
               RENUM           =SIMP(statut='f',typ='TXM',defaut="AUTO",into=("AMD","AMF","PORD","METIS","QAMD","AUTO")),
               PCENT_PIVOT     =SIMP(statut='f',typ='I',defaut=80,),
               RESI_RELA       =SIMP(statut='f',typ='R',defaut=-1.0,),
             ),
             b_gcpc         =BLOC(condition = "METHODE == 'GCPC' ", fr="Paramètres de la méthode du gradient conjugué",
               PRE_COND        =SIMP(statut='f',typ='TXM',into=("LDLT_INC",),defaut="LDLT_INC" ),
               NIVE_REMPLISSAGE=SIMP(statut='f',typ='I',defaut= 0 ),
               RESI_RELA       =SIMP(statut='f',typ='R',defaut= 1.E-6 ),
               NMAX_ITER       =SIMP(statut='f',typ='I',defaut= 0 ),
             ),
             EPS             =SIMP(statut='f',typ='R',defaut= 0.E+0 ),
           ),
           LAGR_NON_LOCAL  =FACT(statut='f',
             ITER_DUAL_MAXI  =SIMP(statut='f',typ='I',defaut= 50),
             RESI_DUAL_ABSO  =SIMP(statut='o',typ='R'),
             RESI_PRIM_ABSO  =SIMP(statut='o',typ='R'),
             R               =SIMP(statut='f',typ='R',defaut= 1000.),
             ITER_PRIM_MAXI  =SIMP(statut='f',typ='I',defaut= 10),
           ),
         INFO            =SIMP(statut='f',typ='I',into=(1,2) ),
         TITRE           =SIMP(statut='f',typ='TXM',max='**' ),
 )

#& MODIF COMMANDE  DATE 22/05/2006   AUTEUR MCOURTOI M.COURTOIS 
#            CONFIGURATION MANAGEMENT OF EDF VERSION
# ======================================================================
# COPYRIGHT (C) 1991 - 2004  EDF R&D                  WWW.CODE-ASTER.ORG
# THIS PROGRAM IS FREE SOFTWARE; YOU CAN REDISTRIBUTE IT AND/OR MODIFY  
# IT UNDER THE TERMS OF THE GNU GENERAL PUBLIC LICENSE AS PUBLISHED BY  
# THE FREE SOFTWARE FOUNDATION; EITHER VERSION 2 OF THE LICENSE, OR     
# (AT YOUR OPTION) ANY LATER VERSION.                                                  
#                                                                       
# THIS PROGRAM IS DISTRIBUTED IN THE HOPE THAT IT WILL BE USEFUL, BUT   
# WITHOUT ANY WARRANTY; WITHOUT EVEN THE IMPLIED WARRANTY OF            
# MERCHANTABILITY OR FITNESS FOR A PARTICULAR PURPOSE. SEE THE GNU      
# GENERAL PUBLIC LICENSE FOR MORE DETAILS.                              
#                                                                       
# YOU SHOULD HAVE RECEIVED A COPY OF THE GNU GENERAL PUBLIC LICENSE     
# ALONG WITH THIS PROGRAM; IF NOT, WRITE TO EDF R&D CODE_ASTER,         
#    1 AVENUE DU GENERAL DE GAULLE, 92141 CLAMART CEDEX, FRANCE.        
# ======================================================================

# RESPONSABLE MCOURTOI M.COURTOIS

from Macro.test_fichier_ops import test_fichier_ops

TEST_FICHIER=MACRO(nom="TEST_FICHIER", op=test_fichier_ops,
                   UIinfo={"groupes":("Impression",)},
                   fr="Tester la non régression de fichiers produits par des commandes aster",
   FICHIER          =SIMP(statut='o',typ='TXM',validators=LongStr(1,255)),
   NB_CHIFFRE      =SIMP(statut='o',typ='I',),   # defaut=6        pas de defaut, il faut
   EPSILON         =SIMP(statut='o',typ='R',),   # defaut=1.E-12   se poser la question !
   EXPR_IGNORE     =SIMP(statut='f',typ='TXM',max='**',
                         fr="Liste d'expressions régulières permettant d'ignorer certaines lignes"),
   VALE_K          =SIMP(statut='o',typ='TXM' ),
   REFERENCE       =SIMP(statut='f',typ='TXM',
                         into=("ANALYTIQUE","SOURCE_EXTERNE","NON_REGRESSION","AUTRE_ASTER") ),

   b_version       =BLOC(condition = "REFERENCE == 'NON_REGRESSION'",
      VERSION         =SIMP(statut='f',typ='TXM' ),
   ),

   INFO            =SIMP(statut='f',typ='I',defaut=1,into=(1,2) ),
)
#& MODIF COMMANDE  DATE 17/10/2006   AUTEUR MCOURTOI M.COURTOIS 
#            CONFIGURATION MANAGEMENT OF EDF VERSION
# ======================================================================
# COPYRIGHT (C) 1991 - 2001  EDF R&D                  WWW.CODE-ASTER.ORG
# THIS PROGRAM IS FREE SOFTWARE; YOU CAN REDISTRIBUTE IT AND/OR MODIFY
# IT UNDER THE TERMS OF THE GNU GENERAL PUBLIC LICENSE AS PUBLISHED BY
# THE FREE SOFTWARE FOUNDATION; EITHER VERSION 2 OF THE LICENSE, OR   
# (AT YOUR OPTION) ANY LATER VERSION.                                 
#
# THIS PROGRAM IS DISTRIBUTED IN THE HOPE THAT IT WILL BE USEFUL, BUT 
# WITHOUT ANY WARRANTY; WITHOUT EVEN THE IMPLIED WARRANTY OF          
# MERCHANTABILITY OR FITNESS FOR A PARTICULAR PURPOSE. SEE THE GNU    
# GENERAL PUBLIC LICENSE FOR MORE DETAILS.                            
#
# YOU SHOULD HAVE RECEIVED A COPY OF THE GNU GENERAL PUBLIC LICENSE   
# ALONG WITH THIS PROGRAM; IF NOT, WRITE TO EDF R&D CODE_ASTER,       
#    1 AVENUE DU GENERAL DE GAULLE, 92141 CLAMART CEDEX, FRANCE.      
# ======================================================================
# RESPONSABLE MCOURTOI M.COURTOIS
TEST_FONCTION=PROC(nom="TEST_FONCTION",op= 135,
            fr="Extraction d'une valeur numérique ou d'un attribut de fonction pour comparaison à une valeur de référence",
            UIinfo={"groupes":("Impression",)},
         TEST_NOOK       =SIMP(statut='f',typ='TXM',defaut="NON",into=("OUI","NON") ),
         VALEUR          =FACT(statut='f',max='**',
                               fr="Tester la valeur d une fonction ou d une nappe",
           regles=(UN_PARMI('VALE_REFE','VALE_REFE_C',),
                   DERIVABLE('FONCTION'),),
           FONCTION        =SIMP(statut='o',typ=(fonction_sdaster,fonction_c,nappe_sdaster,formule) ),
           SENSIBILITE     =SIMP(statut='f',typ=(para_sensi,theta_geom),
                                 fr="Paramètre de sensibilité.",
                                 ang="Sensitivity parameter"),
           NOM_PARA        =SIMP(statut='f',typ='TXM',validators=NoRepeat(),max=2),
           VALE_PARA       =SIMP(statut='o',typ='R'  ,validators=NoRepeat(),max=2),
           VALE_REFE       =SIMP(statut='f',typ='R',max='**' ),
           VALE_REFE_C     =SIMP(statut='f',typ='C',max='**' ),
           VALE_ABS        =SIMP(statut='f',typ='TXM',defaut="NON",into=("OUI","NON") ),
           CRITERE         =SIMP(statut='f',typ='TXM',fr="Critère de comparaison avec la solution de référence",
                                 defaut="RELATIF",into=("RELATIF","ABSOLU") ),
           PRECISION       =SIMP(statut='f',typ='R',fr="Ecart maximal autorisé avec la solution de référence",
                                 defaut= 1.E-3 ),
           REFERENCE       =SIMP(statut='f',typ='TXM',
                                 into=("ANALYTIQUE","SOURCE_EXTERNE","NON_REGRESSION","AUTRE_ASTER") ),
           b_version = BLOC (condition = "REFERENCE == 'NON_REGRESSION'", 
             VERSION         =SIMP(statut='f',typ='TXM' ),
           ),
         ),
         ATTRIBUT        =FACT(statut='f',max='**',
                               fr="Tester la valeur d un attribut d une fonction ou d''une nappe",
           FONCTION        =SIMP(statut='o',typ=(fonction_sdaster,fonction_c,nappe_sdaster,formule) ),
           PARA            =SIMP(statut='f',typ='R' ),
           CRIT_PARA       =SIMP(statut='f',typ='TXM',defaut="RELATIF",into=("RELATIF","ABSOLU") ),
           PREC_PARA       =SIMP(statut='f',typ='R',defaut= 1.E-3 ),
           ATTR            =SIMP(statut='o',typ='TXM',
                                 into=("NOM_PARA","NOM_RESU","PROL_DROITE","PROL_GAUCHE","INTERPOL",
                                       "PROL_GAUCHE_FONC","PROL_DROITE_FONC","INTERPOL_FONC","NOM_PARA_FONC") ),
           ATTR_REFE       =SIMP(statut='o',typ='TXM' ),
           REFERENCE       =SIMP(statut='f',typ='TXM',
                                 into=("ANALYTIQUE","SOURCE_EXTERNE","NON_REGRESSION","AUTRE_ASTER") ),
           b_version       =BLOC(condition = "REFERENCE == 'NON_REGRESSION'", 
             VERSION         =SIMP(statut='f',typ='TXM' ),
           ),
         ),
         TABL_INTSP      =FACT(statut='f',max='**',
                               fr="Tester la valeur d une fonction contenue dans une table interspectrale",
           regles=(UN_PARMI('NUME_ORDRE_I','NOEUD_I'),),
           INTE_SPEC       =SIMP(statut='o',typ=table_fonction),
           NOEUD_I         =SIMP(statut='f',typ=no),
           NUME_ORDRE_I    =SIMP(statut='f',typ='I' ),
           b_nume_ordre_i = BLOC (condition = "NUME_ORDRE_I != None", 
             NUME_ORDRE_J    =SIMP(statut='o',typ='I' ),
           ),
           b_noeud_i = BLOC (condition = "NOEUD_I != None",             
             NOEUD_J         =SIMP(statut='o',typ=no),
             NOM_CMP_I       =SIMP(statut='o',typ='TXM' ),
             NOM_CMP_J       =SIMP(statut='o',typ='TXM' ),
           ),
           NUME_VITE_FLUI  =SIMP(statut='f',typ='I' ),
           VALE_PARA       =SIMP(statut='o',typ='R' ),
           VALE_REFE_C     =SIMP(statut='o',typ='C',max='**' ),
           CRITERE         =SIMP(statut='f',typ='TXM',fr="Critère de comparaison avec la solution de référence",
                                 defaut="RELATIF",into=("RELATIF","ABSOLU") ),
           PRECISION       =SIMP(statut='f',typ='R',fr="Ecart maximal autorisé avec la solution de référence",
                                 defaut= 1.E-3 ),
           REFERENCE       =SIMP(statut='f',typ='TXM',
                                 into=("ANALYTIQUE","SOURCE_EXTERNE","NON_REGRESSION","AUTRE_ASTER") ),
           b_version       =BLOC(condition = "REFERENCE == 'NON_REGRESSION'", 
             VERSION         =SIMP(statut='f',typ='TXM' ),
           ),
         ),
)  ;
#& MODIF COMMANDE  DATE 10/10/2006   AUTEUR REZETTE C.REZETTE 
# RESPONSABLE VABHHTS J.PELLET
#            CONFIGURATION MANAGEMENT OF EDF VERSION
# ======================================================================
# COPYRIGHT (C) 1991 - 2001  EDF R&D                  WWW.CODE-ASTER.ORG
# THIS PROGRAM IS FREE SOFTWARE; YOU CAN REDISTRIBUTE IT AND/OR MODIFY
# IT UNDER THE TERMS OF THE GNU GENERAL PUBLIC LICENSE AS PUBLISHED BY
# THE FREE SOFTWARE FOUNDATION; EITHER VERSION 2 OF THE LICENSE, OR
# (AT YOUR OPTION) ANY LATER VERSION.
#
# THIS PROGRAM IS DISTRIBUTED IN THE HOPE THAT IT WILL BE USEFUL, BUT
# WITHOUT ANY WARRANTY; WITHOUT EVEN THE IMPLIED WARRANTY OF
# MERCHANTABILITY OR FITNESS FOR A PARTICULAR PURPOSE. SEE THE GNU
# GENERAL PUBLIC LICENSE FOR MORE DETAILS.
#
# YOU SHOULD HAVE RECEIVED A COPY OF THE GNU GENERAL PUBLIC LICENSE
# ALONG WITH THIS PROGRAM; IF NOT, WRITE TO EDF R&D CODE_ASTER,
#    1 AVENUE DU GENERAL DE GAULLE, 92141 CLAMART CEDEX, FRANCE.
#
#
# ======================================================================
TEST_RESU=PROC(nom="TEST_RESU",op=23,
            UIinfo={"groupes":("Impression",)},
         fr="Extraction d'une valeur d'une structure de donnée et comparaison à une valeur de référence",
         regles=(AU_MOINS_UN('CHAM_NO','CHAM_ELEM','RESU','GENE','OBJET')),

         CHAM_NO         =FACT(statut='f',max='**',
           regles=(UN_PARMI('NOEUD','GROUP_NO','TYPE_TEST'),
                   EXCLUS('NOEUD','GROUP_NO'),
                   PRESENT_PRESENT('NOEUD','NOM_CMP'),
                   PRESENT_PRESENT( 'GROUP_NO','NOM_CMP'),
                   UN_PARMI('VALE','VALE_I','VALE_C'),),
           CHAM_GD         =SIMP(statut='o',typ=cham_no_sdaster),
           NOEUD           =SIMP(statut='f',typ=no   ),
           GROUP_NO        =SIMP(statut='f',typ=grno ),
           NOM_CMP         =SIMP(statut='f',typ='TXM'),
           TYPE_TEST       =SIMP(statut='f',typ='TXM',into=("SOMM_ABS","SOMM","MAX","MIN")),
           VALE            =SIMP(statut='f',typ='R',max='**'),
           VALE_I          =SIMP(statut='f',typ='I',max='**'),
           VALE_C          =SIMP(statut='f',typ='C',max='**'),
           VALE_ABS        =SIMP(statut='f',typ='TXM',defaut="NON",into=("OUI","NON") ),
           CRITERE         =SIMP(statut='f',typ='TXM',defaut="RELATIF",into=("RELATIF","ABSOLU")),
           PRECISION       =SIMP(statut='f',typ='R',defaut= 1.0E-3),
           REFERENCE       =SIMP(statut='f',typ='TXM',into=("ANALYTIQUE","SOURCE_EXTERNE",
                                                            "NON_REGRESSION","AUTRE_ASTER")),
           VERSION         =SIMP(statut='f',typ='TXM'),
         ),

         CHAM_ELEM       =FACT(statut='f',max='**',
           regles=(UN_PARMI('MAILLE','TYPE_TEST',),
                   EXCLUS('NOEUD','GROUP_NO','POINT'),
                   PRESENT_PRESENT('NOEUD','NOM_CMP'),
                   PRESENT_PRESENT('GROUP_NO','NOM_CMP'),
                   PRESENT_PRESENT('POINT','NOM_CMP'),
                   UN_PARMI('VALE','VALE_I','VALE_C'), ),
           CHAM_GD         =SIMP(statut='o',typ=cham_elem),
           MAILLE          =SIMP(statut='f',typ=ma),
           POINT           =SIMP(statut='f',typ='I' ),
           SOUS_POINT      =SIMP(statut='f',typ='I'),
           NOEUD           =SIMP(statut='f',typ=no),
           GROUP_NO        =SIMP(statut='f',typ=grno),
           NOM_CMP         =SIMP(statut='f',typ='TXM',max='**'),
           TYPE_TEST       =SIMP(statut='f',typ='TXM',into=("SOMM_ABS","SOMM","MAX","MIN") ),
           VALE            =SIMP(statut='f',typ='R',max='**' ),
           VALE_I          =SIMP(statut='f',typ='I',max='**' ),
           VALE_C          =SIMP(statut='f',typ='C',max='**' ),
           VALE_ABS        =SIMP(statut='f',typ='TXM',defaut="NON",into=("OUI","NON") ),
           CRITERE         =SIMP(statut='f',typ='TXM',defaut="RELATIF",into=("RELATIF","ABSOLU")),
           PRECISION       =SIMP(statut='f',typ='R',defaut= 1.0E-3 ),
           REFERENCE       =SIMP(statut='f',typ='TXM',into=("ANALYTIQUE","SOURCE_EXTERNE",
                                                            "NON_REGRESSION","AUTRE_ASTER") ),
           VERSION         =SIMP(statut='f',typ='TXM' ),
         ),

         RESU            =FACT(statut='f',max='**',
           regles=(UN_PARMI('NUME_ORDRE','INST','FREQ','NUME_MODE','NOEUD_CMP','NOM_CAS','ANGL'),
                   UN_PARMI('NOM_CHAM','PARA'),
                   PRESENT_ABSENT('PARA','NOEUD','GROUP_NO','POINT','NOM_CMP','TYPE_TEST'),
                   PRESENT_PRESENT('NOM_CMP','NOM_CHAM'),
                   EXCLUS('NOEUD','GROUP_NO','POINT','TYPE_TEST'),
                   PRESENT_PRESENT('NOEUD','NOM_CMP'),
                   PRESENT_PRESENT('GROUP_NO','NOM_CMP'),
                   PRESENT_PRESENT('POINT','NOM_CMP'),
                   UN_PARMI('VALE','VALE_I','VALE_C'),
                   DERIVABLE('RESULTAT'),),
           RESULTAT        =SIMP(statut='o',typ=resultat_sdaster),
           SENSIBILITE     =SIMP(statut='f',typ=(para_sensi,theta_geom),
                                 fr="Paramètre de sensibilité.",
                                 ang="Sensitivity parameter"),
           NUME_ORDRE      =SIMP(statut='f',typ='I'),
           INST            =SIMP(statut='f',typ='R'),
           FREQ            =SIMP(statut='f',typ='R'),
           NUME_MODE       =SIMP(statut='f',typ='I'),
           NOEUD_CMP       =SIMP(statut='f',typ='TXM',min=2,max=2),
           NOM_CAS         =SIMP(statut='f',typ='TXM'),
           ANGL            =SIMP(statut='f',typ='R'),
           PARA            =SIMP(statut='f',typ='TXM'),
           NOM_CHAM        =SIMP(statut='f',typ='TXM',into=C_NOM_CHAM_INTO()),
           NOM_CMP         =SIMP(statut='f',typ='TXM',max='**'),
           MAILLE          =SIMP(statut='f',typ=ma   ,max='**'),
           NOEUD           =SIMP(statut='f',typ=no   ,max='**'),
           GROUP_NO        =SIMP(statut='f',typ=grno ,max='**'),
           POINT           =SIMP(statut='f',typ='I'),
           SOUS_POINT      =SIMP(statut='f',typ='I'),
           TYPE_TEST       =SIMP(statut='f',typ='TXM',into=("SOMM_ABS","SOMM","MAX","MIN")),
           VALE            =SIMP(statut='f',typ='R',max='**'),
           VALE_I          =SIMP(statut='f',typ='I',max='**'),
           VALE_C          =SIMP(statut='f',typ='C',max='**'),
           VALE_ABS        =SIMP(statut='f',typ='TXM',defaut="NON",into=("OUI","NON") ),
           CRITERE         =SIMP(statut='f',typ='TXM',into=("RELATIF","ABSOLU"),max=2),
           PRECISION       =SIMP(statut='f',typ='R',max=2),
           REFERENCE       =SIMP(statut='f',typ='TXM',into=("ANALYTIQUE","SOURCE_EXTERNE",
                                                            "NON_REGRESSION","AUTRE_ASTER",) ),
           VERSION         =SIMP(statut='f',typ='TXM' ),
         ),

         GENE            =FACT(statut='f',max='**',
           regles=(UN_PARMI('VALE','VALE_I','VALE_C') ,),
           RESU_GENE       =SIMP(statut='o',typ=(vect_asse_gene, tran_gene, mode_gene, harm_gene)),
           b_vect_asse     =BLOC(condition = "AsType(RESU_GENE) == vect_asse_gene",
             NUME_CMP_GENE   =SIMP(statut='o',typ='I'),
           ),
           b_mode          =BLOC(condition = "(AsType(RESU_GENE) == harm_gene) or (AsType(RESU_GENE) == mode_gene)",
                            regles=(UN_PARMI('NUME_ORDRE','FREQ','NUME_MODE'),
                                    UN_PARMI('NOM_CHAM','PARA'),
                                    PRESENT_PRESENT('NOM_CHAM','NUME_CMP_GENE'),),
             NOM_CHAM        =SIMP(statut='f',typ='TXM',into=C_NOM_CHAM_INTO()),
             NUME_CMP_GENE   =SIMP(statut='f',typ='I'),
             PARA            =SIMP(statut='f',typ='TXM'),
             NUME_ORDRE      =SIMP(statut='f',typ='I'),
             NUME_MODE       =SIMP(statut='f',typ='I'),
             FREQ            =SIMP(statut='f',typ='R'),
           ),
           b_tran          =BLOC(condition = "AsType(RESU_GENE) == tran_gene",
                            regles=(UN_PARMI('NUME_ORDRE','INST') ,),
             NOM_CHAM        =SIMP(statut='o',typ='TXM',into=C_NOM_CHAM_INTO()),
             NUME_CMP_GENE   =SIMP(statut='o',typ='I'),
             NUME_ORDRE      =SIMP(statut='f',typ='I'),
             INST            =SIMP(statut='f',typ='R'),
           ),
           VALE            =SIMP(statut='f',typ='R',max='**'),
           VALE_I          =SIMP(statut='f',typ='I',max='**'),
           VALE_C          =SIMP(statut='f',typ='C',max='**'),
           VALE_ABS        =SIMP(statut='f',typ='TXM',defaut="NON",into=("OUI","NON") ),
           CRITERE         =SIMP(statut='f',typ='TXM',into=("RELATIF","ABSOLU"),max=2),
           PRECISION       =SIMP(statut='f',typ='R',max=2),
           REFERENCE       =SIMP(statut='f',typ='TXM',into=("ANALYTIQUE","SOURCE_EXTERNE",
                                                            "NON_REGRESSION","AUTRE_ASTER",) ),
           VERSION         =SIMP(statut='f',typ='TXM' ),
         ),

         OBJET           =FACT(statut='f',max='**',
           regles=(UN_PARMI('S_I','S_R','RESUME',),
                   UN_PARMI('VALE','VALE_I','VALE_C','RESUME','S_R','S_I'),),
           NOM             =SIMP(statut='o',typ='TXM'),
           S_R             =SIMP(statut='f',typ='R'),
           S_I             =SIMP(statut='f',typ='I'),
           RESUME          =SIMP(statut='f',typ='I'),
           VALE            =SIMP(statut='f',typ='R'),
           VALE_I          =SIMP(statut='f',typ='I'),
           VALE_C          =SIMP(statut='f',typ='C'),
           VALE_ABS        =SIMP(statut='f',typ='TXM',defaut="NON",into=("OUI","NON") ),
           CRITERE         =SIMP(statut='f',typ='TXM',defaut="RELATIF",into=("RELATIF","ABSOLU")),
           PRECISION       =SIMP(statut='f',typ='R',defaut=1.0E-3 ),
           REFERENCE       =SIMP(statut='f',typ='TXM',into=("ANALYTIQUE","SOURCE_EXTERNE",
                                                            "NON_REGRESSION","AUTRE_ASTER",) ),
           VERSION         =SIMP(statut='f',typ='TXM' ),
         ),
)  ;
#& MODIF COMMANDE  DATE 10/10/2006   AUTEUR REZETTE C.REZETTE 
#            CONFIGURATION MANAGEMENT OF EDF VERSION
# ======================================================================
# COPYRIGHT (C) 1991 - 2001  EDF R&D                  WWW.CODE-ASTER.ORG
# THIS PROGRAM IS FREE SOFTWARE; YOU CAN REDISTRIBUTE IT AND/OR MODIFY
# IT UNDER THE TERMS OF THE GNU GENERAL PUBLIC LICENSE AS PUBLISHED BY
# THE FREE SOFTWARE FOUNDATION; EITHER VERSION 2 OF THE LICENSE, OR   
# (AT YOUR OPTION) ANY LATER VERSION.                                 
#
# THIS PROGRAM IS DISTRIBUTED IN THE HOPE THAT IT WILL BE USEFUL, BUT 
# WITHOUT ANY WARRANTY; WITHOUT EVEN THE IMPLIED WARRANTY OF          
# MERCHANTABILITY OR FITNESS FOR A PARTICULAR PURPOSE. SEE THE GNU    
# GENERAL PUBLIC LICENSE FOR MORE DETAILS.                            
#
# YOU SHOULD HAVE RECEIVED A COPY OF THE GNU GENERAL PUBLIC LICENSE   
# ALONG WITH THIS PROGRAM; IF NOT, WRITE TO EDF R&D CODE_ASTER,       
#    1 AVENUE DU GENERAL DE GAULLE, 92141 CLAMART CEDEX, FRANCE.      
# ======================================================================
# RESPONSABLE VABHHTS J.PELLET
TEST_TABLE=PROC(nom="TEST_TABLE",op= 177,
            UIinfo={"groupes":("Impression",)},
         fr="Tester une cellule ou une colonne d'une table",
         regles=(UN_PARMI('VALE','VALE_I','VALE_C', ),
                 DERIVABLE('TABLE'),),
#  concept table_sdaster à tester
         TABLE           =SIMP(statut='o',typ=table_sdaster),

         SENSIBILITE     =SIMP(statut='f',typ=(para_sensi,theta_geom),
                                 fr="Paramètre de sensibilité.",
                                 ang="Sensitivity parameter"),
         FILTRE          =FACT(statut='f',max='**',
           NOM_PARA        =SIMP(statut='o',typ='TXM' ),
           CRIT_COMP       =SIMP(statut='f',typ='TXM',defaut="EQ",
                                 into=("EQ","LT","GT","NE","LE","GE","VIDE",
                                       "NON_VIDE","MAXI","ABS_MAXI","MINI","ABS_MINI") ),
           b_vale          =BLOC(condition = "(CRIT_COMP in ('EQ','NE','GT','LT','GE','LE'))",
              regles=(UN_PARMI('VALE','VALE_I','VALE_K','VALE_C',),),
              VALE            =SIMP(statut='f',typ='R',),
              VALE_I          =SIMP(statut='f',typ='I',),
              VALE_C          =SIMP(statut='f',typ='C',),
              VALE_K          =SIMP(statut='f',typ='TXM' ),),

           CRITERE         =SIMP(statut='f',typ='TXM',defaut="RELATIF",into=("RELATIF","ABSOLU") ),
           PRECISION       =SIMP(statut='f',typ='R',defaut= 1.E-3 ),
         ),
         TYPE_TEST       =SIMP(statut='f',typ='TXM',into=("SOMM_ABS","SOMM","MAX","MIN") ),
         NOM_PARA        =SIMP(statut='o',typ='TXM' ),
         VALE            =SIMP(statut='f',typ='R',max='**' ),
         VALE_I          =SIMP(statut='f',typ='I',max='**' ),
         VALE_C          =SIMP(statut='f',typ='C',max='**' ),
         VALE_ABS        =SIMP(statut='f',typ='TXM',defaut="NON",into=("OUI","NON") ),
         CRITERE         =SIMP(statut='f',typ='TXM',defaut="RELATIF",into=("RELATIF","ABSOLU") ),
         PRECISION       =SIMP(statut='f',typ='R',defaut= 1.2E-3 ),
         REFERENCE       =SIMP(statut='f',typ='TXM',
                               into=("ANALYTIQUE","SOURCE_EXTERNE","NON_REGRESSION","AUTRE_ASTER") ),
         b_version       =BLOC(condition = "REFERENCE == 'NON_REGRESSION'",
             VERSION         =SIMP(statut='f',typ='TXM' ),
         INFO            =SIMP(statut='f',typ='I',defaut=1,into=(1,2) ),
         ),
)  ;
#& MODIF COMMANDE  DATE 12/06/2006   AUTEUR BOITEAU O.BOITEAU 
#            CONFIGURATION MANAGEMENT OF EDF VERSION
# ======================================================================
# COPYRIGHT (C) 1991 - 2001  EDF R&D                  WWW.CODE-ASTER.ORG
# THIS PROGRAM IS FREE SOFTWARE; YOU CAN REDISTRIBUTE IT AND/OR MODIFY
# IT UNDER THE TERMS OF THE GNU GENERAL PUBLIC LICENSE AS PUBLISHED BY
# THE FREE SOFTWARE FOUNDATION; EITHER VERSION 2 OF THE LICENSE, OR
# (AT YOUR OPTION) ANY LATER VERSION.
#
# THIS PROGRAM IS DISTRIBUTED IN THE HOPE THAT IT WILL BE USEFUL, BUT
# WITHOUT ANY WARRANTY; WITHOUT EVEN THE IMPLIED WARRANTY OF
# MERCHANTABILITY OR FITNESS FOR A PARTICULAR PURPOSE. SEE THE GNU
# GENERAL PUBLIC LICENSE FOR MORE DETAILS.
#
# YOU SHOULD HAVE RECEIVED A COPY OF THE GNU GENERAL PUBLIC LICENSE
# ALONG WITH THIS PROGRAM; IF NOT, WRITE TO EDF R&D CODE_ASTER,
#    1 AVENUE DU GENERAL DE GAULLE, 92141 CLAMART CEDEX, FRANCE.
# ======================================================================
THER_LINEAIRE=OPER(nom="THER_LINEAIRE",op=25,sd_prod=evol_ther,reentrant='f',
            UIinfo={"groupes":("Résolution",)},
                   fr="Résoudre un problème thermique linéaire stationnaire ou transitoire",
         regles=(CONCEPT_SENSIBLE('ENSEMBLE'),),
         MODELE          =SIMP(statut='o',typ=modele_sdaster),
         CHAM_MATER      =SIMP(statut='o',typ=cham_mater),
         CARA_ELEM       =SIMP(statut='f',typ=cara_elem),
         EXCIT           =FACT(statut='o',max='**',
           CHARGE          =SIMP(statut='o',typ=(char_ther,char_cine_ther)),
           FONC_MULT       =SIMP(statut='f',typ=(fonction_sdaster,nappe_sdaster,formule)),
         ),
         INCREMENT       =FACT(statut='f',
           LIST_INST       =SIMP(statut='o',typ=listr8_sdaster ),
           NUME_INIT       =SIMP(statut='f',typ='I'),
           NUME_FIN        =SIMP(statut='f',typ='I'),
         ),
         TEMP_INIT       =FACT(statut='f',
           regles=(EXCLUS('STATIONNAIRE','EVOL_THER','CHAM_NO','VALE'),),
           STATIONNAIRE    =SIMP(statut='f',typ='TXM',into=("OUI",) ),
           EVOL_THER       =SIMP(statut='f',typ=evol_ther),
           CHAM_NO         =SIMP(statut='f',typ=cham_no_sdaster),
           VALE            =SIMP(statut='f',typ='R'),
           NUME_INIT       =SIMP(statut='f',typ='I'),
         ),
         SENSIBILITE     =SIMP(statut='f',typ=(para_sensi,theta_geom),validators=NoRepeat(),max='**',
                               fr="Liste des paramètres de sensibilité.",
                               ang="List of sensitivity parameters",
         ),
           SENS_INIT       =FACT(statut='f',
             regles=(EXCLUS('STATIONNAIRE','EVOL_THER', ),),
             STATIONNAIRE    =SIMP(statut='f',typ='TXM',into=("OUI",) ),
             EVOL_THER       =SIMP(statut='f',typ=evol_ther),
             NUME_INIT       =SIMP(statut='f',typ='I'),
           ),
         SOLVEUR         =FACT(statut='d',
           METHODE         =SIMP(statut='f',typ='TXM',defaut="MULT_FRONT",into=("MULT_FRONT","LDLT","GCPC","MUMPS") ),
           b_mult_front    =BLOC(condition = "METHODE == 'MULT_FRONT' ",fr="Paramètres de la méthode multi frontale",
             RENUM           =SIMP(statut='f',typ='TXM',defaut="METIS",into=("MD","MDA","METIS") ),
           ),
           b_ldlt          =BLOC(condition = "METHODE == 'LDLT' ",fr="Paramètres de la méthode LDLT",
             RENUM           =SIMP(statut='f',typ='TXM',defaut="RCMK",into=("RCMK","SANS") ),
           ),
           b_ldlt_mult      =BLOC(condition = "METHODE == 'LDLT' or METHODE == 'MULT_FRONT' ",
                                   fr="Paramètres relatifs à la non inversibilité de la matrice à factorise",
             NPREC           =SIMP(statut='f',typ='I',defaut= 8 ),
             STOP_SINGULIER  =SIMP(statut='f',typ='TXM',defaut="OUI",into=("OUI","NON") ),
           ),
           b_gcpc          =BLOC(condition = "METHODE == 'GCPC' ", fr="Paramètres de la méthode du gradient conjugué",
             PRE_COND        =SIMP(statut='f',typ='TXM',into=("LDLT_INC",),defaut="LDLT_INC" ),
             NIVE_REMPLISSAGE=SIMP(statut='f',typ='I',defaut= 0 ),
             RENUM           =SIMP(statut='f',typ='TXM',defaut="RCMK",into=("SANS","RCMK") ),
             RESI_RELA       =SIMP(statut='f',typ='R',defaut= 1.E-6 ),
             NMAX_ITER       =SIMP(statut='f',typ='I',defaut= 0 ),
           ),
           b_mumps        =BLOC(condition = "METHODE == 'MUMPS' ",fr="Paramètres de la méthode MUMPS",
             TYPE_RESOL      =SIMP(statut='f',typ='TXM',defaut="AUTO",into=("NONSYM","SYMGEN","SYMDEF","AUTO")),
             SCALING         =SIMP(statut='f',typ='TXM',defaut="AUTO",into=("SANS","AUTO")),
             RENUM           =SIMP(statut='f',typ='TXM',defaut="AUTO",into=("AMD","AMF","PORD","METIS","QAMD","AUTO")),
             PCENT_PIVOT     =SIMP(statut='f',typ='I',defaut=80,),
             RESI_RELA       =SIMP(statut='f',typ='R',defaut=1.E-6,),
             ),
         ),
         PARM_THETA      =SIMP(statut='f',typ='R',defaut= 0.57),
         ARCHIVAGE       =FACT(statut='f',
           regles=(UN_PARMI('LIST_ARCH','PAS_ARCH','LIST_INST','INST'),),
           LIST_ARCH       =SIMP(statut='f',typ=listis_sdaster),
           LIST_INST       =SIMP(statut='f',typ=listr8_sdaster),
           INST            =SIMP(statut='f',typ='R',validators=NoRepeat(),max='**'),
           PRECISION       =SIMP(statut='f',typ='R',defaut= 1.0E-3 ),
           CRITERE         =SIMP(statut='f',typ='TXM',defaut="RELATIF",
                                 into=("RELATIF","ABSOLU")),
           PAS_ARCH        =SIMP(statut='f',typ='I'),
           CHAM_EXCLU      =SIMP(statut='f',typ='TXM',into=("VARI",)),
         ),
         TITRE           =SIMP(statut='f',typ='TXM',max='**'),
         INFO            =SIMP(statut='f',typ='I',into=(1,2)),
)  ;
#& MODIF COMMANDE  DATE 19/06/2006   AUTEUR BOITEAU O.BOITEAU 
#            CONFIGURATION MANAGEMENT OF EDF VERSION
# ======================================================================
# COPYRIGHT (C) 1991 - 2001  EDF R&D                  WWW.CODE-ASTER.ORG
# THIS PROGRAM IS FREE SOFTWARE; YOU CAN REDISTRIBUTE IT AND/OR MODIFY
# IT UNDER THE TERMS OF THE GNU GENERAL PUBLIC LICENSE AS PUBLISHED BY
# THE FREE SOFTWARE FOUNDATION; EITHER VERSION 2 OF THE LICENSE, OR
# (AT YOUR OPTION) ANY LATER VERSION.
#
# THIS PROGRAM IS DISTRIBUTED IN THE HOPE THAT IT WILL BE USEFUL, BUT
# WITHOUT ANY WARRANTY; WITHOUT EVEN THE IMPLIED WARRANTY OF
# MERCHANTABILITY OR FITNESS FOR A PARTICULAR PURPOSE. SEE THE GNU
# GENERAL PUBLIC LICENSE FOR MORE DETAILS.
#
# YOU SHOULD HAVE RECEIVED A COPY OF THE GNU GENERAL PUBLIC LICENSE
# ALONG WITH THIS PROGRAM; IF NOT, WRITE TO EDF R&D CODE_ASTER,
#    1 AVENUE DU GENERAL DE GAULLE, 92141 CLAMART CEDEX, FRANCE.
# ======================================================================
THER_NON_LINE=OPER(nom="THER_NON_LINE",op= 186,sd_prod=evol_ther,reentrant='f',
            UIinfo={"groupes":("Résolution",)},
                   fr="Résoudre un problème thermique non linéaire (conditions limites ou comportement matériau)"
                      +" stationnaire ou transitoire" ,
         regles=(CONCEPT_SENSIBLE('ENSEMBLE'),),
         MODELE          =SIMP(statut='o',typ=(modele_sdaster) ),
         CHAM_MATER      =SIMP(statut='o',typ=(cham_mater) ),
         CARA_ELEM       =SIMP(statut='c',typ=(cara_elem) ),
         COMP_THER_NL    =FACT(statut='d',max='**',
           RELATION        =SIMP(statut='f',typ='TXM',defaut="THER_NL",
                                 into=("THER_NL",
                                       "THER_HYDR",
                                       "SECH_GRANGER",
                                       "SECH_MENSI",
                                       "SECH_BAZANT",
                                       "SECH_NAPPE"
                                       ) ),
         regles=(PRESENT_ABSENT('TOUT','GROUP_MA','MAILLE'),),
           TOUT            =SIMP(statut='f',typ='TXM',into=("OUI",) ),
           GROUP_MA        =SIMP(statut='f',typ=grma,validators=NoRepeat(),max='**'),
           MAILLE          =SIMP(statut='f',typ=ma  ,validators=NoRepeat(),max='**'),
         ),
         EVOL_THER_SECH  =SIMP(statut='f',typ=evol_ther),
         EXCIT           =FACT(statut='o',max='**',
           CHARGE          =SIMP(statut='o',typ=char_ther),
           FONC_MULT       =SIMP(statut='f',typ=(fonction_sdaster,nappe_sdaster,formule)),
         ),
         INCREMENT       =FACT(statut='f',
           LIST_INST       =SIMP(statut='o',typ=listr8_sdaster),
           NUME_INIT       =SIMP(statut='f',typ='I'),
           NUME_FIN        =SIMP(statut='f',typ='I'),
         ),
         TEMP_INIT       =FACT(statut='f',
           regles=(EXCLUS('STATIONNAIRE','EVOL_THER','CHAM_NO','VALE'),),
           STATIONNAIRE    =SIMP(statut='f',typ='TXM',into=("OUI",)),
           EVOL_THER       =SIMP(statut='f',typ=evol_ther),
           CHAM_NO         =SIMP(statut='f',typ=cham_no_sdaster),
           VALE            =SIMP(statut='f',typ='R'),
           NUME_INIT       =SIMP(statut='f',typ='I'),
         ),
         NEWTON          =FACT(statut='d',
           REAC_ITER       =SIMP(statut='f',typ='I',defaut= 0 ),
           RESI_LINE_RELA  =SIMP(statut='f',typ='R',defaut= 1.0E-3 ),
           ITER_LINE_MAXI  =SIMP(statut='f',typ='I',defaut= 0 ),
         ),
         CONVERGENCE     =FACT(statut='d',
           RESI_GLOB_MAXI  =SIMP(statut='f',typ='R'),
           RESI_GLOB_RELA  =SIMP(statut='f',typ='R'),
           ITER_GLOB_MAXI  =SIMP(statut='f',typ='I',defaut= 10 ),
         ),
         SENSIBILITE     =SIMP(statut='f',typ=(para_sensi,theta_geom),validators=NoRepeat(),max='**',
                               fr="Liste des paramètres de sensibilité.",
                               ang="List of sensitivity parameters",
         ),
         SOLVEUR         =FACT(statut='d',
           METHODE         =SIMP(statut='f',typ='TXM',defaut="MULT_FRONT",into=("MULT_FRONT","LDLT","GCPC","MUMPS") ),
           b_mult_front    =BLOC(condition = "METHODE == 'MULT_FRONT' ",fr="Parametres de la méthode multi frontale",
             RENUM           =SIMP(statut='f',typ='TXM',defaut="METIS",into=("MD","MDA","METIS") ),
           ),
           b_ldlt          =BLOC(condition = "METHODE == 'LDLT' ",fr="Parametres de la méthode LDLT",
             RENUM           =SIMP(statut='f',typ='TXM',defaut="RCMK",into=("RCMK","SANS") ),
           ),
           b_ldlt_mult     =BLOC(condition = "METHODE == 'LDLT' or METHODE == 'MULT_FRONT' ",
                                   fr="Parametres relatifs a la non inversibilité de la matrice a factorise",
             NPREC           =SIMP(statut='f',typ='I',defaut= 8 ),
             STOP_SINGULIER  =SIMP(statut='f',typ='TXM',defaut="OUI",into=("OUI","NON") ),
           ),
           b_gcpc          =BLOC(condition = "METHODE == 'GCPC' ", fr="Parametres de la méthode du gradient conjugué",
             PRE_COND        =SIMP(statut='f',typ='TXM',into=("LDLT_INC",),defaut="LDLT_INC" ),
             NIVE_REMPLISSAGE=SIMP(statut='f',typ='I'  ,defaut= 0 ),
             RENUM           =SIMP(statut='f',typ='TXM',defaut="RCMK",into=("SANS","RCMK") ),
             RESI_RELA       =SIMP(statut='f',typ='R'  ,defaut= 1.E-6 ),
             NMAX_ITER       =SIMP(statut='f',typ='I'  ,defaut= 0 ),
           ),
           b_mumps        =BLOC(condition = "METHODE == 'MUMPS' ",fr="Paramètres de la méthode MUMPS",
             TYPE_RESOL      =SIMP(statut='f',typ='TXM',defaut="AUTO",into=("NONSYM","SYMGEN","SYMDEF","AUTO")),
             SCALING         =SIMP(statut='f',typ='TXM',defaut="AUTO",into=("SANS","AUTO")),
             RENUM           =SIMP(statut='f',typ='TXM',defaut="AUTO",into=("AMD","AMF","PORD","METIS","QAMD","AUTO")),
             PCENT_PIVOT     =SIMP(statut='f',typ='I',defaut=80,),
             RESI_RELA       =SIMP(statut='f',typ='R',defaut=-1.0,),
             ),
           SYME            =SIMP(statut='f',typ='TXM',defaut="NON",into=("OUI","NON",) ),
         ),
         PARM_THETA      =SIMP(statut='f',typ='R',defaut= 0.57 ),
         ARCHIVAGE       =FACT(statut='f',
           regles=(UN_PARMI('LIST_ARCH','PAS_ARCH','LIST_INST','INST', ),),
           LIST_ARCH       =SIMP(statut='f',typ=(listis_sdaster) ),
           LIST_INST       =SIMP(statut='f',typ=(listr8_sdaster) ),
           INST            =SIMP(statut='f',typ='R',validators=NoRepeat(),max='**'),
           PRECISION       =SIMP(statut='f',typ='R',defaut= 1.0E-3 ),
           CRITERE         =SIMP(statut='f',typ='TXM',defaut="RELATIF",into=("RELATIF","ABSOLU",) ),
           PAS_ARCH        =SIMP(statut='f',typ='I'),
           CHAM_EXCLU      =SIMP(statut='f',typ='TXM',into=("VARI",)),
         ),
         TITRE           =SIMP(statut='f',typ='TXM',max='**'),
         OPTION          =SIMP(statut='f',typ='TXM',validators=NoRepeat(),max=2,
                               into=("FLUX_ELGA_TEMP","FLUX_ELNO_TEMP") ),
         INFO            =SIMP(statut='f',typ='I',into=(1,2) ),

)  ;
#& MODIF COMMANDE  DATE 22/06/2005   AUTEUR REZETTE C.REZETTE 
#            CONFIGURATION MANAGEMENT OF EDF VERSION
# ======================================================================
# COPYRIGHT (C) 1991 - 2001  EDF R&D                  WWW.CODE-ASTER.ORG
# THIS PROGRAM IS FREE SOFTWARE; YOU CAN REDISTRIBUTE IT AND/OR MODIFY
# IT UNDER THE TERMS OF THE GNU GENERAL PUBLIC LICENSE AS PUBLISHED BY
# THE FREE SOFTWARE FOUNDATION; EITHER VERSION 2 OF THE LICENSE, OR
# (AT YOUR OPTION) ANY LATER VERSION.
#
# THIS PROGRAM IS DISTRIBUTED IN THE HOPE THAT IT WILL BE USEFUL, BUT
# WITHOUT ANY WARRANTY; WITHOUT EVEN THE IMPLIED WARRANTY OF
# MERCHANTABILITY OR FITNESS FOR A PARTICULAR PURPOSE. SEE THE GNU
# GENERAL PUBLIC LICENSE FOR MORE DETAILS.
#
# YOU SHOULD HAVE RECEIVED A COPY OF THE GNU GENERAL PUBLIC LICENSE
# ALONG WITH THIS PROGRAM; IF NOT, WRITE TO EDF R&D CODE_ASTER,
#    1 AVENUE DU GENERAL DE GAULLE, 92141 CLAMART CEDEX, FRANCE.
# ======================================================================
THER_NON_LINE_MO=OPER(nom="THER_NON_LINE_MO",op= 171,sd_prod=evol_ther,
                     fr="Résoudre un problème thermique non linéaire (conditions limites ou comportement matériau)"
                        +" stationnaire avec chargement mobile",
                     reentrant='n',
            UIinfo={"groupes":("Résolution",)},
         MODELE          =SIMP(statut='o',typ=modele_sdaster ),
         CHAM_MATER      =SIMP(statut='o',typ=cham_mater ),
         CARA_ELEM       =SIMP(statut='c',typ=cara_elem ),
         EXCIT           =FACT(statut='o',max='**',
           CHARGE          =SIMP(statut='o',typ=char_ther ),
           FONC_MULT       =SIMP(statut='c',typ=(fonction_sdaster,nappe_sdaster,formule) ),
         ),
         TEMP_INIT       =FACT(statut='f',
           EVOL_THER       =SIMP(statut='f',typ=evol_ther ),
           NUME_INIT       =SIMP(statut='f',typ='I',defaut= 0 ),
         ),
         CONVERGENCE     =FACT(statut='d',
           CRIT_TEMP_RELA  =SIMP(statut='f',typ='R',defaut= 1.E-3 ),
           CRIT_ENTH_RELA  =SIMP(statut='f',typ='R',defaut= 1.E-2 ),
           ITER_GLOB_MAXI  =SIMP(statut='f',typ='I',defaut= 10 ),
           ARRET           =SIMP(statut='c',typ='TXM',defaut="OUI",into=("OUI","NON") ),
         ),
         SOLVEUR         =FACT(statut='d',
           METHODE         =SIMP(statut='f',typ='TXM',defaut="MULT_FRONT",into=("MULT_FRONT","LDLT","GCPC") ),
           b_mult_front    =BLOC(condition = "METHODE == 'MULT_FRONT' ",fr="Paramètres de la méthode multi frontale",
             RENUM           =SIMP(statut='f',typ='TXM',defaut="METIS",into=("MD","MDA","METIS") ),
           ),
           b_ldlt          =BLOC(condition = "METHODE == 'LDLT' ",fr="Paramètres de la méthode LDLT",
             RENUM           =SIMP(statut='f',typ='TXM',defaut="RCMK",into=("RCMK","SANS") ),
           ),
           b_ldlt_mult     =BLOC(condition = "METHODE == 'LDLT' or METHODE == 'MULT_FRONT' ",
                                   fr="Paramètres relatifs à la non inversibilité de la matrice à factorise",
             NPREC           =SIMP(statut='f',typ='I',defaut= 8 ),
             STOP_SINGULIER  =SIMP(statut='f',typ='TXM',defaut="OUI",into=("OUI","NON") ),
           ),
           b_gcpc          =BLOC(condition = "METHODE == 'GCPC' ", fr="Paramètres de la méthode du gradient conjugué",
             PRE_COND        =SIMP(statut='f',typ='TXM',into=("LDLT_INC",),defaut="LDLT_INC" ),
             NIVE_REMPLISSAGE=SIMP(statut='f',typ='I',defaut= 0 ),
             RENUM           =SIMP(statut='f',typ='TXM',defaut="RCMK",into=("SANS","RCMK") ),
             RESI_RELA       =SIMP(statut='f',typ='R',defaut= 1.E-6 ),
             NMAX_ITER       =SIMP(statut='f',typ='I',defaut= 0 ),
           ),
           SYME            =SIMP(statut='f',typ='TXM',defaut="NON",into=("OUI","NON") ),
         ),
         TITRE           =SIMP(statut='f',typ='TXM',max='**' ),
         INFO            =SIMP(statut='f',typ='I',into=(1,2) ),
)  ;



